<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring启动过程之BeanDefinition</title>
    <url>/blog/2020/10/30/spring/1_bean_definition/</url>
    <content><![CDATA[<p>Spring生命周期</p>
<ul>
<li>Spring容器的创建</li>
<li>启动类的加载及作用</li>
<li><code>BeanFactoryPostProcessor</code>后置处理器<ul>
<li><code>ConfigurationClassPostProcessor</code></li>
<li><code>MapperScannerConfigurer</code></li>
<li>···</li>
</ul>
</li>
<li>Spring解析class文件生产<code>BeanDefinition</code>并加入到<code>beanDefinitionMap</code>过程</li>
<li>Spring <code>ApplicationListener</code>的执行过程</li>
<li>Spring Bean的实例化过程</li>
</ul>
<a id="more"></a>

<h2 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1. 流程图"></a>1. 流程图</h2><p><img src="https://images.effiu.cn/blog/spring/spring_lifecycle.jpg" alt="Bean启动过程"></p>
<h2 id="2-相关源码"><a href="#2-相关源码" class="headerlink" title="2. 相关源码"></a>2. 相关源码</h2><h3 id="1-AnnotationConfigApplicationContext"><a href="#1-AnnotationConfigApplicationContext" class="headerlink" title="1. AnnotationConfigApplicationContext"></a>1. AnnotationConfigApplicationContext</h3><blockquote>
<p>ApplicationContext上下文，接受一个Component类做为输入参数。例如<code>@Configuration</code>注解修饰的类。即支持基于Java的配置类。</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/spring/AnnotationConfigApplicationContext.png" alt="AnnotationConfigApplicationContext"></p>
<p><code>AnnotationConfigApplicationContext</code>间接实现了<code>ApplicationContext</code>接口。<code>ApplicationContext</code>接口继承关系如下:</p>
<p><img src="https://images.effiu.cn/blog/spring/ApplicationContext.png" alt="ApplicationContext"></p>
<p>由类的继承结构可以发现，<code>AnnotationConfigApplicationContext</code>支持:</p>
<ul>
<li><p><code>ResourceLoader</code>，即资源加载。<code>ResourcePatternResolver</code>是其子类，<code>PathMatchingResourcePatternResolver</code>实现了<code>ResourcePatternResolver</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// classpath*:下的**/*.class</span></span><br><span class="line">        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">        <span class="comment">// 调用PathMatchingResourcePatternResolver#getResources()方法，其底层是通过确认在文件系统中的位置，然后File类得到所有class文件</span></span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                        ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">                        sbd.setSource(resource);</span><br><span class="line">                        <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                            candidates.add(sbd);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// ··· 省略</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ···</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>BeanFactory</code>，是访问Spring容器的根接口。其子类会维护一个<code>beanDefinitionMap</code>。<code>BeanFactory</code>接口包含多个<code>getBean</code>的实现。</p>
</li>
<li><p><code>MessageSource</code>，用于国际化</p>
</li>
<li><p><code>ApplicationEventPublisher</code>，封装事件发布功能的接口。</p>
</li>
<li><p><code>EnvironmentCapable</code>，配置文件相关，通过<code>String ACTIVE_PROFILES_PROPERTY_NAME = &quot;spring.profiles.active</code>即<code>spring.profiles.active</code>和<code>String DEFAULT_PROFILES_PROPERTY_NAME = &quot;spring.profiles.default&quot;</code>确定配置环境。</p>
</li>
</ul>
<p><code>AnnotationConfigApplicationContext</code>具有上述功能。</p>
<p><code>AnnotationConfigApplicationContext</code>是一个Application Context，其有4个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Spring Boot采用该方式实例化Application Context(通过反射调用无参构造方法)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认调用父类构造方法,会直接创建DefaultListableBeanFactory</span></span><br><span class="line">    <span class="comment">// 读取器，用于支持以编程的方式注册Bean类,配置ConfigurationClassPostProcessor,CommonAnnotationBeanPostProcessor</span></span><br><span class="line">    <span class="comment">// AutowiredAnnotationBeanPostProcessor等</span></span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// BeanDefinition扫描器,检测指定path下的可能的Bean，并将其注册到BeanFactory或者ApplicationContext中</span></span><br><span class="line">    <span class="comment">// 可以用来扫描包和类,将其转换为BeanDefinition</span></span><br><span class="line">    <span class="comment">// 通过AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses)方式启动时，其不是真正的scanner,真正的scanner是</span></span><br><span class="line">	<span class="comment">// org.springframework.context.annotation.ComponentScanAnnotationParser.parse()方法创建的scanner</span></span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类GenericApplicationContext无参数构造方法默认会创建DefaultListableBeanFactory,这里调用重载构造方法指定BeanFactory</span></span><br><span class="line">    <span class="keyword">super</span>(beanFactory);</span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建AnnotationConfigApplicationContext，生成新的bean definitions并从给定的组件类且自动刷新context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递basePackages，例如 basePackages=com.abc</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this()会初始化3个对象,BeanFactory、Reader、Scanner</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// 扫描指定的包路径，classpath*:com/abc/**/*.class下的所有class类,将符合条件的类生成BeanDefinition,</span></span><br><span class="line">    <span class="comment">// 遍历并注册到BeanFactory中</span></span><br><span class="line">    scan(basePackages);</span><br><span class="line">    <span class="comment">// AbstractApplicationContext.refresh()方法，是Spring启动的核心</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们以<code>AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(App.class);</code>启动Spring容器时，具体过程如下:</p>
<ul>
<li>调用<code>AnnotationConfigApplicationContext</code>，会默认调用父类无参数构造方法。创建<code>DefaultListableBeanFactory</code>。同时会创建<strong>reader</strong>和<strong>scanner</strong>。</li>
<li><code>register(componentClasses);</code>，<strong>reader</strong>将启动类注册到BeanFactory中。</li>
<li><code>refresh()</code>是Spring容器的核心，其主要完成了class文件的解析成BeanDefiniton、Bean的实例化及其声明周期。</li>
</ul>
<h3 id="2-AnnotatedBeanDefinitionReader"><a href="#2-AnnotatedBeanDefinitionReader" class="headerlink" title="2. AnnotatedBeanDefinitionReader"></a>2. AnnotatedBeanDefinitionReader</h3><blockquote>
<p>是一个适配器，用于支持以编程的方式注册Bean类，其通过编程的方式将<code>ConfigurationClassPostProcessor</code>、<code>AutowiredAnnotationBeanPostProcessor</code>、<code>CommonAnnotationBeanPostProcessor</code>等添加到<code>ApplicationContext</code>中。核心源码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new AnnotatedBeanDefinitionReader()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加@Configuration注解后置处理器:ConfigurationClassPostProcessor(BeanFactoryPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        <span class="comment">// 将ConfigurationClassPostProcessor以CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME做为BeanName</span></span><br><span class="line">        <span class="comment">// 放入到beanDefinitionMap中，并返回一个holder</span></span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加@Autowired、@Value注解后置处理器:AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="comment">// 添加@Resource、@PostConstruct、@PreDestroy注解相关后置处理器:CommonAnnotationBeanPostProcessor</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                                                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持@EventListener注解:EventListenerMethodProcessor</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册DefaultEventListenerFactory,用于@EventListener</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="register"></div>`register(componentClasses);`中，其将启动类解析为BeanDefinition注册到BeanFactory中。当使用`new AnnotationConfigApplicationContext(Class<?>... componentClasses)`的方式启动容器时, 其会注册该`componentClasses`

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将启动类作为一个Bean加入到beanDefinitionMap中去</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据提供的类创建一个BeanDefinition</span></span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">    <span class="comment">// 判断该类是否跳过解析，主要是@Condition相关</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abd.setInstanceSupplier(supplier);</span><br><span class="line">    <span class="comment">// 作用域scope</span></span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">    <span class="comment">// beanName，根据BeanNameGenerator</span></span><br><span class="line">    String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line">    <span class="comment">// 处理类的通用注解,@Primary、@Lazy、@DependsOn、@Role、@Description</span></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    <span class="comment">// @Qualifier注解相关,如果向容器中注册Bean时，当使用类@Qualifier注解时</span></span><br><span class="line">    <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">                abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">                abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">            customizer.customize(abd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    <span class="comment">// 注册到beanDefinitionMap中</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-ClassPathBeanDefinitionScanner"><a href="#3-ClassPathBeanDefinitionScanner" class="headerlink" title="3. ClassPathBeanDefinitionScanner"></a>3. ClassPathBeanDefinitionScanner</h3><blockquote>
<p><code>ClassPathBeanDefinitionScanner</code>的作用是读取class后缀文件，然后包装成BeanDefinition，注册时BeanFactory中。</p>
</blockquote>
<ul>
<li>当使用<code>new AnnotationConfigApplicationContext(String... basePackages)</code>的方式启动容器时，其会直接调用<code>scan(String... basePackages)方法</code>，将<strong>basePackages</strong>下符合条件的class解析成BeanDefinition。</li>
<li>当使用<code>AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses)</code>的方式启动容器时，其是在<code>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)</code>中调用完成扫描的</li>
</ul>
<p><code>ClassPathBeanDefinitionScanner</code>继承了<code>ClassPathScanningCandidateComponentProvider</code>。关键源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定的packages中执行扫描</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">// 调用的是其父类 ClassPathScanningCandidateComponentProvider</span></span><br><span class="line">    doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>ClassPathScanningCandidateComponentProvider</code>中关键源码<div id='doscan'></div>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扫描指定packages中的类，返回符合条件的BeanDefinition集合</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 扫描符合条件的候选组件</span></span><br><span class="line">        <span class="comment">// 例如:AnnotationBeanNameGenerator#postProcessBeanDefinitionRegistry</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解析通用注解@Lazy、@Primary、@DependsOn、@Role、@Description</span></span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                definitionHolder =</span><br><span class="line">                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                <span class="comment">// 将BeanDefinition添加到BeanFactory中</span></span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描指定的class path，返回符合条件的BeanDefinition集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">        <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// classpath*:下的**/*.class</span></span><br><span class="line">        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">        <span class="comment">// 使用PathMatchingResourcePatternResolver</span></span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">        <span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line">        <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                        ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">                        sbd.setSource(resource);</span><br><span class="line">                        <span class="comment">// 判断当前BeanDefinition是否是符合候选条件</span></span><br><span class="line">                        <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                            candidates.add(sbd);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// exception</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-主要过程"><a href="#3-主要过程" class="headerlink" title="3. 主要过程"></a>3. 主要过程</h2><blockquote>
<p>大致过程就是上面的流程图，这里结合相关类源码做一些细化，完善整个流程</p>
</blockquote>
<p><code>new AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses)</code>的方式启动Spring容器，SpringBoot虽然不是使用该构造方法完成启动，但是大致流程类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// 使用reader注册componentClasses到BeanFactory中</span></span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用无参数构造方法，其会在父类构造方法中初始化``DefaultListableBeanFactory`。</li>
<li>创建reader:<code>AnnotatedBeanDefinitionReader</code>，其支持以编程的方式注册Bean类，会添加一些注解支持。例如<ul>
<li><code>ConfigurationClassPostProcessor</code>支持<code>@Configuration</code></li>
<li><code>AutowiredAnnotationBeanPostProcessor</code>支持<code>@Autowired</code>、<code>@Value</code></li>
<li><code>CommonAnnotationBeanPostProcessor</code>支持<code>@PostConstruct</code>、<code>@PreDestory</code>、<code>@Resource</code>等</li>
<li><code>EventListenerMethodProcessor</code>支持<code>@EventListener</code></li>
</ul>
</li>
<li>创建scanner，这个一个扫描组件，用来扫描指定path下的class文件，解析为BeanDefinition并注册到BeanFactory中。在我们使用<code>new AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses)</code>构造方法时，其并不是真的扫描器。真正的扫描器在<code>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)</code>时创建。</li>
</ul>
<p><code>register(componentClasses)</code>，具体源码解释见<a href="#register">上文</a>。其将该启动类解析为<strong>BeanDefinition</strong>注册到<strong>BeanFactory</strong>中，该类会在后面扫描类解析为BeanDefinition并注册到BeanFactory中发挥至关重要重要作用。</p>
<p><code>refresh()</code>，这是Spring启动过程中最重要的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 准备</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新并返回BeanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanFactory的前期准备，比如配置不支持注入的接口、优先注入的类(类似于@Primary)等等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 空方法，扩展方法中有实现</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 调用所有注册的BeanFactoryPostProcessor，所有的BeanDefinition到map中</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * <span class="doctag">@see</span> org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)</span></span><br><span class="line"><span class="comment">			 * <span class="doctag">@see</span> org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)</span></span><br><span class="line"><span class="comment">			 * 	扫描指定目录下的所有class文件,将符合条件的类解析为BeanDefinition,注册到BeanFactory中去。</span></span><br><span class="line"><span class="comment">			 * <span class="doctag">@see</span> org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanFactory(ConfigurableListableBeanFactory)</span></span><br><span class="line"><span class="comment"> 			 */</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 注册所有的BeanPostProcessor</span></span><br><span class="line"><span class="comment">			 * <span class="doctag">@see</span> PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ApplicationEventMulticaster管理ApplicationListener对象,并向其发布事件,默认SimpleApplicationEventMulticaster</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化其他特殊bean，例如ThemeSource、WebServer、servletContext</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            </span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// 实例化所有bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述源码中，最重要的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 扫描path生成BeanDefinition,并注册到BeanFactory中</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"><span class="comment">// 2. 注册BeanPostProcessor，添加到BeanFactory中</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"><span class="comment">// 3. 实例化所有bean</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure>

<p><code>invokeBeanFactoryPostProcessors(beanFactory);</code>中，其会调用<code>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</code>,<code>ConfigurationClassPostProcessor</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>，其主要作用如下：以当前<code>BeanFactory</code>中的Configuration <strong>Bean</strong>为起点，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 6个internal的内部Bean以及启动类</span></span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">        BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            <span class="comment">// 只添加配置类到configCandidates类中去, @SpringBootApplication是由@Configuration的修饰的,所以启动类在configCandidates中</span></span><br><span class="line">            configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">    configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">        <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">    <span class="comment">// 从应用程序上下文中检查任何自定义的BeanName生成策略</span></span><br><span class="line">    SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">        sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">                AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">            <span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">    <span class="comment">// 解析带有@Configuration的类</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">        <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 带有@Configuration的类的@Component、@ComponentScan以及扫描指定的packages、@PropertySource、@Import、@ImportResource、方法上带有@Bean</span></span><br><span class="line">        <span class="comment">// 将带有@Configuration的类以及类内部带有@Bean注解的类、@ComponentScan扫描后的ConfigurationClass注册为BeanDefinition</span></span><br><span class="line">        <span class="comment">// @Controller、@Service、@Component、@Repository等注解修饰的类会被解析为BeanDefinition</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line">        <span class="comment">// Spring会把已经解析过的配置类放到configurationClasses集合中。</span></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        <span class="comment">// 移除已经解析过的配置类</span></span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">                registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">                <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// reader解析parse过程中标记出的@Import、@ImportSource、@Bean等并将BeanDefinition注册到BeanFactory中</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        candidates.clear();</span><br><span class="line">        <span class="comment">// 当BeanDefinition的数量大于candidateNames时，candidateNames是Spring启动类+一些internal类，说明有用户自定义Bean</span></span><br><span class="line">        <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">            String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">            Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">            Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历registry中的BeanDefinition判断是否还有为parse过的Configuration类，若存在则继续解析</span></span><br><span class="line">            <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                    BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">                    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                        !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                        candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            candidateNames = newCandidateNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">        <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">        <span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line">        ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>筛选出配置类，例如<code>@Configuration</code>修饰的类</p>
</li>
<li><p>解析配置类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Component注解</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">        <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">        processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">        org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                        <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// 过滤掉无用的componentScan，并扫描componentScan</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// 遍历@ComponentScan发现的BeanDefinition，是否发现新的@Configuration配置类，若发现则解析</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @Import annotations</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">    AnnotationAttributes importResource =</span><br><span class="line">        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process individual @Bean methods</span></span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该配置类存在父类则返回上层，递归处理</span></span><br><span class="line">    <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        <span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>是否使用<code>@Component</code></li>
<li>是否使用<code>@PropertySource</code>。</li>
<li><code>@ComponentScan</code>、这里是最关键的。若存在<code>@ComponentScan</code>修饰的类，立即执行扫描，关键源码<a href='#doscan'>见上文</a>。<ul>
<li>在发现<code>@ComponentScan</code>后，其会先通过<code>org.springframework.core.io.support.ResourcePatternResolver#getResources</code>扫描<strong>basePackages</strong>，返回<strong>basePackages</strong>下的所有class类文件</li>
<li>遍历class类文件，找出符合条件的类，包装为<code>BeanDefinition</code>。</li>
<li>解析<code>BeanDefinition</code>，填充<code>BeanDefinition</code>，例如：scope、lazy、primary、dependsOn、role、description等属性。</li>
<li>注册到<code>BeanFactory</code>中</li>
<li>遍历<code>@ComponentScan</code>发现的<code>BeanDefinition</code>，是否发现新的<code>@Configuration</code>配置类，若发现则解析</li>
</ul>
</li>
<li>是否<code>@Import</code>、<code>@ImportSource</code>、<code>@Bean</code>等注解</li>
</ul>
</li>
<li><p>解析配置类，将parse过程中标记出的<code>@Import</code>、<code>@ImportSource</code>、<code>@Bean</code>等解析为<code>BeanDefinition</code>注册到<code>BeanFactory</code>中</p>
</li>
<li><p>检查上述过程是否有新的配置类，若存在则继续解析</p>
</li>
</ul>
<p>上述过程是<code>ConfigurationClassPostProcessor</code>将类解析为<code>BeanDefinition</code>，并注册到<code>BeanFactory</code>的详细过程。其实Spring不止这一个<code>BeanFactoryPostProcessor</code>，还有其他的。例如: </p>
<ul>
<li><code>MapperScannerConfigurer</code>，是一个MyBatis实现的后置处理器，其完成了Mapper的相关功能，将会在后续说明。</li>
<li><code>RefreshScope</code>，Spring Cloud相关</li>
<li><code>org.springframework.cloud.autoconfigure.RefreshAutoConfiguration.RefreshScopeBeanDefinitionEnhancer</code>，Spring Cloud相关</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring启动之BeanPostProcessor后置处理器</title>
    <url>/blog/2020/10/27/spring/3_beanPostProcessor/</url>
    <content><![CDATA[<p><strong>Spring</strong>的<code>BeanPostProcessor</code>后置处理器承担了很多工作</p>
<ul>
<li><p>AOP、代理</p>
</li>
<li><p>构造方法注入的构造方法推断，构造方法上使用<code>@Autowired</code>等注解时</p>
</li>
<li><p>循环依赖，提前暴露未完成的Bean</p>
</li>
<li><p>依赖注入，<code>@Resource</code>、<code>@Autowired</code>、<code>@Value</code>等，不同注解依赖不同的后置处理器</p>
</li>
<li><p><input disabled="" type="checkbox">  动态注入</p>
</li>
<li><p>执行<code>Aware</code>回调</p>
</li>
<li><p><code>@Import</code>注解，通过<code>ImportAwareBeanPostProcessor</code>将<code>@Import</code>修饰的注解注入到<code>@Import</code>指定的类中</p>
</li>
<li><p>初始化和销毁方法，<code>@PostConsturct</code>、<code>@PreDestroy</code>后置处理完成</p>
</li>
<li><p><code>ApplicationListener</code>的监听等</p>
</li>
</ul>
<a id="more"></a>

<h2 id="相关BeanPostProcessor"><a href="#相关BeanPostProcessor" class="headerlink" title="相关BeanPostProcessor"></a>相关BeanPostProcessor</h2><p><img src="https://images.effiu.cn/blog/spring/BeanPostProcessor.png" alt=" "></p>
<p>在<strong>Spring Boot</strong>中<strong>Spring framework</strong>相关<strong>BeanPostProcesso</strong>如下:</p>
<ol>
<li>ApplicationContextAwareProcessor</li>
<li>ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor</li>
<li>PostProcessorRegistrationDelegate.BeanPostProcessorChecker</li>
<li>CommonAnnotationBeanPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>ApplicationListenerDetector</li>
</ol>
<blockquote>
<p>忽略Spring MVC、Spring Boot、Spring Cloud相关BeanPostProcessor，例如:Spring Boot的<code>ConfigurationPropertiesBindingPostProcessor</code>,Spring Cloud的<code>ConfigurationPropertiesBeans</code>等等。</p>
</blockquote>
<p>上述6个后置处理器相关接口以及发挥作用的方法(标红的):</p>
<p><img src="https://images.effiu.cn/blog/spring/BeanPostProcessor_class.jpg" alt="BeanPostProcessor类图"></p>
<blockquote>
<p>上述标红的为真正执行的类,类中的成员仅仅是一些重要的<strong>field</strong>和方法，即在获取Bean过程中执行后置处理器相关的方法。</p>
</blockquote>
<h2 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h2><blockquote>
<p><strong>BeanPostProcessor</strong>在<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>中的<code>obtainFreshBeanFactory()</code>和<code>registerBeanPostProcessors()</code>方法中注册的</p>
</blockquote>
<p><code>org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</code>加载了<code>ApplicationContextAwareProcessor</code>和<code>ApplicationListenerDetector</code>两个后置处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个BeanPostProcessor:ApplicationContextAwareProcessor</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 配置自动注入忽略的接口，需要以其他的方式完成相关Bean的引用,例如实现ApplicationContextAware接口完成引用</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动装配时指定实现类(一个接口有多个实现类的情况),作用类似于@Primary注解</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    <span class="comment">// 第二个BeanPostProcessor</span></span><br><span class="line">	<span class="comment">// ApplicationListenerDetector用于将ApplicationListener子类Bean放入到&#123;@link applicationListeners&#125; 集合中</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register default environment beans. 三个Bean，environment、systemProperties、systemEnvironment, 可以直接通过@Autowried等注解使用</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors</code>通过调用<code>ConfigurationClassPostProcessor#postProcessBeanFactory()</code>方法注册了<code>ImportAwareBeanPostProcessor</code>后置处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConfigurationClassPostProcessor部分源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">        <span class="comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line">        <span class="comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">        processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enhanceConfigurationClasses(beanFactory);</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors</code>注册了<code>BeanPostProcessorChecker</code>、<code>AutowiredAnnotationBeanPostProcessor</code>、<code>CommonAnnotationBeanPostProcessor</code>、以及重新注册了<code>ApplicationListenerDetector</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历beanDefinitionNames获取BeanPostProcessorNames</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    <span class="comment">// BeanPostProcessorChecker用于当在BeanPostProcessor实例化期间创建Bean时，当某个Bean不适合所有BeanPostProcessor时，记录信息. BeanPostProcessorChecker内部会比较beanProcessorTargetCount与beanFactory.getBeanPostProcessorCount()</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">    <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            <span class="comment">// CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor两个BeanPostProcessor</span></span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    <span class="comment">// 注册实现PriorityOrdered的BeanPostProcessors</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">    <span class="comment">// 注册实现Ordered的BeanPostProcessors</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">// 注册所有常规的BeanPostProcessors</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">// 最后重新注册所有内部BeanPostProcessor</span></span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">    <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanPostProcessor作用"><a href="#BeanPostProcessor作用" class="headerlink" title="BeanPostProcessor作用"></a>BeanPostProcessor作用</h2><p>排序后的BeanPostProcessor顺序为:</p>
<ol>
<li>ApplicationContextAwareProcessor</li>
<li>ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor</li>
<li>PostProcessorRegistrationDelegate.BeanPostProcessorChecker</li>
<li>CommonAnnotationBeanPostProcessor</li>
<li>AutowiredAnnotationBeanPostProcessor</li>
<li>ApplicationListenerDetector</li>
</ol>
<h3 id="ApplicationContextAwareProcessor"><a href="#ApplicationContextAwareProcessor" class="headerlink" title="ApplicationContextAwareProcessor"></a>ApplicationContextAwareProcessor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">          bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">          bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware))&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareInterfaces(bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, acc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">        ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">        ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">        ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">        ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationContextAwareProcessor</code>加载的是<code>EnvironmentAware</code>、<code>EmbeddedValueResolverAware</code>、<code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>6个用于回调的Aware。</p>
<h3 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h3><blockquote>
<p>是<code>ConfigurationClassPostProcessor</code>的子类，在Spring容器启动过程中，由其父类完成注册</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImportAwareBeanPostProcessor</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(<span class="meta">@Nullable</span> PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在AutowiredAnnotationBeanPostProcessor的postProcessProperties方法注入Bean之前,注入BeanFactory,</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnhancedConfiguration) &#123;</span><br><span class="line">            ((EnhancedConfiguration) bean).setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若该bean是ImportAware, 则将@Import注解的类</span></span><br><span class="line">        <span class="comment">// (支持@Configuration、@Component,实现ImportSelector、ImportBeanDefinitionRegistrar接口的实现类)</span></span><br><span class="line">        <span class="comment">// 通过ImportAware的setImportMetadata将该注解注入到@Import指定类中</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ImportAware) &#123;</span><br><span class="line">            ImportRegistry ir = <span class="keyword">this</span>.beanFactory.getBean(IMPORT_REGISTRY_BEAN_NAME, ImportRegistry.class);</span><br><span class="line">            AnnotationMetadata importingClass = ir.getImportingClassFor(ClassUtils.getUserClass(bean).getName());</span><br><span class="line">            <span class="keyword">if</span> (importingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ((ImportAware) bean).setImportMetadata(importingClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanPostProcessorChecker"><a href="#BeanPostProcessorChecker" class="headerlink" title="BeanPostProcessorChecker"></a>BeanPostProcessorChecker</h3><blockquote>
<p>没有实际逻辑，只是用于在BeanPostProcessor实例化期间创建Bean时记录日志。</p>
</blockquote>
<h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p><code>CommonAnnotationBeanPostProcessor</code>支持的注解,<code>@Resource</code>、<code>@EJB</code>、<code>@WebServiceRef</code>，其继承了<code>InitDestroyAnnotationBeanPostProcessor</code>，<code>InitDestroyAnnotationBeanPostProcessor</code>支持<code>@PostConstruct</code>和<code>@PreDestroy</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; webServiceRefClass;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; ejbClass;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; resourceAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    webServiceRefClass = loadAnnotationType(<span class="string">&quot;javax.xml.ws.WebServiceRef&quot;</span>);</span><br><span class="line">    ejbClass = loadAnnotationType(<span class="string">&quot;javax.ejb.EJB&quot;</span>);</span><br><span class="line">    <span class="comment">// 配置支持的注解</span></span><br><span class="line">    resourceAnnotationTypes.add(Resource.class);</span><br><span class="line">    <span class="keyword">if</span> (webServiceRefClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resourceAnnotationTypes.add(webServiceRefClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ejbClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resourceAnnotationTypes.add(ejbClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将支持的注解解析为InjectionMetadata,放入到injectionMetadataCache</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    InjectionMetadata metadata = findResourceMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从injectionMetadataCache中取得InjectionMetadata，然后完成注入</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 属性注入</span></span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of resource dependencies failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InjectionMetadata"><a href="#InjectionMetadata" class="headerlink" title="InjectionMetadata"></a>InjectionMetadata</h3><p><code>InjectionMetadata</code>要注入的数据元，<code>InjectElement</code>是其内部类。<code>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</code>方法会将BeanPostProcessor支持的注解解析为<code>InjectionMetadata</code>，然后由<code>InstantiationAwareBeanPostProcessorAdapter.postProcessProperties</code>方法完成注入。</p>
<p><code>InjectionMetadata</code>部分源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待注入的元素,field或者method</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;InjectedElement&gt; injectedElements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> Member member;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isField;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// postProcessProperties中会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String requestingBeanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span></span></span><br><span class="line"><span class="function">				<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isField) &#123;</span><br><span class="line">        Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">        ReflectionUtils.makeAccessible(field);</span><br><span class="line">        field.set(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkPropertySkipping(pvs)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = (Method) <span class="keyword">this</span>.member;</span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            method.invoke(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p><code>AutowiredAnnotationBeanPostProcessor</code>支持<code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code>、<code>@Lookup</code>等注解</p>
<blockquote>
<p><code>AutowiredAnnotationBeanPostProcessor</code>会将支持的注解的field或者method解析为<code>InjectMetadata</code>，但是<code>AutowiredAnnotationBeanPostProcessor</code>内部自己实现了<code>InjectedElement</code>的子类<code>AutowiredFieldElement</code>和<code>AutowiredMethodElement</code>，分别用于属性注入和方法注入。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置支持@Autowired、@Value以及JSR-330相关注解</span></span><br><span class="line">    <span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">    <span class="keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">                                          ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ··· 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将支持的注解解析为InjectionMetadata(AutowiredFieldElement、AutowiredMethodElement)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">    metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, <span class="keyword">final</span> String beanName)</span><br><span class="line">    <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let&#x27;s check for lookup methods here...</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.lookupMethodsChecked.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AnnotationUtils.isCandidateClass(beanClass, Lookup.class)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; targetClass = beanClass;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">                        Lookup lookup = method.getAnnotation(Lookup.class);</span><br><span class="line">                        <span class="keyword">if</span> (lookup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">&quot;No BeanFactory available&quot;</span>);</span><br><span class="line">                            LookupOverride override = <span class="keyword">new</span> LookupOverride(method, lookup.value());</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                RootBeanDefinition mbd = (RootBeanDefinition)</span><br><span class="line">                                    <span class="keyword">this</span>.beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">                                mbd.getMethodOverrides().addOverride(override);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                                <span class="string">&quot;Cannot apply @Lookup to beans without corresponding bean definition&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    targetClass = targetClass.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Lookup method resolution failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.lookupMethodsChecked.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">    Constructor&lt;?&gt;[] candidateConstructors = <span class="keyword">this</span>.candidateConstructorsCache.get(beanClass);</span><br><span class="line">    <span class="keyword">if</span> (candidateConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Fully synchronized resolution now...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.candidateConstructorsCache) &#123;</span><br><span class="line">            candidateConstructors = <span class="keyword">this</span>.candidateConstructorsCache.get(beanClass);</span><br><span class="line">            <span class="keyword">if</span> (candidateConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Constructor&lt;?&gt;[] rawCandidates;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取所有的构造方法</span></span><br><span class="line">                    rawCandidates = beanClass.getDeclaredConstructors();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                    <span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line">                                                    <span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Constructor&lt;?&gt;&gt; candidates = <span class="keyword">new</span> ArrayList&lt;&gt;(rawCandidates.length);</span><br><span class="line">                Constructor&lt;?&gt; requiredConstructor = <span class="keyword">null</span>;</span><br><span class="line">                Constructor&lt;?&gt; defaultConstructor = <span class="keyword">null</span>;</span><br><span class="line">                Constructor&lt;?&gt; primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);</span><br><span class="line">                <span class="keyword">int</span> nonSyntheticConstructors = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : rawCandidates) &#123;</span><br><span class="line">                    <span class="comment">// 是否由编译器自己生成的构造方法</span></span><br><span class="line">                    <span class="keyword">if</span> (!candidate.isSynthetic()) &#123;</span><br><span class="line">                        nonSyntheticConstructors++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (primaryConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 检查是否存在使用支持注解修饰的类构造方法</span></span><br><span class="line">                    MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(candidate);</span><br><span class="line">                    <span class="keyword">if</span> (ann == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 检查父类构造方法是否存在支持的注解</span></span><br><span class="line">                        Class&lt;?&gt; userClass = ClassUtils.getUserClass(beanClass);</span><br><span class="line">                        <span class="keyword">if</span> (userClass != beanClass) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Constructor&lt;?&gt; superCtor =</span><br><span class="line">                                    userClass.getDeclaredConstructor(candidate.getParameterTypes());</span><br><span class="line">                                ann = findAutowiredAnnotation(superCtor);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">                                <span class="comment">// Simply proceed, no equivalent superclass constructor found...</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 只能存在一个需要注入的构造方法，否则会抛出异常</span></span><br><span class="line">                        <span class="keyword">if</span> (requiredConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                            <span class="string">&quot;Invalid autowire-marked constructor: &quot;</span> + candidate +</span><br><span class="line">                                                            <span class="string">&quot;. Found constructor with &#x27;required&#x27; Autowired annotation already: &quot;</span> +</span><br><span class="line">                                                            requiredConstructor);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 判断是否需要注入，若需要那么当不存在要注入的bean时会抛出异常</span></span><br><span class="line">                        <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                        <span class="keyword">if</span> (required) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!candidates.isEmpty()) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                                                <span class="string">&quot;Invalid autowire-marked constructors: &quot;</span> + candidates +</span><br><span class="line">                                                                <span class="string">&quot;. Found constructor with &#x27;required&#x27; Autowired annotation: &quot;</span> +</span><br><span class="line">                                                                candidate);</span><br><span class="line">                            &#125;</span><br><span class="line">                            requiredConstructor = candidate;</span><br><span class="line">                        &#125;</span><br><span class="line">                        candidates.add(candidate);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (candidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                        defaultConstructor = candidate;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!candidates.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// Add default constructor to list of optional constructors, as fallback.</span></span><br><span class="line">                    <span class="keyword">if</span> (requiredConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (defaultConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            candidates.add(defaultConstructor);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (candidates.size() == <span class="number">1</span> &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Inconsistent constructor declaration on bean with name &#x27;&quot;</span> + beanName +</span><br><span class="line">                                        <span class="string">&quot;&#x27;: single autowire-marked constructor flagged as optional - &quot;</span> +</span><br><span class="line">                                        <span class="string">&quot;this constructor is effectively required since there is no &quot;</span> +</span><br><span class="line">                                        <span class="string">&quot;default constructor to fall back to: &quot;</span> + candidates.get(<span class="number">0</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    candidateConstructors = candidates.toArray(<span class="keyword">new</span> Constructor&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rawCandidates.length == <span class="number">1</span> &amp;&amp; rawCandidates[<span class="number">0</span>].getParameterCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;rawCandidates[<span class="number">0</span>]&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nonSyntheticConstructors == <span class="number">2</span> &amp;&amp; primaryConstructor != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                         defaultConstructor != <span class="keyword">null</span> &amp;&amp; !primaryConstructor.equals(defaultConstructor)) &#123;</span><br><span class="line">                    candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryConstructor, defaultConstructor&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nonSyntheticConstructors == <span class="number">1</span> &amp;&amp; primaryConstructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[] &#123;primaryConstructor&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.candidateConstructorsCache.put(beanClass, candidateConstructors);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (candidateConstructors.length &gt; <span class="number">0</span> ? candidateConstructors : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从injectionMetadataCache中取出需要出入的原始数据完成注入</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationListenerDetector"><a href="#ApplicationListenerDetector" class="headerlink" title="ApplicationListenerDetector"></a>ApplicationListenerDetector</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType,</span><br><span class="line">                                            String beanName) &#123;</span><br><span class="line">    <span class="comment">// 若Bean是ApplicationListener则将其放入到singletonNames内</span></span><br><span class="line">    <span class="comment">// 在postProcessAfterInitialization方法中，将ApplicationListener子类放入到ApplicationListeners集合中</span></span><br><span class="line">    if (ApplicationListener.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">        this.singletonNames.put(beanName, beanDefinition.isSingleton());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object postProcessAfterInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    if (bean instanceof ApplicationListener) &#123;</span><br><span class="line">        <span class="comment">// potentially not detected as a listener by getBeanNamesForType retrieval</span></span><br><span class="line">        <span class="comment">// getBeanNamesForType可能不会将其判断为监听器,所以此处判断是否是ApplicationListener若是则将其加入到ApplicationListeners中</span></span><br><span class="line">        Boolean flag = this.singletonNames.get(beanName);</span><br><span class="line">        if (Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line">            <span class="comment">// singleton bean (top-level or inner): register on the fly</span></span><br><span class="line">            this.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">         &#125; else if (Boolean.FALSE.equals(flag)) &#123;</span><br><span class="line">                this.singletonNames.remove(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanPostProcessor的执行顺序"><a href="#BeanPostProcessor的执行顺序" class="headerlink" title="BeanPostProcessor的执行顺序"></a>BeanPostProcessor的执行顺序</h2><blockquote>
<p><code>BeanPostProcessor</code>在<strong>Bean</strong>的实例化过程中每个方法执行的顺序。上文已经指出在<strong>Bean</strong>的实例化过程中8次调用后置处理器的地方。</p>
</blockquote>
<h3 id="postProcessBeforeInstantiation"><a href="#postProcessBeforeInstantiation" class="headerlink" title="postProcessBeforeInstantiation"></a>postProcessBeforeInstantiation</h3><p>第一次调用后置处理器是<code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>，其会在目标对象被实例化之前调用，因为此时目标对象未被实例化，所以可以返回自定义对象，比如代理对象。</p>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>是<code>InstantiationAwareBeanPostProcessor</code>的一个子类，所有使用<code>@AspectJ</code>注解修饰的类，都会被其自动识别，其实现了<code>BeanFactoryAware</code>接口，所有持有beanFactory对象，会在创建代理类后将<strong>targetClass</strong>赋给代理类。</p>
<blockquote>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>与AOP相关，待后续研究</p>
</blockquote>
<h3 id="determineCandidateConstructors"><a href="#determineCandidateConstructors" class="headerlink" title="determineCandidateConstructors"></a>determineCandidateConstructors</h3><p>第二次调用后置处理器是<code>SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors</code>方法，主要是推断创建Bean的构造方法。具体见<a href='#AutowiredAnnotationbeanPostProcessor'>AutowiredAnnotationBeanPostProcessor</a>。</p>
<h3 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h3><p>第三次调用后置处理器是<code>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</code>其主要作用的解析类中要注入的对象然后放入到<code>BeanDefinition</code>中，然后会在``InstantiationAwareBeanPostProcessor.postProcessProperties`中完成属性注入</p>
<h3 id="getEarlyBeanReference"><a href="#getEarlyBeanReference" class="headerlink" title="getEarlyBeanReference"></a>getEarlyBeanReference</h3><p>第四次调用后置处理器是<code>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</code>，用于循环依赖中提前暴露Bean</p>
<h3 id="postProcessAfterInstantiation"><a href="#postProcessAfterInstantiation" class="headerlink" title="postProcessAfterInstantiation"></a>postProcessAfterInstantiation</h3><p>第五次调用后置处理器是<code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</code>主要是在Bean完成实例化后判断是否需要属性注入，返回false则不需要完成属性注入</p>
<h3 id="postProcessProperties"><a href="#postProcessProperties" class="headerlink" title="postProcessProperties"></a>postProcessProperties</h3><p>第六次调用后置处理器是<code>InstantiationAwareBeanPostProcessor.postProcessProperties</code>，主要是完成属性注入。</p>
<ul>
<li>在``ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor.postProcessProperties<code>中指定</code>BeanFactory`</li>
<li>在<code>CommonAnnotationBeanPostProcessor.postProcessProperties</code>中注入<code>@Resurce</code>、<code>@WebServiceRef</code>、<code>@EJB</code>、<code>@PostConstruct</code>、<code>@PreDestory</code>注解相关</li>
<li>在<code>AutowiredAnnotationBeanPostProcessor.postProcessProperties</code>中进行属性注入<code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code>注解相关属性</li>
</ul>
<h3 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h3><p>第七次调用后置处理器是<code>BeanPostProcessor.postProcessBeforeInitialization</code>，<code>BeanPostProcessor</code>是最顶层接口，所以所有后置处理器都有该方法。存在逻辑的如下:</p>
<ul>
<li><code>ApplicationContextAwareProcessor</code>: 执行<code>EnvironmentAware</code>、<code>EmbeddedValueResolverAware</code>、<code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>相关回调</li>
<li><code>ImportAwareBeanPostProcessor</code>: 实现<code>ImportAware</code>接口的Bean</li>
<li><code>CommonAnnotationBeanPostProcessor</code>其继承了<code>InitDestroyAnnotationBeanPostProcessor</code>类，其会执行<code>@PostConstruct</code>方法</li>
</ul>
<h3 id="postProcessAfterInitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h3><p>第八次调用后置处理器是<code>BeanPostProcessor.postProcessAfterInitialization</code>，<code>BeanPostProcessor</code>是最顶层接口，所以所有后置处理器都有该方法。</p>
<ul>
<li><code>ApplicationListenerDetector</code>，将符合条件的<strong>Bean</strong>放入到<code>ApplicationContext.applicationListeners</code>中，用于监听<strong>Application</strong>事件</li>
<li><input disabled="" type="checkbox"> <code>AnnotationAwareAspectJAutoProxyCreator</code>，待研究</li>
</ul>
<h3 id="requiresDestruction和postProcessBeforeDestruction"><a href="#requiresDestruction和postProcessBeforeDestruction" class="headerlink" title="requiresDestruction和postProcessBeforeDestruction"></a>requiresDestruction和postProcessBeforeDestruction</h3><p>第9次调用后置处理器，<code>DestructionAwareBeanPostProcessor#requiresDestruction</code>和<code>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</code>，判断Bean实例是否需要该后置处理器销毁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisposableBeanAdapter</span><span class="params">(Object bean, String beanName, RootBeanDefinition beanDefinition,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;BeanPostProcessor&gt; postProcessors, <span class="meta">@Nullable</span> AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法中返回该bean在销毁时需要执行的后置处理器,filterPostProcessors</span></span><br><span class="line">    <span class="keyword">this</span>.beanPostProcessors = filterPostProcessors(postProcessors, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DestructionAwareBeanPostProcessor#requiresDestruction方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;DestructionAwareBeanPostProcessor&gt; <span class="title">filterPostProcessors</span><span class="params">(List&lt;BeanPostProcessor&gt; processors, Object bean)</span> </span>&#123;</span><br><span class="line">    List&lt;DestructionAwareBeanPostProcessor&gt; filteredPostProcessors = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(processors)) &#123;</span><br><span class="line">        filteredPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(processors.size());</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processor <span class="keyword">instanceof</span> DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">                DestructionAwareBeanPostProcessor dabpp = (DestructionAwareBeanPostProcessor) processor;</span><br><span class="line">                <span class="keyword">if</span> (dabpp.requiresDestruction(bean)) &#123;</span><br><span class="line">                    filteredPostProcessors.add(dabpp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filteredPostProcessors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理@PreDestroy注解</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">            processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// DisposableBean接口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ··· 省略</span></span><br><span class="line">            ((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// throw ex</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 推断的destroyMethod，例如close、shutdown方法,xml中的destroy-method、default-destroy-method属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToInvoke = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (methodToInvoke != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当销毁Bean时:</p>
<ol>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroySingletons</code></li>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroySingleton</code></li>
<li><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroyBean</code></li>
</ol>
<blockquote>
<p>destroyBean的源码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(String beanName, <span class="meta">@Nullable</span> DisposableBean bean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Trigger destruction of dependent beans first...</span></span><br><span class="line">    Set&lt;String&gt; dependencies;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">        <span class="comment">// Within full synchronization in order to guarantee a disconnected Set</span></span><br><span class="line">        dependencies = <span class="keyword">this</span>.dependentBeanMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁依赖的bean</span></span><br><span class="line">    <span class="keyword">if</span> (dependencies != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dependentBeanName : dependencies) &#123;</span><br><span class="line">            destroySingleton(dependentBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actually destroy the bean now...</span></span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 此处调用的是DisposableBeanAdapter.destroy()方法。</span></span><br><span class="line">            bean.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Destruction of bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger destruction of contained beans...</span></span><br><span class="line">    Set&lt;String&gt; containedBeans;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.containedBeanMap) &#123;</span><br><span class="line">        <span class="comment">// Within full synchronization in order to guarantee a disconnected Set</span></span><br><span class="line">        containedBeans = <span class="keyword">this</span>.containedBeanMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (containedBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String containedBeanName : containedBeans) &#123;</span><br><span class="line">            destroySingleton(containedBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove destroyed bean from other beans&#x27; dependencies.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = <span class="keyword">this</span>.dependentBeanMap.entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">            Map.Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();</span><br><span class="line">            Set&lt;String&gt; dependenciesToClean = entry.getValue();</span><br><span class="line">            dependenciesToClean.remove(beanName);</span><br><span class="line">            <span class="keyword">if</span> (dependenciesToClean.isEmpty()) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove destroyed bean&#x27;s prepared dependency information.</span></span><br><span class="line">    <span class="keyword">this</span>.dependenciesForBeanMap.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring启动过程之Bean的实例化</title>
    <url>/blog/2020/10/21/spring/2_spring_bean/</url>
    <content><![CDATA[<p>Spring Bean的创建过程。</p>
<ul>
<li>Bean的创建过程</li>
<li>循环依赖</li>
<li>IoC/自动装配/自动注入过程</li>
<li>BeanPostProcessor后置处理器</li>
<li>······</li>
</ul>
<a id="more"></a>

<h2 id="Spring-Bean的创建过程"><a href="#Spring-Bean的创建过程" class="headerlink" title="Spring Bean的创建过程"></a>Spring Bean的创建过程</h2><p><img src="https://images.effiu.cn/blog/spring/spring_bean_lifecycle.jpg" alt="Bean创建过程"></p>
<ol>
<li><p>Spring Context容器的入口是<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>，这里是整个IoC的完整过程。</p>
<ul>
<li>构建<code>BeanFactory</code></li>
<li>注册后置处理器<code>BeanPostProcessor</code></li>
<li>国际化，感兴趣的事件</li>
<li>创建Bean，根据<code>BeanPostProcessor</code>完成注入</li>
<li>······</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> 创建BeanFactory、注册BeanFactoryPostProcessor</li>
</ul>
</li>
<li><p>注册BeanPostProcessor</p>
<blockquote>
<p><strong>Spring framework</strong>中注册6个<strong>BeanPostProcessor</strong>的过程</p>
</blockquote>
</li>
<li><p>Bean的创建过程</p>
<ol>
<li>验证，Merge BeanDefinition(<code>@Lookup</code>等)，判断是否是抽象类、单例、懒加载、FactoryBean等等</li>
<li>推断构造方法</li>
<li>new对象(反射),放到Spring容器中</li>
<li>缓存注解信息，并合并BeanDefination对象</li>
<li>提前暴露自己(bean的半成品)</li>
<li>判定是否需要属性注入</li>
<li>完成属性注入</li>
<li>调用生命周期回调方法<code>Aware</code>等</li>
<li>完成代理AOP</li>
<li>put容器</li>
<li>销毁对象</li>
</ol>
</li>
</ol>
<h2 id="Bean创建过程源码"><a href="#Bean创建过程源码" class="headerlink" title="Bean创建过程源码"></a>Bean创建过程源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 验证Bean的名字是否非法</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line">	<span class="comment">// 从单例缓存中检查是否存在单例bean，第一次必定返回null</span></span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前bean正在被创建则抛出异常，prototype bean</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//TODO 解析合并后的BeanDefinition对象 待研究</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">            <span class="comment">// 确保当前Bean所依赖的Bean的初始化, @DependsOn</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="comment">// 省略</span></span><br><span class="line">                    <span class="comment">// 实例化该例DependsOn的类</span></span><br><span class="line">                    getBean(dep);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断类是否是单例，prototype bean Spring是不会实例化的</span></span><br><span class="line">			<span class="comment">// SpringBoot和Spring MVC中@Controller、@Service、@Component、@Repository默认都是单例</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 创建bean的过程,对象的创建以及代理</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Bean创建失败，清除Bean创建标识</span></span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Bean的过程如下(省略部分代码，只保留主要逻辑)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">	RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">    <span class="comment">// 从BeanDefinition Map中得到要创建的bean的类型</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">    	mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次调用后置处理器，判断是否加代理，Spring Boot中没有任何处理</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Bean的真正过程</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    	<span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二次调用后置处理器</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 第三次调用后置处理器，通过后置处理器合并BeanDefinition,拿到所有需要注入的属性</span></span><br><span class="line">                <span class="comment">// ApplicationListenerDetector: 将属于ApplicationListener的Bean放入到ApplicationContext上下文的applicationListener集合中</span></span><br><span class="line">                <span class="comment">// CommonAnnotationBeanPostProcessor: 将@Resource、@webServiceRef、@EJB修饰的属性放入到RootBeanDefinition中</span></span><br><span class="line">                <span class="comment">// AutowiredAnnotationBeanPostProcessor: 将@Autowired、@Value、JSR-330相关注解放入到RootBeanDefinition中</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环依赖相关</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="comment">// 当支持循环依赖时，就会提前暴露自己(为了其他对象可以注入自己)，第四次调用后置处理器,实际在Spring Boot中没有处理任何事情</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否需要属性注入,若需要则注入则完成注入,第五、六次调用后置处理器</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化Spring，进行第七、八次后置处理器的调用</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">//异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 第9次调用后置处理器</span></span><br><span class="line">		<span class="comment">// DestructionAwareBeanPostProcessor的requiresDestruction方法和postProcessBeforeDestruction方法，具体destroy过程见:</span></span><br><span class="line">		<span class="comment">// org.springframework.beans.factory.support.DisposableBeanAdapter.destroy()方法</span></span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</code>方法完成属性注入(省略部分代码，只保留主要逻辑):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任何实现postProcessAfterInstantiation的BeanPostProcessor都可以修改postProcessAfterInstantiation的返回值,例如:动态注入</span></span><br><span class="line">    <span class="comment">// 第五次调用后置处理器，判断是否需要属性注入,CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor、ImportAwareBeanPostProcessor都默认为true</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                <span class="comment">// 调用后置处理器 判断是否需要属性注入，实现InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation就不会进行属性注入</span></span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始属性注入</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 自动注入的方式。。。省略</span></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第六次调用后置处理器</span></span><br><span class="line">        <span class="comment">// 1.在ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor.postProcessProperties中指定BeanFactory</span></span><br><span class="line">        <span class="comment">// 2.在CommonAnnotationBeanPostProcessor.postProcessProperties中注入@Resurce、@WebServiceRef、@EJB相关</span></span><br><span class="line">        <span class="comment">// 3.其会在AutowiredAnnotationBeanPostProcessor.postProcessProperties中进行属性注入@Autowired、@Value、@Inject注解</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 完成属性注入</span></span><br><span class="line">                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">                pvs = pvsToUse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd)</code>方法会执行工厂相关回调方法、init方法等BeanPostProcessor后置处理器，具体如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行或者回调Aware相关接口:BeanNameAware、BeanClassLoaderAware、BeanFactoryAware，只有这三个</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 第七次调用后置处理器</span></span><br><span class="line">		<span class="comment">// 1.ApplicationContextAwareProcessor: 执行EnvironmentAware、EmbeddedValueResolverAware、ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware相关回调</span></span><br><span class="line">		<span class="comment">// 2.ImportAwareBeanPostProcessor: 实现ImportAware接口的Bean</span></span><br><span class="line">		<span class="comment">// 3.BeanPostProcessorChecker:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 4.CommonAnnotationBeanPostProcessor继承自CommonAnnotationBeanPostProcessor, 执行带@PostConstract注解的方法</span></span><br><span class="line">		<span class="comment">// 5.AutowiredAnnotationBeanPostProcessor:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 6.ApplicationListenerDetector:将ApplicationListener添加到applicationContext中</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先处理实现InitializingBean,然后处理xml的init-method方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 第8次调用后置处理器</span></span><br><span class="line">		<span class="comment">// 1.ApplicationContextAwareProcessor、ImportAwareBeanPostProcessor、: 没有做任何事情</span></span><br><span class="line">		<span class="comment">// 2.BeanPostProcessorChecker: 一些日志</span></span><br><span class="line">		<span class="comment">// 3.CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor:没有做任何事情</span></span><br><span class="line">		<span class="comment">// 4.ApplicationListenerDetector: 将符合条件的Bean放入到ApplicationContext.applicationListeners中</span></span><br><span class="line">		<span class="comment">// AOP代理 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程不仅仅是Bean的创建过程，还包括了创建Bean过程中相关的后置处理器逻辑，<strong>Spring framework</strong>相关的共6个后置处理器，具体见下文。</p>
<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><blockquote>
<p>循环依赖只有单例Bean才支持循环依赖，Spring只支持field注入的循环依赖。</p>
</blockquote>
<p>以<code>AbstractBeanFactory#doGetBean</code>为起点，该方法中有两个<code>getSingleton()</code>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 验证Bean的名字是否非法</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">// 从单例缓存中检查是否存在单例bean，第一次必定返回null</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create bean instance.</span></span><br><span class="line">        <span class="comment">// 判断类是否是单例，prototype bean Spring是不会实例化的</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建bean的过程,对象的创建以及代理</span></span><br><span class="line">                    <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                    <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                    <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                    <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                    <span class="comment">// 从单例缓存中删除该Bean，因为其可能因为循环依赖提前放入到eagerly缓存中，所以删除所有依赖其的Bean</span></span><br><span class="line">                    destroySingleton(beanName);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次<code>getSingle(String beanName)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例池(一级缓存)，存放的是实例化好的bean</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 第一次必然是空，且singletonsCurrentlyInCreation不包含该beanName</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 三级级缓存，存放临时对象，第一次必然为空</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// allowEarlyReference，在第一次调用getSingleton时写死为true,在第二次调用时,写死为false,禁用缓存工厂,返回提前暴露的AOP代理类</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 二级缓存、存放的是工厂(用于代理)</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// 将通过工厂创建的代理类，放入到三级缓存中</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">// 节省内存，没必要重新调用singletonFactory.getObject(),所以要remove</span></span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二次调用<code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code>，为重载后的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 从一级缓存中获取Bean</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前单例池是否正在被销毁</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="comment">// throw new Exception</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前bean放入到正在创建的集合singletonsCurrentlyInCreation中去</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">          	<span class="comment">// ···</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 实际创建Bean,getObject()方法实际调用的是AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="comment">// ···</span></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Bean无论创建成功还是失败都从singletonsCurrentlyInCreation中移除</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 若创建成功则将其放入到一级缓存单例池中去，并从二级缓存(singleFactories)和三级缓存(earlySingleObjects)中移除</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述源码中<code>singletonFactory.getObject()</code>实际调用的是<code>AbstractAutowireCapableBeanFactory#createBean(String, RootBeanDefinition, Object[])</code>，具体如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">    <span class="comment">// 从BeanDefinition Map中得到要创建的bean的类型</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// ···</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Bean的真正过程，</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// throw ex;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// throw ex</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续深入<code>doCreateBean(String, RootBeanDefinition, Object[])</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二次调用后置处理器,创建对象</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建的实例对象</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过后置处理器合并BeanDefinition,拿到所有需要注入的属性</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">               <span class="comment">// throw ex</span></span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否支持单例的循环依赖</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="comment">// 若支持循环依赖则将bean提前暴露</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 当支持循环依赖时，就会提前暴露自己(为了其他对象可以注入自己)，第四次调用后置处理器</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// ···· 省略Bean的注入过程和初始化过程(Aware回调、初始化方法等)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 返回的是当前bean提前暴露的对象,为代理后的对象, allowEarlyReference=false,禁用singletonObjects缓存</span></span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">// 将Bean替换成代理后的Bean</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                                                               <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                                               <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;been&quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot; &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;wrapped. This means that said other beans do not use the final version of &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;the&quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot; &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using&quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot; &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for &quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;example&quot;</span> +</span><br><span class="line">                                                               <span class="string">&quot;.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ··· 实现disposableBean接口</span></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code>方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 将singletonFactory放入到缓存工厂中,从earlySinglenObjects中移除</span></span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="comment">// 已经注册的Bean Name集合</span></span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是循环依赖相关代码。以AB互相依赖为例，假设先加载A：</p>
<ol>
<li><code>getBean(a)</code></li>
<li>调用<code>getSingleton(a)</code>，第一次调用，因为此时Bean a未创建且3个缓存中都没有,所以返回null</li>
<li>调用<code>getSingleton(a, ObjectFactory&lt;?&gt; singletonFactory)</code>，该方法中<code>singletonFactory.getObject()</code>实际调用的是<code>AbstractBeanFactory#createBean</code></li>
<li>Bean a的实例化</li>
<li>将Bean a提前暴露<code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code>，将Bean a的对象工厂加入到<code>singletonFactories</code>中</li>
<li>Bean a的属性注入(<code>populateBean(beanName, mbd, instanceWrapper)</code>)，此时发现A依赖B，调用<code>getBean(b)</code></li>
<li>调用<code>getSingleton(b)</code>，第一次调用返回<strong>null</strong></li>
<li>第二次调用<code>getSingleton(ae, ObjectFactory&lt;?&gt; singletonFactory)</code></li>
<li>Bean b的实例化</li>
<li>Bean b的属性注入，此时发现依赖A，调用<code>getBean(a)</code>，第一次执行<code>getSingleton(a)</code>，然后在<code>singletonFactories</code>中取得Bean a的工厂，调用<code>singletonFactory.getObject()</code>，这里会执行<code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code>中的<strong>lambda</strong>表达式，实际是执行一个<code>BeanPostProcessor</code>后置处理器<code>AnnotationAwareAspectJAutoProxyCreator</code>，<code>AnnotationAwareAspectJAutoProxyCreator#getEarlyBeanReference</code>生成Bean a的代理类，即Bean b 注入Bean a的代理类。</li>
<li>Bean b完成属性注入、<strong>Aware</strong>回调、初始化后，<code>getSingleton(b, false)</code>调用第一个<code>getSingleton</code>并禁用<code>singletonFacotries</code>，从<code>earlySingleObjects</code>中获取提前暴露的对象，<code>exposedObject = earlySingletonReference</code>将Bean替换为<code>earlySingletonReference</code>并返回</li>
<li>Bean a完成属性注入、Aware回调、初始化</li>
<li>Bean a返回提前暴露的<code>earlySingleObject</code>。</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB lock</title>
    <url>/blog/2020/07/16/mysql/12_innodb_lock/</url>
    <content><![CDATA[<p>Mysql InnoDB 何时加锁的整理</p>
<a id="more"></a>

<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><ul>
<li>查看事务:<code>SELECT * FROM information_schema.INNODB_TRX;</code></li>
<li>查看锁:<code>SELECT * FROM information_schema.INNODB_LOCKS;</code></li>
<li>表:<code>team_number</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;team_number&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,</span><br><span class="line">  &#96;number&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;编号&#39;,</span><br><span class="line">  &#96;group_id&#96; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;组织id&#39;,</span><br><span class="line">  &#96;name&#96; varchar(10) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,</span><br><span class="line">  &#96;age&#96; tinyint(3) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;年龄0～127&#39;,</span><br><span class="line">  &#96;sex&#96; tinyint(2) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;性别,1男;2女&#39;,</span><br><span class="line">  &#96;create_time&#96; timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT &#39;更新时间&#39;,</span><br><span class="line">  &#96;deleted&#96; tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;逻辑删除状态&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uidx_number&#96; (&#96;number&#96;),</span><br><span class="line">  KEY &#96;idx_name&#96; (&#96;name&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;小组成员表&#39;;</span><br><span class="line"></span><br><span class="line">insert into &#96;team_number&#96; (&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(123,&#39;陈一九&#39;,34);</span><br><span class="line">insert into &#96;team_number&#96; (&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(124,&#39;李仁增&#39;,31);</span><br><span class="line">insert into &#96;team_number&#96; (&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(125,&#39;王玉林&#39;,29);</span><br><span class="line">insert into &#96;team_number&#96; (&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(126,&#39;张帅&#39;,28);</span><br><span class="line">insert into &#96;team_number&#96; (&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(127,&#39;闫泽宇&#39;,28);</span><br></pre></td></tr></table></figure>

<h2 id="2-ReadView"><a href="#2-ReadView" class="headerlink" title="2. ReadView"></a>2. ReadView</h2><h3 id="1-Repeated-Read"><a href="#1-Repeated-Read" class="headerlink" title="1. Repeated Read"></a>1. Repeated Read</h3><blockquote>
<p>  在Repeated Read下，只会在创建事务时创建ReadView，默认的事务隔离级别</p>
</blockquote>
<ol>
<li>会话1</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM team_number;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>会话2</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE team_number set age &#x3D; 99 WHERE id &#x3D; 4;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行<ol>
<li>执行会话1的查询，但不提交事务</li>
<li>执行会话2不提交事务，之后执行会话1的查询。</li>
<li>会话2事务提交，执行会话1的查询</li>
<li>比较上述3个查询结果</li>
</ol>
</li>
</ol>
<h3 id="2-Read-Committed"><a href="#2-Read-Committed" class="headerlink" title="2. Read Committed"></a>2. Read Committed</h3><blockquote>
<p>  在Read Committed下，每次查询都会创建一次ReadView</p>
</blockquote>
<ol>
<li>会话1</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM team_number;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>会话2同上</p>
</li>
<li><p>执行</p>
<ol>
<li>执行会话1的查询但不提交事务</li>
<li>执行会话2但不提交事务，执行会话1的查询</li>
<li>提交会话2的事务，执行会话1的查询</li>
<li>比较结果</li>
<li>提交会话1的事务</li>
</ol>
</li>
</ol>
<h2 id="3-锁"><a href="#3-锁" class="headerlink" title="3. 锁"></a>3. 锁</h2><h3 id="1-MVCC的缺陷"><a href="#1-MVCC的缺陷" class="headerlink" title="1. MVCC的缺陷"></a>1. MVCC的缺陷</h3><blockquote>
<p>  在REPEATABLE READ隔离级别下，默认不加锁，只在第一次执行SELECT时生产一个ReadView，把脏读、不可重复读、幻读都解决了，但是其存在缺陷。</p>
</blockquote>
<ol>
<li>事务1</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第一步: 开启事务1，并执行到SELECT</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM team_number WHERE id &#x3D; 7;</span><br><span class="line">-- 第三步: 执行update语句并提交</span><br><span class="line">UPDATE team_number SET group_id &#x3D; 1 WHERE id &#x3D; 7;</span><br><span class="line">-- 第四步: 查询</span><br><span class="line">SELECT * FROM team_number WHERE id &#x3D; 7;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>事务2</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第二步: 开始事务2,执行Insert插入并提交事务</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">BEGIN;</span><br><span class="line">insert into &#96;team_number&#96; (&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(129,&#39;匿名1&#39;,27);</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>MVCC会在第一步开启事务1时，创建一个ReadView，之后创建事务2并提交。ReadView并不能阻止T1执行Update或者Delete对事务2插入的数据做改动，这就会使新事务的trx_id变成了事务1的事务Id，之后Select该记录，就会变得可见，所以MVCC并不能完全解决幻读问题。</p>
<h3 id="2-多粒度锁"><a href="#2-多粒度锁" class="headerlink" title="2. 多粒度锁"></a>2. 多粒度锁</h3><ul>
<li>行锁和表锁</li>
<li>S锁(<code> Shared Lock</code>)和X锁(<code>Exclusive Lock</code>)</li>
<li>意向锁(<strong>Intention</strong>)</li>
</ul>
<blockquote>
<p>IX锁、IS锁是表级锁，是为了在之后加表级别的X锁和S锁时可以快速判断表中记录是否存在锁(防止遍历表记录判断是否存在锁)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<h3 id="3-锁的分类"><a href="#3-锁的分类" class="headerlink" title="3. 锁的分类"></a>3. 锁的分类</h3><ol>
<li><p>表锁</p>
<ol>
<li>表级别的X锁和S锁，DML语言不会加表锁;DDL语言则会锁表</li>
<li>表级别的IS锁和IX锁，在对表中的记录加S锁和X锁时，要先对表加IS锁、IX锁</li>
</ol>
<ul>
<li><input disabled="" type="checkbox"> 表级别的<strong>AUTO-INC</strong>锁</li>
</ul>
</li>
<li><p>行锁</p>
<ol>
<li><p>记录锁(<code>LOCK_REC_NOT_GAP</code>)，<code>lock_type=RECORD</code>即仅仅把一条记录锁上。行锁区分S锁和X锁。如下图是给id=3的记录加记录锁。</p>
</li>
<li><p>间隙锁(<code>LOCK_GAP</code>)，用来解决MVVC的缺陷，当事务读取的记录不存在时，无法给记录加锁，需要使用Gap Lock，下图中给<code>id=6</code>的记录加了间隙锁，这意味着在事务期间(5,6)区间内不允许插入记录。</p>
</li>
</ol>
<blockquote>
<p>忽略id为主键，可以假设在name(张帅,匿名)区间内加<strong>间隙锁</strong>。若在该区间内插入记录,则会阻塞，直到锁释放。gap锁本质是为了防止插入新纪录，gap锁并不会限制对记录加其他锁，这仅仅是为了解决幻读问题</p>
</blockquote>
<ol start="3">
<li><p>Next Key Locks,当我们既想锁住某条记录，又想阻止其他事务在该记录前面插入数据时，就需要使用<code>LOCK_ORDINARY</code>。其本质是<code>LOCK_REC_NOT_GAP</code>和<code>LOCK_GAP</code>的合体。</p>
</li>
<li><p>Insert Intention Locks,当我们要插入一条新纪录时，需要判断一下插入位置是否被别的事务加了<code>LOCK_GAP</code>锁，若存在锁，则事务等待，直到拥有<code>LOCK_GAP</code>锁的事务提交(释放锁)。但是插入记录的事务在等待时也需要在内存中生成一个锁结构，表明有事务想在间隙中插入新纪录。官方命名为:<code>LOCK_INSERT_INTENTION</code>，即<strong>插入意向锁</strong>。</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://images.effiu.cn/blog/other/image03.png" alt="锁示意图"></p>
<h2 id="4-语句加锁分析"><a href="#4-语句加锁分析" class="headerlink" title="4. 语句加锁分析"></a>4. 语句加锁分析</h2><p>SQL语句加锁本身是一个伪命题，因为一个语句加锁有很多制约条件，例如:</p>
<ul>
<li>事务隔离级别</li>
<li>执行时使用的索引</li>
<li>查询条件</li>
<li>具体执行的语句类型</li>
</ul>
<p><font color='red'><strong>加锁</strong>是为了解决并发事务执行过程中引起的脏写、脏读、不可重复读、幻读</font>。其中MVCC算是一种解决脏读、不可重复读、幻读的一种方案。加锁是为了解决上述问题不同场景，需要加的锁不一样，不能为了加锁而加锁。</p>
<p>正常工作中，SQL语句大致分为3类，普通SELECT语句、锁定读的语句(UPDATE、DELETE等)、INSERT语句。</p>
<p>采用加锁的方式解决读-写问题时，不可重复读、脏读都不会发生，因为所有行为都要排队进行。</p>
<h3 id="1-普通SELECT语句"><a href="#1-普通SELECT语句" class="headerlink" title="1. 普通SELECT语句"></a>1. 普通SELECT语句</h3><ul>
<li><code>READ UNCOMMITTED</code>隔离级别下，不加锁，直接读取记录的最新版本，可能发生<code>脏读</code>、<code>不可重复读</code>和<code>幻读</code>问题。</li>
<li><code>READ COMMITTED</code>隔离级别下，不加锁，在每次执行普通的<code>SELECT</code>语句时都会生成一个<code>ReadView</code>，这样解决了<code>脏读</code>问题，但没有解决<code>不可重复读</code>和<code>幻读</code>问题。</li>
<li><code>REPEATABLE READ</code>隔离级别下，不加锁，只在第一次执行普通的<code>SELECT</code>语句时生成一个<code>ReadView</code>，这样把<code>脏读</code>、<code>不可重复读</code>和<code>幻读</code>问题都解决了，但是<font color='red'><strong>MVVC存在缺陷</strong></font>。</li>
<li><code>SERIALIZABLE</code>隔离级别下，需要分为两种情况讨论：<ul>
<li>禁用自动提交时，普通的<code>SELECT</code>语句会被转为<code>SELECT ... LOCK IN SHARE MODE</code>这样的语句，也就是在读取记录前需要先获得记录的<code>S锁</code>，具体的加锁情况和<code>REPEATABLE READ</code>隔离级别下一样。</li>
<li>启用自动提交时，普通的<code>SELECT</code>语句并不加锁，只是利用<code>MVCC</code>来生成一个<code>ReadView</code>去读取记录。因为启用自动提交意味着一个事务中只包含一条语句，一条语句也就没有<code>不可重复读</code>、<code>幻读</code>这样的问题。</li>
</ul>
</li>
</ul>
<h3 id="2-锁定读"><a href="#2-锁定读" class="headerlink" title="2. 锁定读"></a>2. 锁定读</h3><ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...</code></li>
<li><code>DELETE ...</code></li>
</ul>
<blockquote>
<p>UPDATE和DELETE因为在执行过程中需要先定位被改动的记录并给记录加锁，也需要先读取</p>
</blockquote>
<p>锁定读语句，在<code>READ UNCOMMITTED/READ COMMITTED</code>隔离级别下是一致的。</p>
<h4 id="使用主键等值查询"><a href="#使用主键等值查询" class="headerlink" title="使用主键等值查询"></a>使用主键等值查询</h4><ul>
<li><p><code>SELECT * FROM team_number WHERE id = 6 LOCK IN SHARE MODE;</code> 为id=5的记录加S锁。</p>
</li>
<li><p><code>SELECT * FROM team_number WHERE id = 6 FOR UPDATE;</code>为id=5的记录加X锁。</p>
</li>
<li><p><code> UPDATE ......</code> 为记录加锁，若锁不涉及二级索引则，其只加<code>RECORD</code>类型的X锁。若<code>UPDATE</code>语句更新列包含二级索引，例如<code>UPDATE team_number SET name = &#39;佚名&#39; WHERE id = 6;</code>。这时会先对<code>id = 6</code>的聚簇索引加X锁,然后对<code>id = 6</code>对应的二级索引的记录加X锁</p>
</li>
<li><p><code>DELETE ......</code>对聚簇索引和所有的二级索引中对应的记录做<code>DELETE</code>操作。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第一步: 开启事务1，并执行到SELECT</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line">-- SELECT * FROM team_number WHERE number &#x3D; 125 LOCK IN SHARE MODE;</span><br><span class="line">-- UPDATE team_number SET sex &#x3D; 1 WHERE id &#x3D; 6;</span><br><span class="line">UPDATE team_number SET name &#x3D; &#39;6佚名&#39; WHERE id &#x3D; 6;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第二步，事务2</span><br><span class="line"></span><br><span class="line">-- 用来演示当对聚簇索引和idx_name加锁时,未对uidx_number索引加锁</span><br><span class="line">SELECT id,number FROM team_number FORCE INDEX(uidx_number) WHERE number&#x3D; 128 LOCK IN SHARE MODE;</span><br><span class="line">&#x2F;&#x2F; 同时对聚簇索引和idx_name二级索引加锁</span><br><span class="line">SELECT * FROM team_number FORCE INDEX(idx_name) WHERE name &#x3D; &#39;佚名&#39; FOR UPDATE;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">UPDATE team_number FORCE INDEX(idx_name) set sex &#x3D; 2 WHERE name &#x3D; &#39;6佚名&#39; </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第三步，事务3</span><br><span class="line">&#x2F;&#x2F; 观察聚簇索引锁和二级索引锁</span><br><span class="line">SELECT * FROM team_number WHERE id &#x3D; 6 FOR UPDATE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用主键进行范围查询"><a href="#使用主键进行范围查询" class="headerlink" title="使用主键进行范围查询"></a>使用主键进行范围查询</h4><ul>
<li><code>SELECT * FROM team_number WHERE id &lt;= 5 LOCK IN SHARE MODE;</code>，S锁</li>
</ul>
<ol>
<li><p>先到聚簇索引中定位到满足<code>id &lt;= 5</code>的第一条记录，也就是<code>id</code>值为<code>1</code>的记录，然后为其加锁。</p>
<ol start="2">
<li>判断一下该记录是否符合<code>索引条件下推</code>中的条件。</li>
<li>该记录是否符合范围查询的边界条件，Mysql要求每从聚簇索引中取出一条记录都要判断是否符合边界条件，若不符合则释放掉锁，并返回（返回之前不会释放1～5的S锁）。</li>
<li>最后符合要求的id依次为，1～5。</li>
<li>但是其在判断是否符合条件时是要加锁的，若不符合条件会在释放锁(若该记录有锁则会阻塞)。</li>
</ol>
</li>
<li><p>若id=6此时存在锁,则该查询会阻塞</p>
<ol start="7">
<li>若条件为<code>id&gt;=5</code>，则在最后一条<code>Supremum</code>伪记录并不会上锁</li>
<li><strong>并不时根据索引找到id=5的记录，然后向前寻找</strong></li>
</ol>
</li>
</ol>
<ul>
<li><p><code>SELECT ... FOR UPDATE</code>，X锁</p>
</li>
<li><p>若<code>UPDATE</code>语句并没有更新二级索引列，加锁方式与<code>SELECT ... FOR UPDATE</code>语句一致，X锁。若更新二级索引列，<code>UPDATE team_number SET name = &#39;6佚名&#39; WHERE id &gt;= 6;</code>，则会先对聚簇索引加X锁，在对二级索引加锁。</p>
<ol>
<li>先对<code>id=6</code>的记录的聚簇索引加锁，再对idx_name索引加锁</li>
<li>对<code>id=7</code>的记录重复上述操作</li>
<li>对所有满足条件的记录重复上述操作。</li>
<li>若条件为<code>id&lt;=7</code>，则只会对聚簇索引加锁，随后释放锁，并不会对二级索引加锁</li>
</ol>
</li>
<li><p><code>DELETE ...</code>，会对聚簇所有以及所有二级索引加锁，其过程与<code>UPDATE ...</code>一致</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第一步: 开启事务1，并执行到SELECT</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line">-- X锁，其与S锁不兼容便于查看效果</span><br><span class="line">SELECT * FROM team_number WHERE id &lt;&#x3D; 5 FOR UPDATE;</span><br><span class="line">-- 抢占id&#x3D;6的X锁</span><br><span class="line">UPDATE team_number SET sex &#x3D; 2 WHERE id &#x3D; 6;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- X锁</span><br><span class="line">SELECT * FROM team_number WHERE id &#x3D; 5 FOR UPDATE;</span><br><span class="line"></span><br><span class="line">-- X锁,id&#x3D;6未抢到</span><br><span class="line">SELECT * FROM team_number WHERE id &lt;&#x3D; 5 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- X锁</span><br><span class="line">SELECT * FROM team_number WHERE id &#x3D; 5 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h4 id="二级索引进行等值查询"><a href="#二级索引进行等值查询" class="headerlink" title="二级索引进行等值查询"></a>二级索引进行等值查询</h4><blockquote>
<p>在READ UNCOMMITTED和READ COMMITTED隔离级别下，使用普通的二级索引和唯一二级索引进行加锁的过程是一样的。</p>
</blockquote>
<ul>
<li><code>SELECT ... FOR UPDATE;</code>。例如<code>SELECT * team_number FORCE INDEX(idx_name) WHERE name = &#39;6佚名&#39; FOR UPDATE; </code>，其是先对<code>idx_name</code>所属的二级索引加X锁，然后进行回表操作(不考虑数据量太小，Mysql直接全表查询的情况)，对聚簇索引加X锁。<ul>
<li>当二级索引非唯一索引时，MySQL对等值匹配的条件有特殊处理，他们规定在InnoDB存储引擎层查找到当前记录的下一条记录时，在对其加锁前就直接判断该记录是否满足等值匹配的条件，如果不满足直接返回</li>
<li>事务1先对二级索引加锁，同时事务2则对同一记录的聚簇索引加锁，这种情况会导致死锁。</li>
</ul>
</li>
<li><code>SELECT ... LOCK IN SHARE MODE</code>。与<code>SELECT ... FOR UPDATE;</code>类似。先对二级索引加S锁，在对聚簇索引加S锁。</li>
<li><code>UPDATE ...</code>，与<code>SELECT ... FOR UPDATE;</code>类似,若更新了其他二级索引的字段，则也会对该索引加锁。</li>
<li><code>DELETE ...</code>，与<code>UPDATE ...</code>类似</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE team_number SET &#96;name&#96; &#x3D; &#39;匿名&#39; WHERE number &#x3D; 128;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 事务1，聚簇索引锁</span><br><span class="line">SELECT * FROM team_number WHERE id &#x3D; 6 LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 事务2，idx_name索引锁</span><br><span class="line">SELECT * FROM team_number WHERE &#96;name&#96; &#x3D; &#39;佚名&#39; LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 事务3，uidx_number索引锁</span><br><span class="line">SELECT * FROM team_number WHERE &#96;number&#96; &#x3D; 128 LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<h4 id="二级索引进行范围查询"><a href="#二级索引进行范围查询" class="headerlink" title="二级索引进行范围查询"></a>二级索引进行范围查询</h4><ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code>为记录加S锁，先给二级索引加S锁，再给聚簇索引加S锁。</li>
<li><code>SELECT ... FOR UPDATE;</code>来为记录加X锁，先给二级索引加X锁，再给聚簇索引加S锁。</li>
<li><code>UDPATE ...</code>，与<code>SELECT ... FOR UPDATE;</code>类似,若更新了其他二级索引则会对其加锁</li>
<li><code>DELETE ...</code>与``UDPATE …`类似</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> <code>UPDATE team_number SET sex = 1 WHERE number &lt;=127;</code>，其从前向后查询然后比较，对每一条记录都是先加锁后判断(索引条件下推或者返回)，<strong>在5.7.21中，并没有释放掉最后一个记录的锁(number=128)</strong></li>
</ul>
<blockquote>
<p>在使用主键进行范围查询时，已经说明其会对最后一条记录先加锁后释放锁(若update包含二级索引，则也不会对二级索引加锁)，但是针对二级索引进行范围查询时，number=128记录是先对二级索引加锁，在对聚簇索引加锁，然后释放掉聚簇索引锁，在释放二级索引锁</p>
</blockquote>
<h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><ul>
<li><p><code>SELECT ... LOCK IN SHARE MODE;</code>为聚簇索引记录加S锁</p>
</li>
<li><p><code>SELECT ... FOR UPDATE;</code>为聚簇索引记录加X锁</p>
<blockquote>
<p>在遍历聚簇索引过程中，都会先为每条记录加锁，若不满足条件则释放</p>
</blockquote>
</li>
<li><p><code>UDPATE ...</code>，与<code>SELECT ... FOR UPDATE;</code>类似,若更新了其他二级索引则会对其加锁</p>
<blockquote>
<p>若不满足条件，也不会为二级索引加锁</p>
</blockquote>
</li>
<li><p><code>DELETE ...</code>与``UDPATE …`类似</p>
</li>
</ul>
<p><code>SELECT * FROM team_number WHERE sex = 1 FOR UPDATE;</code></p>
<h3 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3. 幻读"></a>3. 幻读</h3><p>MySQL<code>REPEATABLE READ</code>要解决的是幻读问题，而幻读是新增记录，所以不涉及<strong>幻读</strong>(插入SQL)的加锁方式均与<code>READ UNCOMMITTED</code>和<code>READ COMMITTED</code>一致</p>
<blockquote>
<p>GAP锁的S锁与S锁目标一致，都是为了解决幻读，禁止插入记录。</p>
</blockquote>
<h4 id="主键进行等值查询"><a href="#主键进行等值查询" class="headerlink" title="主键进行等值查询"></a>主键进行等值查询</h4><ul>
<li><code>SELECT * FROM team_number WHERE id = 9 FOR UPDATE;</code>，<ul>
<li>主键具有唯一性，所以多次执行改SQL时，也不会出现别的记录，也就没有幻读问题，此时与<code>READ UNCOMMITTED</code>和<code>READ COMMITTED</code>一致，在<code>id=6</code>的记录上加X锁。</li>
<li>若<code>id=9</code>的记录不存在,那么为了禁止幻读产生，必须要在(7,20)之间加gap锁</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第一步</span><br><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM team_number WHERE id &#x3D; 8 FOR UPDATE;</span><br><span class="line">&#x2F;&#x2F; 第三步</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第2步</span><br><span class="line">insert into &#96;team_number&#96; (&#96;id&#96;,&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(19,149,&#39;匿名9&#39;,28);</span><br></pre></td></tr></table></figure>

<p>其他情况不会产生幻读，所以与<code>READ UNCOMMITTED</code>和<code>READ COMMITTED</code>一致。</p>
<h4 id="主键进行范围查询"><a href="#主键进行范围查询" class="headerlink" title="主键进行范围查询"></a>主键进行范围查询</h4><ul>
<li><code>SELECT * FROM team_number WHERE id &gt;= 8 FOR UPDATE</code>，为了解决幻读问题，需要禁止插入<code>id &gt;=8</code>的记录，而主键是唯一的,所以只需保证禁止插入<code>id&gt;8</code>的记录就可以。<ul>
<li>为<code>id=8</code>的记录加上X锁</li>
<li>为<code>id&gt;8</code>的所有聚簇索引加上X型的<strong>Next-Key</strong>锁(Record锁+GAP锁)</li>
<li>针对<code>Supremum</code>记录也加GAP锁，但是当作GAP锁处理的。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM team_number WHERE id &gt;&#x3D; 8 LOCK IN SHARE MODE;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 观察X型GAP锁</span><br><span class="line">insert into &#96;team_number&#96; (&#96;id&#96;,&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(18,148,&#39;匿名8&#39;,28);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 观察X锁</span><br><span class="line">UPDATE team_number SET sex &#x3D; 2 WHERE id &#x3D; 19;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SELECT * FROM team_number WHERE id &lt;= 7 FOR UPDATE</code>，这个有点特殊(与<code>READ UNCOMMITTED</code>和<code>READ COMMITTED</code>类似)<ul>
<li><code>REPEATABLE READ</code>隔离级别下，在判断<code>id=18</code>的记录不满足边界条件<code>id&lt;=7</code>后，并不会去释放加在该记录上的锁</li>
<li><ul>
<li><input disabled="" type="checkbox"> 不这里为什么要这样</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM team_number WHERE id &lt;&#x3D; 7 FOR UPDATE;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 并没有释放掉 id&#x3D;19的记录锁</span><br><span class="line">UPDATE team_number SET sex &#x3D; 2 WHERE id &#x3D; 19;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 没有对 id &#x3D; 20 的记录加锁</span><br><span class="line">UPDATE team_number SET sex &#x3D; 2 WHERE id &#x3D; 20;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code>与<code>SELECT ... FOR UPDATE</code>类似</li>
<li><code>UPDATE ...</code>，与<code>SELECT ... FOR UDPATE</code>类似，如果<code>UPDATE</code>语句更新二级索引列，则需要将对应二级索引列加锁<ul>
<li><code>update team_number set name = &#39;匿名&#39; where id &lt;= 7</code>，虽然会对<code>id=18</code>的聚簇索引加锁,但是并没有对其二级索引加锁</li>
</ul>
</li>
<li><code>DELETE</code>与<code>UPDATE</code>类似</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line">update team_number set name &#x3D; &#39;匿名&#39; where id &lt;&#x3D; 7;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用聚簇索引查看锁</span><br><span class="line">UPDATE team_number SET sex &#x3D; 2 WHERE id &#x3D; 19;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用idx_number查看锁,只堵塞在聚簇索引出，没有阻塞idx_number索引</span><br><span class="line">UPDATE team_number SET sex &#x3D; 2 WHERE number &#x3D; 19;</span><br></pre></td></tr></table></figure>

<h4 id="唯一二级索引进行等值查询"><a href="#唯一二级索引进行等值查询" class="headerlink" title="唯一二级索引进行等值查询"></a>唯一二级索引进行等值查询</h4><ul>
<li><code>SELECT * FROM team_number WHERE number=126 FOR UPDATE</code><ul>
<li><code>number</code>列是唯一二级索引，所以没有幻读问题，只需要给<code>idx_number</code>加一个X型锁以及对聚簇索引加X锁。</li>
<li>若<code>number=130</code>，数据不存在，则会对<code>number=149</code>加GAP锁，但是并不会给聚簇索引加锁</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM team_number FORCE INDEX(uidx_number) WHERE number &#x3D; 130 FOR UPDATE;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看锁结构，其并没有对聚簇索引加锁</span><br><span class="line">insert into &#96;team_number&#96; (&#96;id&#96;,&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(18,147,&#39;匿名8&#39;,28);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code>，与<code>SELECT ... FOR UPDATE</code>类似</li>
<li><code>UPDATE ...</code>与<code>SELETE ... FOR UPDATE</code>类似,若被更新的列包含其他二级索引列，则对应的二级索引记录也会被加<code>X型正经记录锁</code>。</li>
</ul>
<h4 id="唯一二级索引进行范围查询的"><a href="#唯一二级索引进行范围查询的" class="headerlink" title="唯一二级索引进行范围查询的"></a>唯一二级索引进行范围查询的</h4><ul>
<li><code>SELECT ... FOR UPDATE</code>，与使用主键进行范围查询类似，区别是先对二级索引加GAP锁，再对对应的聚簇索引记录加<code>RECORD</code>锁<ul>
<li><code>SELECT * FROM team_number where number &gt;= 147 FOR UPDATE;</code>，对<code>number &gt;= 147</code>加Next-Key锁</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM team_number FORCE INDEX(uidx_number) where number &gt;&#x3D; 147 FOR UPDATE;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 聚簇索引X锁阻塞</span><br><span class="line">UPDATE team_number SET sex &#x3D; 2 WHERE id &#x3D; 7;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 事务3 插入记录，会因为gap锁阻塞，因为对id&#x3D;147也是Next-Key锁</span><br><span class="line">insert into &#96;team_number&#96; (&#96;id&#96;,&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(17,146,&#39;匿名7&#39;,28);</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/other/image04.png" alt="锁结构"></p>
<ul>
<li><code>SELECT * FROM team_number WHERE number &lt;= 129 LOCK IN SHARE MODE;</code>其会给<code>number=129</code>以及之前的每条记录加Next-Key锁，其会对<code>id&gt;129</code>的第一条记录加Next-Key锁并不会释放</li>
<li><code>SELECT ... LOCK IN SHARE MODE</code>与<code>SELECT ... FOR UPDATE</code>类似</li>
<li><code>UPDATE ...</code>与<code>SELECT ... FOR UPDATE</code>类似，若更新了其他二级索引，则也会对该索引列加锁</li>
<li><code>DELETE ...</code> 与<code>UPDATE ...</code> 类似</li>
</ul>
<h4 id="普通二级索引进行等值查询"><a href="#普通二级索引进行等值查询" class="headerlink" title="普通二级索引进行等值查询"></a>普通二级索引进行等值查询</h4><ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code>，例如<code>SELECT * FROM team_number where name=&#39;匿名&#39; FOR UPDATE;</code><ul>
<li>普通二级索引，所以允许重复，其会对所有<code>name=&#39;匿名&#39;</code>的记录加Next-Key锁，然后对最后一个<code>name=&#39;匿名&#39;</code>的下一条记录加GAP锁。</li>
<li>若普通二级索引不存在，则会在其下一条记录上加Gap锁</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SET autocommit &#x3D; 0;</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM team_number where &#96;name&#96; &#x3D; &#39;7匿名&#39; FOR UPDATE;</span><br><span class="line">-- SELECT * FROM team_number where &#96;name&#96; &#x3D; &#39;8匿名&#39; FOR UPDATE;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 因为其对每条name&#x3D;&#39;7匿名&#39;的记录都加了Next-Key锁，所以阻塞</span><br><span class="line">insert into &#96;team_number&#96; (&#96;id&#96;,&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(17,130,&#39;7匿名&#39;,28);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 因为其对name&#x3D;&#39;9匿名&#39;记录加了Gap锁，所以阻塞</span><br><span class="line">insert into &#96;team_number&#96; (&#96;id&#96;,&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(17,130,&#39;8匿名&#39;,28);</span><br><span class="line">-- 记录不存在的加锁情况</span><br><span class="line">insert into &#96;team_number&#96; (&#96;id&#96;,&#96;number&#96;,&#96;name&#96;,&#96;age&#96;) values(17,130,&#39;9匿名&#39;,28);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code>与<code>SELECT ... FOR UPDATE</code>类似</li>
<li><code>UPDATE ...</code>与<code>SELECT ... FOR UPDATE</code>类似，若包含其他二级索引，则会对对应索引记录加X锁</li>
<li><code>DELETE ...</code>与<code>UPDATE ...</code>类似</li>
</ul>
<h4 id="普通二级索引进行范围查询"><a href="#普通二级索引进行范围查询" class="headerlink" title="普通二级索引进行范围查询"></a>普通二级索引进行范围查询</h4><blockquote>
<p>与唯一二级索引情况一致</p>
</blockquote>
<h4 id="全表扫描-1"><a href="#全表扫描-1" class="headerlink" title="全表扫描"></a>全表扫描</h4><ul>
<li><code>SELECT * FROM team_number where sex = 2 FOR UDPATE</code>,全表扫描，每读取一条记录都会先加X锁，再判断<code>sex = 2</code>条件是否成立</li>
</ul>
<blockquote>
<p>在REPEATABLE READ隔离级别下，InnoDB存储引擎并不会真正的释放掉锁，所以聚簇索引的全部记录都会被加锁，并且在事务提交前不释放。此时其他事务的任何请求都会被阻塞，会严重影响并发事务处理能力。</p>
</blockquote>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code>与<code>SELECT ... FOR UPDATE</code>类似</li>
<li><code>UPDATE ...</code>与<code>SELECT ... FOR UPDATE</code>类似，若包含其他二级索引的也会对二级索引加锁</li>
<li><code>DELETE</code>与<code>UPDATE ...</code>类似，且会对所有二级索引加锁</li>
</ul>
<h3 id="INSERT-语句"><a href="#INSERT-语句" class="headerlink" title="INSERT 语句"></a>INSERT 语句</h3><blockquote>
<p><code>INSERT</code>语句一般情况下不加锁，不过当前事务在插入一条记录前需要先定位到该记录在<code>B+树</code>中的位置，如果该位置的下一条记录已经被加了<code>gap锁</code>(<code>next-key锁</code>也包含<code>gap锁</code>)，那么当前事务会在该记录上加上一种类型为<code>插入意向锁</code>的锁，并且事务进入等待状态。</p>
</blockquote>
<h4 id="主键或者唯一索引重复"><a href="#主键或者唯一索引重复" class="headerlink" title="主键或者唯一索引重复"></a>主键或者唯一索引重复</h4><ul>
<li><p>当插入重复主键时报错，<code>Duplicate entry &#39;20&#39; **for** key &#39;PRIMARY&#39;</code>,其实在报错之前会对聚簇索引中加S锁(相当于一次读取)</p>
<ul>
<li>在<code>READ UNCOMMITTED/READ COMMITTED</code>隔离级别下，加的是<code>S型正经记录锁</code>。</li>
<li>在<code>REPEATABLE READ/SERIALIZABLE</code>隔离级别下，加的是<code>S型next-key锁</code>。</li>
</ul>
</li>
<li><p>当插入唯一的二级索引重复时，会在报错前对已经在B+树中的唯一二级索引记录加<code>Next-Key</code>锁。</p>
</li>
<li><p><code>INSERT ... ON DUPLICATE KEY ...</code>，会对<code>B+树</code>中已存在的相同键值的记录加<code>X锁</code>，而不是<code>S锁</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HikariCP</title>
    <url>/blog/2020/05/04/java/HikariCP/</url>
    <content><![CDATA[<p>HikarCP是快速、简单、可靠的、非常轻量的JDBC连接池。</p>
<a id="more"></a>

<h2 id="1-HikariConfig"><a href="#1-HikariConfig" class="headerlink" title="1. HikariConfig"></a>1. HikariConfig</h2><h3 id="1-基本配置项"><a href="#1-基本配置项" class="headerlink" title="1. 基本配置项"></a>1. 基本配置项</h3><ul>
<li><p><code>dataSourceClassName</code>:JDBC驱动程序提供的<code>DataSource</code>类的名称。如果使用<code>jdbcUrl</code>进行基于老式<code>DriverManager</code>的<code>JDBC</code>驱动程序配置，则不需要此属性。见源码:<code>com.zaxxer.hikari.pool.PoolBase#initializeDataSource中</code></p>
</li>
<li><p><code>jdbcUrl</code>:HikariCP会基于<code>DriverManager</code>进行<code>DataSource</code>进行数据源的配置，基于数据源的配置优于基于jdbcUrl的配置，但是实际差异不大。</p>
</li>
<li><p><code>username</code>:设置从基础驱动程序获取连接时使用的身份验证的用户名。</p>
</li>
<li><p><code>password</code>:设置从基础驱动程序获取链接时使用的身份验证的密码。</p>
</li>
<li><p><code>isAutoCommit</code>:控制从连接池返回的连接的自动提交行为，默认为true</p>
</li>
<li><p><code>connectionTimeout</code>:控制客户端等待来自池的连接的最大毫秒数，最小值为250ms，默认值为<code>Integer.MAX_VALU</code>。</p>
</li>
<li><p><code>idleTimeout</code>:控制池中处于空闲状态的连接的最长时间。仅仅当<code>minimumIdle</code>小于<code>maximumPoolSize</code>时才会起作用，否则当达到<code>maximumPoolSize</code>后将不会销毁。若值为0，则表示永远不会销毁，最小值为10s，默认值为10m。</p>
</li>
<li><p><code>maxLifeTime</code>:此属性控制池中连接的最大生存期。使用中的连接永远不会停止使用，只有在关闭后才将其删除。0表示无限寿命(会遵守<code>idleTime</code>设置)，默认30m。</p>
</li>
<li><p><code>connectionTestQuery</code>:若支持JDBC4，则不推荐设置该属性。是针对不支持JDBC4的驱动程序在从池中提供连接之前执行的查询，以验证与数据库的连接仍然有效。</p>
<blockquote>
<p>  JDBC4以后，<code>connection</code>提供了<code>isValid</code>方法，不再需要改配置检查连接,见<code>com.zaxxer.hikari.pool.PoolBase#isConnectionAlive</code>。</p>
</blockquote>
</li>
<li><p><code>minIdle</code>:连接池中的最小空闲数，若空闲连接下降到该值以下，且池中总连接数小于<code>maxPoolSize</code>,则<strong>HikariCP</strong>将最大努力快速有效地添加连接。<font color='red'>为了获得最佳性能和对峰值需求的响应能力,不建议设置此值</font>。默认等于<code>maxPoolSize</code>。</p>
</li>
<li><p><code>maxPoolSize</code>:控制允许池内连接数达到的最大值，包括空闲中和使用中的连接数。当池内连接数达到最大且空闲连接为0时，<code>getConnection()</code>将阻塞<code>connectioinTimeout</code>秒。</p>
</li>
<li><p><code>poolName</code>:表示连接池的用户定义名称，主要用于在日志或者JMX管理控制台中，以识别池信息，默认自动生成，<code>poolName = &quot;HikariPool-&quot; + POOL_NUMBER.getAndIncrement();</code>。</p>
</li>
<li><p><code>connectionInitSql</code>:设置一个SQL语句，每次创建连接后执行，然后把连接加入到连接池中。</p>
</li>
</ul>
<h3 id="2-配置方式"><a href="#2-配置方式" class="headerlink" title="2. 配置方式"></a>2. 配置方式</h3><ol>
<li><code>new HikariCP()</code>，其是通过<code>System.setProperty(&quot;hikaricp.configurationFile&quot;, filePath)</code>获取配置文件路径，将配置文件加载为<code>Properties</code>，然后通过反射将文件内的配置信息初始化。</li>
<li><code>new HikariConfig(Properties properties)</code>，直接通过反射将properties内的配置信息初始化连接池配置。</li>
<li><code>new HikariConfig(String propertyFileName)</code>与1类似。</li>
</ol>
<h3 id="3-部分源码"><a href="#3-部分源码" class="headerlink" title="3. 部分源码"></a>3. 部分源码</h3><p><code>HikariConfig</code>是一个连接池配置属性类，主要是一些配置属性及其<code>get</code>和<code>set</code>方法，还有这些属性是否合法的校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateNumerics</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// maxLifetime不能小于30s</span></span><br><span class="line">    <span class="keyword">if</span> (maxLifetime != <span class="number">0</span> &amp;&amp; maxLifetime &lt; SECONDS.toMillis(<span class="number">30</span>)) &#123;</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;&#123;&#125; - maxLifetime is less than 30000ms, setting to default &#123;&#125;ms.&quot;</span>, poolName, MAX_LIFETIME);</span><br><span class="line">        maxLifetime = MAX_LIFETIME;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若idleTimeout大于maxLifetime且maxLifetime大于0，则idleTimeout=0</span></span><br><span class="line">    <span class="keyword">if</span> (idleTimeout + SECONDS.toMillis(<span class="number">1</span>) &gt; maxLifetime &amp;&amp; maxLifetime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;&#123;&#125; - idleTimeout is close to or more than maxLifetime, disabling it.&quot;</span>, poolName);</span><br><span class="line">        idleTimeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// idleTimeout必须大于10</span></span><br><span class="line">    <span class="keyword">if</span> (idleTimeout != <span class="number">0</span> &amp;&amp; idleTimeout &lt; SECONDS.toMillis(<span class="number">10</span>)) &#123;</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;&#123;&#125; - idleTimeout is less than 10000ms, setting to default &#123;&#125;ms.&quot;</span>, poolName, IDLE_TIMEOUT);</span><br><span class="line">        idleTimeout = IDLE_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leakDetectionThreshold &gt; <span class="number">0</span> &amp;&amp; !unitTest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leakDetectionThreshold &lt; SECONDS.toMillis(<span class="number">2</span>) || (leakDetectionThreshold &gt; maxLifetime &amp;&amp; maxLifetime &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            LOGGER.warn(<span class="string">&quot;&#123;&#125; - leakDetectionThreshold is less than 2000ms or more than maxLifetime, disabling it.&quot;</span>, poolName);</span><br><span class="line">            leakDetectionThreshold = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connectionTimeout必须大于250ms</span></span><br><span class="line">    <span class="keyword">if</span> (connectionTimeout &lt; <span class="number">250</span>) &#123;</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;&#123;&#125; - connectionTimeout is less than 250ms, setting to &#123;&#125;ms.&quot;</span>, poolName, CONNECTION_TIMEOUT);</span><br><span class="line">        connectionTimeout = CONNECTION_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// validationTimeout必须大于250ms</span></span><br><span class="line">    <span class="keyword">if</span> (validationTimeout &lt; <span class="number">250</span>) &#123;</span><br><span class="line">        LOGGER.warn(<span class="string">&quot;&#123;&#125; - validationTimeout is less than 250ms, setting to &#123;&#125;ms.&quot;</span>, poolName, VALIDATION_TIMEOUT);</span><br><span class="line">        validationTimeout = VALIDATION_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若maxPoolSize小于0，则maxPoolSize = minIdle</span></span><br><span class="line">    <span class="keyword">if</span> (maxPoolSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            minIdle = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPoolSize = minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若minIdle小于0或者大于maxPoolSize，则minIdle = maxPoolSize</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span> || minIdle &gt; maxPoolSize) &#123;</span><br><span class="line">        minIdle = maxPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-HikariConfigMXBean"><a href="#4-HikariConfigMXBean" class="headerlink" title="4. HikariConfigMXBean"></a>4. HikariConfigMXBean</h3><p><code>HikariConfig</code>实现了<code>HikariConfigMXBean</code>，其是一个<code>javax.management</code>的MBean，用于连接池的配置。<code>HikariConfigMXBean</code>其内部方法如下:</p>
<p><img src="https://images.effiu.cn/blog/other/hikaricp/02.png" alt="HikariConfigMXBean方法"></p>
<blockquote>
<p>  JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。通常使用JMX来监控系统的运行状态或管理系统的某些方面，比如清空缓存、重新加载配置文件等</p>
</blockquote>
<h2 id="2-PoolBase"><a href="#2-PoolBase" class="headerlink" title="2. PoolBase"></a>2. PoolBase</h2><p>PoolBase是一个抽象类，其实现了连接池的部分公共方法。</p>
<ol>
<li>初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.zaxxer.hikari.pool.PoolBase#initializeDataSource中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeDataSource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String jdbcUrl = config.getJdbcUrl();</span><br><span class="line">    <span class="keyword">final</span> String username = config.getUsername();</span><br><span class="line">    <span class="keyword">final</span> String password = config.getPassword();</span><br><span class="line">    <span class="keyword">final</span> String dsClassName = config.getDataSourceClassName();</span><br><span class="line">    <span class="keyword">final</span> String driverClassName = config.getDriverClassName();</span><br><span class="line">    <span class="keyword">final</span> Properties dataSourceProperties = config.getDataSourceProperties();</span><br><span class="line"></span><br><span class="line">    DataSource dataSource = config.getDataSource();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//说明dataSourceClassName和jdbcUrl不需要同时配置</span></span><br><span class="line">	<span class="comment">// 会根据dataSourceName初始化dataSource</span></span><br><span class="line">    <span class="keyword">if</span> (dsClassName != <span class="keyword">null</span> &amp;&amp; dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dataSource = createInstance(dsClassName, DataSource.class);</span><br><span class="line">        PropertyElf.setTargetFromProperties(dataSource, dataSourceProperties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据jdbcUrl初始化dataSource</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jdbcUrl != <span class="keyword">null</span> &amp;&amp; dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        dataSource = <span class="keyword">new</span> DriverDataSource(jdbcUrl, driverClassName, dataSourceProperties, username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据connectionTimeout，最小为1000</span></span><br><span class="line">        setLoginTimeout(dataSource, connectionTimeout);</span><br><span class="line">        <span class="comment">// 创建网络超时坚持任务</span></span><br><span class="line">        createNetworkTimeoutExecutor(dataSource, dsClassName, jdbcUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>建立连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Connection <span class="title">newConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String username = config.getUsername();</span><br><span class="line">        String password = config.getPassword();</span><br><span class="line"></span><br><span class="line">        connection = (username == <span class="keyword">null</span>) ? dataSource.getConnection() : dataSource.getConnection(username, password);</span><br><span class="line">        <span class="comment">// 设置一些初始值或者状态，例如超时时间、自动提交、事物隔离级别、连接检查等</span></span><br><span class="line">        setupConnection(connection);</span><br><span class="line">        lastConnectionFailure.set(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        lastConnectionFailure.set(e);</span><br><span class="line">        quietlyCloseConnection(connection, <span class="string">&quot;(Failed to create/set connection)&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置连接的初始状态,包括网络超时时间、驱动版本、连接的一些属性等等</span></span><br><span class="line"><span class="comment"> * Setup a connection initial state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connection a Connection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException thrown from driver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupConnection</span><span class="params">(<span class="keyword">final</span> Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (networkTimeout == UNINITIALIZED) &#123;</span><br><span class="line">        <span class="comment">// validationTimeout控制测试连接活跃最长时间，必须小于connectionTimeout,最小值为250ms，默认5000ms</span></span><br><span class="line">        networkTimeout = getAndSetNetworkTimeout(connection, validationTimeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setNetworkTimeout(connection, validationTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 驱动检查，连接检查方式</span></span><br><span class="line">    checkDriverSupport(connection);</span><br><span class="line">    <span class="comment">// 设置只读与事物自动提交</span></span><br><span class="line">    connection.setReadOnly(isReadOnly);</span><br><span class="line">    connection.setAutoCommit(isAutoCommit);</span><br><span class="line">    <span class="comment">// 设置默认的事物隔离</span></span><br><span class="line">    <span class="keyword">if</span> (transactionIsolation != defaultTransactionIsolation) &#123;</span><br><span class="line">        connection.setTransactionIsolation(transactionIsolation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catalog:为支持catalog概念的db设置默认的catalog</span></span><br><span class="line">    <span class="comment">// MySQL、Oracle都不支持catalog，支持的有DB2、MS SQL Server</span></span><br><span class="line">    <span class="keyword">if</span> (catalog != <span class="keyword">null</span>) &#123;</span><br><span class="line">        connection.setCatalog(catalog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// connectionInitSql是创建连接后执行的SQL，用于判断连接是否成功，默认为空</span></span><br><span class="line">    executeSql(connection, config.getConnectionInitSql(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    setNetworkTimeout(connection, networkTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关闭连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 译：悄悄或者偷偷的关闭连接，后台任务关闭连接</span></span><br><span class="line"><span class="comment"> * 调用场景:</span></span><br><span class="line"><span class="comment"> * 1. closeConnection时,后台任务销毁连接(连接超过最大空闲时间，被标记为evict等)</span></span><br><span class="line"><span class="comment"> * 2. 关闭线程池时，当指定销毁连接任务池失败后调用</span></span><br><span class="line"><span class="comment"> * 3. newConnection失败后，若连接不为null，则关闭连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> closureReason</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quietlyCloseConnection</span><span class="params">(<span class="keyword">final</span> Connection connection, <span class="keyword">final</span> String closureReason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;&#123;&#125; - Closing connection &#123;&#125;: &#123;&#125;&quot;</span>, poolName, connection, closureReason);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                setNetworkTimeout(connection, SECONDS.toMillis(<span class="number">15</span>));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                connection.close(); <span class="comment">// continue with the close even if setNetworkTimeout() throws</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            LOGGER.debug(<span class="string">&quot;&#123;&#125; - Closing connection &#123;&#125; failed&quot;</span>, poolName, connection, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/other/hikaricp/01.png" alt="PoolBase的类图"></p>
<p>从上图可知，<code>PoolBase</code>中没有暴露关于连接池的<code>public</code>方法。大部分时<code>private</code>方法，以及部分``abstract<code>方法和缺省修饰符的方法。其只是一个基础类，继承</code>PoolBase`的类才是真正可用的连接池。</p>
<h2 id="3-PoolEntry"><a href="#3-PoolEntry" class="headerlink" title="3. PoolEntry"></a>3. PoolEntry</h2><p>是一个包装了<code>Connection</code>的<code>final</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolEntry</span> <span class="keyword">implements</span> <span class="title">IConcurrentBagEntry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	Connection connection;</span><br><span class="line">   </span><br><span class="line">	<span class="comment">//······ 省略</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务，当超过最大生存时间时销毁连接。ScheduledFuture非PoolEntry创建，而是由连接池创建</span></span><br><span class="line"><span class="comment">     * 连接池创建连接时，将PoolEntry的销毁任务加入到endOfLife中去。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> ScheduledFuture&lt;?&gt; endOfLife;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * statement数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FastList&lt;Statement&gt; openStatements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接池，用于将该连接归还连接池、销毁或者关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HikariPool hikariPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * STATE_NOT_IN_USE = 0;</span></span><br><span class="line"><span class="comment">     * STATE_IN_USE = 1;</span></span><br><span class="line"><span class="comment">     * STATE_REMOVED = -1;</span></span><br><span class="line"><span class="comment">     * STATE_RESERVED = -2;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//······ 省略</span></span><br><span class="line">    </span><br><span class="line">    PoolEntry(<span class="keyword">final</span> Connection connection, <span class="keyword">final</span> PoolBase pool, <span class="keyword">final</span> <span class="keyword">boolean</span> isReadOnly, <span class="keyword">final</span> <span class="keyword">boolean</span> isAutoCommit) &#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">        <span class="keyword">this</span>.hikariPool = (HikariPool) pool;</span><br><span class="line">        <span class="keyword">this</span>.isReadOnly = isReadOnly;</span><br><span class="line">        <span class="keyword">this</span>.isAutoCommit = isAutoCommit;</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">// 最后借出时间默认为当前的时间戳，即创建时间</span></span><br><span class="line">        <span class="keyword">this</span>.lastAccessed = ClockSource.INSTANCE.currentTime();</span><br><span class="line">        <span class="comment">//默认最多创建16个Statements</span></span><br><span class="line">        <span class="keyword">this</span>.openStatements = <span class="keyword">new</span> FastList&lt;&gt;(Statement.class, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//······ 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-HikariPool"><a href="#4-HikariPool" class="headerlink" title="4. HikariPool"></a>4. HikariPool</h2><p><code>HikariPool</code>是真正的连接池，提供了连接池的大部分行为。下面是部分源码:</p>
<p>连接池的初始化过程，创建Executor(创建连接的任务<code>addConnectionExecutor</code>、销毁连接任务<code>closeConnectionExecutor</code>、维护连接池内的空闲连接任务<code>houseKeepingExecutorService</code>、<code>leakTask</code>等)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HikariPool</span> <span class="keyword">extends</span> <span class="title">PoolBase</span> <span class="keyword">implements</span> <span class="title">HikariPoolMXBean</span>, <span class="title">IBagStateListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录当前可使用连接总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger totalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PoolEntry创建任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor addConnectionExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭连接池内连接的Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor closeConnectionExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于维护连接池内的空闲连接，超过minimumIdle部分将会被销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor houseKeepingExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentBag&lt;PoolEntry&gt; connectionBag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接泄漏任务检测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProxyLeakTask leakTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对信号量&#123;<span class="doctag">@link</span> java.util.concurrent.Semaphore&#125;的封装</span></span><br><span class="line"><span class="comment">     * 当信号量许可证已满时，获取连接等操作会被阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SuspendResumeLock suspendResumeLock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HikariPool</span><span class="params">(<span class="keyword">final</span> HikariConfig config)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用PoolBase</span></span><br><span class="line">        <span class="keyword">super</span>(config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.connectionBag = <span class="keyword">new</span> ConcurrentBag&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.totalConnections = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">// 可以通过配置更新，getConnection()方法是否会阻塞</span></span><br><span class="line">        <span class="keyword">this</span>.suspendResumeLock = config.isAllowPoolSuspension() ? <span class="keyword">new</span> SuspendResumeLock() : SuspendResumeLock.FAUX_LOCK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//······ 省略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试创建一个连接并关闭。创建连接池时检查是否可以建立连接</span></span><br><span class="line">        checkFailFast();</span><br><span class="line"></span><br><span class="line">        ThreadFactory threadFactory = config.getThreadFactory();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建数据库连接任务,maximumPoolSize为阻塞队列大小、拒绝策略为丢弃</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.addConnectionExecutor = createThreadPoolExecutor(config.getMaximumPoolSize(), poolName + <span class="string">&quot; connection adder&quot;</span>, threadFactory, <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关闭连接任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.closeConnectionExecutor = createThreadPoolExecutor(config.getMaximumPoolSize(), poolName + <span class="string">&quot; connection closer&quot;</span>, threadFactory, <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.getScheduledExecutorService() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            threadFactory = threadFactory != <span class="keyword">null</span> ? threadFactory : <span class="keyword">new</span> DefaultThreadFactory(poolName + <span class="string">&quot; housekeeper&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">this</span>.houseKeepingExecutorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory, <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">            <span class="comment">// 当houseKeepingExecutorService的shutdown方法被调用时，不再执行线程池内的任务</span></span><br><span class="line">            <span class="keyword">this</span>.houseKeepingExecutorService.setExecuteExistingDelayedTasksAfterShutdownPolicy(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 取消任务时立即从任务池中移除任务</span></span><br><span class="line">            <span class="keyword">this</span>.houseKeepingExecutorService.setRemoveOnCancelPolicy(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.houseKeepingExecutorService = config.getScheduledExecutorService();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置延时任务池的延时时间以及执行的command</span></span><br><span class="line">        <span class="keyword">this</span>.houseKeepingExecutorService.scheduleWithFixedDelay(<span class="keyword">new</span> HouseKeeper(), <span class="number">0L</span>, HOUSEKEEPING_PERIOD_MS, MILLISECONDS);</span><br><span class="line">        <span class="comment">// 创建防止连接泄漏的任务</span></span><br><span class="line">        <span class="keyword">this</span>.leakTask = <span class="keyword">new</span> ProxyLeakTask(config.getLeakDetectionThreshold(), houseKeepingExecutorService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>// 从连接池中获取链接的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Connection <span class="title">getConnection</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> hardTimeout)</span> <span class="keyword">throws</span> SQLException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个许可证，当达到最大时会阻塞</span></span><br><span class="line">    suspendResumeLock.acquire();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTime = clockSource.currentTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> timeout = hardTimeout;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> PoolEntry poolEntry = connectionBag.borrow(timeout, MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (poolEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// We timed out... break and throw exception</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = clockSource.currentTime();</span><br><span class="line">            <span class="comment">// 判断借到的连接是否可用</span></span><br><span class="line">            <span class="keyword">if</span> (poolEntry.isMarkedEvicted() || (clockSource.elapsedMillis(poolEntry.lastAccessed, now) &gt; ALIVE_BYPASS_WINDOW_MS &amp;&amp; !isConnectionAlive(poolEntry.connection))) &#123;</span><br><span class="line">                closeConnection(poolEntry, <span class="string">&quot;(connection is evicted or dead)&quot;</span>); <span class="comment">// Throw away the dead connection (passed max age or failed alive test)</span></span><br><span class="line">                timeout = hardTimeout - clockSource.elapsedMillis(startTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                metricsTracker.recordBorrowStats(poolEntry, startTime);</span><br><span class="line">                <span class="keyword">return</span> poolEntry.createProxyConnection(leakTask.schedule(poolEntry), now);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// timeout = hardTimeout - 当前时间戳，即超过了入参规定的时间</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (timeout &gt; <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(poolName + <span class="string">&quot; - Interrupted during connection acquisition&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        suspendResumeLock.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logPoolState(<span class="string">&quot;Timeout failure &quot;</span>);</span><br><span class="line">    metricsTracker.recordConnectionTimeout();</span><br><span class="line"></span><br><span class="line">    String sqlState = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">final</span> Throwable originalException = getLastConnectionFailure();</span><br><span class="line">    <span class="keyword">if</span> (originalException <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">        sqlState = ((SQLException) originalException).getSQLState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> SQLException connectionException = <span class="keyword">new</span> SQLTransientConnectionException(poolName + <span class="string">&quot; - Connection is not available, request timed out after &quot;</span> + clockSource.elapsedMillis(startTime) + <span class="string">&quot;ms.&quot;</span>, sqlState, originalException);</span><br><span class="line">    <span class="keyword">if</span> (originalException <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">        connectionException.setNextException((SQLException) originalException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> connectionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭连接池:关闭连接池、关闭所有空闲连接，且终止或者关闭存活的连接，关闭创建的所有Executor等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 连接池状态</span></span><br><span class="line">        poolState = POOL_SHUTDOWN;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125; - Close initiated...&quot;</span>, poolName);</span><br><span class="line">        logPoolState(<span class="string">&quot;Before closing &quot;</span>);</span><br><span class="line">        <span class="comment">// 标记池内所有连接</span></span><br><span class="line">        softEvictConnections();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭创建连接执行器，逐个关闭线程池内的任务</span></span><br><span class="line">        addConnectionExecutor.shutdown();</span><br><span class="line">        <span class="comment">// 关闭线程池内锁中的等待队列中的任务</span></span><br><span class="line">        addConnectionExecutor.awaitTermination(<span class="number">5L</span>, SECONDS);</span><br><span class="line">        <span class="comment">// 关闭维护minimumIdleSize的线程池执行器以及任务</span></span><br><span class="line">        <span class="keyword">if</span> (config.getScheduledExecutorService() == <span class="keyword">null</span> &amp;&amp; houseKeepingExecutorService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            houseKeepingExecutorService.shutdown();</span><br><span class="line">            houseKeepingExecutorService.awaitTermination(<span class="number">5L</span>, SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        connectionBag.close();</span><br><span class="line">        <span class="comment">// 杀死连接执行器</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService assassinExecutor = createThreadPoolExecutor(config.getMaximumPoolSize(), poolName + <span class="string">&quot; connection assassinator&quot;</span>,</span><br><span class="line">                                                                          config.getThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = clockSource.currentTime();</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                abortActiveConnections(assassinExecutor);</span><br><span class="line">                <span class="comment">// 标记连接为被销毁状态</span></span><br><span class="line">                softEvictConnections();</span><br><span class="line">            &#125; <span class="keyword">while</span> (getTotalConnections() &gt; <span class="number">0</span> &amp;&amp; clockSource.elapsedMillis(start) &lt; SECONDS.toMillis(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            assassinExecutor.shutdown();</span><br><span class="line">            assassinExecutor.awaitTermination(<span class="number">5L</span>, SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shutdownNetworkTimeoutExecutor();</span><br><span class="line">        closeConnectionExecutor.shutdown();</span><br><span class="line">        closeConnectionExecutor.awaitTermination(<span class="number">5L</span>, SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        logPoolState(<span class="string">&quot;After closing &quot;</span>);</span><br><span class="line">        unregisterMBeans();</span><br><span class="line">        metricsTracker.close();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125; - Closed.&quot;</span>, poolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 译：永久关闭指定连接(吞掉任何异常)</span></span><br><span class="line"><span class="comment"> * 以下几种情况会调用closeConnection方法</span></span><br><span class="line"><span class="comment"> *    1. 连接被标记为evict</span></span><br><span class="line"><span class="comment"> *    2. 连接超过最大可空闲时间，houseKeeper任务</span></span><br><span class="line"><span class="comment"> *    3. 连接被借用后发现不可用，getConnection()获取链接方法</span></span><br><span class="line"><span class="comment"> *    4. evict方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">(<span class="keyword">final</span> PoolEntry poolEntry, <span class="keyword">final</span> String closureReason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connectionBag.remove(poolEntry)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tc = totalConnections.decrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (tc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGGER.warn(<span class="string">&quot;&#123;&#125; - Unexpected value of totalConnections=&#123;&#125;&quot;</span>, poolName, tc, <span class="keyword">new</span> Exception());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = poolEntry.close();</span><br><span class="line">        <span class="comment">// 关闭connection的任务交给另外的线程</span></span><br><span class="line">        closeConnectionExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                quietlyCloseConnection(connection, closureReason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HouseKeeper任务，清理超过最大空闲时间的连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 译：用于清理空闲连接(超过minimumIdle部分)</span></span><br><span class="line"><span class="comment"> * The house keeping task to retire idle connections.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseKeeper</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> previous = clockSource.plusMillis(clockSource.currentTime(), -HOUSEKEEPING_PERIOD_MS);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// refresh timeouts in case they changed via MBean</span></span><br><span class="line">        connectionTimeout = config.getConnectionTimeout();</span><br><span class="line">        validationTimeout = config.getValidationTimeout();</span><br><span class="line">        leakTask.updateLeakDetectionThreshold(config.getLeakDetectionThreshold());</span><br><span class="line">        <span class="comment">// 连接池中空闲状态连接的最长时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> idleTimeout = config.getIdleTimeout();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = clockSource.currentTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Detect retrograde time, allowing +128ms as per NTP spec.</span></span><br><span class="line">        <span class="keyword">if</span> (clockSource.plusMillis(now, <span class="number">128</span>) &lt; clockSource.plusMillis(previous, HOUSEKEEPING_PERIOD_MS)) &#123;</span><br><span class="line">            LOGGER.warn(<span class="string">&quot;&#123;&#125; - Retrograde clock change detected (housekeeper delta=&#123;&#125;), soft-evicting connections from pool.&quot;</span>,</span><br><span class="line">                        clockSource.elapsedDisplayString(previous, now), poolName);</span><br><span class="line">            previous = now;</span><br><span class="line">            softEvictConnections();</span><br><span class="line">            fillPool();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (now &gt; clockSource.plusMillis(previous, (<span class="number">3</span> * HOUSEKEEPING_PERIOD_MS) / <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="comment">// No point evicting for forward clock motion, this merely accelerates connection retirement anyway</span></span><br><span class="line">            LOGGER.warn(<span class="string">&quot;&#123;&#125; - Thread starvation or clock leap detected (housekeeper delta=&#123;&#125;).&quot;</span>, clockSource.elapsedDisplayString(previous, now), poolName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        previous = now;</span><br><span class="line"></span><br><span class="line">        String afterPrefix = <span class="string">&quot;Pool &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (idleTimeout &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 从队列中获取STATE_NOT_IN_USE的连接</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;PoolEntry&gt; idleList = connectionBag.values(STATE_NOT_IN_USE);</span><br><span class="line">            <span class="keyword">int</span> removable = idleList.size() - config.getMinimumIdle();</span><br><span class="line">            <span class="comment">// 当未被使用的连接大于minIdle时</span></span><br><span class="line">            <span class="keyword">if</span> (removable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                logPoolState(<span class="string">&quot;Before cleanup &quot;</span>);</span><br><span class="line">                afterPrefix = <span class="string">&quot;After cleanup  &quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Sort pool entries on lastAccessed</span></span><br><span class="line">                <span class="comment">// 根据最近访问时间增序排序</span></span><br><span class="line">                Collections.sort(idleList, LAST_ACCESS_COMPARABLE);</span><br><span class="line">                <span class="keyword">for</span> (PoolEntry poolEntry : idleList) &#123;</span><br><span class="line">                    <span class="comment">// 若上次使用时间大于idleTimeout，则修改poolEntry状态</span></span><br><span class="line">                    <span class="keyword">if</span> (clockSource.elapsedMillis(poolEntry.lastAccessed, now) &gt; idleTimeout &amp;&amp; connectionBag.reserve(poolEntry)) &#123;</span><br><span class="line">                        <span class="comment">// 关闭连接</span></span><br><span class="line">                        closeConnection(poolEntry, <span class="string">&quot;(connection has passed idleTimeout)&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (--removable == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// keep min idle cons</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logPoolState(afterPrefix);</span><br><span class="line"></span><br><span class="line">        fillPool(); <span class="comment">// Try to maintain minimum connections</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-ConcurrentBag"><a href="#5-ConcurrentBag" class="headerlink" title="5. ConcurrentBag"></a>5. ConcurrentBag</h2><p><code>ConcurrentBag</code>是一个用于<code>HikariPool</code>的特殊的并发类，其实现了<code>LinkedBlockingDeque</code>和<code>LinkedTransferQueue</code>。这是一个定制化的无锁的实现，使用**AQS(AbstractQueuedLongSynchronizer)**同步器管理跨线程的通信。部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PoolEntry实现了该接口，poolEntry的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IConcurrentBagEntry</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> STATE_NOT_IN_USE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> STATE_IN_USE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> STATE_REMOVED = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> STATE_RESERVED = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectState, <span class="keyword">int</span> newState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HikariPool#getConnection(long)</code>内会调用<code>borrow</code>方法尝试获取可用连接，在<code>borrow</code>中会首先尝试从<code>getConnection</code>方法调用者的<code>threadList</code>中寻找可用连接，否则再从<code>sharedList</code>中获取连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">borrow</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">final</span> TimeUnit timeUnit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当调用borrow时首先查看调用者线程是否释放了可用连接</span></span><br><span class="line">    <span class="comment">// Try the thread-local list first</span></span><br><span class="line">    List&lt;Object&gt; list = threadList.get();</span><br><span class="line">    <span class="keyword">if</span> (weakThreadLocals &amp;&amp; list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        threadList.set(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从尾部获取，类似于剽窃算法(fork/join)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 移除当前元素，长度减1</span></span><br><span class="line">        <span class="keyword">final</span> Object entry = list.remove(i);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">final</span> T bagEntry = weakThreadLocals ? ((WeakReference&lt;T&gt;) entry).get() : (T) entry;</span><br><span class="line">        <span class="comment">// 若threadList中的poolEntry非空且set state成功</span></span><br><span class="line">        <span class="keyword">if</span> (bagEntry != <span class="keyword">null</span> &amp;&amp; bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bagEntry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若调用者线程没有可用连接，则从shareList中获取连接</span></span><br><span class="line">    <span class="comment">// Otherwise, scan the shared list ... for maximum of timeout</span></span><br><span class="line">    timeout = timeUnit.toNanos(timeout);</span><br><span class="line">    Future&lt;Boolean&gt; addItemFuture = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startScan = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> originTimeout = timeout;</span><br><span class="line">    <span class="keyword">long</span> startSeq;</span><br><span class="line">    <span class="comment">// 等待+1</span></span><br><span class="line">    waiters.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// scan the shared list</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 获取当前计数值</span></span><br><span class="line">                startSeq = synchronizer.currentSequence();</span><br><span class="line">                <span class="keyword">for</span> (T bagEntry : sharedList) &#123;</span><br><span class="line">                    <span class="comment">// 遍历shardList，确定可用的连接</span></span><br><span class="line">                    <span class="keyword">if</span> (bagEntry.compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) &#123;</span><br><span class="line">                        <span class="comment">// if we might have stolen another thread&#x27;s new connection, restart the add...</span></span><br><span class="line">                        <span class="comment">// 若当前等待连接数大于1且不存在创建连接任务，则创建poolEntry给其他waiter使用</span></span><br><span class="line">                        <span class="keyword">if</span> (waiters.get() &gt; <span class="number">1</span> &amp;&amp; addItemFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// HikariPool实现了IBagStateListener，是将创建poolEntry的任务添加到addConnectionExecutor中</span></span><br><span class="line">                            <span class="comment">// 会将poolEntry添加到shareList中</span></span><br><span class="line">                            listener.addBagItem();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> bagEntry;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (startSeq &lt; synchronizer.currentSequence());</span><br><span class="line">            <span class="comment">// 若执行到此处说明没有获取到可用连接</span></span><br><span class="line">            <span class="keyword">if</span> (addItemFuture == <span class="keyword">null</span> || addItemFuture.isDone()) &#123;</span><br><span class="line">                <span class="comment">// 说明当前没有创建poolEntry的任务，将poolEntry添加到shareList中去</span></span><br><span class="line">                addItemFuture = listener.addBagItem();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新timeout，用于超时结束循环</span></span><br><span class="line">            timeout = originTimeout - (System.nanoTime() - startScan);</span><br><span class="line">        &#125; <span class="keyword">while</span> (timeout &gt; <span class="number">10_000L</span> &amp;&amp; synchronizer.waitUntilSequenceExceeded(startSeq, timeout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        waiters.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-启动过程"><a href="#6-启动过程" class="headerlink" title="6. 启动过程"></a>6. 启动过程</h2><p>使用HikariCP需要一些简单的配置，具体如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HikariConfig hikariCP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSourceConfig dataSourceConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//datasourceConfig是一个Config类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HikariDataSource(datasourceConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">hikariCP:</span></span><br><span class="line">	<span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">	<span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">	<span class="attr">jdbcUrl:</span> <span class="string">jdbc:mysql://127.0.0.1:3318/db_name?serverTimezone=Asia/Shanghai&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;characterEncoding=utf8&amp;allowMultiQueries=true</span></span><br><span class="line">	<span class="attr">username:</span> <span class="string">your_name</span></span><br><span class="line">	<span class="attr">password:</span> <span class="string">your_password</span></span><br><span class="line">	<span class="attr">connectionTimeout:</span> <span class="number">30000</span></span><br><span class="line">	<span class="attr">minIdle:</span> <span class="number">2</span></span><br><span class="line">	<span class="attr">maxPoolSize:</span> <span class="number">2</span></span><br><span class="line">	<span class="attr">connectionInitSql:</span> <span class="string">set</span> <span class="string">names</span> <span class="string">utf8mb4</span></span><br></pre></td></tr></table></figure>

<p>我们设置jdbcUrl为错误的连接，查看启动报错的异常栈，可以查看启动类的调用过程。具体如下:</p>
<p><img src="https://images.effiu.cn/blog/other/hikaricp/03.png" alt="hikariCp启动过程"></p>
<p>上面创建Hikari连接池，其是调用<code>com.zaxxer.hikari.HikariDataSource#HikariDataSource(com.zaxxer.hikari.HikariConfig)</code>的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HikariDataSource</span><span class="params">(HikariConfig configuration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    configuration.validate();</span><br><span class="line">    configuration.copyState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">&quot;&#123;&#125; - Started.&quot;</span>, configuration.getPoolName());</span><br><span class="line">    pool = fastPathPool = <span class="keyword">new</span> HikariPool(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>HikariPool</code>的构造方法，其会在创建连接池时检查数据库是否可以正常连接<code>checkFailFast()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void checkFailFast()</span><br><span class="line">&#123;</span><br><span class="line">	if (config.isInitializationFailFast()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;&#x2F; 尝试创建一个连接，并关闭</span><br><span class="line">        newConnection().close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                e.addSuppressed(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new PoolInitializationException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>newConnection()</code>过程中，会抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Connection <span class="title">newConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String username = config.getUsername();</span><br><span class="line">        String password = config.getPassword();</span><br><span class="line"></span><br><span class="line">        connection = (username == <span class="keyword">null</span>) ? dataSource.getConnection() : dataSource.getConnection(username, password);</span><br><span class="line">        <span class="comment">// 设置一些初始值或者状态，例如超时时间、自动提交、事物隔离级别、连接检查等</span></span><br><span class="line">        setupConnection(connection);</span><br><span class="line">        lastConnectionFailure.set(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        lastConnectionFailure.set(e);</span><br><span class="line">        quietlyCloseConnection(connection, <span class="string">&quot;(Failed to create/set connection)&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-获取数据库连接过程"><a href="#7-获取数据库连接过程" class="headerlink" title="7. 获取数据库连接过程"></a>7. 获取数据库连接过程</h2><p><code>com.zaxxer.hikari.HikariDataSource#getConnection()</code>方法调用<code>HikariPool.getConnection()</code>方法，其是调用<code>com.zaxxer.hikari.util.ConcurrentBag#borrow</code>方法获取可用连接。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC的工作机制与设计模式</title>
    <url>/blog/2020/04/19/web/14-springmvc/</url>
    <content><![CDATA[<p>Spring MVC的工作机制</p>
<a id="more"></a>


<h2 id="1-Spring-MVC的工作机制"><a href="#1-Spring-MVC的工作机制" class="headerlink" title="1. Spring MVC的工作机制"></a>1. Spring MVC的工作机制</h2><p>Spring MVC的核心是<code>org.springframework.web.servlet.DispatcherServlet</code>。实际上Spring MVC非常简单，我们只需要提供一个路径映射关系；定义一个业务逻辑的处理流程规则，以及视图解析器，Spring MVC就可以帮助我们完成所有的MVC功能了，甚至目前视图解析器已经不流行了。<code>DispatcherServlet</code>类依赖关系图:</p>
<p><img src="https://images.effiu.cn/blog/web/79.png" alt="DispatcherServlet类依赖关系"></p>
<p>从上面的依赖关系图可以发现，<code>DispathcerServlet</code>类继承了<code>HttpServlet</code>，在Servlet的init方法调用时执行Spring MVC的初始化工作。Spring的工作流程主要在<code>DispatcherServlet</code>的<code>initStrategies</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>initMultipartResolver</code>，初始化<code>MultipartResolver</code>，用于处理文件上传服务器，若有文件上传，那么会将当前的<code>HttpServletRequest</code>包装成<code>DefaultMultipartHttpServletRequest</code>，且将每个用于上传的内容封装成<code>CommonsMultipartFile</code>对象。</li>
<li><code>initLocaleResolver</code>，处理应用的国际化问题，通过解析请求的Locale和设置相应的Locale来控制应用中的字符编码问题</li>
<li><code>initThemeResolver</code>，用于定义一个主题，例如可以根据用户的喜好来设置用户访问的页面的样式。</li>
<li><code>initHandlerMappings</code>，用于定义用户设置的请求映射关系，<code>HandlerMapping</code>接口的实现类会把用户定义的URL映射成一个Handler实例。</li>
<li><code>initHandlerAdapters</code>，用于根据<code>Handler</code>的类型定义不同的处理机制。</li>
<li><code>initHandlerExceptionResolvers</code>，当Handler处理出错时，会通过这个Handler来统一处理，默认实现类是<code>SimpleMappingExceptionResolver</code>，将错误日志记录在log中，且重定向到默认的错误页面。</li>
<li><code>initRequestToViewNameTranslator</code>，将指定的<code>ViewName</code>按照定义的<code>RequestToViewNameTranslator</code>替换成想要的格式，例如加上前缀或者后缀等。</li>
<li><code>initViewResolvers</code>，用于将View解析成页面，<code>ViewResolvers</code>中可以设置解析策略。默认是<code>InternalResourceViewResolver</code>，按照JSP页面来解析。</li>
</ul>
<p>上面是Spring的整个流程，在一个请求中可能需要我们来扩展的地方都定义了扩展点，只需要实现相应的接口类，并创建一个Spring Bean就可以拓展Spring MVC框架。</p>
<p>Spring MVC中，只有3个组件是用户必须要定义和扩展的：定义URL映射规则、实现业务逻辑的Handler实例对象、渲染模版资源。</p>
<p><code>DispatcherServlet</code>的启动流程：HttpServlet初始化调用了<code>HttpServletBean</code>的<code>init</code>方法，该方法的作用是获取Servlet中的init参数，并创建一个<code>BeanWrapper</code>对象，然后由子类执行BeanWrapper的初始化工作，查看源码可以发现目前<code>BeanWrapper</code>没有任何作用，因为其没有任何实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Initializing servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">            bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">            <span class="comment">// 目前没有类实现改方法</span></span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    <span class="comment">// FrameworkServlet等类实现了该方法</span></span><br><span class="line">    initServletBean();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27; configured successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring容器的真正创建是在<code>FrameworkServlet</code>的<code>initServletBean</code>方法中完成的，这个方法会创建<code>WebApplicationContext</code>对象，并调用其<code>refresh</code>方法完成配置文件的加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">&quot;Initializing Spring FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">&quot;FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;: initialization started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建WebApplicationContexgt,并调用其refresh方法完成配置文件的加载,</span></span><br><span class="line">        <span class="comment">// 还会调用DispatcherServlet的onRefresh方法，触发DispatcherServlet的初始化工作</span></span><br><span class="line">        <span class="comment">// onRefresh方法调用的是initStrategies方法</span></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">&quot;FrameworkServlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;: initialization completed in &quot;</span> +</span><br><span class="line">                         elapsedTime + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring MVC初始化时序图如下：</p>
<p><img src="https://images.effiu.cn/blog/web/80.png" alt="Spring MVC初始化时序图"></p>
<h2 id="2-Controller设计"><a href="#2-Controller设计" class="headerlink" title="2. Controller设计"></a>2. Controller设计</h2><h3 id="1-HandlerMapping"><a href="#1-HandlerMapping" class="headerlink" title="1. HandlerMapping"></a>1. HandlerMapping</h3><p>Spring MVC的Control主要由<code>HandlerMapping</code>和<code>HandlerAdapters</code>两个组件提供。<code>HandlerMapping</code>负责映射用户的URL和对应的处理类，<code>HandlerMapping</code>没有规定URL与相应的处理类如何映射，只是定义了根据一个URL必须返回一个由<code>HandlerExecutionChain</code>代表的处理链，我们可以在这个处理链中添加任意的<code>HandlerAdapters</code>实例处理URL对应的请求。</p>
<p>Spring MVC默认的<code>HandlerMapping</code>是<code>BeanNameUrlHandlerMapping</code>，可以根据Bean的name属性映射到URL中。其作用就是帮助管理URL和处理类的映射关系，简单理解，就是将一个或者多个URL映射到一个或者多个Spring Bean中。</p>
<p>以<code>SimpleUrlHandlerMapping</code>为例说明Spring MVC将请求URL映射到Bean。Spring MVC提供了一个<code>AbstractHandlerMapping</code>，其还实现了<code>Ordered</code>接口并继承了<code>WebApplicationObjectSupport</code>类，可以让<code>HandlerMapping</code>通过设置<code>setOrder</code>方法提高优先级，通过覆盖<code>initApplicationContext</code>方法实现初始化一些工作。</p>
<p>HandlerMapping的初始化工作完成的两个最重要的工作就是将URL与Handler的对应关系保存到HandlerMap集合中，并将所有interceptors对象保存到<code>adaptedInterceptors</code>数组中，等请求到后执行所有的adaptedInterceptors数组中的对象。所有的interceptor对象都必须实现HandlerInterceptor接口。</p>
<h3 id="2-HandlerAdapter初始化"><a href="#2-HandlerAdapter初始化" class="headerlink" title="2. HandlerAdapter初始化"></a>2. HandlerAdapter初始化</h3><p>Spring MVC中提供了HandlerAdapter的实现类。具体见下图:</p>
<p><img src="https://images.effiu.cn/blog/web/81.png" alt="HandlerAdapter实现类图"></p>
<p>具体区分<code>HandlerAdapter</code>可以根据其<code>supports</code>方法。例如: <code>SimpleControllerHandlerAdapter</code>的<code>supports</code>方法，可以判断其可以继承Controller接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SimpleServletHandlerAdapter</code>可以继承<code>Servlet</code>接口等。</p>
<p><code>HandlerAdapter</code>的初始化比较简单，只是单调创建一个<code>HandlerAdapter</code>对象，并把这个对象保存到<code>DispatcherServlet</code>的<code>handlerAdapters</code>中。当Spring MVC将某个URL映射到某个Handler时，在handlerAdapters集合中查询哪个<code>HandlerAdapter</code>对象supports这个Handler，在确定HandlerAdapter后执行对应的<code>handle</code>方法。例如：</p>
<ul>
<li><p><code>SimpleControllerHandlerAdapter</code>的handle方法是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SimpleServletHandlerAdapter</code>则是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((Servlet) handler).service(request, response);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-Controller的调用逻辑"><a href="#3-Controller的调用逻辑" class="headerlink" title="3. Controller的调用逻辑"></a>3. Controller的调用逻辑</h3><p>整个Spring MVC的调用时从<code>DispatcherServlet</code>的<code>doService</code>方法开始的，在该方法中会将<code>ApplicationContext</code>、<code>localeResolver</code>、<code>themeResolver</code>等对象添加到request中，然后调用<code>doDispatcher</code>方法，这才是处理用户请求的地方。</p>
<p>Controller的处理逻辑关键是<code>DispatcherServlet</code>的<code>handlerMappings</code>集合中根据请求的URL匹配每个<code>HandlerMapping</code>对象中的某个Handler，匹配成功后返回这个Handler的处理链<code>HandlerExecutionChain</code>对象，这个对象中还包含用户自定义的多个<code>HandlerInterceptor</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>preHandle</code>，在Handler执行前执行</li>
<li><code>postHandle</code>，在Handler执行后执行</li>
<li><code>afterCompletion</code>，DispatcherServlet返回之前执行，若preHandle返回false，时，当前请求执行完<code>afterCompletion</code>后直接返回，Handler也将不执行</li>
</ul>
<h2 id="3-View-And-Model"><a href="#3-View-And-Model" class="headerlink" title="3. View And Model"></a>3. View And Model</h2><p>目前流行的是返回JSON格式的字符串。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架的设计理念与设计模式分析</title>
    <url>/blog/2020/04/19/web/13-springframework/</url>
    <content><![CDATA[<p>Spring的设计理念对我们有很强的借鉴意义，其通过抽象复杂多变的对象，进一步做规范，然后根据它定义的这套规范设计一个容器，在容器中构建它们的复杂关系。</p>
<ul>
<li>有哪些基础核心组件</li>
<li>如何构成Spring的架构</li>
<li>AOP特性是如何利用基础组件工作的</li>
<li>有哪些设计模式</li>
</ul>
<a id="more"></a>

<h2 id="1-Spring的骨骼架构"><a href="#1-Spring的骨骼架构" class="headerlink" title="1. Spring的骨骼架构"></a>1. Spring的骨骼架构</h2><p><img src="https://images.effiu.cn/blog/spring/02.png" alt="Sprinig框架的总体架构图"></p>
<p>Spring框架中核心组件只有3个: Core、Context和Bean。AOP、WEB等其他上层特性功能都是基于核心组件的。</p>
<h3 id="1-Spring设计理念"><a href="#1-Spring设计理念" class="headerlink" title="1. Spring设计理念"></a>1. Spring设计理念</h3><p>Spring是面向Bean的编程，所以Bean组件是核心中的核心。这与Java是面向对象编程类似，Spring是面向Bean编程。</p>
<p>Spring解决了一个非常关键的问题，使我们可以把对象之间的依赖关系转而用配置文件来管理，即依赖注入机制(Dependency Injection, DI)，而注入关系是在一个叫Ioc(nversion of Control)的容器中管理的。Spring是通过把对象包装在bean中从而达到管理对象以及做一些额外操作的目的。</p>
<h3 id="2-核心组件协同工作"><a href="#2-核心组件协同工作" class="headerlink" title="2. 核心组件协同工作"></a>2. 核心组件协同工作</h3><p>Bean是Spring核心组件中的核心，Context是Bean的容器，Core则是一个工具。</p>
<p>Bean是一种对象，Context是发现Bean之间的关系，并建立以及维护这种关系。Context也是bean的关系集合，即Ioc容器。Core组件是发现、建立和维护每个Bean之间的关系需要的一系列工具。</p>
<p><img src="https://images.effiu.cn/blog/web/64.png" alt="Spring框架的总体架构图"></p>
<h2 id="2-核心组件详解"><a href="#2-核心组件详解" class="headerlink" title="2. 核心组件详解"></a>2. 核心组件详解</h2><h3 id="1-Bean组件"><a href="#1-Bean组件" class="headerlink" title="1. Bean组件"></a>1. <strong>Bean</strong>组件</h3><p>Bean组件是在<code>org.springframework.beans</code>包下，主要做3件事。Bean的定义、创建以及解析。只有Bean的创建是需要我们参与(<code>@Service</code>等)，其他两个则由Spring在内部完成。</p>
<p>Spring Bean的创建是采用的工厂模式，顶级接口是<code>BeanFactory</code>。</p>
<p><img src="https://images.effiu.cn/blog/web/65.png" alt="Spring Bean工厂的继承层次关系"></p>
<p><code>BeanFactory</code>有3个子类:<code>ListableBeanFactory</code>、<code>HierarchicalBeanFactory</code>、<code>AutowireCapableBeanFactory</code>。最终的默认实现类是<code>DefaultListableBeanFactory</code>，其实现了上面所有的接口，这么做的目的是不同接口有不同的应用场合，主要是为了区分在Spring内部对象的传递和转化过程中，对对象数据访问所做的限制。例如，<code>ListableBeanFactory</code>表示接口的Bean可以是列表(注入List)，<code>HierarchicalBeanFactory</code>表示Bean是有继承关系的，<code>AutowireCapableBeanFactory</code>接口定义Bean的自动装配规则。</p>
<p>Bean的定义主要由<code>BeanDefinition</code>描述:</p>
<p><img src="https://images.effiu.cn/blog/web/66.png" alt="Spring Bean工厂的继承层次关系"></p>
<p>如上所示，<code>BeanDefinaition</code>接口继承了<code>AttributeAccessor</code>和<code>BeanMetadataElement</code>。而<code>AbstractBeanDefinition</code>和<code>RootBeanDefinition</code>等继承了<code>BeanDefinition</code>接口。当Spring成功解析Bean相关注解后<code>@Service</code>、<code>@Controller</code>等后，就会被转化为<code>BeanDefinition</code>对象。Bean的解析过程非常复杂，例如xml解析、Java注解解析等。每种解析方式都分为好多步。</p>
<ul>
<li><input disabled="" type="checkbox"> 阅读<strong>Spring Bean</strong>组件源码</li>
</ul>
<h3 id="2-Context组件"><a href="#2-Context组件" class="headerlink" title="2. Context组件"></a>2. <strong>Context</strong>组件</h3><p>Context是在<code>org.springframework.context</code>下，Context在Spring中的作用，实际上是给Spring提供一个运行时的环境，用以保存各个对象的状态。</p>
<p><code>ApplicationContext</code>是<code>Context</code>的顶级父类，其除了可以标识一个应用环境的基本信息外，还继承了5个用于扩展Context功能的接口，如下：</p>
<p><img src="https://images.effiu.cn/blog/web/67.png" alt="Context相关的类结构图"></p>
<p>上述结构图中<code>ApplicationContext</code>是接口，下面的类是<code>ApplicationContext</code>的实现类(只包括JavaConfig方式的相关类)。<code>ApplicationContext</code>继承了<code>ResourceLoader</code>接口，这使得其可以访问任何外部资源。</p>
<p><code>ApplicationContext</code>的两个实现类:</p>
<ul>
<li><code>ConfigurableApplicationContext</code>:表示Context是可修改的，也就是在构建Context中，用户可以动态添加或修改已有的配置信息。它有很多子类，见上图。</li>
<li><code>WebApplicationContext</code>: 这是为Web准备的Context。</li>
</ul>
<p><code>ApplicationContext</code>的最下层是根据不同方式的Context的实现类，例如，基于xml格式、基于Java Config的方式。</p>
<p>总体来说，<code>ApplicationContext</code>完成了几件事情：</p>
<ul>
<li>标识一个应用环境</li>
<li>利用BeanFactory创建Bean对象</li>
<li>保存对象关系表</li>
<li>能够捕获各种事件</li>
</ul>
<h3 id="3-Core组件"><a href="#3-Core组件" class="headerlink" title="3. Core组件"></a>3. <strong>Core</strong>组件</h3><p>Core组件是Spring的核心组件，里面有好多关键类。例如，一个重要的组成部分就是定义了资源的访问方式。下图是与Resource相关的类结构图:</p>
<p><img src="https://images.effiu.cn/blog/web/68.png" alt="Resource类图"></p>
<p><code>Resource</code>接口封装了各种可能的资源类型，对于使用者来说屏蔽文件类型的不同。对于Resource来说，其继承了<code>InputStreamSource</code>接口，接口中包含一个<code>getInputStream()</code>方法，用于返回<code>InputStream</code>类。所有的资源都通过<code>InputStream</code>获取，所以也屏蔽了资源的提供者。<br><img src="https://images.effiu.cn/blog/web/69.png" alt="Context和Resource的类关系图"></p>
<p>其中<code>DefaultResourceLoader</code>等持有<code>Resource</code>的引用。所以Context把资源的加载、解析和描述工作委托给了<code>ResourcePatternResolver</code>类完成。`ApplicationContext把资源的加载委托、解析和资源的定义整合在一起便与其他组件使用。Core中还有很多类似于这种整合的方式。</p>
<h3 id="4-Ioc如何工作"><a href="#4-Ioc如何工作" class="headerlink" title="4. Ioc如何工作"></a>4. Ioc如何工作</h3><h4 id="1-创建BeanFactory工厂"><a href="#1-创建BeanFactory工厂" class="headerlink" title="1. 创建BeanFactory工厂"></a>1. 创建BeanFactory工厂</h4><p>Ioc容器实际上是Context组件结合其他两个组件共同构建的一个Bean的关系网。构建的入口在<code>AbstractApplicationContext</code>类的<code>refresh</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 获取实现了BeanFactoryPostProcessor接口的子类，执行其postProcessBeansFactory方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 获取用户定义的实现了BeanPostProcessor接口的子类，并把其注册到BeanFactory对象中</span></span><br><span class="line">            <span class="comment">// 的beanPostProcessor变量中。</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 开始实例化Bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是构建Ioc整个过程的完整代码。基本上每行代码，代表了一个过程。</p>
<ul>
<li>构建BeanFactory，以便于产生所需要的Bean。<code>obtainFreshBeanFactory</code>方法内部调用<code>refreshBeanFactory</code>。</li>
<li>注册可能感兴趣的事件</li>
<li>创建Bean实例对象</li>
<li>触发被监听的事件</li>
</ul>
<p>构建BeanFactory的过程是在<code>AbstractRefreshableApplicationContext</code>的<code>refreshBeanFactory()</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// DefaultListableBeanFactory 是BeanFactory的原始对象类型</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanFactory</code>的类继承关系图如下：</p>
<p><img src="https://images.effiu.cn/blog/web/70.png" alt="BeanFactory关系图"></p>
<p>上图中包括BeanFactory相关的类，还有与Bean的register相关的类。BeanFactory的创建过程如下：</p>
<p><img src="https://images.effiu.cn/blog/web/71.png" alt="创建BeanFactory过程"></p>
<p><img src="https://images.effiu.cn/blog/web/72.png" alt="解析和等级bean"></p>
<p>在创建好BeanFactory后，会添加一些Spring本身需要的工具类，在在<code>AbstractApplicationContext.prepareBeanFactory</code>方法中完成。</p>
<h4 id="2-创建Bean实例，构建Bean关系网"><a href="#2-创建Bean实例，构建Bean关系网" class="headerlink" title="2. 创建Bean实例，构建Bean关系网"></a>2. 创建Bean实例，构建Bean关系网</h4><p><code>AbstractApplicationContext</code>类的<code>refresh</code>方法中的<code>finishBeanFactoryInitialization</code>方法开始实例化Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    <span class="comment">// 实例化所有非non-lazy-initd的bean</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>preInstantiateSingletons()</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是BeanFactory</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// FACTORY_BEAN_PREFIX是&amp;</span></span><br><span class="line">                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                                                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                                                    getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中有判断Bean是否是BeanFactory，这是一个特殊的Bean，Spring有一大半的扩展功能都与BeanFactory有关，其是一个工厂Bean，用于生产Bean。若需要自定义产生实例的方法，可以继承<code>FactoryBean</code>，然后实现<code>getObject()</code>方法。Spring中，BeanFactory就是通过调用<code>getObject()</code>方法就能获取用于自定义产生的对象。Spring获取BeanFactory本身的对象是通过在前面加上<code>&amp;</code>完成的。</p>
<p>Bean实例对象以及构建Bean实例对象之间的关联关系是Spring中的一个核心，流程图如下：</p>
<p><img src="https://images.effiu.cn/blog/web/73.png" alt="Bean实例创建流程"></p>
<p>普通的Bean是通过调用getBean方法直接创建其实例。创建过程见下图：</p>
<p><img src="https://images.effiu.cn/blog/web/74.png" alt="Bean实例创建时序图"></p>
<p>另外的重点是建立Bean对象之间的关系，这是Spring的核心竞争力。例如依赖注入、循环依赖等。</p>
<h4 id="3-Ioc容器的扩展点"><a href="#3-Ioc容器的扩展点" class="headerlink" title="3. Ioc容器的扩展点"></a>3. Ioc容器的扩展点</h4><p>Ioc容器让Bean对象有了一定的扩展性。具体如下：</p>
<p><img src="https://images.effiu.cn/blog/web/75.png" alt="Bean对象实例关系时序图"></p>
<p>Spring Ioc容器，主要有<code>BeanfactoryPostProcessor</code>和<code>BeanPostProcessor</code>，分别在构建BeanFactory和构建Bean对象时调用。另外还有<code>InitializingBean</code>和<code>DisposableBean</code>，分别在Bean实例创建和销毁时被调用，现在可以通过注解替代<code>@PostConstruce</code>和<code>@PreDestory</code>。</p>
<h2 id="3-Spring中AOP特性"><a href="#3-Spring中AOP特性" class="headerlink" title="3. Spring中AOP特性"></a>3. Spring中AOP特性</h2><h3 id="1-动态代理实现原理"><a href="#1-动态代理实现原理" class="headerlink" title="1. 动态代理实现原理"></a>1. 动态代理实现原理</h3><p>Spring AOP是基于动态代理实现的。在JDK的<code>java.lang.reflect</code>包下有个<code>Proxy</code>类，其正是构造代理类的入口</p>
<p><img src="https://images.effiu.cn/blog/web/76.png" alt="Proxy类结构"></p>
<p><code>Proxy</code>类中有4个<code>public</code>方法，其中<code>newProxyInstance</code>就是创建代理对象的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有3个参数：</p>
<ul>
<li><code>ClassLoader</code>，用于加载代理类的Loader类，一般使用和被代理类的同一个Loader</li>
<li><code>Class&lt;?&gt;[]</code>，被代理的接口</li>
<li><code>InvocationHandler</code>，执行除了被代理接口中方法之外的用户自定义的操作，用户调用目标方法都被代理到<code>invocationHandler</code>的<code>invoke</code>方法中。</li>
</ul>
<h3 id="2-Spring-AOP实现代理"><a href="#2-Spring-AOP实现代理" class="headerlink" title="2. Spring AOP实现代理"></a>2. Spring AOP实现代理</h3><p>代理的目的是调用目标方法时可以转而执行<code>InvocationHandler</code>类的<code>invoke</code>方法。Spring不仅仅遵守AOP联盟的约定实现了AOP，还对其做了扩展，增加了<code>PointCut</code>、<code>Advisor</code>等接口，使代理更加灵活。</p>
<p>Spring JDK动态代理的类是<code>JDKDynamicAopProxy</code>，其也实现了<code>InvocationHandler</code>接口。在Spring创建代理对象后，在我们调用目标对象上的方法时，都会被代理到<code>InvocationHandler</code>类的<code>invoke</code>方法中执行。</p>
<p><img src="https://images.effiu.cn/blog/web/77.png" alt="Spring创建代理对象时序图"></p>
<p>下面是Spring拦截器的时序图：</p>
<p><img src="https://images.effiu.cn/blog/web/78.png" alt="Spring创建代理对象时序图"></p>
<p>其他用到代理的，比如，Spring事物管理机制。</p>
<p>Spring也支持CGLIB类代理。</p>
<h2 id="4-Spring中的设计模式"><a href="#4-Spring中的设计模式" class="headerlink" title="4. Spring中的设计模式"></a>4. Spring中的设计模式</h2><h3 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h3><p>代理模式是给某一个对象创建一个代理对象。由这个代理对象控制对原对象的引用，而创建这个代理对象后可以在调用原对象时增加一些额外的操作。</p>
<p>在Spring AOP中JDK动态代理就是利用代理模式实现的。</p>
<h3 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2. 策略模式"></a>2. 策略模式</h3><p>策略模式指完成某个操作可能有多种方法，不同方法有不同的应用场景，把各种操作方法作为一个实现策略，使用者可以根据需要选择合适的策略。</p>
<ul>
<li>Context: 使用不同策略的环境，其可以根据自身的条件选择不同的策略实现类来完成所要做的操作。它持有一个策略实例的引用。</li>
<li>Strategy: 抽象策略，定义每个策略都要实现的策略方法。</li>
<li>ConcreteStrategy: 具体策略实现类，实现在抽象策略中定义的策略方法。</li>
</ul>
<p>Spring中有很多地方使用策略模式，如bean定义对象的创建以及代理对象的创建等。Spring代理方式有JDK动态代理和CGLIB代理，Spring针对这两种方式使用了策略模式。</p>
<ul>
<li><code>JDKDynamicAopProxy</code>，JDK动态代理实现类</li>
<li><code>CglibAopProxy</code>，CGLIB代理实现类</li>
</ul>
<p>在<code>DefaultAopProxyFactory</code>中，会选择创建代理的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                         <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// JDK动态代理，若targetClass是接口类型或者是动态生成的代理类</span></span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CGLIB代理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ProxyCreaterSupport</code>中引用了<code>AopProxyFactory</code>接口，<code>DefaultAopProxyFactory</code>便是其实现类。</p>
<p><code>ProxyFactoryBean.getObject()</code>方法中，使用<code>ProxyCreaterSupport</code>类创建代理类。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat的系统架构与设计模式</title>
    <url>/blog/2020/04/15/web/11-Tomcat/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Session与Cookie</title>
    <url>/blog/2020/04/14/web/10-session-and-cookie/</url>
    <content><![CDATA[<p>Session与Cookie是Http中的一个配置项，但是其相对复杂。因为几乎所有的系统都会用到cookie，我们不得不考虑HTTP对Cookie数量和大小的限制，而Session同样存在问题，例如，分布式系统中如何共享。其他问题如：Cookie被盗、Cookie伪造等。</p>
<p>Session与Cookie都是为了保持用户与后端服务器的交互状态，各有优点与缺点。</p>
<a id="more"></a>

<h2 id="1-理解Cookie"><a href="#1-理解Cookie" class="headerlink" title="1. 理解Cookie"></a>1. 理解Cookie</h2><p>当一个用户通过HTTP请求访问一个服务器时，服务器可以将一些键值对返回给客户端浏览器，还会加一些限制条件，在条件符合这个用户下次访问服务器时，数据又被完整地带回给服务器。</p>
<p>在一个时间段内，若与用户相关的数据被频繁访问，可以针对这个数据做缓存，这样可以大大提高数据的访问性能，Cookie就是这个作用。针对同一客户端发出的请求，每次发出都会带有第一次访问时服务器端设置的信息，这样服务端就可以根据Cookie值来划分访问的用户了。</p>
<h3 id="1-Cookie工作流程"><a href="#1-Cookie工作流程" class="headerlink" title="1. Cookie工作流程"></a>1. Cookie工作流程</h3><p><strong style='color:red'>Cookie是如何加到HTTP的header中的</strong>? 如下图所示，Tomcat是在<code>org.apache.catalina.connector.Response#generateCookieString</code>方法中将cookie构建成一个字符串的。</p>
<p><img src="https://images.effiu.cn/blog/web/58.png" alt="Tomcat创建cookie的时序图"></p>
<h3 id="2-使用Cookie的限制"><a href="#2-使用Cookie的限制" class="headerlink" title="2. 使用Cookie的限制"></a>2. 使用Cookie的限制</h3><p>Cookie是HTTP头中的一个字段，其本身没有限制，但是Cookie是存储在浏览器中的，不同浏览器都会Cookie的大小有限制。</p>
<h2 id="2-理解Seesion"><a href="#2-理解Seesion" class="headerlink" title="2. 理解Seesion"></a>2. 理解Seesion</h2><p>Cookie可以让服务器端跟踪每个客户端的访问，但是每次访问都必须回传这些Cookie，增加了客户端与服务端的数据传输量，Session则可以解决这个问题。</p>
<p>在同一个客户端每次与服务端进行交互时，不需要每次回传所有的Cookie值，只需要传回一个ID，这个ID是客户端第一次访问服务器时生成的，且具有唯一性。服务端可以根据这个ID判断用户身份等。这个ID通常是<strong>NAME</strong>为<strong>JSESSIONID</strong>的一个Cookie。</p>
<h3 id="1-Session和Cookie"><a href="#1-Session和Cookie" class="headerlink" title="1. Session和Cookie"></a>1. Session和Cookie</h3><p>有3种设置session的方式：</p>
<ul>
<li>基于URL Path Parameter(JSESSIONID)，默认支持</li>
<li>基于Cookie，若没有修改Context容器的Cookies标识，则默认也是支持的，若浏览器不支持则会将Cookie按照参数的形式拼接在url后面，传递格式:<code>servletPath;name=value</code>。同时服务也会从url中获取cookie</li>
<li>基于SSL，默认不支持。只有<code>connector.getAttribute(&quot;SSLEnabled&quot;)</code>为<code>true</code>时才支持。</li>
</ul>
<p>在<code>web.xml</code>中配置<code>session-config</code>配置项，可以修改Cookie的NAME值。若是基于SSL的，则会根据<code>javax.servlet.request.ssl_session</code>属性值设置SessionID。</p>
<h3 id="2-Session工作模式"><a href="#2-Session工作模式" class="headerlink" title="2. Session工作模式"></a>2. Session工作模式</h3><p>服务器会根据SessionID创建<code>HttpSession</code>对象。第一次是通过<code>request.getSession()</code>，该方法会将<code>HttpSession</code>加到<code>org.apache.catalina.Manager</code>的sessions容器中保存。<code>Manager</code>类管理所有Session的生命周期，Session过期将会被回收，服务器关闭，Session将被序列化到磁盘。</p>
<p><img src="https://images.effiu.cn/blog/web/59.png" alt="png"></p>
<p><img src="https://images.effiu.cn/blog/web/60.png" alt="Seesion工作时序图"></p>
<p>request获取的Session对象保存在<code>org.apache.catalina.session.StandardManager</code>(实现了<code>org.apache.catalina.Manager</code>接口)中，其本质是<code>ConcurrentHashMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Map&lt;String, Session&gt; sessions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>我们通过<code>request.getSession(sessionId)</code>从<code>StandardManager</code>中得到Session。一个sessionId对应一个Session。</p>
<p><code>StandardManager</code>类负责<strong>Servlet</strong>容器中所有<code>StandardSession</code>对象的生命周期管理。当<strong>Servlet</strong>容器关闭时，<code>StandardManager</code>负责持久化没有过去的<code>StandardSession</code>对象，其会将其持久化到<code>SESSIONS.ser</code>文件中。</p>
<p><code>protected String pathname = &quot;SESSIONS.ser&quot;;</code>当Servlet容器关闭时，<code>StandardManager</code>会调用<code>unload</code>方法将集合中的StandardSession写入到<code>SESSIONS.ser</code>文件中，然后在日志启动时重新恢复。但是若要持久化保存Session对象，必须使用Servlet容器的stop命令，而不能直接kill掉进程。</p>
<p>StandardManager管理的sessions Map集合中的StandardSession是有过期时间的，过期会被清除。Tomcat中默认是60s(<code>maxInactiveInterval</code>属性)。检查Session是否失效是在一个后台线程中完成的<code>backgroundProcess()</code>中。另外<code>request.getSession()</code>也会检查Session是否过期。</p>
<h2 id="3-分布式Session框架"><a href="#3-分布式Session框架" class="headerlink" title="3. 分布式Session框架"></a>3. 分布式Session框架</h2><h3 id="1-Session和Cookie的问题"><a href="#1-Session和Cookie的问题" class="headerlink" title="1. Session和Cookie的问题"></a>1. Session和Cookie的问题</h3><p>Session和Cookie都有各自的优缺点。在大型互联网系统中单独使用Cookie和Session都是不行的。使用Cookie可以应对分布式部署的问题，由于Cookie将数据存储在浏览器中，所以每次访问都会将最新的值待会给处理器请求的服务器，这样也解决了在分布式服务器中不同请求到不同服务器导致的Cookie不一致的问题。</p>
<p>使用Cookie也会带来很多问题：</p>
<ul>
<li>客户端Cookie存储限制，系统越多越大，Cookie的维护也越难，而且浏览器对于Cookie的存储是又限制的，超过限制会出现丢失Cookie的现象</li>
<li>Cookie管理混乱。</li>
<li>安全性不好。可以通过设置HttpOnly属性设置一些私密Cookie被客户端访问，但是仍然保证不了Cookie被篡改。还可以对Cookie进行加密，但是在分布式系统中维护Cookie的Key也是比较麻烦的。</li>
</ul>
<h3 id="2-分布式Session解决的问题"><a href="#2-分布式Session解决的问题" class="headerlink" title="2. 分布式Session解决的问题"></a>2. 分布式Session解决的问题</h3><p>结合Cookie和Session各自的优点，即分布式Session框架，可以解决很多问题：</p>
<ul>
<li>Session配置的统一管理</li>
<li>Cookie使用的监控和统一规范管理</li>
<li>Session存储的多元化</li>
<li>Session配置的动态修改</li>
<li>Session加密Key的定期修改</li>
<li>Session各种存储的监控和报警支持</li>
<li>Session框架的可扩展性</li>
<li>跨域名Seesion与Cookie共享的问题。大型互联网系统存在多个域名的情况下，Cookie和Session共享的问题。</li>
</ul>
<h3 id="3-分布式Session实现思路"><a href="#3-分布式Session实现思路" class="headerlink" title="3. 分布式Session实现思路"></a>3. 分布式Session实现思路</h3><p>需要一个订阅服务器，用来让服务器订阅可写的Session项和Cookie项，这可以限制应用可以使用的Session和Cookie，甚至可以精确到Cookie的读写。这样就可以精确控制某个应用场景下的Cookie和Session的数量。</p>
<p>通过订阅服务器推送配置可以有效地集中管理资源，所以可以省去每个应用都来配置Cookie，简化管理。比如，某个应用要使用一个新增的Cookie，则可以通过一个统一的平台来申请，申请通过才可以将这个配置项增加到订阅服务器；</p>
<p>订阅服务器目前有很多开源的配置服务器，例如Zookeeper集群管理服务器，可以统一管理所有服务器的配置文件。</p>
<p>Session服务器是分布式的，可以随时读取和写入。例如，Redis。</p>
<p>分布式的Session框架，我们需要重写HttpSession的操作接口，使应用操作Session的对象与原来没有区别，这个操作需要在进入应用之前完成，例如配置一个Filter拦截用户请求。</p>
<p>关于跨域名共享Cookie的问题，是因为Cookie是有域名限制的，在一个域名下的Cookie不能被另外一个域名访问，所以若一个用户在域名A下登陆成功，那么域名B如何保证登陆状态仍然有效呢？</p>
<p><img src="https://images.effiu.cn/blog/web/61.png" alt="跨域名同步session"></p>
<p>实现Session同步，需要一个跳转应用，这个应用可以被多个域名访问，主要功能是从一个域名下取得SeesionID，然后将这个SeesionID同步到另一个域名下。</p>
<p>关键是将一个SeesionID作为Cookie写入到两个域名下。</p>
<p>我们还可以设置一个Session签名，当用户登陆成功后根据用户私密信息生成一个签名以表示当前这个唯一的合法登陆状态。然后把这个签名作为一个Cookie保存在当前用户的浏览器中。用户每次访问服务器都会检查这个签名和从服务器分布式缓存中取得的Session重新生成的签名是否一致。</p>
<h2 id="4-Cookie压缩"><a href="#4-Cookie压缩" class="headerlink" title="4. Cookie压缩"></a>4. Cookie压缩</h2><p>若Cookie的量非常大，可以对Cookie进行压缩。压缩算法可以使用gzip和deflate算法。Header中仅支持部分ASCII码，将Cookie压缩后再进行转码。</p>
<h2 id="5-多终端Session统一"><a href="#5-多终端Session统一" class="headerlink" title="5. 多终端Session统一"></a>5. 多终端Session统一</h2><p>目前很多互联网企业都支持多终端，PC端和移动端等。例如，同时访问手机端和PC端；在手机上访问PC端网站等问题，所以我们需要做到Session的统一。</p>
<p>目前很流行的是手机端扫描PC端二维码进行登录。其实现流程是：</p>
<p><img src="https://images.effiu.cn/blog/web/62.png" alt="多终端登录"></p>
<p>手机在扫码之前就已经是登录状态，当用户扫码后，手机端根据二维码请求服务器并带有一个特殊标识，标识用户通过手机端登录，PC端通过心跳请求发送到服务器，验证是否已经登录成功，若已经登录成功就可以获取对应的SessionID等登录信息。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>Cookie和Session都是为了保持用户访问的连续状态，这是为了方便业务实现，也是为了简化服务端的设计，提高性能。同时也需要解决Session的同步问题，跨域名Session同步问题等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet工作原理</title>
    <url>/blog/2020/04/12/web/9-servlet/</url>
    <content><![CDATA[<ul>
<li>Servlet是如何工作的</li>
<li>一个Web工程在Servlet容器中是如何启动的</li>
<li>Servlet容器如何解析在<code>web.xml</code>中定义的Servlet</li>
<li>用户的请求如何被分配给指定的Servlet</li>
<li>Servlet容器如何管理Servlet生命周期</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> 未阅读源码，需要阅读源码加深理解</li>
</ul>
<a id="more"></a>

<h2 id="1-Servlet容器"><a href="#1-Servlet容器" class="headerlink" title="1. Servlet容器"></a>1. Servlet容器</h2><p><strong>Servlet</strong>容器是一个独立发展的标准化产品，目前有很多种，例如:<strong>Tomcat</strong>、<strong>Jetty</strong>等。</p>
<p><strong>Tomcat</strong>容器等级中，<strong>Context</strong>容器直接管理<strong>Servlet</strong>在容器中的包装类<strong>Wrapper</strong>。</p>
<p><img src="https://images.effiu.cn/blog/web/50.png" alt="Tomcat容器模型"></p>
<p>一个<strong>Context</strong>对应一个Web工程。通过观察<code>server.xml</code>配置文件可以验证上图:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat-users.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.LockOutRealm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">&quot;UserDatabase&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/path&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;/projects&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-Servlet容器启动过程"><a href="#1-Servlet容器启动过程" class="headerlink" title="1. Servlet容器启动过程"></a>1. Servlet容器启动过程</h3><p><strong>Tomcat 7</strong>有启动类<code>org.apache.catalina.startup.Tomcat</code>。创建一个实例对象并调用<code>start</code>方法可以启动<strong>Tomcat</strong>，还可以通过该对象修改启动参数，例如动态增加<strong>Context</strong>、<strong>Servlet</strong>等。</p>
<p>一个Web应用对应一个<strong>Context</strong>上下文。每个Web应用都会创建一个<strong>StandardContext</strong>容器，且其会有一些参数，<code>path</code>、<code>docBase</code>等。<code>ContextConfig</code>负责整个Web应用配置的解析工作。</p>
<p><strong>Tomcat</strong>的启动逻辑是基于观察者模式设计的，所有的容器都会继承<code>Lifecycle</code>接，其管理着容器的整个生命周期，所有容器的修改和状态的改变都会由它去通知已经注册的观察者(Listener)。</p>
<p><img src="https://images.effiu.cn/blog/web/51.png" alt="Tomcat的启动时序图"></p>
<p>重点是<code>StandardContext</code>的启动过程。</p>
<p>当<code>Context</code>容器的初始化状态为init时，添加到Context容器的Listener将会被调用。<code>ContextConfig</code>继承了<code>LifecycleListener</code>接口，其是在调用<code>Tomcat.addWebapp</code>时被加入到<code>StandardContext</code>容器中的。<code>ContextConfig</code>类会负责整个Web应用的配置文件解析工作。</p>
<p><code>ContextConfig.init</code>主要工作如下：</p>
<ul>
<li>创建用于解析XML配置文件的<code>contextDigester</code>对象</li>
<li>读取默认的<code>context.xml</code>配置文件，若存在则解析</li>
<li>读取默认的<strong>Host</strong>配置文件，若存在则解析</li>
<li>读取默认的<strong>Context</strong>自身的配置文件，若存在则解析</li>
<li>设置<strong>Context</strong>的<strong>docBase</strong>等信息。</li>
</ul>
<p><code>init</code>方法后，Context容器会执行<code>startInternal</code>方法，主要如下：</p>
<ul>
<li>创建读取资源文件的对象</li>
<li>创建ClassLoader对象</li>
<li>设置应用的工作目录</li>
<li>启动相关辅助类，如logger、realm、resources等</li>
<li>修改启动状态，通知感兴趣的观察者(Web应用配置)</li>
<li>子容器的初始化</li>
<li>获取ServletContext并设置必要的参数</li>
<li>初始化<code>load on startup</code>的Servlet</li>
</ul>
<h3 id="2-Web应用的初始化工作"><a href="#2-Web应用的初始化工作" class="headerlink" title="2. Web应用的初始化工作"></a>2. Web应用的初始化工作</h3><p>Web应用的初始化是在<code>ContextConfig</code>的<code>configureStart</code>方法中实现的，应用初始化的主要工作是解析<code>web.xml</code>。</p>
<ul>
<li>首先找globalWebXml，文件搜索路径是engine的工作目录下的<code>org/papche/catalina/startup/NO_DEFAULT_XML</code>或者<code>cont/web.xml</code></li>
<li>接着查找hostWebXml。文件路径是<code>System.getProperty(&quot;catalina.base&quot;)/conf/$&#123;EngineName&#125;/$&#123;HostName&#125;/web.xml.default</code>中</li>
<li>之后是寻找应用的配置文件<code>examples/WEB-INF/web.xml</code>。</li>
</ul>
<p><code>web.xml</code>中的各个配置项将会被解析成相应的属性保存在<code>WebXml</code>对象中。若是<strong>Servlet 3.0</strong>，解析还将完成额外的工作，例如对annotations的支持等。</p>
<p>然后会将WebXml对象中的属性设置到Context容器中，包括创建Servlet、filter、Listener等。见<code>ContextConfig.configureContext</code>，部分代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ServletDef servlet : webxml.getServlets().values()) &#123;</span><br><span class="line">    Wrapper wrapper = context.createWrapper();</span><br><span class="line">	<span class="comment">// load-on-startup</span></span><br><span class="line">    <span class="keyword">if</span> (servlet.getLoadOnStartup() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (servlet.getEnabled() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wrapper.setEnabled(servlet.getEnabled().booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setName(servlet.getServletName());</span><br><span class="line">    Map&lt;String,String&gt; params = servlet.getParameterMap();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">        wrapper.addInitParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setRunAs(servlet.getRunAs());</span><br><span class="line">    Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span><br><span class="line">    <span class="keyword">for</span> (SecurityRoleRef roleRef : roleRefs) &#123;</span><br><span class="line">        wrapper.addSecurityReference(</span><br><span class="line">            roleRef.getName(), roleRef.getLink());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setServletClass(servlet.getServletClass());</span><br><span class="line">    MultipartDef multipartdef = servlet.getMultipartDef();</span><br><span class="line">    <span class="keyword">if</span> (multipartdef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (multipartdef.getMaxFileSize() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            multipartdef.getMaxRequestSize()!= <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            multipartdef.getFileSizeThreshold() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wrapper.setMultipartConfigElement(<span class="keyword">new</span> MultipartConfigElement(</span><br><span class="line">                multipartdef.getLocation(),</span><br><span class="line">                Long.parseLong(multipartdef.getMaxFileSize()),</span><br><span class="line">                Long.parseLong(multipartdef.getMaxRequestSize()),</span><br><span class="line">                Integer.parseInt(</span><br><span class="line">                    multipartdef.getFileSizeThreshold())));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wrapper.setMultipartConfigElement(<span class="keyword">new</span> MultipartConfigElement(</span><br><span class="line">                multipartdef.getLocation()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (servlet.getAsyncSupported() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wrapper.setAsyncSupported(</span><br><span class="line">            servlet.getAsyncSupported().booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.setOverridable(servlet.isOverridable());</span><br><span class="line">    context.addChild(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是将<code>Servlet</code>包装成<strong>Context</strong>容器中的<code>StandardWrapper</code>的过程。这里<code>StandardWrapper</code>是<strong>Tomcat</strong>容器的一部分，具有容器的特性，而Servlet作为一个独立的Web开发标准，不应该强耦合在Tomcat中。其他所有的<code>web.xml</code>属性都被解析到<code>Context</code>中，<strong>Context</strong>容器才是真正运行<strong>Servlet</strong>的<strong>Servlet</strong>容器。</p>
<h2 id="2-创建Servlet实例"><a href="#2-创建Servlet实例" class="headerlink" title="2. 创建Servlet实例"></a>2. 创建Servlet实例</h2><h3 id="1-创建Servlet"><a href="#1-创建Servlet" class="headerlink" title="1. 创建Servlet"></a>1. 创建Servlet</h3><p>在Context容器启动时会实例化一些<code>load-on-startup</code>大于0的Servlet，其在globalWebXml中。例如:<code>org.apache.catalina.servlets.DefaultServlet</code>和<code>org.apache.jasper.servlet.JspServlet</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>fork<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>xpoweredBy<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  其他在启动时实例化的类，例如：<code>org.apache.catalina.servlets.CGIServlet</code>和<code> org.apache.catalina.ssi.SSIServlet</code>等</p>
</blockquote>
<p>创建Servlet实例的方法是从<code>Wrapper.loadServlet</code>开始的，<code>loadServlet</code>方法要完成的就是获取<strong>servletClass</strong>，然后交给<code>InstanceManager</code>去创建一个基于<code>servletClass.class</code>的对象。若Servlet配置了<strong>jsp-file</strong>，那么servletClass就是<code>org.apache.jasper.servlet.JspServlet</code></p>
<h3 id="2-初始化Servlet"><a href="#2-初始化Servlet" class="headerlink" title="2. 初始化Servlet"></a>2. 初始化Servlet</h3><p>初始化Servlet在<code>StandardWrapper</code>的<code>initServlet</code>方法中，主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[] &#123; facade &#125;;</span><br><span class="line">        <span class="comment">// init 方法</span></span><br><span class="line">        SecurityUtil.doAsPrivilege(<span class="string">&quot;init&quot;</span>,</span><br><span class="line">                                   servlet,</span><br><span class="line">                                   classType,</span><br><span class="line">                                   args);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// destroy() will not be called, thus clear the reference now</span></span><br><span class="line">            SecurityUtil.remove(servlet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// init方法</span></span><br><span class="line">    servlet.init(facade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其主要是调用Servlet的<code>init</code>方法，把包装了<code>StandardWrapper</code>对象的<code>StandardWrapperFacade</code>作为<code>ServletConfig</code>传给Servlet。</p>
<p>实际上Servlet对象的初始化已经完成，但是在Servlet被<code>web.xml</code>解析到完成初始化，中间还有好多其他工作。例如，各种容器状态的转化引起的监听事件的处罚、访问权限的控制等。完整时序图如下：</p>
<p><img src="https://images.effiu.cn/blog/web/52.png" alt="初始化Servlet时序图"></p>
<h2 id="3-Servlet体系结构"><a href="#3-Servlet体系结构" class="headerlink" title="3. Servlet体系结构"></a>3. Servlet体系结构</h2><p>Servlet顶层类的关联图如下：</p>
<p><img src="https://images.effiu.cn/blog/web/53.png" alt="Servlet顶层关系图"></p>
<p>Servlet规范相关的类主要就是上面5个类，与Servlet运行相关的是<code>ServletConfig</code>、<code>ServletRequest</code>、<code>ServletResponse</code>，都是通过容器传递给Servlet的。<code>ServletConfig</code>是在Servlet初始化时完成的，后面两个是请求到达时调用Servlet的方法传递过来的。<code>ServletRequest</code>、<code>ServletResponse</code>主要的请求相关内容，<code>ServletConfig</code>则是Servlet的一些配置信息。<code>ServletContext</code>则是项目的配置信息。</p>
<p>ServletConfig和ServletContext在Tomcat容器中的关系图：</p>
<p><img src="https://images.effiu.cn/blog/web/54.png" alt="png"></p>
<p>可以发现，<code>StandardWrapper</code>和<code>StandardWrapperFacade</code>都实现了<code>ServletConfig</code>接口。而<code>StandardWrapperFacade</code>是<code>StandardWrapper</code>的门面类，实际传递给Servlet的是门面类对象，这样可以保证从<code>StandardWapper</code>中拿到<code>ServletConfig</code>中规定的数据，而又不保留全部数据。</p>
<p><code>ServletContext</code>也是同样的结构。都是利用门面模式暴露部分数据。例如，工作路径、容器支持的Servlet版本等信息</p>
<p>在Servlet运行中传递的<code>ServletRequest</code>、<code>ServletResponse</code>可以被转化为<code>HttpServletRequest</code>和<code>HttpServletResponse</code>。</p>
<p>Tomcat接到请求时会首先创建<code>org.apache.coyote.Request</code>、<code>org.apache.coyote.Response</code>，这是Tomcat内部使用的描述一次请求和响应的信息类，是一个轻量级的类，很小、易回收。接下来会交给一个用户线程去处理这个请求时又会创建<code>org.apache.catalina.connector.Request</code>和<code>org.apache.catalina.connector.Response</code>，这两个才是贯穿整个Servlet容器直到传给Servlet，传给Servlet的是Request和Response的门面类<code>RequestFacade</code>和<code>ResponseFacade</code>，也是基于封装容器中的数据使用的门面模式。</p>
<p><img src="https://images.effiu.cn/blog/web/55.png" alt="Request和Response的转变过程"></p>
<h2 id="4-Servlet工作流程"><a href="#4-Servlet工作流程" class="headerlink" title="4. Servlet工作流程"></a>4. Servlet工作流程</h2><p>用户从浏览器向服务器发送一个请求的url:<code>https://hostname:port/contextPaht/servletPath</code>。其中<code>hostname:port</code>用来建立TCP连接，后面的URL才是选择在服务器哪个子容器中的Servlet。</p>
<p>Tomcat中存在一个影射类，<code>org.apache.catalina.mapper.Mapper</code>，其保存了Tomcat的Containner容器中所有自容器的信息，当<code>org.apache.catalina.connector.Request</code>进入Container容器之前，Mapper会根据这次请求的<strong>hostname</strong>和<strong>contextpath</strong>将其设置到Request的mappingData中去。</p>
<p>Mapper中的映射关系是由<code>MapperListener</code>的<code>startInternal</code>方法完成的。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    Engine engine = service.getContainer();</span><br><span class="line">    <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findDefaultHost();</span><br><span class="line">	<span class="comment">// 将MapperListener作为一个监听者添加到整个Container容器的每个自容器中，</span></span><br><span class="line">    <span class="comment">// 当任何一个子容器发生变化MapperListener都会被通知到，</span></span><br><span class="line">    <span class="comment">// 相应的保存容器关系的mapper对象也会被修改(containerEvent方法)</span></span><br><span class="line">    addListeners(engine);</span><br><span class="line"></span><br><span class="line">    Container[] conHosts = engine.findChildren();</span><br><span class="line">    <span class="keyword">for</span> (Container conHost : conHosts) &#123;</span><br><span class="line">        Host host = (Host) conHost;</span><br><span class="line">        <span class="keyword">if</span> (!LifecycleState.NEW.equals(host.getState())) &#123;</span><br><span class="line">            <span class="comment">// Registering the host will register the context and wrappers</span></span><br><span class="line">            registerHost(host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ···</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addListeners</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">    container.addContainerListener(<span class="keyword">this</span>);</span><br><span class="line">    container.addLifecycleListener(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">for</span> (Container child : container.findChildren()) &#123;</span><br><span class="line">        addListeners(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是执行Servlet的方法(真正的业务代码)。通常自定义的Servlet并不会真正实现<code>javax.servlet.Servlet</code>接口，而是继承<code>HttpServlet</code>或者<code>GenericServlet</code>类，我们可以有选择的覆盖相应的方法去实现要完成的接口。</p>
<p>当Servlet从Servlet容器中移除时，也表明Servlet的生命周期结束了，这时Servlet的destory方法将会被调用。</p>
<h2 id="5-Servlet中的Listener"><a href="#5-Servlet中的Listener" class="headerlink" title="5. Servlet中的Listener"></a>5. Servlet中的Listener</h2><p>在整个Tomcat服务器中，Listener的应用非常广泛，是基于观察者模式设计的。Listener的设计为开发者提供了一种快捷的手段，可以方便的从纵向维度控制程序和数据。目前Servlet存在6中观察者接口，分别是：<code>EventListener</code>类型的<code>ServletContextAttributeListener</code>、<code>ServletRequestAttributeListener</code>、<code>ServletRequestListener</code>、<code>HttpSessionAttributeListener</code>和<code>LifecycleListener</code>类型的<code>ServletContextListener</code>和<code>HttpSessionListener</code>。实际上上述接口都继承了<code>EventListener</code>接口。</p>
<p>这些Listener基本涵盖了整个Servlet生命周期中的所有事件，其可以配置在<code>web.xml</code>的<code>listener</code>标签中，也可以在应用程序中动态添加listener。例如，Spring的<code>org.springframework.web.context.ContextLoaderListener</code>就是实现了<code>ServletContextListener</code>。当容器加载时启动Spring容器。<code>ContextLoaderListener</code>在<code>contextInitialized</code>方法中初始化Spring容器。加载Spring容器的办法：</p>
<ul>
<li><code>web.xml</code>中的<code>context-param</code>中配置Spring的<code>applicationContext.xml</code>路径</li>
<li>默认在<code>/WEB-INF/</code>路径下查找默认的Spring配置文件。</li>
</ul>
<h2 id="6-Servlet中的Filter"><a href="#6-Servlet中的Filter" class="headerlink" title="6. Servlet中的Filter"></a>6. Servlet中的Filter</h2><p>Filter是<code>web.xml</code>中另外一个常用配置项，其比Servlet更加灵活，不仅提供了<code>request</code>和<code>response</code>，还提供了一个<code>FilterChain</code>对象，其可以让我们更加灵活控制请求的流转。</p>
<p><img src="https://images.effiu.cn/blog/web/56.png" alt="Filter相关类结构图"></p>
<p><code>FilterConfig</code>和<code>FilterChain</code>的实现类分别是<code>ApplicationFilterConfig</code>和<code>ApplicationFilterChain</code>，而Filter的实现由用户自定义。Filter类中三个接口方法：</p>
<ul>
<li><code>init(FilterConfig)</code>，初始化接口。</li>
<li><code>doFilter(ServletRequest, ServletResponse, FilterChain)</code>，在用户请求进来时会执行该方法，<code>FilterChain.doFilter</code>会进入下一链。</li>
<li><code>destory()</code>，Filter容器销毁时，这个方法被调用</li>
</ul>
<p>Filter类的核心是<code>FilterChain</code>对象。其内部包含了到最终Servlet对象的所有Filter对象，这些对象保存在<code>ApplicationFilterChain</code>对象的filter数组中。在<code>FilterChain</code>链上每执行一个Filter对象，数组的当前计数都会+1，直到等于数组的长度，在所有filter执行后，才会执行最终的Servlet。</p>
<p><img src="https://images.effiu.cn/blog/web/57.png" alt="Filter执行时序图"></p>
<h2 id="7-Servlet中的url-pattern"><a href="#7-Servlet中的url-pattern" class="headerlink" title="7. Servlet中的url-pattern"></a>7. Servlet中的url-pattern</h2><p>在<code>web.xml</code>中每个Servlet、Filter都需要配置<code>&lt;url-pattern/&gt;</code>。</p>
<ul>
<li>Servlet的匹配是根据<code>org.apache.catalina.mapper.Mapper</code>类完成的，其会根据请求的URL匹配每个Servlet中配置的<code>&lt;url-pattern/&gt;</code></li>
<li>Filter的匹配是在创建<code>ApplicationFilterChain</code>对象时进行的，它会把所有定义的Filter的<code>&lt;url-pattern&gt;</code>与当前的URL匹配，若匹配成功就将这个Filter保存到<code>ApplicationFilterChain</code>的filters数组中。</li>
</ul>
<p><code>web.xml</code>加载时，会首先检查<code>&lt;url-pattern/&gt;</code>是否符合规则，这是在<code>StandardContext</code>的<code>validateURLPattern</code>方法中完成的。<code>&lt;url-pattern/&gt;</code>的解析规则：</p>
<ul>
<li>精确匹配: 如<code>/foo.html</code>只会匹配<code>foo.html</code></li>
<li>路径匹配: 如<code>/foo/*</code>会匹配所有以<code>foo</code>开头的URL</li>
<li>后缀匹配: 如<code>*.html</code>会匹配所有以<code>html</code>结尾的URL</li>
</ul>
<p>对于Servlet来说，精确匹配 &gt; 最长路径匹配 &gt; 后缀匹配</p>
<p>Filter的匹配规则在<code>ApplicationFilterFactory.matchFiltersURL</code>方法中定义。只要匹配成功就会加入到调用链中去。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存管理</title>
    <url>/blog/2020/04/11/web/8-JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Java中基本上不会显式的调用分配内存的函数，甚至不用关心哪些程序指令需要分配内存、哪些不需要分配内存。因为在Java中，分配和回收内存都由JVM自动完成。但是我们仍然需要了解Java是如何管理内存的。本节内容:</p>
<ul>
<li>从操作系统层面介绍物理内存的分配和Java运行的内存分配之间的关系，Java使用的内存与物理内存的区别</li>
<li>Java如何从物理内存申请内存，如何划分</li>
<li>Java如何分配和回收内存</li>
</ul>
<a id="more"></a>

<h2 id="1-物理内存和虚拟内存"><a href="#1-物理内存和虚拟内存" class="headerlink" title="1. 物理内存和虚拟内存"></a>1. 物理内存和虚拟内存</h2><p>物理内存是RAM(随机存储器)。计算机中还有寄存器，用于存储计算单元执行指令的中间结果。寄存器的大小决定了一次计算可使用的最大数值。</p>
<p>链接处理器和RAM或者处理器和寄存器的是地址总线。地址总线的宽度影响了物理地址的索引范围，因为总线的宽度决定了处理器一次可以从寄存器或者内存中获取多少bit，以及处理器最大可以寻址的地址空间。例如32位地址总线可以寻址$0$ ~ $0^{32}$个内存位置。一个地址是一个字节，所以共4GB的内存空间</p>
<p>大部分情况下都通过调用操作系统提供的接口来访问内存，在Java中甚至不需要写和内存相关的代码。当我们要运行程序时，都要先向操作系统申请内存地址，通常操作系统管理内存的申请空间是按照进程管理的。每个进程都拥有自己独立的地址空间，操作系统会保证每个进程只能访问自己的内存空间。这既能保证程序的安全，又便于操作系统管理物理内存。</p>
<p>进程的内存空间独立是逻辑上的独立，是由操作系统保证的，但是真正的物理空间并不一定是只能由一个进程来使用。因为随着程序越来越庞大以及设计的多任务性，物理内存无法保证满足程序的需求，这种情况下出现了虚拟内存。</p>
<p>虚拟内存使得多个进程在同时运行时可以共享物理内存，但这只是空间上的共享，逻辑上仍然相互独立。虚拟内存可以让进程共享物理内存、提高内存利用率，还可以扩展内存的地址空间。例如：一个虚拟内存地址可能被影射到物理内存、文件或者其他可以寻址的存储器上；一个进程在不活动的情况下，操作系统可以将这个进程相关的物理内存中的数据迁移到磁盘文件中，将物理内存留给正在活动的程序使用。但是要尽量避免这种情况的经常出现，操作系统频繁的交互物理内存的数据和磁盘数据，效率会非常低。在Linux服务器上，要关注Linux中的swap分区的活跃度。若swap分区被频繁使用，系统将会非常缓慢，这可能意味着物理内存已经严重不足或者某些程序没有及时释放内存。</p>
<h2 id="2-内核空间和用户空间"><a href="#2-内核空间和用户空间" class="headerlink" title="2. 内核空间和用户空间"></a>2. 内核空间和用户空间</h2><p>计算机中的内存空间被分为内核空间和用户空间，程序只能使用用户空间的内存。</p>
<p>内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者连接硬件资源等的程序逻辑。为了保证操作系统的稳定性，运行在操作系统中的用户程序不能访问操作系统所使用的内存空间。为了保证安全性，用户程序访问硬件资源只能由操作系统发起，如网络连接等，需要调用操作系统提供的接口来实现，这个过程即<strong>系统调用</strong>。每一次系统调用都会存在两个内存空间的切换。这种从内核空间到用户空间的数据复制很费时，虽然保证了程序运行的安全性和稳定性，但是也牺牲了效率。</p>
<blockquote>
<p>  网络传输也是一次系统调用，通过网络传输的数据先是从内核空间接受来自远程服务器的数据，然后从内核空间复制到用户空间。</p>
</blockquote>
<p>内核空间和用户空间的大小分配也是一个问题。在分配给用户空间供用户程序使用，还是保证内核有足够的空间来运行。</p>
<h2 id="3-Java中需要使用内存的组件"><a href="#3-Java中需要使用内存的组件" class="headerlink" title="3. Java中需要使用内存的组件"></a>3. Java中需要使用内存的组件</h2><h3 id="1-Java堆"><a href="#1-Java堆" class="headerlink" title="1. Java堆"></a>1. Java堆</h3><p>Java堆用于存储Java对象的内存区域，堆的大小在JVM启动时一次向操作系统申请完成。</p>
<ul>
<li><code>-Xmx</code>表示堆的最大大小</li>
<li><code>-Xms</code>表示初始大小</li>
</ul>
<p>Java堆中内存空间的管理由JVM控制，对象创建由Java应用程序控制，但是对象所占的空间释放由管理堆内存的垃圾收集器完成。</p>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>JVM运行实际程序的实体是线程，当然线程需要内存空间来存储一些必要的数据。每个线程创建时JVM都会为其创建一个对战，堆栈的大小根据不同JVM实现而不同，一般在256KB~756KB之间。</p>
<p>线程所占的空间比堆空间小。但是若线程过多，线程总内存使用量也可能非常大。当前很多应用程序根据CPU的核数来分配创建的线程数。若线程数超过CPU核数效率就会降低。</p>
<h3 id="3-类和类加载器"><a href="#3-类和类加载器" class="headerlink" title="3. 类和类加载器"></a>3. 类和类加载器</h3><p>Java中类和类加载器本身都需要内存空间，其存储在堆中，这个区域叫做永久代(PermGen区)。</p>
<p>JVM是按需加载类的，对于一个jar包中的类，JVM不会全部加载，而是只加载那些在应用程序中明确使用的类到内存中。若要查看JVM到底加载了哪些类，可以在启动参数上加<code>-verbose:class</code></p>
<p>理论上使用的Java类越多，需要占用的内存也越多。类被卸载的条件如下：</p>
<ul>
<li>Java堆中没有对表示该类加载器的<code>java.lang.classLoader</code>对象的引用</li>
<li>Java堆没有对表示类加载器的类的任何<code>java.lang.Class</code>对象的引用</li>
<li>Java堆上该类加载器的任何类的所有对象都不在存活(被引用)</li>
</ul>
<p>很明显，JVM本身创建的3个类加载器加载的类都不会被释放。</p>
<h3 id="4-NIO"><a href="#4-NIO" class="headerlink" title="4. NIO"></a>4. NIO</h3><p>Java在1.4版本后新增了NIO类库。引入了基于通道和缓冲区来执行的IO方式。NIO使用<code>java.nio.ByteBuffer。allocateDirect()</code>分配内存，即NIO的直接内存，<code>ByteBuffer.allocateDirector</code>分配的内存使用的是本机北村而不是Java堆上的内存，其每一次分配内存都会调用操作系统的<code>os::malloc()</code>函数。直接<code>ByteBuffer</code>产生的数据若与网络或者磁盘交互都会在操作系统的内核空间发生，不需要将数据复制到Java内存中，很显然这减少了内核空间与用户空间之间的数据交换。</p>
<p>直接<code>ByteBuffer</code>对象会自动清理本机缓冲区，但这个过程只能作为Java堆GC的一部分执行。GC仅在Java堆被填满，以至于无法为堆分配请求服务时发生，或者在Java应用程序中显式请求时发生。当前很多NIO框架中都在代码中显式的调用<code>System.gc()</code>来释放NIO持有的内存。但是这会影响程序的性能，增加GC的次数。可以通过<code>-XX:+DisableExplicitGC</code>控制<code>System.gc()</code>的影响，但是这也可能导致NIO Direct memory内存泄漏问题。</p>
<h3 id="5-JNI"><a href="#5-JNI" class="headerlink" title="5. JNI"></a>5. JNI</h3><p>JNI技术使本机代码(如C语言)可以调用Java方法，即native memory。Java运行时本身也依赖与JNI代码来实现类库功能，如文件操作、网络IO操作或者其他系统调用。JNI也会增加Java运行时的本机内存占用。</p>
<h2 id="4-JVM内存结构"><a href="#4-JVM内存结构" class="headerlink" title="4. JVM内存结构"></a>4. JVM内存结构</h2><p>JVM是按照运行时数据的存储结构来划分内存结构的，不同格式的数据存储在不同的区域。运行时数据包括Java程序本身的数据信息和JVM运行Java程序需要的额外数据信息，如记录当前程序指令执行的指针等</p>
<ul>
<li>PC寄存器数据</li>
<li>Java栈</li>
<li>堆</li>
<li>方法区</li>
<li>本地方法区</li>
<li>运行时常量池</li>
</ul>
<h3 id="1-PC寄存器"><a href="#1-PC寄存器" class="headerlink" title="1.PC寄存器"></a>1.PC寄存器</h3><p>PC寄存器严格来说是一个数据结构，用于保存当前正常执行的程序的内存地址，而Java程序是多线程执行的，所以不能一直线性执行下去，若有多个线程交叉执行，被中断的线程的程序当前执行到哪条内存地址必然被保存，便于恢复执行时再按照被中断时的指令地址继续执行。</p>
<p>JVM规范只定义了Java方法需要记录指针信息，而对于Native方法，并没有要求记录指针地址。</p>
<h3 id="2-Java栈"><a href="#2-Java栈" class="headerlink" title="2. Java栈"></a>2. Java栈</h3><p>Java栈是与线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的Java栈，在这个Java栈中又会有多个栈桢，这些栈桢是与方法关联在一起的，每运行一个方法就创建一个栈桢，每个栈桢都含有一些内部变量、操作栈和方法返回值等信息</p>
<p>每当一个方法执行完成时，这个栈桢就会弹出栈桢的元素作为方法的返回值(若上一栈桢没有返回值，那么当前栈桢的操作栈的操作数没有变化)，并清除这个栈桢，Java栈的栈顶的栈桢是当前正在执行的活动栈，即正在执行的方法，PC寄存器也会指向这个地址。只有活动栈的本地变量可以被操作栈使用。</p>
<p>Java栈与Java线程对应的，数据不是共享的，所以不用关心数据的一致性问题，也不会存在同步锁的问题</p>
<h3 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h3><p>堆是存储Java对象的地方，是JVM管理Java对象的核心存储区域。每一个存储在堆中的Java对象都是对应的Class的一个副本，其会复制包括继承自它的父类的所有非静态属性</p>
<p>堆是被所有Java线程共享的，所以其存在同步问题</p>
<h3 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h3><p>JVM方法区是用于存储类结构信息的地方。class解析成JVM能识别的几个部分，不同部分会在class被JVM加载到内存中时，存储到不同的数据结构中，常量池、域、方法数据、方法体、构造函数，包括类中的专用方法、实例初始化、接口初始化都存储在这个区域。</p>
<p>方法区属于Java堆(永久区)的一部分，其可以被所有线程共享，且大小可以通过参数来设置。</p>
<p>方法区在永久区中，所以其是受JVM管理的，也会被GC回收器回收，但是其存储的信息相对比较稳定。</p>
<h3 id="5-运行时常量池"><a href="#5-运行时常量池" class="headerlink" title="5. 运行时常量池"></a>5. 运行时常量池</h3><p>JVM规范中使这样定义运行时常量池的: <strong>Runtime Constant Pool</strong>代表运行时每个class文件中的常量表，包括编译期的数字常量、方法或者域的引用(运行时解析)。运行时常量池类似于符号表，运行时常量池是在JVM的方法区中分配的，每个Class或者Interface的常量池都是在JVM创建class或者接口时创建的。可以抛出OutOfMemoryError</p>
<h3 id="6-本地方法栈"><a href="#6-本地方法栈" class="headerlink" title="6. 本地方法栈"></a>6. 本地方法栈</h3><p>本地方法栈是为了JVM运行Native方法准备的空间，其和Java栈的作用类似。除了代码中包含的Native方法会使用这个存储空间，在JVM利用JIT技术时也会将一些Java方法重新编译为Native Code，编译后的本地代码也是利用这个栈跟踪方法的执行状态的。</p>
<p>JVM中没有对本地方法栈做严格限制，其可以由不同的JVM实现者自由实现，其也可以抛出OutOfMemoryError和StackOverflowError。</p>
<h2 id="5-JVM内存分配策略"><a href="#5-JVM内存分配策略" class="headerlink" title="5. JVM内存分配策略"></a>5. JVM内存分配策略</h2><h3 id="1-通常的内存分配策略"><a href="#1-通常的内存分配策略" class="headerlink" title="1. 通常的内存分配策略"></a>1. 通常的内存分配策略</h3><p>操作系统中内存分配策略分为三种：</p>
<ul>
<li>静态内存分配</li>
<li>栈内存分配</li>
<li>堆内存分配</li>
</ul>
<p>静态内存分配指在程序编译时就可以确定每个数据在运行时的存储空间需求。这种分配策略不允许在程序代码中有可变数据结构(例如:可变数组)的存在，也不允许有嵌套或者递归的结构出现，因为这会导致编译程序无法计算准确的存储空间需求</p>
<p>栈式内存分配也被称为动态存储分配，是由一个类似于堆栈的运行栈来实现的。与静态内存分配相反，栈式内存中程序对数据区的需求在编译时是完全未知的，只有到了运行时才知道，但是规定程序进入一个程序模块时，必须知道程序模块所需的数据区大小才能够为其分配内存。栈式内存分配按照先进后出的原则进行分配。</p>
<p>堆内存分配是当程序真正运行到相应代码时才会知道空间大小。堆分配是最自由的，但却对操作系统和内存管理程序来说是一种挑战，在运行时分配内存运行效率也是最差的</p>
<h3 id="2-Java中的内存分配"><a href="#2-Java中的内存分配" class="headerlink" title="2. Java中的内存分配"></a>2. Java中的内存分配</h3><p>JVM内存分配基于两种，分别是堆和栈。</p>
<p>Java栈分配是和线程绑定的。当创建线程时，JVM就会为这个线程创建一个新的栈，线程的方法的调用和返回对应于这个Java栈的压栈和出栈。当线程调用一个方法时，JVM就会在Java堆栈里新压入一个栈帧，这个帧就是当前的活跃帧。在方法执行期间，这个帧用来保存参数、局部变量、中间计算过程和返回值等数据</p>
<p>栈中主要存放一些基本类型的变量数据和对象句柄(引用)。存取速度比堆快、仅次于寄存器，栈数据可以共享。缺点是存在栈中的数据大小与生存期是必须确定的。</p>
<p><a href="https://www.effiu.cn/blog/2020/04/05/web/7-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/">JVM方法调用栈</a>中，查看字节码可以看到每个方法中都有attribute，里面包括<code>stack=2, locals=4, args_size=1</code>部分，分别说明了stack和local variable的最大值。</p>
<blockquote>
<p>  若非static方法还会有隐藏的this指针，local variable和args_size都会+1</p>
</blockquote>
<p>这里说是最大值是因为JVM在真正执行时分配的stack和local variable的空间是可以公用的。若不同变量作用域没有重合，Slot是可以重复使用的。</p>
<p>应用程序在运行中创建的所有类实例或者数组都存放在堆中，并由应用程序所有线程共享。Java中分配堆内存是自动初始化的，所有对象的存储空间都是在堆中分配的，但是这个对象的引用在栈中分配的。在创建对象的过程中堆中分配的内存用来建立对象，栈中分配内存用来存储指向这个堆对象的指针。</p>
<p>Java堆是一个运行时数据区，对象通过<code>new</code>、<code>newarray</code>、<code>anewarray</code>、<code>multianewarray</code>等指令创建，它们不需要显式释放内存。堆是由垃圾收集器负责回收的，堆的优势是动态的分配内存大小、生存期也不必事先知道。Java的GC会自动回收不再使用的数据。但是缺点是由于要在运行时动态分配内存，存取速度慢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>javac -v</code>后，查看指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: new           #2                  // class java/lang/String</span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        4: ldc           #3                  // String 123</span><br><span class="line">        6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">9</span>: astore_1</span><br><span class="line">       <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">12</span>: <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>先执行<code>new</code>指令，<code>#2</code>表示的是常量池中的类型信息，即<code>class java/lang/String</code>，且必须是CONSTANT_Class_info型。</li>
<li>JVM会为这个新对象分配一个空间，新对象的属性值是默认值，然后执行新对象的<code>objectref</code>引用压入栈顶。</li>
<li><code>new</code>指令执行后，得到的对象还没有初始化，所以这个新对象没有初始化完成，所以这时候不应该赋值给s变量，应该先调用构造函数初始化类，然后将<code>objectref</code>引用复制一份，在新对象初始化完成后再将这个引用赋值给本地变量。通过<code>invokespecial</code>指令调用构造函数，若构造函数需要参数，则需要先将参数压入栈中。</li>
<li><code>astore_1</code>是在类创建完成后，将引用复制给本地变量s。</li>
</ol>
<p><strong style='color:red'>堆用来存放对象，栈用来执行程序</strong>。而在C/C++中所有方法的调用都是通过栈来进行的，所有的局部局部变量、行参都是从栈中的。堆在运行中请求操作系统分配内存，由于操作系统管理内存分配，所以分配和销毁都会占用时间，因此堆的效率较低。但是堆的优点是编译器不需要知道从堆内分配多少存储空间，也不需要知道对象的生存期，因此堆具有很大的灵活性。Java是面向对象的，具有多态性，多态变量所需要的存储空间只有在运行时创建了对象之后才能确定。</p>
<h2 id="6-JVM回收策略"><a href="#6-JVM回收策略" class="headerlink" title="6. JVM回收策略"></a>6. JVM回收策略</h2><p>Java分配内存的方式：静态内存分配，动态内存分配</p>
<h3 id="1-静态内存分配回收"><a href="#1-静态内存分配回收" class="headerlink" title="1. 静态内存分配回收"></a>1. 静态内存分配回收</h3><p>Java中的静态内存分配指的是在Java被编译时就已经能够准确确定需要的内存空间，当程序被加载时系统一次性分配内存。这些内存在执行过程中不会发生变化，直到程序执行结束时才会被回收。<strong style='color:red'>Java的类和方法中的局部变量包括原生数据类型和对象的引用都是静态分配内存的</strong>。如下:对象的引用一般占4个字节，l占8个字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">1</span>;</span><br><span class="line">Long lg = <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p>静态内存空间当代码块运行结束时回收，其是在Java栈上分配的，在方法运行结束时，对应的栈桢也会被撤销。</p>
<h3 id="2-动态内存分配和回收"><a href="#2-动态内存分配和回收" class="headerlink" title="2. 动态内存分配和回收"></a>2. 动态内存分配和回收</h3><p>Java中对象存储在堆中，是可以被共享的，当方法执行结束也不一定会消失。Java中对象的内存分配是动态的，即在程序执行时才知道要分配的存储空间大小，而不是在编译时就可以确定的。对象何时被回收也不确定的，需要等到对象不再被使用时才可以被回收。</p>
<p>内存的分配时在创建对象时发生的，而内存的回收是以对象不再引用为前提。对象真正的回收是垃圾收集器完成的。</p>
<h3 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3 垃圾回收"></a>3 垃圾回收</h3><p><a href="https://www.effiu.cn/blog/2019/06/10/jvm/3_gc_memory_allocation/">垃圾收集器与内存分配策略</a></p>
<h2 id="7-内存问题分析"><a href="#7-内存问题分析" class="headerlink" title="7. 内存问题分析"></a>7. 内存问题分析</h2><p>见《深入分析Java Web技术内幕》page 233</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM体系结构与工作方式</title>
    <url>/blog/2020/04/05/web/7-JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>JVM可以跨计算机体系结构来执行Java字节码，主要是由于JVM屏蔽了与各个计算机平台相关的软件或硬件之间的差异，使得平台相关的耦合统一由JVM提供者来实现。本节主要包括：</p>
<ul>
<li>JVM的总体设计的体系结构</li>
<li>JVM的执行引擎的工作方式</li>
<li>执行引擎如何模拟JVM指令</li>
</ul>
<a id="more"></a>

<h2 id="1-JVM体系结构"><a href="#1-JVM体系结构" class="headerlink" title="1. JVM体系结构"></a>1. JVM体系结构</h2><h3 id="1-JVM"><a href="#1-JVM" class="headerlink" title="1. JVM"></a>1. JVM</h3><h4 id="1-什么是JVM"><a href="#1-什么是JVM" class="headerlink" title="1. 什么是JVM"></a>1. 什么是JVM</h4><p>JVM，即Java虚拟机，通过模拟一个计算机来达到一个计算机所具有的计算功能。真实计算机(以计算为中心)的体系结构分为如下几个部分：</p>
<ul>
<li>指令集：计算机可以识别的机器语言的命令集合</li>
<li>计算单元：能够识别且控制指令执行的功能模块</li>
<li>寻址方式：地址的位数、最小地址和最大地址范围，以及地址的运行规则</li>
<li>寄存器：包括操作数寄存器、变址寄存器、控制寄存器等的定义、数量和使用方式</li>
<li>存储单元：能够存储操作数和保存操作结构的单元。如内核级缓存、内存和磁盘等。</li>
</ul>
<p>上述几个部分中与代码执行最密切的是指令集。<strong style='color:red'>指令集就是CPU中用来计算和控制计算机系统的一套指令的集合</strong>，每一种新型的CPU在设计时都规定了一系列与其他硬件电路相配合的指令系统。指令集的先进程度也关系到CPU的性能发挥，其是体现CPU性能的一个重要标志。</p>
<h4 id="2-计算机中的指令集"><a href="#2-计算机中的指令集" class="headerlink" title="2. 计算机中的指令集"></a>2. 计算机中的指令集</h4><p>指令集从主流体系机构上可分为<strong>精简指令集</strong>(Reduced Instruction Set Computing,<strong>RISC</strong>)和<strong>复杂指令集</strong>(Complex Instruction Set Computing, <strong>CISC</strong>)。当前普遍使用的是复杂指令集，例如：<strong>x86</strong>架构的CPU是复杂指令集，Intel和AMD也开发出了很多扩展指令集，如MMX(Multi Media eXtension,多媒体扩展指令集)，其在处理多媒体数据时性能更强，还有AMD为提高3D处理性能的3DNow!指令集等。</p>
<h4 id="3-指令集与汇编的关系"><a href="#3-指令集与汇编的关系" class="headerlink" title="3. 指令集与汇编的关系"></a>3. 指令集与汇编的关系</h4><p>指令集是可以被机器识别的机器码，也就是其必须以二进制格式存于计算机中。汇编语言是能够别人识别的指令，汇编语言在顺序和逻辑上是与机器指令一一对应的。汇编语言是为了让人们可以容易的记住机器指令而使用的助记符。大部分汇编指令都可以直接翻译成一条机器指令。例如<strong>MOVAX,1234H</strong>这条指令对应的机器码为<code>B83412</code>。</p>
<h4 id="4-指令集与CPU架构的关系"><a href="#4-指令集与CPU架构的关系" class="headerlink" title="4. 指令集与CPU架构的关系"></a>4. 指令集与CPU架构的关系</h4><p>不同CPU的指令集会有不同。那么不同CPU的指令集是否兼容呢？例如Intel与AMD的CPU指令集是否兼容？当然是兼容的。汇编语言都是对寄存器和段的直接操作的命令，这些寄存器和段等芯片都是架构的一部分，不同的芯片架构设计一定会对应到不同的机器指令集合。虽然CPU的架构会影响指令集，但是现在芯片厂商都会采用兼容的方式兼容其他指令集。</p>
<p><code>cat /proc/cpuinfo</code>可以查看linux系统支持的指令集</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vdevops ~]# cat /proc/cpuinfo </span><br><span class="line">processor       : 0</span><br><span class="line">vendor_id       : GenuineIntel</span><br><span class="line">cpu family      : 6</span><br><span class="line">model           : 79</span><br><span class="line">model name      : Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz</span><br><span class="line">stepping        : 1</span><br><span class="line">microcode       : 0x1</span><br><span class="line">cpu MHz         : 2494.222</span><br><span class="line">cache size      : 40960 KB</span><br><span class="line">physical id     : 0</span><br><span class="line">siblings        : 1</span><br><span class="line">core id         : 0</span><br><span class="line">cpu cores       : 1</span><br><span class="line">apicid          : 0</span><br><span class="line">initial apicid  : 0</span><br><span class="line">fpu             : yes</span><br><span class="line">fpu_exception   : yes</span><br><span class="line">cpuid level     : 13</span><br><span class="line">wp              : yes</span><br><span class="line">flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ibrs ibpb stibp fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt spec_ctrl intel_stibp</span><br><span class="line">bogomips        : 4988.44</span><br><span class="line">clflush size    : 64</span><br><span class="line">cache_alignment : 64</span><br><span class="line">address sizes   : 46 bits physical, 48 bits virtual</span><br><span class="line">power management:</span><br></pre></td></tr></table></figure>

<p>JVM也有一套合适的指令集，这个指令集可以被JVM解析执行，即JVM字节码指令集，符合class规范的字节码都可以被JVM执行。</p>
<ul>
<li>一个抽象规范，这个规范约束类JVM到底是什么，有哪些组成部分</li>
<li>一个具体的实现，所谓具体实现就是不同的厂商按照这个抽象的规范用软件或者软件和硬件结合的方式在相同或不同的平台上的具体实现</li>
<li>一个运行中的实例，当其在一个平台上运行时，其就是一个运行中的实例，每个运行中的Java程序都是一个JVM实现。</li>
</ul>
<h3 id="2-JVM体系结构"><a href="#2-JVM体系结构" class="headerlink" title="2. JVM体系结构"></a>2. JVM体系结构</h3><p>JVM的结构基本上由4部分组成：</p>
<ul>
<li>类加载器，在JVM启动时或者在类运行时将需要的class加载到JVM中</li>
<li>执行引擎，执行引擎的任务是负责执行class文件包含的字节码指令，相当于机器上的CPU</li>
<li>内存区，将内存划分为若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者PC指针的记录器等</li>
<li>本地方法调用，调用C或者C++实现的本地方法的代码返回结果</li>
</ul>
<p><img src="https://images.effiu.cn/blog/web/40.png" alt="JVM体系结构"></p>
<h4 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h4><p>每个被JVM装载的类型都有一个对应的<code>java.lang.Class</code>类实例与之对应，该实例可以唯一表示被JVM装载的Class类，且其在Java堆中。<a href='https://www.effiu.cn/blog/2020/04/01/web/6-ClassLoader工作机制/'>ClassLoader工作机制</a></p>
<h4 id="2-执行引擎"><a href="#2-执行引擎" class="headerlink" title="2. 执行引擎"></a>2. 执行引擎</h4><p>执行引擎是JVM的核心部分，执行引擎的作用是解析JVM字节码指令。在<strong>《Java虚拟机规范》</strong>中定义了执行每条指令应该处理什么，并且应该得到什么结果。但是并没有规定其实现过程。执行引擎采取什么方式实现由JVM的实现厂家自己去实现，无论直接解释执行还是采用JIT技术转成本地代码去执行，甚至采用寄存器实现都可以。执行引擎的具体实现有很大的发挥空间。</p>
<p>现在流行的是SUN的hotspot是基于栈的执行引擎，而Google的Dalvik是基于寄存器的执行引擎。</p>
<h4 id="3-Java内存管理"><a href="#3-Java内存管理" class="headerlink" title="3. Java内存管理"></a>3. Java内存管理</h4><p>执行引擎执行程序时需要存储一些东西，例如操作码需要的操作数，操作码的执行结果等。<code>class</code>字节码还有类的对象等信息都需要在执行引擎执行之前准备好。一个JVM实例包含方法区、Java堆、Java栈、PC寄存器和本地方法区。每个新的执行引擎实例被创建时都会创建一个Java栈、和一个PC寄存器，若当前在执行一个Java方法，那么在当前这个Java栈中保存的是该线程中方法调用的状态，包括方法的参数、局部变量、方法的返回值及运算的中间结果等。而PC寄存器会指向即将执行的下一条指令。</p>
<p>若是本地方法调用，则存储在本地方法调用栈中或者特定实现中的某个内存区域。</p>
<h2 id="2-JVM工作机制"><a href="#2-JVM工作机制" class="headerlink" title="2. JVM工作机制"></a>2. JVM工作机制</h2><h3 id="1-机器执行代码"><a href="#1-机器执行代码" class="headerlink" title="1. 机器执行代码"></a>1. 机器执行代码</h3><p>计算机只接受机器指令，<strong style='color:red'>高级语言必须经过编译器编译成机器指令才能被计算机正确执行</strong>。机器语言一般与平台密切相关，而高级语言屏蔽了所有底层的硬件甚至底层软件平台(操作系统)。高级语言之所以能屏蔽底层硬件架构的差异就是因为中间的转换环节，即编译环节。不同硬件平台一般需要的编译器也是不同的。目前，不同硬件平台的差异性已经被更上一层的软件平台(操作系统)代替了，因为操作系统几乎完全屏蔽了硬件平台，<strong style='color:red'>编译环节屏蔽了操作系统的差异性</strong>。</p>
<p>通常的编译器是将高级语言直接编译成可执行的目标机器文件(实际上是某种操作系统中需要动态链接的目标二进制文件，例如Windows中是dynamic link library,DLL)。还有一些编译器是将高级语言编译成另外一种高级语言，或者是将低级语言编译成高级语言(反编译)，或者是将高级语言编译成虚拟机目标语言，例如Java编译器。</p>
<p>通常一个程序从编写到执行会经历以下阶段:</p>
<p>源代码(source code) -&gt; 预处理器(preprocessor) -&gt; 编译器(compiler) -&gt; 汇编程序(assembler) -&gt; 目标代码(object code) -&gt; 链接器(linker) -&gt; 可执行程序(executables)</p>
<p><strong style='color:red'>编译器的作用就是把源代码变成可执行程序</strong>，即中间所有环节都是由编译器完成的。</p>
<p>在linux平台下，通常一个软件安装要经过<code>configure</code>、<code>make</code>、<code>make install</code>、<code>make clean</code>4个环节。</p>
<ul>
<li><code>configure</code>为程序在当前操作系统下选择合适的编译器来编译程序代码，以及一些环境参数</li>
<li><code>make</code>对程序代码进行编译操作，将源码编译成可执行的目标文件</li>
<li><code>make install</code>将已经编译好的可执行文件安装到操作系统指定或者默认目录下</li>
<li><code>make clean</code>删除编译时产生的临时文件</li>
</ul>
<p>那么如何让机器执行代码呢？无论是哪种指令集都只有几种最基本的元素：<strong>加</strong>、<strong>减</strong>、<strong>乘</strong>、<strong>求余</strong>、<strong>求模</strong>等。这些运算还可以继续分解成二进制位运算：<strong>与</strong>、<strong>或</strong>、<strong>异或</strong>等。这些运算可以通过指令完成，而指令的核心目的是确定需要运算的种类(操作码)和运算需要的数据(操作数)，以及从那里(寄存器或栈)获取操作数、将运算存放到什么地方(寄存器或栈)等。不同的操作方式又将指令划分成一地址指令、二地址指令、三地址指令和零地址指令等n地址指令。不同的指令集会有不同的架构实现。例如基于寄存器的架构实现和基于栈的架构实现。</p>
<h3 id="2-JVM为什么选择基于栈的架构"><a href="#2-JVM为什么选择基于栈的架构" class="headerlink" title="2. JVM为什么选择基于栈的架构"></a>2. JVM为什么选择基于栈的架构</h3><p>JVM执行字节码指令是基于栈的机构，所有操作数必须先入栈，然后根据指令中的操作码选择从栈中弹出若干个元素进行计算后，再将结果压入栈中。JVM中操作数可以存放在每一个栈桢中的一个本地变量集中，即在每个方法调用时就会给这个方法分配一个本地变量集，本地变量集在编译时已经基本确定，所以操作数入栈可以直接是常量入栈或者从本地变量集中取一个变量压入栈中。</p>
<p>基于栈的结构与基于寄存器的操作有所不同，一个操作数需要入栈和出栈，若要进行一个简单的加法运算，则需要2次入栈(本地变量入栈)和2次出栈(用于加法运算)，然后将结果入栈。若是基于寄存器的架构，则只需要将两个操作数存入寄存器进行加法运算后再将结果存入寄存器中即可。基于寄存器的架构没有多余的操作。</p>
<p>JVM是要设计成与平台无关的，平台无关性要保证在没有或者很少的寄存器的机器上同样可以正确执行Java代码。</p>
<p>另外一个理由是为了指令的紧凑性，因为Java字节可能在网络上传输，所以class文件的大小也是设计JVM字节码指令的一个重要因素，例如class文件中除了处理两个表跳转的指令外，其他都是字节对齐的，操作码可以只占一个字节大小，这都是为了让class文件更加紧凑。</p>
<h3 id="3-执行引擎的框架设计"><a href="#3-执行引擎的框架设计" class="headerlink" title="3. 执行引擎的框架设计"></a>3. 执行引擎的框架设计</h3><p>每当创建一个线程时，JVM会为这个线程创建一个Java栈，同时为这个线程分配一个寄存器，且这个寄存器会指向这个线程第一行可执行代码，每当调用一个新方法时会在这个栈上创建一个新的栈桢数据结构，这个栈桢会保留这个方法的一些元信息。如在这个方法中定义的局部变量、一些用来支持常量池的解析、正常方法返回及异常处理机制等。</p>
<p>JVM在调用某些指令时可能需要使用常量池中的一些常量，或者获取常量代表的数据或者这个数据指向的实例化对象，而这些信息都存储在所有线程共享的方法区和Java堆中</p>
<p><img src="https://images.effiu.cn/blog/web/41.png" alt="Java执行部件"></p>
<h3 id="4-执行引擎的执行过程"><a href="#4-执行引擎的执行过程" class="headerlink" title="4. 执行引擎的执行过程"></a>4. 执行引擎的执行过程</h3><p><a href="https://www.effiu.cn/blog/2019/07/28/jvm/8_vm_bytecode_execution_engine#4-%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95">执行引擎的执行过程</a></p>
<h3 id="5-JVM方法调用栈"><a href="#5-JVM方法调用栈" class="headerlink" title="5. JVM方法调用栈"></a>5. JVM方法调用栈</h3><p>JVM方法调用分为两种，Java方法调用、本地方法调用。下面是Java方法调用过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = math(a, b) /<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a+ b)/<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>javap -verbose</code>指令查看字节码指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Last modified <span class="number">2020</span>-<span class="number">4</span>-<span class="number">5</span>; size <span class="number">370</span> bytes</span><br><span class="line">  MD5 checksum a2e2cb10733d15ad537edb2b35e3187b</span><br><span class="line">  Compiled from <span class="string">&quot;JVMTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">effiu</span>.<span class="title">essay</span>.<span class="title">JVMTest</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Methodref          #3.#16         // com/effiu/essay/JVMTest.math:(II)I</span><br><span class="line">   #3 = Class              #17            // com/effiu/essay/JVMTest</span><br><span class="line">   #4 = Class              #18            // java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Utf8               Code</span><br><span class="line">   #8 = Utf8               LineNumberTable</span><br><span class="line">   #9 = Utf8               main</span><br><span class="line">  #10 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #11 = Utf8               math</span><br><span class="line">  #12 = Utf8               (II)I</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               JVMTest.java</span><br><span class="line">  #15 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = NameAndType        #11:#12        // math:(II)I</span><br><span class="line">  #17 = Utf8               com/effiu/essay/JVMTest</span><br><span class="line">  #18 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.effiu.essay.JVMTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iconst_2</span><br><span class="line">         <span class="number">3</span>: istore_2</span><br><span class="line">         <span class="number">4</span>: iload_1</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         6: invokestatic  #2                  // Method math:(II)I</span><br><span class="line">         <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">11</span>: idiv</span><br><span class="line">        <span class="number">12</span>: istore_3</span><br><span class="line">        <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">13</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: iload_0</span><br><span class="line">         <span class="number">1</span>: iload_1</span><br><span class="line">         <span class="number">2</span>: iadd</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">5</span>: imul</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;JVMTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>当JVM执行main方法时，首先将两个常数1和2存储到局部变量区1和2中(指令0~3)，math的两个参数也存储在其对应的方法栈桢中的局部变量区1和2中，所以将a和b从局部变量区压入栈中(指令4～5)。见下图(执行到第5条指令)：</p>
<p><img src="https://images.effiu.cn/blog/web/42.png" alt="执行到第5条指令"></p>
<p><code>invokestatic</code>指令时JVM会为math方法创建一个新的栈桢，且将两个参数存储在math方法对应的栈桢的前两个局部变量区中(指令0～1)。此时PC寄存器指向的是math方法的地址。见下图</p>
<p><img src="https://images.effiu.cn/blog/web/43.png" alt="执行到第5条指令"></p>
<p>此时math方法的栈桢中已经有两个变量了，其是从main方法的栈桢中传过来的。math方法会先将a、b两个变量相加，再乘以10。见下图：</p>
<p><img src="https://images.effiu.cn/blog/web/44.png" alt="执行到第5条指令"></p>
<p><code>ireturn</code>指令是将当前栈桢栈顶元素返回到调用这个方法的栈中，即返回30到main方法，main方法将30放到栈顶。见下图(main第7条指令的状态)</p>
<p><img src="https://images.effiu.cn/blog/web/45.png" alt="执行到第5条指令"></p>
<p>main方法将math方法返回的除以10，存到变量3中，见下图</p>
<p><img src="https://images.effiu.cn/blog/web/46.png" alt="执行到第5条指令"></p>
<p>执行<code>return</code>指令时main方法对应的栈桢将撤销，若当前线程对应的JVM栈中没有栈桢，这个Java栈也将被JVM撤销，整个JVM退出。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>主要包含以下两个问题</p>
<ul>
<li>JVM的体系结构</li>
<li>JVM的执行引擎执行JVM指令的过程</li>
</ul>
<p>实际上JVM的执行过程非常复杂，包括JVM在执行字节码时如何自动优化字节码，并将其编译成本地代码，即JIT技术等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassLoader工作机制</title>
    <url>/blog/2020/04/01/web/6-ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>ClassLoader</strong>就是类加载器，负责将<strong>Class</strong>加载到JVM中。</p>
<p><strong>ClassLoader</strong>还可以审查每个类应该由谁加载，这是一种父类优先的等级加载机制。ClassLoader还负责将Class字节码重新解析成JVM统一要求的对象格式。</p>
<p>Java Web中的ClassLoader是如何实现的？</p>
<a id="more"></a>

<h2 id="1-ClassLoader类结构"><a href="#1-ClassLoader类结构" class="headerlink" title="1. ClassLoader类结构"></a>1. ClassLoader类结构</h2><p><strong>ClassLoader</strong>中常用的方法如下：</p>
<ul>
<li><code>defineClass</code>，用来将byte字节流解析成JVM能够识别的Class对象，这意味着我们不仅仅可以通过class文件实例化对象，还可以通过其他方式实例化对象，例如：网络IO。直接调用<code>defineClass</code>生成类的<code>Class</code>对象还没有被<strong>resolve</strong>，resolve将会在这个对象真正实例化时才进行。</li>
<li><code>findClass</code>，查找和加载指定的class对象。其内部调用了<code>defineClass</code>。我们可以通过直接覆盖ClassLoader父类的<code>finClass</code>方法来实现类的加载规则，从而按照自己的要求加载类，若你想在类被加载到JVM中时，就被链接(<code>Link</code>)，那么可以接着调用另外一个<code>resolveClass</code>方法。</li>
<li><code>this.getClass().getClassLoader().loadClass(&quot;className&quot;)</code>，调用该类的类加载器的<code>loadClass</code>方法获得该类的Class对象。<code>loadClass</code>可以被重载，可以决定什么时候解析类。</li>
</ul>
<p>ClassLoader是个抽象类，其有很多子类，若要实现字节的ClassLoader，一般都会继承URLClassLoader这个子类，该类已经实现了大部分工作，我们一般只需要在适当的地方做修改。</p>
<p><strong>ClassLoader</strong>还提供了一些辅助方法。例如：<code>getResource</code>、<code>GetResourceAsStream</code>等，还有获取<code>SystemClassLoader</code>的方法等。</p>
<h2 id="2-ClassLoader的等级加载机制"><a href="#2-ClassLoader的等级加载机制" class="headerlink" title="2. ClassLoader的等级加载机制"></a>2. ClassLoader的等级加载机制</h2><p><strong>ClassLoader</strong>的采用的是父类委托机制。</p>
<p>整个JVM平台提供三层ClassLoader：<a href="https://www.effiu.cn/blog/2019/07/14/jvm/7_jvm_class_load#3-类加载器">具体见</a>。</p>
<p>如果我们实现自己的类加载器，不管是实现ClassLoader抽象类，还是继承<code>URLClassLoader</code>，或者其他子类，其父加载器都是<strong>AppClassLoader</strong>。不管调用哪个父类构造器，创建的对象都必须最终调用<code>getSystemClassLoader()</code>作为父类加载器。<code>getSystemClassLoader()</code>返回的就是<strong>AppClassLoader</strong>。</p>
<p><strong>ExtClassLoader</strong>和<strong>AppClassLoader</strong>都继承了<strong>URLClassLoader</strong>。<strong>URLClassLoader</strong>继承了<strong>ClassLoader</strong>类。在创建<strong>Launcher</strong>时，会先创建<strong>ExtClassLoader</strong>，然后将<strong>ExtClassLoader</strong>作为父加载器创建<strong>AppClassLoader</strong>。通过<code>Launcher.getClassLoader()</code>返回的是<strong>AppClassLoader</strong>，所以除了<code>System.getProperty(java.ext.dirs)</code>目录下的类是由ExtClassLoader加载外，其他类都是由<strong>AppClassLoader</strong>加载。</p>
<p>JVM加载class文件到内存有两种方式：</p>
<ul>
<li>隐式加载：就是不通过在代码中调用ClassLoader来加载需要的类，而是通过JVM来自动加载需要的类到内存的方式。例如：类中引用或者继承某个类时，JVM在解析当前类时就会把引用类加载到内存中</li>
<li>显式加载：是通过代码中调用<code>ClassLoader</code>类来加载。例如：<code>Class.forName</code>、<code>this.getClass.getClassLoader().loadClass()</code>。</li>
</ul>
<h2 id="3-加载Class文件"><a href="#3-加载Class文件" class="headerlink" title="3. 加载Class文件"></a>3. 加载Class文件</h2><p><img src="https://images.effiu.cn/blog/web/35.png" alt="JVM加载类阶段"></p>
<ul>
<li>第一个阶段是找到<code>.class</code>文件并把这个类包含的字节码加载到内存中。<code>findClass</code>方法内，会把<code>class</code>文件或者其他二进制字节加载到内存中(byte数组或者ByteBuffer)。<code>findClass</code>方法由父类的<code>loadClass</code>调用</li>
<li>链接阶段，分为字节码验证、Class类数据结构分析以及内存分配、符号表的连接。<code>findClass</code>方法会调用<code>defineClass</code></li>
<li>静态属性和初始化赋值，静态块的执行等。</li>
</ul>
<h3 id="1-加载字节码到内存"><a href="#1-加载字节码到内存" class="headerlink" title="1. 加载字节码到内存"></a>1. 加载字节码到内存</h3><p>在抽象类<strong>ClassLoader</strong>中并没有定义如何去加载，如何去找到指定类且把字节码加载到内存中需要由子类实现，<code>findClass</code>是抽象方法。<code>URLClassLoader</code>中<code>findClass</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    String path = name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                    <span class="comment">// URLClassPath对象，帮助取得要加载的class文件字节流</span></span><br><span class="line">                    <span class="comment">// URLClassPath中定义了去寻找class文件的方式。</span></span><br><span class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 找到class文件后，调用父类ClassLoader中的defineClass创建类对象</span></span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/web/36.png" alt="URLClassLoader类的构造函数"></p>
<p><strong>URLClassLoader</strong>类的构造函数，如下图，必须要指定一个URL数据才可以创建URLClassLoader对象，即必须指定到那些目录下去查找class文件。</p>
<p><img src="https://images.effiu.cn/blog/web/37.png" alt="png"></p>
<p>在创建URLClassPath对象时会根据传过来的URL数组中的路径来判断是文件还说jar包，根据路径的不同分别创建<code>FileLoader</code>和<code>JarLoader</code>，或则使用默认加载器。</p>
<p>设置每个ClassLoader的搜索路径：</p>
<table>
<thead>
<tr>
<th>ClassLoader类型</th>
<th>参数选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BootStrap ClassLoader</td>
<td>-Xbootclasspath:<br/>-Xbootclasspath/a:<br/>-Xbootclasspath/p:</td>
<td>设置Bootstrap ClassLoader的搜索路径<br/>把路径添加到已经存在Bootstrap ClassLoader搜索路径的后面<br/>把路径添加到已经存在Bootstrap ClassLoader搜索路径的前面</td>
</tr>
<tr>
<td>ExtClassLoader</td>
<td>-Djava.ext.dirs</td>
<td>设置ExtClassLoader搜索路径</td>
</tr>
<tr>
<td>AppClassLoader</td>
<td>-Djava.class.path=<br/>-cp或者 -classpath</td>
<td>设置AppClassLoader的搜索路径</td>
</tr>
</tbody></table>
<p>最常用的是<code>-classpath</code>的环境变量。</p>
<h3 id="2-验证与解析"><a href="#2-验证与解析" class="headerlink" title="2. 验证与解析"></a>2. 验证与解析</h3><ul>
<li><p>字节码验证，类装入器对于类的字节码要做许多检测，以确保格式正确、行为正确</p>
</li>
<li><p>类准备，在这个阶段准备代表每个类中定义的字段、方法和实现接口所必需的数据结构</p>
</li>
<li><p>解析，类装入器装入类所引用的其他所有类。可以用许多方式引用类。如：超类、接口、字段、方法签名、方法中使用的本地变量</p>
</li>
</ul>
<h3 id="3-初始化Class对象"><a href="#3-初始化Class对象" class="headerlink" title="3. 初始化Class对象"></a>3. 初始化Class对象</h3><p>在类中包含的静态初始化器都被执行，在这个阶段末尾静态字段都被初始化为默认值。</p>
<h2 id="4-常见加载类错误解析"><a href="#4-常见加载类错误解析" class="headerlink" title="4. 常见加载类错误解析"></a>4. 常见加载类错误解析</h2><h3 id="1-ClassNotFoundException"><a href="#1-ClassNotFoundException" class="headerlink" title="1. ClassNotFoundException"></a>1. ClassNotFoundException</h3><p><strong>ClassNotFoundException</strong>主要发生在显式加载类的时候。显式加载类有以下方式：</p>
<ul>
<li><code>Class.forName()</code></li>
<li><code>ClassLoader.loadClass()</code></li>
<li><code>ClassLoader.findSystemClass()</code>方法</li>
</ul>
<p>当JVM要加载指定文件的字节码到内存时，并没有找到这个文件对应的字节码，即文件并不存在。解决办法就是检查在当前的<strong>classpath</strong>下有没有指定的文件存在。可以通过<code>this.getClass().getClassLoader().getResource(&quot;&quot;).toString()</code>查看当前的<strong>classpath</strong>。</p>
<h3 id="2-NoClassDefFoundError"><a href="#2-NoClassDefFoundError" class="headerlink" title="2. NoClassDefFoundError"></a>2. NoClassDefFoundError</h3><p>一般在第一次使用命令执行Java类时很可能碰到。例如<code>java -cp ***.jar ClassName</code>。正确写法<code>java -cp ***.jar xxx.xx.ClassName</code>。</p>
<p>JVM规范中出现<code>NOClassDefFoundError</code>可能的情况是使用<code>new</code>关键字、属性引用某个类、继承了某个接口或类，以及方法的某个参数中引用了某个类，这是会触发JVM隐式加载这些类时发现这些类不存在的异常。</p>
<h3 id="3-UnsatisfiedLinkError"><a href="#3-UnsatisfiedLinkError" class="headerlink" title="3. UnsatisfiedLinkError"></a>3. UnsatisfiedLinkError</h3><p><strong>UnsatisfiedLinkError</strong>通常是在解析<code>native</code>标识的方法时JVM找不到对应的本机库文件时出现</p>
<h3 id="4-ClassCastException"><a href="#4-ClassCastException" class="headerlink" title="4. ClassCastException"></a>4. ClassCastException</h3><p>出现强制类型转换时出现这个错误。JVM在进行类型转换时会按照如下规则检查：</p>
<ul>
<li>对于普通对象，对象必须是目标类的实例或目标类的子类的实例。若目标类是接口，那么会把它当做该接口的一个子类</li>
<li>对于数组类型，目标类必须是数组类型或者<code>java.lang.Object</code>、<code>java.lang.Cloneable</code>、<code>java.io.serializable</code>。</li>
</ul>
<p>若不满足上述条件，JVM就会报错。</p>
<h3 id="5-ExceptionInInitializerError"><a href="#5-ExceptionInInitializerError" class="headerlink" title="5. ExceptionInInitializerError"></a>5. ExceptionInInitializerError</h3><p><code>ExceptionInInitializerError</code>在JVM中的规范如下：</p>
<ul>
<li>若Java虚拟机试图创建类<code>ExceptionInInitializerError</code>的新实例，但是因为出现OOM而无法创建新实例，那么就抛出<code>OutOfMemoryError</code>对象</li>
<li>若初始化器抛出一些Exception，而且Exception类不是Error或者它的某个子类，那么就会创建<code>ExceptionInInitializerError</code>类的一个新实例，并用Exception作为参数，代替Exception</li>
</ul>
<h2 id="5-常用的ClassLoader分析"><a href="#5-常用的ClassLoader分析" class="headerlink" title="5. 常用的ClassLoader分析"></a>5. 常用的ClassLoader分析</h2><p><a href='https://www.effiu.cn/blog/2019/08/06/jvm/9_classloader_case#1-Tomcat-正统的类加载器架构'>Tomcat类加载器结构</a></p>
<p>查看<code>catalina.sh</code>，可以发现Tomcat启动类是<code>org.apache.catalina.startup.Bootstrap</code>，查看源码的<code>initClassLoaders</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// CommonClassLoader, 无父类加载器</span></span><br><span class="line">        commonLoader = createClassLoader(<span class="string">&quot;common&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>( commonLoader == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="comment">// no config file, default to this loader - we might be in a &#x27;single&#x27; env.</span></span><br><span class="line">            commonLoader=<span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// catalinaClassLoader，父类加载器是commonClassLoader</span></span><br><span class="line">        catalinaLoader = createClassLoader(<span class="string">&quot;server&quot;</span>, commonLoader);</span><br><span class="line">        <span class="comment">// sharedClassLoader, 父类加载器是commonClassLoader</span></span><br><span class="line">        sharedLoader = createClassLoader(<span class="string">&quot;shared&quot;</span>, commonLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleThrowable(t);</span><br><span class="line">        log.error(<span class="string">&quot;Class loader creation threw exception&quot;</span>, t);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-实现自己的类加载器"><a href="#6-实现自己的类加载器" class="headerlink" title="6. 实现自己的类加载器"></a>6. 实现自己的类加载器</h2><p><strong>ClassLoader</strong>可以完成的事情包括以下几项：</p>
<ul>
<li>在自定义路径下查找自定义的<code>class</code>文件，但是我们需要<code>class</code>文件并不总是在自己设置的<strong>classpath</strong>下，所以就需要自己实现<strong>ClassLoader</strong>加载class文件</li>
<li>对自己要加载的类做特殊处理，如保证通过网络传输的类的安全性，可以将类经过加密，在加载到JVM之前需要对类的字节码解密，解密过程就可以在自定义的类加载器中实现</li>
<li>可以定义累的实现规则，若我们可以检查已经加载的class文件是否被修改，若修改了则重新加载该类，从而实现热部署。</li>
</ul>
<h3 id="1-加载自定义路径下的class文件"><a href="#1-加载自定义路径下的class文件" class="headerlink" title="1. 加载自定义路径下的class文件"></a>1. 加载自定义路径下的class文件</h3><p><code>ClassLoader</code>抽象类的<code>loadClass()</code>方法调用抽象方法<code>findClass()</code>，这需要子类实现。</p>
<p><code>URLClassLoader</code>内<code>findClass()</code>和<code>defineClass()</code>实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    String path = name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 定义Class对象</span></span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/web/38.png" alt="defineClass方法"></p>
<p><code>defineClass</code>有以上几个方法，可以看到有可以直接根据二进制文件创建<code>Class</code>对象的，我们无论从任何目录都可以根据<code>FileInputStream(filePath)</code>得到其二进制流。</p>
<p><img src="https://images.effiu.cn/blog/web/39.png" alt="URLClassLoader构造方法"></p>
<p><code>URLClassLoader</code>的上述方法，可以设置加载<code>class</code>文件的<strong>url</strong>路径，所以我们也可以直接继承<code>URLClassLoader</code>，然后通过构造方法或者<code>addURL</code>方法设置<strong>classpath</strong>。</p>
<h3 id="2-加载自定义格式的class文件"><a href="#2-加载自定义格式的class文件" class="headerlink" title="2. 加载自定义格式的class文件"></a>2. 加载自定义格式的class文件</h3><p>如果从网络上加载class文件，那么需要使用网络IO得到其IO流，然后使用<code>ByteArrayOutputStream</code>得到其二进制数组。</p>
<p>解密等其他操作也只要在其中完成就可以。</p>
<h3 id="3-类的热部署"><a href="#3-类的热部署" class="headerlink" title="3. 类的热部署"></a>3. 类的热部署</h3><p>JVM加载类之前会检查类是否已经被加载过，<code>findLoadClass()</code>检查是否可以返回实例。但是JVM检查一个类是否是同一个类会有两个条件。</p>
<ul>
<li>类的完整类名是否一样</li>
<li>加载这个类的ClassLoader是否是同一个(每个类加载器实例，都维护自己的空间)</li>
</ul>
<p>要实现热部署只需要创建不同的ClassLoader实例对象，然后通过不同的实例对象来加载同名的类。</p>
<p>使用不同的ClassLoader实例加载同一个类，不回导致JVM的PermGen(永久代)区无限增大，因为ClassLoader也是对象，若没有对象引用其时，也会被JVM回收。但是被类加载器加载的字节码会保存在JVM的PermGen区，这个数据一般在执行Full GC时才会被回收，所以若是大量频繁的动态加载类，若Full GC次数不频繁，则应该加大PermGen区的大小，防止内存溢出。</p>
<h2 id="7-Java不应该动态加载类"><a href="#7-Java不应该动态加载类" class="headerlink" title="7. Java不应该动态加载类"></a>7. Java不应该动态加载类</h2><p>熟悉Java的都知道，Java每当修改一个类，必须要重启一遍程序，这非常浪费时间。那么我们能不能动态加载类而不重启JVM呢？<strong style='color:red'>不能</strong>。</p>
<p>Java的优势是基于共享对象的机制，达到信息的高度共享，通过保存并持有对象的状态而省去类信息的重复创建和回收(<strong>Class对象</strong>)。对象一旦被创建，这个对象就可以被人持有和利用。</p>
<p>若要动态加载一个对象进入JVM，那么如何做到JVM中对象的平滑过渡？修改Class对象，则需要更新Java堆栈中对应Class的实例对象的引用关系。这违反了JVM的设计原则，对象的引用关系只有对象的创建者持有和使用，JVM不可以干预对象的引用关系，因为JVM不知道对象是如何被使用的，这涉及到JVM并不知道对象的运行时类型而只知道编译时类型。</p>
<p>若一定要实现动态加载类，就要克服类加载后，对象的状态被保存且被引用的问题。方法就是不保存对象的状态，在对象被创建后就立即释放掉。JSP就是这种方式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Javac编译原理</title>
    <url>/blog/2020/03/28/web/4-Javac%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Java是当前最流行的一门语言。不仅仅是Java本身，也包括Java相关的一些概念，JDK、J2EE、JVM等。现在很多新兴语言如<strong>groove</strong>、<strong>scale</strong>等都是依托于JVM的。</p>
<p>Java语言有Java语言规范，详细描述了Java语言有哪些语法和词法；Java虚拟机也有Java虚拟机规范，Java虚拟机规范和Java语言规范不是同一回事。那么如何让Java语法规则适应Java虚拟机的语法规则呢？这就由<strong>Javac</strong>编译器完成。Javac的任务就是将Java语言规范转化为Java虚拟机语言规范。</p>
<p>Javac编译器将Java编译成class字节码涉及以下内容</p>
<ul>
<li>Javac的语法树结构</li>
<li>Javac的工作流程<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>符号表的构建</li>
<li>annotation处理</li>
<li>标注和语法检查</li>
<li>数据流分析</li>
<li>类型转化</li>
<li>语法糖</li>
<li>······</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="1-Javac是什么"><a href="#1-Javac是什么" class="headerlink" title="1. Javac是什么"></a>1. Javac是什么</h2><p>Javac是一种编译器，能将一种语言规范转化为另外一种语言规范。一般的编译器是将便于人类理解的语言规范转化成机器容易理解的语言规范，例如C、C++等是将源码直接编译成目标机器码，即CPU直接执行的指令集合。</p>
<p>Javac的编译器也是将Java编译成对所有机器非常友好的语言。但是这种语言是不是针对不同平台、不同语言的机器的，而是针对JVM的，有JVM消除不同种类、不同语言之间的差别。Javac的任务是将Java源代码语言转化成JVM可以识别的一种语言，然后由JVM将JVM语言转化为当前机器可以识别的机器语言。</p>
<p>Java向开发者屏蔽了很多与目标机器相关的细节，使得Java成了跨平台的语言。</p>
<p>Javac的任务是将Java源码编译成Java字节码，也就是JVM可以识别的二进制码。<strong>class</strong>文件是二进制文件，其有自己的格式，只有JVM才可以正确识别。</p>
<h2 id="2-Javac编译器的基本架构"><a href="#2-Javac编译器的基本架构" class="headerlink" title="2. Javac编译器的基本架构"></a>2. Javac编译器的基本架构</h2><p>Javac编译的基本作用是将符合Java语言规范的源代码转化为符合Java虚拟机规范的Java字节码。如何实现这个转换过程？这个过程又需要完成哪些步骤呢？</p>
<ol>
<li>读取源代码，找出字节中哪些是我们定义的语法关键词，如Java中的<code>if</code>、<code>else</code>、<code>for</code>、<code>while</code>等关键词，即<strong style='color:red'>词法分析</strong>。词法分析的过程是从源代码中找出一些规范化的Token流。</li>
<li><strong style='color:red'>语法分析</strong>。对这些Token流进行语法分析，检查这些关键字组合是否符合Java语言规范，例如<code>if</code>后是否是<code>boolean</code>表达式。语法分析会形成一个符合Java语言规范的语法抽象数，语法抽象树是一个结构化的语法表达式，其用作是把语言的主要词法用一个结构化的形式组织在一起。这个语法抽象树后面还可以重新组织(语法糖等行为)。</li>
<li><strong style='color:red'>语义分析</strong>。语义分析主要是把一些难懂的、复杂的语法转化为更加简单的语法。语义分析的结果是将复杂的语法转化为最简单的语法，例如将<code>foreach</code>转化为<code>for</code>循环、注解等，最后形成一个注解后的抽象语法树，其更加接近目标语言的语法规则。</li>
<li><strong style='color:red'>字节码生成器</strong>。根据经过注解的抽象语法树生成字节码，也就是将一个数据结构转化为另外一个数据结构。代码生成器的结果是生成复合Java虚拟机规范的字节码。</li>
</ol>
<p>Javac的各个模块完成了将Java源代码转化成Java字节码的任务。Javac主要有上面4个模块。</p>
<p><img src="https://images.effiu.cn/blog/web/28.png" alt="png"></p>
<h2 id="3-Javac工作原理分析"><a href="#3-Javac工作原理分析" class="headerlink" title="3. Javac工作原理分析"></a>3. Javac工作原理分析</h2><h3 id="1-词法分析器"><a href="#1-词法分析器" class="headerlink" title="1. 词法分析器"></a>1. 词法分析器</h3><p>Javac分析词法是从源文件的第一个字符开始，按照Java语法规范依次找出<code>package</code>、<code>import</code>、类定义，以及属性和方法定义等，最后构建一个抽象语法树。</p>
<p>词法分析将类中所有关键字匹配到Token类的所有项中的任何一项(见下图)。例如:<code>TokenKind.IDENTIFIER</code>、<code>TokenKind.PACKAGE</code>、<code>TokenKind.SEMI</code>等</p>
<p><img src="https://images.effiu.cn/blog/web/29.png" alt="png"></p>
<p><code>Token</code>中，除了在Java语言规范中定义的保留关键字，还有一个特殊的<code>TokenKind.IDENTIFIER</code>。主要用于表示用户定义的名称，例如类名、包名、变量名、方法名等。</p>
<p>那么Javac是如何分辨Token的？Javac在进行词法分析时会根据Java语言规范来控制什么顺序、什么时候应该出现什么Token，Token流的顺序要符合Java语言规范，具体见<code>JavaxParser.parseCompilationUnit</code>方法。Java代码规则：<code>package</code>语法、<code>import</code>语法、类定义、<code>field</code>定义、<code>method</code>定义、变量定义、表达式定义等语法规则，然后还包括用于自定义的变量名出，比如包名、类名、变量名、方法名，关键字和用户自定义变量名之间用空格隔开，每个语法表达式用<code>;</code>结束。</p>
<p><strong style='color:red'>词法分析器的作用是将Java源文件的字符流转变为对应的Token流</strong>。</p>
<h3 id="2-语法分析器"><a href="#2-语法分析器" class="headerlink" title="2. 语法分析器"></a>2. 语法分析器</h3><p><strong style='color:red'>语法分析器是将词法分析器得到的Token流组建成更加结构化的语法树，抽象语法树</strong>。Javac的语法树使得Java源码更加结构化，这种结构化可以使后续进一步处理更方便。每个语法树上的节点都是<code>com.sun.tools.javac.tree.JCTree</code>的一个实例，语法树规则如下：</p>
<ul>
<li>每个语法树都会实现一个接口<strong>xxxTree</strong>，这个接口又继承自<code>com.sun.source.tree.Tree</code>接口，例如<code>IfTree</code>语法节点用于表示一个<code>if</code>表达式。</li>
<li>每个语法节点都是<code>com.sun.tools.java.tree.JCTree</code>的子类，且会实现第一节点中的<strong>xxxTree</strong>接口类，名称类似于<strong>JCxxx</strong>，例如<code>JCIf</code>。</li>
<li>所有<strong>JCxxx</strong>类都作为一个静态内部类定义在<code>JCTree</code>类中</li>
</ul>
<p><img src="https://images.effiu.cn/blog/web/30.png" alt="png"></p>
<p><img src="https://images.effiu.cn/blog/web/31.png" alt="png"></p>
<p><strong>JCxxx</strong>与<strong>xxxTree</strong>的类关系图如下：</p>
<p><img src="https://images.effiu.cn/blog/web/32.png" alt="png"></p>
<p>Javac会将词法分析得到的Token流，根据生成Token流的类型，例如<code>TokenKind.IF</code>，生成不同的语法节点，例<code>JCIf</code>，最终会构成一个抽象语法树。</p>
<h3 id="3-语义分析器"><a href="#3-语义分析器" class="headerlink" title="3. 语义分析器"></a>3. 语义分析器</h3><p>语法分析器生成了的抽象语法树，其仍然很粗糙，我们需要在这个语法树上做一些处理，例如：添加默认构造函数、检查变量是否已被初始化、常量折叠、操作变量是否匹配、所有操作语句是否可达、异常是否被捕获或者抛出、解除语法糖等等。只有这些都完成后才是一个完整的语法树，才可以被Javac生成字节码。</p>
<h4 id="1-填充符号表"><a href="#1-填充符号表" class="headerlink" title="1. 填充符号表"></a>1. 填充符号表</h4><p>将Java类中的符号输入到符号表中，主要由<code>com.sun.tools.javac.comp.Enter</code>完成。</p>
<ul>
<li>将在所有类中出现的符号输入到类自身的符号表中，所有类符号、类的参数类型符号、超类符号和继承的接口类型符号等都存储到一个未处理的列表中</li>
<li>将为处理列表中所有的类都解析到各自的类符号列表中，由<code>MemberEnter.complete</code>完成。</li>
</ul>
<p>首先：类本身会有一些符号变量，例如、类名称、变量名、方法名等，还有一些其他类的(调用其他类的方法或者变量、继承自父类等)，这些符号都是在其他类中定义的，那么就需要将这些类的符号也解析到符号表中。然后，按照递归向下的顺序解析语法树，将所有的符号都输入到符号表中。</p>
<p><code>Enter</code>类还有一个重要的步骤是添加默认的构造函数。</p>
<h4 id="2-注解处理器"><a href="#2-注解处理器" class="headerlink" title="2. 注解处理器"></a>2. 注解处理器</h4><p>注解处理是由<code>com.sun.tools.javac.processing.JavacProcessingEnvironment</code>类完成的。</p>
<h4 id="3-标注检查"><a href="#3-标注检查" class="headerlink" title="3. 标注检查"></a>3. 标注检查</h4><p>标注检查是由<code>com.sun.tools.javac.comp.Attr</code>完成的，其最重要的是检查语义是否合法，并进行逻辑判断。</p>
<ul>
<li>变量类型是否匹配</li>
<li>变量在使用前是否已经初始化</li>
<li>能够推导出反省方法的参数类型</li>
<li>字符串常量的合并</li>
</ul>
<p>标注检查还需要其他类协助。如下:</p>
<ul>
<li><code>com.sun.tools.javac.comp.Check</code>，辅助<code>Attr</code>类检查语法树中的变量类型是否正确，方法返回的类型是否与接收的引用值类型匹配等</li>
<li><code>com.sun.tools.javac.comp.Resolve</code>，主要检查变量、方法或类的访问是否合法，变量是否是静态变量、变量是否已经初始化等</li>
<li><code>com.sun.tools.javac.comp.ConstFold</code>，常量折叠</li>
<li><code>com.sun.tools.javac.comp.Infer</code>，帮助推导泛型方法的参数类型等</li>
</ul>
<p>常量折叠，例如<code>int a = 1 + 2</code>，会编译为<code>int a = 3</code></p>
<h4 id="4-数据及控制流分析"><a href="#4-数据及控制流分析" class="headerlink" title="4. 数据及控制流分析"></a>4. 数据及控制流分析</h4><p>由<code>com.sun.tools.javac.comp.Flow</code>类完成数据流分析，数据流分析主要工作如下:</p>
<ul>
<li>检查变量在使用前是否已经被正确赋值。除了Java的原始类型都会有默认的初始化值，其他对象引用都必须在使用前初始化赋值</li>
<li>保证<code>final</code>修饰的变量不会被重复赋值。final变量只能赋值一次，若是静态变量则在定义时就必须赋值。</li>
<li>确定方法的返回值类型。</li>
<li>所有的<strong>Checked Exception</strong>都要捕获或者向上抛出。</li>
<li>所有的语句都要被执行到。例如<code>return</code>后面不能出现语句。</li>
</ul>
<p>数据及控制流分析是进一步对语法树进行语义分析。</p>
<ul>
<li>消除无用代码</li>
<li>去除用真的条件判断</li>
<li>解除一些语法糖</li>
<li>装箱和拆箱的自动类型转换等</li>
</ul>
<h2 id="4-代码生成器"><a href="#4-代码生成器" class="headerlink" title="4. 代码生成器"></a>4. 代码生成器</h2><p>经过语义分析器完成后的语法树，会被被<code>com.sun.tools.javac.jvm.Gen</code>遍历，生成最终的Java字节码。步骤如下：</p>
<ul>
<li>将Java方法中的代码块转化成符合JVM语法的命令形式，JVM操作都是基于栈的，所有操作都必须由出栈和入栈来完成</li>
<li>按照JVM的文件组织格式将字节码输出到以<code>class</code>为扩展名的文件中。</li>
</ul>
<p>处理<code>Gen</code>类，还有两个辅助类：</p>
<ul>
<li><code>Items</code>，表示任何可寻址的操作项(堆中)，包括本地变量、类实例变量或者常量池中用户定义的常量等，这些操作都可以作为一个单位出现在操作栈上</li>
<li><code>Code</code>，存储生成的字节码，并提供一些能够映射操作码的方法。</li>
</ul>
<h2 id="5-访问者模式"><a href="#5-访问者模式" class="headerlink" title="5. 访问者模式"></a>5. 访问者模式</h2><p>词法分析器、语法分析器、语义分析器、代码生成器，每个过程都会多次遍历语法树，每次遍历都会进行不同的处理操作。每次遍历都是一次访问者的执行过程，这就是访问者模式。</p>
<p><img src="https://images.effiu.cn/blog/web/33.png" alt="访问者模式"></p>
<p>访问者模式一般具有抽象访问者、具体访问者、抽象节点元素、具体节点元素、结构对象和客户端集中角色，具体描述如下：</p>
<ul>
<li>抽象访问者(Visitor)，声明所有访问者需要的接口，<code>Visitor</code>接口。</li>
<li>具体访问者(ConcreteVisitor)，实现抽象访问者需要的接口，例如<code>TreeScanner</code>、<code>Enter</code>、<code>Attr</code>、<code>Gen</code>、<code>Flow</code>等</li>
<li>抽象节点元素(Element)，提供一个接口，能够接受访问者作为参数传递给节点元素。<code>Tree</code></li>
<li>具体节点元素(ConcreteElement)，实现抽象节点元素声明的接口，例如<code>JCIf</code>、<code>JCTry</code>等</li>
<li>结构对象(ObjectStructure)，提供一个接口，可以访问到所有的节点元素，一般作为集合所有节点元素的引用，<code>JCCompilationUnit</code>是结构对象。</li>
<li>客户端(Client)，分别创建访问者和节点元素的对象，调用访问者访问变量节点元素，<code>JavaCompiler</code>，持有<code>ObjectStructure</code>和<code>ConcreteElement</code>。</li>
</ul>
<p><img src="http://images.effiu.cn/blog/web/34.png" alt="javac中的访问者模式"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web中文编码</title>
    <url>/blog/2020/03/26/web/3-Java-Web%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>编码问题一直是开发人员经常遇到的问题，尤其是Java，因为Java是跨平台语音，而不同平台之间的编码切换非常多。对于国内的程序员更甚，因为还要转换成汉语。</p>
<ul>
<li>编码格式的区别</li>
<li>要编码的场景</li>
<li>中文编码问题的原因以及如何解决</li>
<li>Java Web开发中可能会存在编码的几个地方</li>
<li>一个HTTP请求怎么控制编码格式</li>
</ul>
<a id="more"></a>

<h2 id="1-常见的编码格式"><a href="#1-常见的编码格式" class="headerlink" title="1. 常见的编码格式"></a>1. 常见的编码格式</h2><p><code>byte</code>是计算机中的一个基本存储单元，其无法一一表示人类的语言，所以必须要经过翻译，才能让计算机理解我们的语言，这个编译过程就是编码。</p>
<p>计算机提供了多种编码方式，<strong>ASCII</strong>、<strong>ISO-8859-1</strong>、<strong>GB2312</strong>、<strong>GBK</strong>、<strong>UTF-8</strong>、<strong>UTF-16</strong>等。其中支持汉子的有<strong>GB2312</strong>、<strong>GBK</strong>、<strong>UTF-8</strong>、<strong>UTF-16</strong>，按照这些编码规则就可以让计算机正确表示我们的字符。</p>
<ol>
<li><p>ASCII码</p>
<p>ASCII码共有128个，用1个字节的低7位表示。0～31表示控制字符，如换行、回车、删除等；32～127是打印字符，如0～9，a～z，A~Z等</p>
</li>
<li><p>ISO-8859-1</p>
<p>ISO组织在ASCII的基础上扩展了ASCII码，其涵盖了大部分西欧字符。ISO-8859-1是单字节编码，共256个。</p>
</li>
<li><p>GB2312</p>
<p>GB2312是双字节编码，总编码范围是A1～F7。A1～A9是符号区，共包含682个字符，B0～F7是汉子区，共包含6763个汉字</p>
</li>
<li><p>GBK</p>
<p>扩展了GB2312，加入了更多的汉字。其编码范围是8140～FEFE(去掉XX7F)，共23940个码位，能表示21003个汉字，其兼容GB2312</p>
</li>
<li><p>UTF-16</p>
<p>UTF-16具体定义了Unicode字符在计算机中的存取方法，UTF-16用两个字节表示Unicode的转化格式，采用定长的方法，即任何字符都占用两个字节</p>
</li>
<li><p>UTF-8</p>
<p>UTF-16用两个字节的定长方法表示字符，虽然简单、方便，但是很多字符用一个字节就可以表示，这大大浪费了存储空间，这在目前带宽有限的情况下会增大网络传输的流量。UTF-8采用了变长技术，每个编码区域有不同的编码长度，不同类型的字符可以由1～4个字节组成。编码规则如下：</p>
<ul>
<li>若是1个字节，最高位为0，则表示这是一个ASCII字符(00~7F)。UTF-8兼容ASCII码</li>
<li>若是1个字节，以11开头，则连续的1表示这个字符的字节数</li>
<li>若是1个字节，以10开头，表示非首字节，则需要向前查找才能得到当前字符的首字节</li>
</ul>
</li>
</ol>
<h2 id="2-Java中需要编码的场景"><a href="#2-Java中需要编码的场景" class="headerlink" title="2. Java中需要编码的场景"></a>2. Java中需要编码的场景</h2><h3 id="1-I-O操作中的编码"><a href="#1-I-O操作中的编码" class="headerlink" title="1. I/O操作中的编码"></a>1. I/O操作中的编码</h3><p>涉及到编码的地方都是在字节与字符之间的转换发生的，所以主要场景是IO上，包括磁盘IO和网络IO。</p>
<p><img src="https://images.effiu.cn/blog/web/05.png" alt="png"></p>
<p><code>Reader</code>类是Java IO中读字符的父类，而<code>InputStream</code>是读字节的父类，<code>InputStreamReader</code>是字节与字符之间的桥梁，其负责处理读取字节到字符的转换，对于具体字节到字符的解码实现，其又委托<code>StreamDecoder</code>完成，在解码过程中必须由用户指定<code>charset</code>编码格式。默认使用系统本地的字符集，中文环境是<strong>GBK</strong>。下面是编码和解码的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String filePath = <span class="string">&quot;/Users/zhangshuai/Desktop/test.txt&quot;</span>;</span><br><span class="line">String charset = <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(filePath);</span><br><span class="line">    OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fos, charset);</span><br><span class="line">    writer.write(<span class="string">&quot;这仅仅是一个测试&quot;</span>);</span><br><span class="line">    writer.flush();</span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">    InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fis, charset);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((i = reader.read(cs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        builder.append(cs, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略资源关闭</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-内存中的编码"><a href="#2-内存中的编码" class="headerlink" title="2. 内存中的编码"></a>2. 内存中的编码</h3><p>Java 开发中除IO外，最常用的是内存中进行字节到字符的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;this is a 测试&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes(charset);</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(bytes, charset);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Java中如何编解码"><a href="#3-Java中如何编解码" class="headerlink" title="3. Java中如何编解码"></a>3. Java中如何编解码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;this is a 测试&quot;</span>;</span><br><span class="line"><span class="comment">// 省略异常</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = s.getBytes(charset);</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/web/22.png" alt="png"></p>
<p>首先根据<code>Charset.forName(String charName)</code>找到<code>Charset</code>类，然后根据<code>Charset</code>创建<code>CharsetEncoder</code>，每个编码方式都有自己的<code>CharsetEncoder</code>实现。然后调用<code>CharsetEncoder.encode</code>类对字符串进行编码。</p>
<p>下图是<code>String.getBytes(charsetName)</code>的编码过程时序图：</p>
<p><img src="https://images.effiu.cn/blog/web/23.png" alt="png"></p>
<p>也是通过<code>charsetName</code>找到<code>Charset</code>类，然后根据编码集生成<code>CharsetEncoder</code>，<code>CharsetEncoder</code>是所有字符编码的父类，然后调用<code>CharsetEncoder.encode</code>进行编码。</p>
<p>对于中文字符，GB2312、GBK、UTF-8、UTF-16都可以使用，其中GB2312与GBK规则类似，但是GBK范围更大，它能处理所有汉字字符，所以应该尽量选择GBK。UTF-16与UTF-8则是两种编码规则，UTF-16编码效率高，从字符到字节相互转换简单，进行字符串操作更好，适合在本地磁盘和内存之间使用，可以进行字符和字节之间的快速切换，但是<strong style='color:red'>UTF-16不适合在网络之间传输</strong>，因为网络传输容易损坏字节流，一旦发生将很难恢复，所以相比UTF-8更适合网络传输。UTF-8对ASCII字符采用单字节存储，另外单个字符损坏也不会影响后续的其他字符，编码效率介于GBK和UTF-16之间。</p>
<h2 id="4-Java-Web中涉及的编码"><a href="#4-Java-Web中涉及的编码" class="headerlink" title="4. Java Web中涉及的编码"></a>4. Java Web中涉及的编码</h2><p>对于中文来说，有IO的地方就会有编码，IO操作会发生编码转换，而大部分乱码都是网络IO引起的。我们需要考虑两个问题：</p>
<ol>
<li><font color='red'>一段文本的实际大小应该如何计算</font>，例如，把整型数字1234567作为字符串处理，采用UTF-8将会占用7个字节(ASCII码范围)，采用UTF-16则会占用14个字节，但是若把其作为int存储则只会占用4个字节；我们压缩Cookie时，会选择不同的压缩算法，发现压缩后的字符数是减少了，但是字节数并没有减少。所谓的压缩只是将多个单字节通过编码转换为一个多字节。</li>
<li><font color='red'>当我们计算机中的某个文本编辑器里输入汉字时，其到底是如何表示的</font>。计算机中所有的信息都是以0和1表示的，那么一个汉字是如何用0和1表示呢？Java中一个char是16个bit，2个字节，当汉字用char表示后，在内存中会占用相当于4个字节的空间。</li>
</ol>
<p>理解上面两个问题后，那么用户从一个浏览器发起一个HTTP请求后，需要存在编码的地方是URL、Cookie、Parameter。服务接受到请求后解析HTTP请求，其中URI、Cookie和POST表单都需要解码，甚至服务器端可能还需要读取数据库中的数据也会发生解码等等。当服务器处理完请求的数据后，需要将这写数据再编码，通过Socket发送到用户请求的浏览器里面，再经过浏览器编码成文本，这个过程最少发生2次编码、2次解码，若发生数据库行为，则会更多。</p>
<p><img src="https://images.effiu.cn/blog/web/24.png" alt="HTTP请求过程的编码示例"></p>
<h3 id="1-URL编解码"><a href="#1-URL编解码" class="headerlink" title="1. URL编解码"></a>1. URL编解码</h3><p>用户提交一个URL，这个URL可能含有中文，因此需要编码。一个URL由以下几个部分组成：</p>
<p><img src="https://images.effiu.cn/blog/web/25.png" alt="URL组成部分"></p>
<p>上图中的path部分和param部分都出现了中文，编码后结果如下：</p>
<p><img src="https://images.effiu.cn/blog/web/26.png" alt="URL编码后"></p>
<p>上图中可以发现，URI编码与参数编码不一致，这是GET请求。浏览器编码URL是将非ASCII码按照某种编码格式编码成16进制数字后将每个16进制表示的字节前加上’%’。对URL的URI部分进行编码的字符集是在connector的<code>&lt;Connector URIEncoding=&quot;UTF-8&quot;/&gt;</code>中定义的，若未定义，那么将以默认编码<strong>ISO-8859-1</strong>解析。</p>
<p>对于GET请求参数的解析：GET请求和POST请求的表单参数都是作为<strong>Parameter</strong>保存的，都通过<code>request.getParameter</code>获取参数值。其解码过程发生在第一次调用<code>request.getParameter</code>时，其在第一次被调用时将会调用<code>org.apache.catalina.connector.Request</code>的<code>parseParameter</code>方法，这个方法将会对GET和POSt方式传递的参数进行解码，但是它们的解码字符集可能不一样。GET请求的解码字符集是通过HTTP的Header传到服务端的，其与对URI编码的字符集不一致。对参数的编码字符集要么从Header中得到，要么是默认的ISO-8859-1。若要使用Header中<strong>ContentType</strong>中定义的编码，要将connector中的<code>&lt;Connector URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;</code>。</p>
<p>URL编码解码是比较复杂的，所以我们尽量在URL中使用非ASCII码字符，否则可能会出现乱码问题。服务端也要设置<code>&lt;Connector URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;</code></p>
<h3 id="2-HTTP-Header编解码"><a href="#2-HTTP-Header编解码" class="headerlink" title="2. HTTP Header编解码"></a>2. HTTP Header编解码</h3><p>当客户端发起一个HTTP请求时，除URL外，还可以能header中携带信息，如Cookie等，所以也会存在编码问题。对Header的编码是在第一次调用<code>request.getHeader</code>时进行的，其是调用<code>org.apache.tomcat.util.buf.MessageBytes.toString</code>方法，使用<strong>ISO-8859-1</strong>将byte编码为char的，没有办法设置Header的编码方式，所以若Header中出现非ASCII编码方式，则会出现乱码。    </p>
<p>若一定要传递中文，则需要使用<code>URLEncode.encode</code>将中文字符编码成<strong>ASCII</strong>，在加入到Header中，然后由服务器进行<strong>URLDecode</strong>。</p>
<ul>
<li><input disabled="" type="checkbox"> 查看解析header源码</li>
</ul>
<h3 id="3-POST表单的编解码"><a href="#3-POST表单的编解码" class="headerlink" title="3. POST表单的编解码"></a>3. POST表单的编解码</h3><p>POST表单提交的参数的解码也是在第一次调用<code>request.getParameter()</code>时发生的，POST参数是通过body传给服务端的，我们在浏览器中提交代码时，首先根据<code>contentType</code>定义的<strong>charset</strong>将参数编码，提交到服务端后同样会用<code>ContentType</code>中的<strong>charset</strong>解码。我们也可以通过<code>request.setCharacterEncoding()</code>设置编码格式。但是一定要在<code>request.getParameter()</code>之前设置，否则不起作用。若<code>contentType</code>没有设置编码方式，那么表单将会按照系统默认的编码方式解析。</p>
<ul>
<li><input disabled="" type="checkbox"> 查看解析post参数的源码</li>
</ul>
<h3 id="4-HTTP-BODY的编解码"><a href="#4-HTTP-BODY的编解码" class="headerlink" title="4. HTTP BODY的编解码"></a>4. HTTP BODY的编解码</h3><p>当用户请求的资源成功获取后，将会通过<strong>response</strong>返回给客户端浏览器。这个过程先要经过服务器编码，再到浏览器解码。编解码字符集可以通过<code>response.setCharacterEncoding()</code>来设置，其也会服务<code>request.setCharacterEncoding</code>的值，会通过<strong>response</strong>的<strong>header</strong>返回给客户端，浏览器也是根据header中的编码方式进行解码，若header中没有设置编码方式，那么浏览器将会根据HTML中的<code>&lt;meta HTTP-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot;/&gt;</code>中的charset来解码，若仍没有定义，那么将会使用浏览器默认编码方式解码。优先级：</p>
<ul>
<li>response header中的编码方式</li>
<li>HTML中规定的编码方式</li>
<li>浏览器默认的编码方式</li>
</ul>
<h3 id="5-其他需要编码的地方"><a href="#5-其他需要编码的地方" class="headerlink" title="5. 其他需要编码的地方"></a>5. 其他需要编码的地方</h3><ul>
<li>XML文件中，<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;</code></li>
<li>JSP文件中，<code>&lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;</code></li>
<li>JS中<ul>
<li><code>escape()</code>，将ASCII字母、数字、标点符号之外的其他字符转化为Unicode编码值，且在编码值前加<code>%u</code></li>
<li><code>encodeURI()</code>，用来对URL进行编码的函数，将整个URL中的字符除部分ASCII码外的字符进行UTF-8编码，在每个码值前加上<code>%</code></li>
<li><code>encodingURIComponent()</code>，支持更少的ASCII码，常用于将一个url作为参数放到另一个url中。</li>
</ul>
</li>
</ul>
<h2 id="5-乱码问题分析"><a href="#5-乱码问题分析" class="headerlink" title="5. 乱码问题分析"></a>5. 乱码问题分析</h2><p>Java中涉及到IO的地方(网络IO和磁盘IO)，绝大部份都涉及到编码。那么遇到乱码问题如何处理呢？乱码出现在<code>char</code>到<code>byte</code>或者<code>byte</code>到<code>char</code>中编码和解码的字符集不一致导致的，甚至一次操作设计了多次编解码，更很难确定哪个环节出现问题。</p>
<h3 id="1-中文字符改变"><a href="#1-中文字符改变" class="headerlink" title="1. 中文字符改变"></a>1. 中文字符改变</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;this is a 测试&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(bytes, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">this</span> is a 娴嬭瘯</span><br></pre></td></tr></table></figure>

<p>“<strong>this is a 测试</strong>”对应的字符集如下：</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">t</th>
<th align="center">h</th>
<th align="center">i</th>
<th>s</th>
<th align="center"></th>
<th align="center">i</th>
<th align="center">s</th>
<th align="center"></th>
<th align="center">a</th>
<th align="center"></th>
<th>测</th>
<th>试</th>
</tr>
</thead>
<tbody><tr>
<td>十进制</td>
<td align="center">116</td>
<td align="center">104</td>
<td align="center">105</td>
<td>115</td>
<td align="center">32</td>
<td align="center">105</td>
<td align="center">115</td>
<td align="center">32</td>
<td align="center">97</td>
<td align="center">32</td>
<td>27979</td>
<td>35797</td>
</tr>
<tr>
<td>十六进制</td>
<td align="center">0074</td>
<td align="center">0068</td>
<td align="center">0069</td>
<td>0073</td>
<td align="center">0020</td>
<td align="center">0069</td>
<td align="center">0073</td>
<td align="center">0020</td>
<td align="center">0061</td>
<td align="center">0020</td>
<td>6d4b</td>
<td>8bd5</td>
</tr>
</tbody></table>
<p>而测试两个字对应的GBK编码，<strong>测B2E2</strong>、<strong>试CAD4</strong>。但是Uncode和GBK字符集都包含“测试”两个字，只是位置不同，所以GBK把“测试”解码成了其他字。</p>
<h3 id="2-中文成了看不懂的字符"><a href="#2-中文成了看不懂的字符" class="headerlink" title="2. 中文成了看不懂的字符"></a>2. 中文成了看不懂的字符</h3><h4 id="1-GBK编码ISO-8859-1解码"><a href="#1-GBK编码ISO-8859-1解码" class="headerlink" title="1. GBK编码ISO-8859-1解码"></a>1. GBK编码ISO-8859-1解码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;this is a 测试&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(bytes, <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">this</span> is a ²âÊÔ</span><br></pre></td></tr></table></figure>

<p>这是由于GBK编码后的结果。<strong>测B2E2</strong>、<strong>试CAD4</strong>可以拆分为4个字节。查看<strong>ISO-8859-1</strong>对照表可以发现：</p>
<p>²对应B2、â对应E2、Ê对应CA、Ô对应D4。</p>
<ul>
<li><input disabled="" type="checkbox"> 尝试用UTF-8编码，ISO-8859-1解码</li>
</ul>
<h4 id="2-UTF-8编码ISO-8859-1解码"><a href="#2-UTF-8编码ISO-8859-1解码" class="headerlink" title="2. UTF-8编码ISO-8859-1解码"></a>2. UTF-8编码ISO-8859-1解码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;this is a 测试&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(bytes, <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/web/27.png" alt="png"></p>
<p>从上图中可以发现，“测试”对应的<strong>UTF-8</strong>码值(十六进制)分别为：6d4b和8bd5，但是“测试”两个字经过UTF-8编码后为6个字节。查看UTF-8编码<code>sun.nio.cs.UTF_8</code>的<code>encode</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">char</span>[] var1, <span class="keyword">int</span> var2, <span class="keyword">int</span> var3, <span class="keyword">byte</span>[] var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5 = var2 + var3;</span><br><span class="line">    <span class="keyword">int</span> var6 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var7 = var6 + Math.min(var3, var4.length); var6 &lt; var7 &amp;&amp; var1[var2] &lt; <span class="number">128</span>; var4[var6++] = (<span class="keyword">byte</span>)var1[var2++]) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2 &lt; var5) &#123;</span><br><span class="line">        <span class="keyword">char</span> var8 = var1[var2++];</span><br><span class="line">        <span class="comment">// var8 小于 128则说明是ASCII，占用1个字节</span></span><br><span class="line">        <span class="keyword">if</span> (var8 &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一位是0</span></span><br><span class="line">            var4[var6++] = (<span class="keyword">byte</span>)var8;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var8 &lt; <span class="number">2048</span>) &#123;</span><br><span class="line">            <span class="comment">// 128 ~ 2048，2^7 - 1 ~ 2^12 - 1，8到12位</span></span><br><span class="line">            <span class="comment">// 第一位是1,则1的个数表示所占的字节数, 192 = 128 + 64,即两个字节</span></span><br><span class="line">            <span class="comment">// 则第一个字节，11开头+取低6位之外的二进制值;第二个字节为10 + 低6位</span></span><br><span class="line">            var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">192</span> | var8 &gt;&gt; <span class="number">6</span>);</span><br><span class="line">            <span class="comment">// “&amp; 63”表示舍弃高位</span></span><br><span class="line">            var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">128</span> | var8 &amp; <span class="number">63</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isSurrogate(var8)) &#123; </span><br><span class="line">            <span class="comment">// \uD800 ~ \uDFFF</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.sgp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.sgp = <span class="keyword">new</span> Parser();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> var9 = <span class="keyword">this</span>.sgp.parse(var8, var1, var2 - <span class="number">1</span>, var5);</span><br><span class="line">            <span class="keyword">if</span> (var9 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.malformedInputAction() != CodingErrorAction.REPLACE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var4[var6++] = <span class="keyword">this</span>.repl;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 四个字节表示，每个字节种6位用于记录编码值</span></span><br><span class="line">                <span class="comment">// 1111 + </span></span><br><span class="line">                var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">240</span> | var9 &gt;&gt; <span class="number">18</span>);</span><br><span class="line">                var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">128</span> | var9 &gt;&gt; <span class="number">12</span> &amp; <span class="number">63</span>);</span><br><span class="line">                var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">128</span> | var9 &gt;&gt; <span class="number">6</span> &amp; <span class="number">63</span>);</span><br><span class="line">                var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">128</span> | var9 &amp; <span class="number">63</span>);</span><br><span class="line">                ++var2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">224</span> | var8 &gt;&gt; <span class="number">12</span>);</span><br><span class="line">            var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">128</span> | var8 &gt;&gt; <span class="number">6</span> &amp; <span class="number">63</span>);</span><br><span class="line">            var4[var6++] = (<span class="keyword">byte</span>)(<span class="number">128</span> | var8 &amp; <span class="number">63</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“测”的<strong>UTF-8</strong>码值分别为6d4b，所以走最后的<code>else</code>代码，占3个字符。<code>6d4b</code>的二进制位<code>0110101101001010</code>共16位。</p>
<ul>
<li><code>&gt;&gt; 12</code>表示取高4位，首位1的个数位占字节数，所以<code>111</code>开头。<code>11100000</code>+ <code>0110</code> = <code>11100110</code>，带符号值为-26，即无符号位230，对应ISO-8859-1的: <code>æ</code>。</li>
<li><code>&gt;&gt; 6 &amp; 63</code>，舍弃低6位后，取低中间6位。<strong>UTF-8</strong>非首位<code>10</code>开头，<code>10000000</code> + <code>101101</code> = <code>10101101</code>，带符号值为-75，即无符号位 181，对应ISO-8859-1的: <code>µ</code>。</li>
<li><code>&gt;&gt; 63</code>，取低6位，即<code>10000000</code> + <code>001010</code> = <code>10001010</code>，带符号值为-117，即无符号位139，对应ISO-8859-1的：<code>‹</code>。</li>
</ul>
<h3 id="3-汉字变成问号"><a href="#3-汉字变成问号" class="headerlink" title="3. 汉字变成问号"></a>3. 汉字变成问号</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;this is a 测试&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(bytes, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">this</span> is a ??</span><br></pre></td></tr></table></figure>

<p>将中文符号经过<strong>ISO-8859-1</strong>编码后，所有字符变成了？，这是因为ISO-8859-1编码时，遇到不在码值范围的统一用<strong>3f</strong>即**?**表示。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>总结了几种常见的编码方式，介绍了支持中文的编码方式，比较了说明场景；其次介绍了Java中涉及到的编码问题，以及如果实现编码的支持，以网络IO为例，说明了HTTP请求过程中发生编码与解码的地方，最后说明了平时遇到的发生乱码问题的原因。</p>
<p>要解决中文编码问题，首先要清楚哪些地方会引起字符到字节的编码，以及从字节到字符的编码。最常见的就是发生磁盘IO或者网络IO的时候；应该清楚发生编码行为的地方的原理或者系统是如何控制编码的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O的工作机制(2)</title>
    <url>/blog/2020/03/22/web/2-2-IO%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>数据从一台主机到另一台主机要经过很多步骤</p>
<ul>
<li>确认相互沟通(TCP握手)</li>
<li>沟通的渠道(物理链路)</li>
<li>沟通的语言(通信协议)</li>
</ul>
<a id="more"></a>

<h2 id="1-网络I-O工作机制"><a href="#1-网络I-O工作机制" class="headerlink" title="1. 网络I/O工作机制"></a>1. 网络I/O工作机制</h2><h3 id="1-TCP状态转化"><a href="#1-TCP状态转化" class="headerlink" title="1. TCP状态转化"></a>1. TCP状态转化</h3><p><img src="https://images.effiu.cn/blog/web/13.png" alt="png"></p>
<ol>
<li>CLOSE: 起始点，在超时或者链接关闭时进入此状态</li>
<li>LISTEN: Server端在等待连接时的状态，Server端要调用Socket、bind、listen函数，才能进入该状态，这是应用程序被动打开(等待客户端来连接)</li>
<li>SYN-SENT: 客户端发起连接，发生SYN给服务器端。若服务器不能连接则直接进入CLOSE状态</li>
<li>SYN-RCVD: 与3对应，服务器端接受客户端的SYN请求，服务器端由LISTEN状态进入SYN-RCVN。同时服务器端回应给客户端一个ACK，发送一个SYN给客户端；若客户端在发起SYN的同时接受到服务器端的SYN请求，客户端会由SYN-SENT转换到SYN-RCVD状态</li>
<li>ESTABLISHED: 服务器端和客户端在完成3次握手后进入该状态，说明已经可以开始传输数据了</li>
<li>FIN-WAIT-1: 主动关闭的一方，由状态5进入。具体动作是发送FIN给对方</li>
<li>FIN-WAIT-2: 主动关闭的一方，接收到对方的FIN ACK，进入此状态。此后不能再接收对方的数据，但是可以向对方发送数据</li>
<li>CLOSE-WAIT: 接收到FIN后，被动关闭的一方进入此状态。具体动作是在接收到FIN的同时发送ACK</li>
<li>LAST-ACK: 被动关闭的一方，发起关闭请求，由状态8进入此状态。具体是发送FIN给对方</li>
<li>CLOSING: 两边同时发起关闭请求时，会由FIN-WAIT-1进入此状态(未收到被动关闭方的FIN ACK)。具体动作是接收到FIN请求，同时响应一个ACK</li>
<li>TIME-WAIT: 有3个状态可以转化为此状态<ul>
<li>由FIN-WAIT-2转换到TIME-WAIT，具体是:在双方不同时发起FIN的情况下，主动关闭的一方在完成自身发起的关闭请求后，接收到被动关闭一方的FIN后进入的状态(FIN ACK先于对方的FIN)<font color='red'>FIN-WAIT-2 -&gt; TIME-WAIT</font></li>
<li>由CLOSING转换到TIME-WAIT，具体是:在双方同时发起关闭，都做了发起FIN的请求，同时接收到了FIN并做了ACK的情况下，就由CLOSING状态进入到TIME-WAIT状态(FIN ACK比对方的FIN晚到)，<font color='red'>FIN-WAIT-1 -&gt; CLOSING -&gt; TIME-WAIT</font></li>
<li>由FIN-WAIT-1转换到TIME-WAIT，具体是: 同时接收到FIN(对方发起)和ACK(本身发起的FIN ACK)，其与CLOSING转换到TIME-WAIT的区别在于本身发起的FIN回应的ACK先于对方的FIN请求到达，而由CLOSING转换到TIME-WAIT则是对方的FIN先到达(FIN ACK)，<font color='red'>FIN-WAIT-1 -&gt; TIME-WAIT</font></li>
</ul>
</li>
</ol>
<p>TCP连接的几种状态对调试网络程序非常有帮助。例如，当压测时CPU、网卡、带宽都不是瓶颈，但是性能上不去，那么就有可能是网络连接的问题。就需要查看当前网络连接的状态。</p>
<h3 id="2-影响网络传输的因素"><a href="#2-影响网络传输的因素" class="headerlink" title="2. 影响网络传输的因素"></a>2. 影响网络传输的因素</h3><p>将一份数据从一个地方传输到另一个地方需要的时间称为响应时间。影响响应时间的因素有很多：</p>
<ul>
<li>网络带宽: 所谓带宽就是一条物理链路在1s内能够传输的最大比特数(b/s)。</li>
<li>传输距离: 也就是数据在光纤中要求的距离，数据在光纤中移动存在折射率，所以其速度大概是光的$2/3$，这个时间就是传输延时</li>
<li>TCP拥塞控制: TCP传输是一个“停-等-停-等”的协议，传输方和接收方的步调要一致，要达到步调一致就要通过拥塞控制来调节。TCP在传输时会设定一个“窗口(BDP, Bandwidht Delay Product)”，这个窗口的大小是由带宽和RTT(Round-Trip Time，数据在两端的时间，即响应时间)决定的，计算公式是带宽(b/s) X RTT(s)。通过这个值可以得出理论上最优的TCP缓冲区大小。现在Liunx系统可以自动调整发送端和接收端缓冲区的大小</li>
</ul>
<h3 id="3-Java-Socket的工作机制"><a href="#3-Java-Socket的工作机制" class="headerlink" title="3. Java Socket的工作机制"></a>3. Java Socket的工作机制</h3><p>Socket描述的是计算机之间完成互相通信的一种抽象功能。大部分情况下使用的都是基于TCP/IP的流套接字，是一种稳定的通信协议。</p>
<p><img src="https://images.effiu.cn/blog/web/14.png" alt="png"></p>
<p>两台主机之间的通信必须经过Socket建立连接，而建立Socket连接必须由底层TCP/IP来建立TCP连接。建立TCP连接需要底层IP来寻址网络中的主机。网络层使用IP帮助我们找到目标主机，而TCP/UDP的地址也就是端口号则帮助我们找到目标主机内的应用程序。这样通过Socket实例唯一代表一个主机上的应用程序的通信链路。</p>
<h3 id="4-建立通信链路"><a href="#4-建立通信链路" class="headerlink" title="4. 建立通信链路"></a>4. 建立通信链路</h3><p>客户端要与服务端通信时，客户端首先要创建一个Socket实例，操作系统为这个Socket实例分配一个没有被使用的端口号，并创建一个包含本地地址、远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。创建Socket实例的构造函数正确返回之前，将要进行TCP的3次握手，3次握手完成后，Socket实例对象将完成创建。</p>
<p>与之对应的服务器端将创建一个SocketServer实例，只要指定的端口没有被占用，一般实例都会成功，同时操作系统也会为ServerSocket实例创建一个底层数据结构，在这个数据结构中包含指定监听的端口号和包含监听地址的通配符(默认为”*”，即监听所有地址),之后调用<code>accept()</code>方法，将会进入阻塞状态等待客户端的请求。若新的请求到达则会为这个连接创建一个新的套接字数据结构，该套接字的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中，此时这个服务端的与之对应的Socket实例并没有完成创建，而要等到与客户端的3次握手后服务端的Socket实例才会返回，并将这个Socket实例对应的数据结构从未完成列表中移到已完成列表中。ServerSocket所关联的列表中每个数据结构都代表一个客户端建立的TCP连接</p>
<h3 id="5-数据传输"><a href="#5-数据传输" class="headerlink" title="5. 数据传输"></a>5. 数据传输</h3><p>传输数据是我们建立连接的目的。Socket传输数据的过程如下：</p>
<p>当连接已经建立成功时，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个<code>InputStream</code>和<code>OutputStream</code>，并通过这两个对象来交换数据。网络I/O都是以字节流传输的，当创建Socket对象时，操作系统将会为<code>InputStream</code>和<code>OutputStrea</code>分别分配一定大小的缓存区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到<code>OutputStream</code>对应的SendQ队列，当队列满时，数据将会被转移到另一端<code>InputStream</code>的RecvQ队列中，若RecvQ队列已满，那么<code>OutputStream</code>的<code>write</code>方法将会阻塞，知道RecvQ有足够的空间容纳SendQ发送的数据。操作系统分配的缓存区的大小及写入端的速度和读取端的速度非常影响这个连接的数据传输效率。由于可能会发生阻塞，所以网络I/O与磁盘I/O不同的是数据的写入和读取还有一个协调的过程，若两边同时传送数据可能会发生死锁，后面的NIO将会介绍如何避免这种情况。</p>
<h2 id="2-NIO的工作方式"><a href="#2-NIO的工作方式" class="headerlink" title="2. NIO的工作方式"></a>2. NIO的工作方式</h2><h3 id="1-BIO的问题"><a href="#1-BIO的问题" class="headerlink" title="1. BIO的问题"></a>1. BIO的问题</h3><p>BIO即阻塞I/O，不管是磁盘I/O还是网络I/O，数据在写入<code>OutputStream</code>或者<code>InputStream</code>读取时都有可能会阻塞，若发生阻塞，线程将会失去CPU的使用权，这在大规模访问量和有性能要求的情况下是不能被接受的。尽管当前网络I/O又一些解决办法，例如：一个客户端对应一个线程，若出现问题只是一个线程阻塞而不会影响其他线程，还有为了减少系统线程的开销，采用线程池的办法减少线程创建和销毁的成本，但是大部分场景是无法解决问题的。例如需要HTTP长连接的情况，服务端需要同时保持大量HTTP长链接，但是这些连接并没有一直在传输数据，所以不可能同时创建这么多线程来保持连接。</p>
<h3 id="2-NIO的工作机制"><a href="#2-NIO的工作机制" class="headerlink" title="2. NIO的工作机制"></a>2. NIO的工作机制</h3><p><img src="https://images.effiu.cn/blog/web/15.png" alt="png"></p>
<p>上图中，<code>Channel</code>和<code>Selector</code>是NIO中的两个核心概念，<code>Selector</code>可以轮询每个<code>Channel</code>的状态，判断是否有事件到达，达到一个线程处理多个事件的效果。<code>Buffer</code>则是一个更加具体的概念(<a href="https://www.effiu.cn/blog/2019/09/22/java/java_io#2-NIO">见nio</a>)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建选择器,调用Selector的静态工厂</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">// 创建SocketChannel,网络IO通道</span></span><br><span class="line">    ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 设置非阻塞</span></span><br><span class="line">    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 设置端口号,最大连接数为10</span></span><br><span class="line">    channel.socket().bind(<span class="keyword">new</span> InetSocketAddress( <span class="number">8080</span>), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 注册监听事件</span></span><br><span class="line">    channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="comment">// 轮询Channel</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 选择一组其相应通道准备好进行I/O操作的key, 该方法执行一个阻塞的selection操作,</span></span><br><span class="line">        <span class="comment">// 其至少有一个channel被返回时才会返回</span></span><br><span class="line">        <span class="comment">// 调用Selector的wakeup方法或者当前线程被interrupted</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 注册到selector上的所有通道,selectedKeys()方法检查注册到selector上的channel是否有需要的事件发生</span></span><br><span class="line">        <span class="comment">// selectionKey可以得到通信通道对象,从而得到通道内的数据,这里读取的数据是Buffer(缓冲区)</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            SelectionKey next = it.next();</span><br><span class="line">            <span class="keyword">if</span> (next.isAcceptable()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                ServerSocketChannel ssChannel = (ServerSocketChannel) next.channel();</span><br><span class="line">                <span class="comment">// 接收到的请求</span></span><br><span class="line">                SocketChannel accept = ssChannel.accept();</span><br><span class="line">                accept.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                accept.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next.isReadable()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                SocketChannel sc = (SocketChannel) next.channel();</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                sc.write(ByteBuffer.wrap(<span class="string">&quot;success&quot;</span>.getBytes()));</span><br><span class="line">                sc.close();</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果如下:</span></span><br><span class="line">accept</span><br><span class="line">read</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">final</span> String host = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    SocketChannel channel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(host, <span class="number">8080</span>));</span><br><span class="line">    <span class="comment">// 客户端设置为阻塞，否则可能没有返回结果</span></span><br><span class="line">    channel.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;connect: &quot;</span> + channel.isConnected());</span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;123&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">    buffer.clear();</span><br><span class="line">    channel.read(buffer);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">    channel.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果如下:</span></span><br><span class="line">connect: <span class="keyword">true</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="3-Buffer的工作方式"><a href="#3-Buffer的工作方式" class="headerlink" title="3. Buffer的工作方式"></a>3. Buffer的工作方式</h3><p>上述例子中，当<code>SockectChannelServer</code>接收到的事件后，将数据读取或写入<code>Buffer</code>缓冲区。我们可以把Buffer简单理解为一组基本数据类型的元素列表，通过几个变量保存这个数据的当前位置状态(4个索引)。</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>缓冲区数组的总长度</td>
</tr>
<tr>
<td>position</td>
<td>下一个要操作的数据元素的位置</td>
</tr>
<tr>
<td>limit</td>
<td>缓冲区数组中不可操作的下一个元素的位置, limit &lt;= capacity</td>
</tr>
<tr>
<td>mark</td>
<td>用于记录当前position的前一个位置，默认是0</td>
</tr>
</tbody></table>
<p>具体见:<a href="https://www.effiu.cn/blog/2019/09/22/java/java_io/#5-缓冲器的细节" target='_blank'>Buffer缓冲器细节</a></p>
<p>通过Channel获取的IO数据首先要经过操作系统的Socket缓冲区，在将数据复制到Buffer，这个操作系统的缓存区就是底层TCP所关联的RecvQ或SendQ队列，从操作系统缓冲区到用户缓冲区复制数据比较耗性能，Buffer提供了另外一种直接操作操作系统缓冲区的方式，即<code>ByteBuffer.allocateDirect(size)</code>，其返回<code>DirectByteBuffer</code>就是与底层存储空间关联的缓冲区，通过Native代码操作非JVM堆的内存空间。每次创建或者释放的时候都调用一次<code>System.gc</code>。<code>DirectByteBuffer</code>可能会导致JVM内存泄漏。</p>
<p><code>DirectByteBuffer</code>和<code>HeapByteBuffer</code>对比如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>HeapByteBuffer</th>
<th>DirectByteBuffer</th>
</tr>
</thead>
<tbody><tr>
<td>存储位置</td>
<td>Java堆中</td>
<td>Native内存中</td>
</tr>
<tr>
<td>I/O</td>
<td>需要在用户地址空间和操作系统内核地址空间复制数据</td>
<td>不需要复制</td>
</tr>
<tr>
<td>内存管理</td>
<td>Java GC回收，创建和回收开销小</td>
<td>通过调用<code>System.gc</code>释放掉Java对象引用的<code>DirectByteBuffer</code>内存空间，若Java对象长时间持有引用可能会导致<code>Native</code>内存泄漏，创建和回收开销很大</td>
</tr>
<tr>
<td>使用场景</td>
<td>并发连接数小于1000，I/O操作较少时比较合适</td>
<td>数据量大，生命周期比较长的情况下比较合适</td>
</tr>
</tbody></table>
<h3 id="4-NIO的数据访问方式"><a href="#4-NIO的数据访问方式" class="headerlink" title="4. NIO的数据访问方式"></a>4. NIO的数据访问方式</h3><p>NIO提供了比传统文件访问方式更好的方法：</p>
<ul>
<li><code>FileChannel.transferTo</code></li>
<li><code>FileChannel.transferFrom</code></li>
<li><code>FileChannel.map</code></li>
</ul>
<h4 id="1-FileChannel-transferXXX"><a href="#1-FileChannel-transferXXX" class="headerlink" title="1. FileChannel.transferXXX"></a>1. FileChannel.transferXXX</h4><p>FileChannel.TransferXXX与传统访问文件的方式相比可以减少数据从内核到用户空间的复制，数据直接在内核空间中移动。其允许我们将一个通道和另一个通道直接相连。</p>
<p><img src="https://images.effiu.cn/blog/web/16.png" alt="传统数据访问方式"></p>
<p><img src="https://images.effiu.cn/blog/web/17.png" alt="FileChannel.transferXXX的数据访问方式"></p>
<h4 id="2-FileChannel-map"><a href="#2-FileChannel-map" class="headerlink" title="2. FileChannel.map"></a>2. FileChannel.map</h4><p><code>FileChannel.map</code>将文件按照一定大小块映射为内存区域，当程序访问内存区域时将直接操作这个文件数据，这种方式省去了从内核空间到用户空间复制的消耗，适合对大文件的只读性操作，其是和操作系统的底层I/O实现相关的。见<a href="https://www.effiu.cn/blog/2019/09/22/java/java_io/#6-内存映射文件" target="_blank">MapperedByteBuffer</a></p>
<h2 id="3-I-O调优"><a href="#3-I-O调优" class="headerlink" title="3. I/O调优"></a>3. I/O调优</h2><h3 id="1-磁盘I-O优化"><a href="#1-磁盘I-O优化" class="headerlink" title="1. 磁盘I/O优化"></a>1. 磁盘I/O优化</h3><p>我们的应用程序通常需要访问磁盘来读取数据，而磁盘I/O非常耗时，所以我们需要判断I/O是否是一个瓶颈，有一些指标可以作为参考。</p>
<h4 id="1-性能检测"><a href="#1-性能检测" class="headerlink" title="1. 性能检测"></a>1. 性能检测</h4><ol>
<li><p>系统的I/O wait指标是否正常。例如：压测时，若测试机器油4个CPU，那么理想I/O wait参数应该不超过25%。若超过则很可能IO就是应用程序瓶颈。linux系统使用<code>iostat</code>命令查看。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vdevops ~]# iostat</span><br><span class="line">Linux 3.10.0-957.27.2.el7.x86_64 (vdevops)      03/21/2020      _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.80    0.00    0.63    0.03    0.00   98.55</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">vda               0.61         0.92         4.65    7381229   37170360</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>IOPS</strong>，确认应用程序需要的最低IOPS，磁盘的IOPS能不能达到要求。**IOPS(Input/Output Operation Per Second)**用于计算存储设备(硬盘、固态硬盘或存储区域网络)性能的量测方式，可以视为每秒的读写次数。每个磁盘的IOPS通常在一个范围内，这和存储设备在磁盘上的数据块大小和访问方式有关，主要由磁盘转速决定，转速越高，IOPS越高。</p>
</li>
<li><p>目前为了提高I/O性能，通常采用一种叫做<strong>RAID</strong>的技术，就是将不同磁盘组合起来提高I/O性能。目前有多种<strong>RAID</strong>技术，每种技术对I/O性能的提升不同，可以用一个RAID因子代表，磁盘的读写吞吐量可以通过<code>iostat</code>命令获取，所以可以计算出一个理论的IOPS值：</p>
<p> (磁盘数 * 每块磁盘的IOPS)/(磁盘的吞吐量 + RAID因子 * 磁盘读写的吞吐量) = IOPS</p>
</li>
</ol>
<h4 id="2-提升I-O性能"><a href="#2-提升I-O性能" class="headerlink" title="2. 提升I/O性能"></a>2. 提升I/O性能</h4><p>通常提升磁盘I/O性能的方法有：</p>
<ul>
<li>增加缓存，减少磁盘访问次数</li>
<li>优化磁盘的管理系统，设计最优的磁盘方式策略，以及磁盘的寻址策略，这是在底层操作系统层面考虑的</li>
<li>设计合理的磁盘存储数据块，以及访问这些数据块的策略，这是在应用层面考虑的。例如：可以给存放的数据设计索引，通过寻址索引来加快和减少磁盘的访问量，还可以采用异步和非阻塞的方式加快磁盘的访问速度。</li>
</ul>
<p>RAID策略说明如下：</p>
<table>
<thead>
<tr>
<th>磁盘阵列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RAID 0</td>
<td>数据被平均写到多个磁盘中，写数据和读数据都是并行的，所以磁盘的IOPS可以提高一倍</td>
</tr>
<tr>
<td>RAID 1</td>
<td>RIAD 1的主要作用是可以提高数据的安全性，其将一份数据分别复制到多个磁盘阵列中，并不能提高IOPS，但是相同数据有多个备份。用于对数据安全要求高的场景中</td>
</tr>
<tr>
<td>RAID 5</td>
<td>是前面两种的折中方式，其将数据平均写到所有磁盘阵列总数减一的磁盘中，在另外一个磁盘中写入这份数据的奇偶校验信息，若其中一个磁盘损坏，可以通过其他磁盘的数据和这个数据的奇偶校验信息复来恢复这份数据</td>
</tr>
<tr>
<td>RAID 0+1</td>
<td>根据数据的备份情况进行分组，一份数据同时写到多个备份磁盘分组中，同时多个分组也会并行读写</td>
</tr>
</tbody></table>
<h3 id="2-TCP网络参数调优"><a href="#2-TCP网络参数调优" class="headerlink" title="2. TCP网络参数调优"></a>2. TCP网络参数调优</h3><p>建立TCP连接，必须知道对方的IP和一个未被使用的端口号。然而一台主机的端口号是有限的，所以能够建立的连接也是有限的，还有一些端口号是受保护的(0~1024)。</p>
<p>Linux中可以通过查看<code>/proc/sys/net/ipv4/ip_local_port_range</code>文件知道当前这个主机可以使用的端口范围。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vdevops ~]# cat /proc/sys/net/ipv4/ip_local_port_range </span><br><span class="line">32768   60999</span><br></pre></td></tr></table></figure>

<p>可使用端口号位32768~60999，共28231个。可分配的端口号，可以表示支持的最大连接数。若超过则会出现端口有限导致的大量请求等待建立连接。若发现大量TIME_WAIT，可以设置<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>为更小的值来快速释放请求。</p>
<p>除了设置TIME_WAIT快速释放连接之外，还可以让TCP连接复用等</p>
<table>
<thead>
<tr>
<th>网络参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>echo &quot;1024 65535&quot; &gt;/proc/sys/net/ip_local_port_range</code></td>
<td>设置向外连接可用端口范围</td>
</tr>
<tr>
<td><code>echo 1 &gt;/proc/sys/net/ipv4/tcp_tw_reuse</code></td>
<td>设置<code>time_wait</code>连接复用</td>
</tr>
<tr>
<td><code>echo 1&gt;/proc/sys/net/ipv4/tcp_tw_recycle</code></td>
<td>设置快速回收<code>time_wait</code>连接</td>
</tr>
<tr>
<td><code>echo 180000 &gt;/proc/sys/net/ipv4/tcp_max_tw_buckets</code></td>
<td>设置最大<code>time_wait</code>连接长度</td>
</tr>
<tr>
<td><code>echo 0 &gt;/proc/sys/net/ipv4/tcp_timestamp</code></td>
<td>表示是否启用以一种比超时重发更精确的方法来启用超时RTT的计算</td>
</tr>
<tr>
<td><code>echo 1 &gt;/proc/sys/net/ipv4/tcp_window_scaling</code></td>
<td>设置TCP/IP会话的滑动窗口大小是否可变</td>
</tr>
<tr>
<td><code>echo 20000 &gt;/proc/sys/net/ipv4/tcp_max_syn_backlong</code></td>
<td>设置最大等待处于客户端还没有应答回来的连接数</td>
</tr>
<tr>
<td><code>echo 20000 &gt;/proc/sys/net/core/somaxconn</code></td>
<td>设置每个处于监听状态的端口的监听队列的长度</td>
</tr>
<tr>
<td><code>echo 10000 &gt;/proc/sys/net/core/netdev_max_blcklog</code></td>
<td>设置最大等待CPU处理的包的数目</td>
</tr>
<tr>
<td><code>echo 2000000 &gt;/proc/sys/net/file-max</code></td>
<td>设置最大打开文件数</td>
</tr>
<tr>
<td><code>echo 15 &gt;/proc/sys/net/ipv4/tcp_fin_timeout</code></td>
<td>设置FIN-WATI-2状态等待回收时间</td>
</tr>
<tr>
<td><code>echo 16777216 &gt;/proc/sys/net/core/rmem_max</code></td>
<td>设置最大的系统套接字数据接受缓冲大小</td>
</tr>
<tr>
<td><code>echo 262144 &gt;/proc/sys/net/core/rmem_default</code></td>
<td>设置默认的系统套接字数据接受缓冲大小</td>
</tr>
<tr>
<td><code>echo 16777216 &gt;/proc/sys/net/core/wmem_max</code></td>
<td>设置最大的系统套接字数据发送缓冲大小</td>
</tr>
<tr>
<td><code>echo 262144 &gt;/proc/sys/net/wmem_default</code></td>
<td>设置默认的系统套接字数据发送缓冲大小</td>
</tr>
<tr>
<td><code>echo 4096 87380 16777216 &gt;/proc/sys/net/ipv4/tcp_rmem</code></td>
<td>设置最大的TCP数据发送缓冲大小，分别是最小、默认和最大值</td>
</tr>
<tr>
<td><code>echo 4096 65536 12777216 &gt;/proc/sys/net/ipv4/tcp_wmem</code></td>
<td>设置最大的TCP数据接收缓冲大小，分别是最小、默认和最大值</td>
</tr>
</tbody></table>
<p>上面的设置都是临时的，系统重启后就回丢失。另外linux还提供了一些工具可以查看当前TCP统计信息：、</p>
<ul>
<li><code>cat /proc/net/netstat</code>:查看TCP统计信息</li>
<li><code>cat /proc/net/snmp</code>:查看当前系统的连接情况</li>
<li><code>netstat -s</code>:查看网络的统计信息</li>
</ul>
<h3 id="3-网络I-O优化"><a href="#3-网络I-O优化" class="headerlink" title="3. 网络I/O优化"></a>3. 网络I/O优化</h3><p>网络I/O优化通常有一些基本原则：</p>
<p><strong style='color:red'>减少网络交互的次数</strong>：减少网络交互次数通常需要在网络交互两端设置缓存。例如Oracle的jdbc驱动程序提供了对查询的SQL结果的缓存，客户端和数据库端都有，可以有效减少数据库的访问。另外还可以合并请求，如数据库查询时，合并查询参数。</p>
<p><strong style='color:red'>减少网络传输数据量的大小</strong>：其办法通常是将数据压缩后在传输，如在HTTP请求中，Web服务器将请求的页面<strong>gzip</strong>压缩后在返回给浏览器，还可以设计简单的协议，尽量通过读取协议头来获取有用的价值信息。</p>
<p><strong style='color:red'>尽量减少编码</strong>：网络I/O中的数据传输是以字节形式进行的，也就是通常需要序列化。但是要发送的数据都是字符形式的，字符到字节必须编码，尽量把编码过程放到发生网络IO前，即提前将字符转化为字节。</p>
<p>交互场景主要包括同步与异步、阻塞与非阻塞方式。</p>
<h4 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1. 同步与异步"></a>1. 同步与异步</h4><p>同步是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一种可靠的任务序列。异步不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。被依赖的任务是否完成，依赖它的任务无法确定，是不可靠的任务序列。</p>
<h4 id="2-阻塞与非阻塞"><a href="#2-阻塞与非阻塞" class="headerlink" title="2. 阻塞与非阻塞"></a>2. 阻塞与非阻塞</h4><p>阻塞与非阻塞主要是从CPU的消耗上来说的，阻塞就是CPU停下来等待一个慢的操作完成，CPU才会接着完成其他工作。非阻塞就是在这个慢的操作执行时，CPU会做其他工作，等待慢的任务完成。表面上看非阻塞提高了CPU的利用率，但是线程的切换次数增加了，增加的CPU使用时间能否补偿系统的切换成本需要确认。</p>
<h4 id="3-两种方式的组合"><a href="#3-两种方式的组合" class="headerlink" title="3.两种方式的组合"></a>3.两种方式的组合</h4><p>同步阻塞、同步非阻塞、异步阻塞、异步非阻塞。4种方式都对IO性能有影响</p>
<table>
<thead>
<tr>
<th>组合方式</th>
<th>性能分析</th>
</tr>
</thead>
<tbody><tr>
<td>同步阻塞</td>
<td>最常用、最简单的，但是IO性能差，CPU大部分时间处于空闲状态</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>提升I/O性能的常用手段，是将I/O的阻塞方式改成非阻塞，尤其在网络I/O长连接同时传输数据也不是很多的情况下，提升性能非常有效</td>
</tr>
<tr>
<td>异步阻塞</td>
<td>在分布式数据库中常用，写记录同步阻塞，主从同步是异步阻塞的。异步阻塞网络I/O能够提升效率。</td>
</tr>
<tr>
<td>异步非阻塞</td>
<td>非常负责，只有在复杂的分布式系统中使用，集群之间消息同步机制一班使用异步非阻塞。适合要传多份相同的数据到集群中不同的机器，同时数据量不大却很频繁的情况。可以使IO性能达到最高</td>
</tr>
</tbody></table>
<h2 id="4-IO中的设计模式"><a href="#4-IO中的设计模式" class="headerlink" title="4. IO中的设计模式"></a>4. IO中的设计模式</h2><h3 id="1-适配器模式"><a href="#1-适配器模式" class="headerlink" title="1. 适配器模式"></a>1. 适配器模式</h3><p>适配器模式是把一个类的接口变换成客户端所能接受的另一种接口，保证可以被使用。常用在项目需要引用开源框架完成工作的情况中。</p>
<p><img src="https://images.effiu.cn/blog/web/18.png" alt="适配器模式"></p>
<ul>
<li>Target(目标接口)：所要转换的所期待的接口</li>
<li>Adaptee(源角色)：需要适配的接口</li>
<li>Adater(适配器)：将源接口适配成目标接口，继承源接口，实现目标接口</li>
</ul>
<p>Java IO中有很多适配需求，将一个接口适配到另一个接口。例如：字符串数据转变成字节数据保存到文件中，将字节数据转变成流数据等。以<code>InputStreamReader</code>为例介绍适配器模式：</p>
<p><code>InputStreamReader</code>继承了<code>Reader</code>接口，但是创建起对象必须在构造函数汇总传入<code>InputStream</code>实例，<code>InputStreamReader</code>的作用是将<code>InputStream</code>适配到<code>Reader</code>。</p>
<p><img src="https://images.effiu.cn/blog/web/19.png" alt="InputStreamReader类结构图"></p>
<p><code>InputStreamReader</code>实现了<code>Reader</code>接口，持有了<code>InputStream</code>实例。其他适配器模式例如：<code>StringReader</code>将一个<code>String</code>类适配到<code>Reader</code>接口。<code>ByteArrayInputStream</code>适配器将<code>byte</code>数组适配到<code>InputStream</code>流处理接口。</p>
<h3 id="2-装饰器模式"><a href="#2-装饰器模式" class="headerlink" title="2. 装饰器模式"></a>2. 装饰器模式</h3><p>顾名思义，将类装饰一下，使其更加强大，但是对类的使用者是透明的，否则会破坏原有类的结构。</p>
<p><img src="https://images.effiu.cn/blog/web/21.png" alt="装饰器模式的结构图"></p>
<ul>
<li>Component：抽象组件角色，定义一组抽象接口，规则被装饰组建的功能</li>
<li>ConcreteComponent：实现抽象组件的所有功能</li>
<li>Decorator：装饰器，持有一个Component对象的实例，定义一个与抽象组件一致的接口</li>
<li>ConcreteDecorator：具体的装饰器实现着，负责实现装饰器角色定义的功能。</li>
</ul>
<p>装饰器模式的作用是赋予被装饰得类更多的功能，在Java IO类库中有很多不同的功能组合情况，都是使用装饰者模式实现的，下面以<code>FilterInputStream</code>为例说明：</p>
<p><img src="https://images.effiu.cn/blog/web/20.png" alt="FilterInputStream类结构图"></p>
<p><code>InputStream</code>类是以抽象组件存在的；而<code>FileInputStream</code>是具体的组件，其实现了抽象组件的所有接口；<code>FilterInputStream</code>是装饰角色，实现了<code>InputStream</code>类的所有接口，持有<code>InputStream</code>的对象实例的引用。<code>BufferedInputStream</code>是具体的装饰器实现着，其给<code>InputStream</code>附加了功能，这个装饰器的作用是使得<code>InputStream</code>读取的数据保存在内存中，而提高读取性能。</p>
<p>其他装饰器模式还有<code>LineNumberInputStream</code>类，作用是提高按行读取数据的功能。</p>
<h3 id="3-适配器与装饰器区别"><a href="#3-适配器与装饰器区别" class="headerlink" title="3. 适配器与装饰器区别"></a>3. 适配器与装饰器区别</h3><p>装饰器和适配器都是包装模式。适配器是将一个接口转变成另外一个接口，目的是改变接口达到充分使用的目的；装饰器模式要保持原有接口，增强原有对象的功能，或者改变原有对象的处理方法提升性能。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 函数式编程</title>
    <url>/blog/2020/03/21/java/lambda/</url>
    <content><![CDATA[<p>随着时代的发展，越来越需要更复杂的应用程序。高效运行时编译器的Java虚拟机，使得我们可以将更多精力放在编写干净、易于维护的代码上。</p>
<p>现在计算机发展方向是多核CPU而不是高频率，但是多核情况下涉及锁的编程算法不但容易出错， 而且耗费时间。 人们开发了<code>java.util.concurrent</code>包和很多第三方类库， 试图将并发抽象化， 帮助程序员写出在多核 CPU 上运行良好的程序。 很可惜， 到目前为止， 我们的成果还远远不够。</p>
<p>为了能够使用 Java 8 编写复杂的集合处理算法，只需要修改一个方法，就能够让代码在多核CPU上高效运行。为了编写类处理批量数据的并行类库，增加了<strong>Lambda表达式</strong>。</p>
<p>面向对象编程是对数据进行抽象，函数式编程是对行为进行抽象。现实世界中，数据和行为是并存的。</p>
<p>函数式编程的核心是：使用不可变值和函数，函数对一个值进行处理，映射成另一个值。</p>
<a id="more"></a>

<h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><h3 id="1-第一个Lambda表达式"><a href="#1-第一个Lambda表达式" class="headerlink" title="1. 第一个Lambda表达式"></a>1. 第一个<code>Lambda</code>表达式</h3><p><strong>Lambda</strong>表达式是一种紧凑的、传递行为的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码中，线程是通过使用<strong>匿名内部类</strong>实现<code>Runnable</code>接口实现的，其是为了方便Java程序员将代码作为数据传递。可以发现，匿名内部类仍然有冗余代码。而实际上，我们并没有想传入对象，而是想传入行为。上述代码的 Java 8 Lambda写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>我们传入的是一个代码块，<code>()</code>代表没有参数的方法，<code>-&gt;</code> 将参数和 <strong>Lamdba</strong> 表达式主体分开，在 <strong>Lambda</strong>中不需要指定参数类型(<code>()</code>或者其他)，<code>javac</code>可以根据程序上下文推导出类型。</p>
<h3 id="2-辨别Lambda表达式"><a href="#2-辨别Lambda表达式" class="headerlink" title="2. 辨别Lambda表达式"></a>2. 辨别<code>Lambda</code>表达式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// () 表示没有参数，Lambda 表达式实现了 Runnable 接口，该接口只有一个 run 方法且没有参数，</span></span><br><span class="line"><span class="comment">// javac推导出其是 run() 方法的行为</span></span><br><span class="line">Runnable noArguments = () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"><span class="comment">// Lambda表达式还可以是一个代码块，使用&#123;&#125;括起来</span></span><br><span class="line">Runnable multiStatement = () -&gt; &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以表示包含多个参数的方法，如下是创建了一个函数，用来计算两个数字相加的结果。</span></span><br><span class="line"><span class="comment">// BinaryOperator&lt;Long&gt; 表示两个相同类型的数的操作，返回一个相同类型的结果</span></span><br><span class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</span><br><span class="line"><span class="comment">// Lambda 表达式中的参数类型不仅仅是由编译器推断得出，也可以显式声明参数类型，如下</span></span><br><span class="line">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda</strong> 表达式依赖于上下文环境，是由编译器推断出的。<code>final String[] array = &#123; &quot;hello&quot;, &quot;world&quot; &#125;;</code>中数组的类型就是根据上下文推断出来的。<code>null</code>本身并没有类型，而是只有<code>String str = null;</code>将<code>null</code>赋值给一个变量后才能知道其类型。</p>
<h3 id="3-引用值，而不是变量"><a href="#3-引用值，而不是变量" class="headerlink" title="3. 引用值，而不是变量"></a>3. 引用值，而不是变量</h3><p>在匿名内部类中，需要引用其方法里的变量时，需要将变量声明未<code>final</code>，即不能重新赋值。<strong>Java 8</strong> 中放松了这个限制，不在需要显式声明为<code>final</code>变量，但是其变量本身需要是<code>final</code>的(即只能被赋值一次，不能被重新赋值)。</p>
<p>在匿名内部类中使用方法里的变量时，若不声明为<code>final</code>，则会出现问题；但是匿名内部类引用外部类的成员变量则不需要声明为<code>final</code>。这是与Java内存区域的堆栈有关的。</p>
<p>匿名内部类在Javac编译后，JVM会为匿名内部类单独生成一个class文件，匿名内部类引用的变量会被copy到内部类的环境中。而如果外部类的方法变量被修改后，会导致内部值与外部值不一致，从而产生意料之外的情况。而堆内存储的是Class文件信息、常量池、对象以及对象包含的类的成员变量等信息。</p>
<p>栈是Java方法执行的内存模型，每调用一个方法就会为每个方法生成一个栈帧。任何操作都是通过入栈和出栈完成的，栈内存储的是局部变量表、操作数栈、动态链接、方法出口等信息。当匿名内部类引用的变量是方法内部变量时，其copy的是调用方方法栈帧中的值，copy后原来栈帧变为不可见；当匿名内部类引用的是外部类的成员变量时，调用方方法栈帧中保存的是指向堆的引用，其实际上是不会变化的(栈帧内指向堆的指针不会变化)，不会出现意料之外的情况，所以不需要声明为<code>final</code>。</p>
<h3 id="4-函数接口"><a href="#4-函数接口" class="headerlink" title="4. 函数接口"></a>4. 函数接口</h3><p>函数接口是只有一个抽象方法的接口，用作<code>Lambda</code>表达式的类型。使用只有一个方法的接口来表示某种特定方法并反复使用，这个方法被用来表示一个行为：接受一些参数，返回一个结果。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Predicate</code>类中，只有一个<code>test(T t)</code>抽象方法，其他的是<code>default</code>方法和<code>static</code>方法。这种就是<strong>函数接口</strong>。常见的函数接口如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th align="center">参数</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td align="center">T</td>
<td><code>boolean</code></td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td align="center">T</td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>Function&lt;T,R&gt;</code></td>
<td align="center">T</td>
<td>R</td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td align="center">none</td>
<td>T</td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td align="center">T</td>
<td>逻辑非(!)</td>
</tr>
<tr>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td align="center">(T, T)</td>
<td>求两个数的乘积</td>
</tr>
</tbody></table>
<h3 id="5-类型推断"><a href="#5-类型推断" class="headerlink" title="5. 类型推断"></a>5. 类型推断</h3><p>某些情况下，用户需要手动指明类型，有些时候省略类型信息可以减少干扰，更易阅读。<strong>Java 7</strong>引入了类型推断，<code>List&lt;Long&gt; list = new ArrayList&lt;&gt;();</code>中，在new对象时没有明确指明类型信息，而是使用菱形操作符，编译器可以自己推断出其实际类型。</p>
<p><code>Lambda</code>表达式中的类型推断是<strong>Java 7</strong>引入的目标类型推断的扩展。我们将一个未指明类型的构造函数直接传递给一个方法，也可以根据方法签名推断类型。例如:<code>private void** useHashmap(Map&lt;String, String&gt; values);</code>,<code>useHashmap(new HashMap&lt;&gt;())</code>调用,就可以根据方法签名推断类型。<strong>Java 7</strong>中可以根据方法签名推断构造函数的泛型类型，而<strong>Java 8</strong>则可以省略<code>Lambda</code>表达式中的所有参数类型, <code>javac</code>根据<code>Lambda</code>表达式上下文信息就能推断出参数的正确类型。虽然程序依然要经过类型检查来保证运行的正确性, 但是已经不再需要显式声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; result = x -&gt; x &gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Predicate 类内的方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>Predicate</code>是一个lambda表达式, 其返回一个<code>boolean</code>值。<code>Predicate</code>只有一个泛型类型的参数，用于<code>test</code>方法中。上例中<code>Predicate</code>的泛型类型<code>Integer</code>,所以要求参数为<code>Integer</code>，javac还会检查<code>x &gt; 5</code>是否返回<code>boolean</code>型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; addLongs = (x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure>

<p><code>BinaryOperator</code>类的泛型是<code>Long</code>,则可以推断出<code>R apply(T t, T u);</code>方法参数为<code>Long</code>，且返回类型为<code>Long</code>。</p>
<h2 id="2-流"><a href="#2-流" class="headerlink" title="2. 流"></a>2. 流</h2><h3 id="1-for循环本质"><a href="#1-for循环本质" class="headerlink" title="1. for循环本质"></a>1. for循环本质</h3><p><code>for</code>循环是一个封装了迭代的语法糖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List var0 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> var3;</span><br><span class="line"><span class="keyword">for</span>(Iterator var2 = var0.iterator(); var2.hasNext(); var1 += var3) &#123;</span><br><span class="line">    var3 = (Integer)var2.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码编译使用<strong>Java Decompiler</strong>打开后如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List localList = Arrays.asList(<span class="keyword">new</span> Integer[] &#123; Integer.valueOf(<span class="number">1</span>), Integer.valueOf(<span class="number">2</span>), Integer.valueOf(<span class="number">3</span>), Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Iterator localIterator = localList.iterator(); localIterator.hasNext();) &#123; </span><br><span class="line">    <span class="keyword">int</span> j = ((Integer)localIterator.next()).intValue();</span><br><span class="line">    i += j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其会先调用<code>iterator</code>方法，产生一个<code>Iterator</code>对象，然后调用该对象的<code>hasNext</code>和<code>next</code>方法，这是属于外部迭代，其本质是一种串行化操作。</p>
<p>Lambda是属于内部迭代，其返回的是Stream对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// activityCourseRelations 是ArrayList, ActivityTarget是DTO对象</span></span><br><span class="line">List&lt;Long&gt; courseNumbers = activityCourseRelations.stream()</span><br><span class="line">		.filter(p -&gt; p.getProductType().equals(ProductTypeEnum.GENERAL_COURSE.getType()))</span><br><span class="line">         .map(ActivityTarget::getCourseNumber).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>上述代码中，Lambda每个方法都返回一个<code>Stream</code>对象。<code>filter</code>方法用于过滤, <code>map</code>其是将一个流转换为另一个流，这里可以理解为返回Dto对象中的指定成员的流，collect是将流转为对象，属于及早求值操作。</p>
<h3 id="2-流的实现机制"><a href="#2-流的实现机制" class="headerlink" title="2. 流的实现机制"></a>2. 流的实现机制</h3><p>通常在<strong>Java</strong>中调用一个方法，计算机会立即执行操作，但是<strong>Stream</strong>却并不是这样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">activityCourseRelations.stream()</span><br><span class="line">		.filter(p -&gt; p.getProductType().equals(ProductTypeEnum.GENERAL_COURSE.getType()));</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>filter</code>()方法只是描述了<strong>Stream</strong>，并没有做什么实际操作，最终不返回新的结合，这种方法叫做<strong>惰性求值方法</strong>。像<code>collect</code>、<code>count</code>等方法，会从Stream中产生新的对象，叫做<strong>及早求值方法</strong>。</p>
<p>判断一个操作是惰性求值还是及早求值很简单：只需看它的返回值。返回值为<code>Stream</code>对象，那么则是惰性求值；若返回另一个值或者空，则是属于及早求值方法。其理性操作是，使用惰性方法形成一个操作链，最后用一个及早求值的操作返回一个想要的结果。</p>
<h3 id="3-常用流操作"><a href="#3-常用流操作" class="headerlink" title="3. 常用流操作"></a>3. 常用流操作</h3><ol>
<li><p><code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</code>方法，其返回一个列表，属于及早求值方法。其常用参数如下：</p>
<ul>
<li><code>Collectors.toList()</code></li>
<li><code>Collectors.toSet()</code></li>
<li><code>Collectors.toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper)</code></li>
<li>``Collectors.groupingBy(Function&lt;? super T, ? extends K&gt; classifier)`</li>
<li>······</li>
</ul>
</li>
<li><p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code>方法，其可以将一个类型的值转换为另一个类型，将一个流中的值转换成一个新的流。</p>
</li>
<li><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，工作中主要用于过滤出符合条件的数据。其参数<code>Predicate</code>返回一个<code>boolean</code>值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// activityCourseRelations 是ArrayList, ActivityTarget是DTO对象</span></span><br><span class="line">List&lt;Long&gt; courseNumbers = activityCourseRelations.stream()</span><br><span class="line">		.filter(p -&gt; p.getProductType().equals(ProductTypeEnum.GENERAL_COURSE.getType()))</span><br><span class="line">         .map(ActivityTarget::getCourseNumber).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</code>用于将多个<code>Stream</code>合并为一个新的<code>Stream</code>。</p>
</li>
<li><p><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code>和<code>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</code>，用于求最大值和最小值，参数为排序规则。常用参数为<code>Comparator.comparing(Function&lt;? super T, ? extends U&gt; keyExtractor)</code>。</p>
</li>
<li><p>通用模式</p>
</li>
</ol>
<p><code>max</code>和<code>min</code>方法都是属于更通用的一种编程模式，即<code>reduce</code>模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object accumulator = initialValue; </span><br><span class="line"><span class="keyword">for</span>(Object element : collection) &#123;</span><br><span class="line">    accumulator = combine(accumulator, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要一个初始值<code>initialValue</code>和<code>combine</code>函数是拿初始值和集合中每个元素做运算，再将结果赋值给<code>accumulator</code>。</p>
<p><code>reduce</code>操作可以实现从一组值中生成一个值。<code>count</code>、<code>max</code>和<code>min</code>等都是属于reduce操作，只是因为这些比较常用，而被加入到标准库中。</p>
<p><code>reduce</code>有两种形式，一种是需要有一个初始值，另一种变式则不需要初始值，其返回一个<code>Optional</code>对象。</p>
<h2 id="3-类库"><a href="#3-类库" class="headerlink" title="3. 类库"></a>3. 类库</h2><blockquote>
<p>  即使我们不需要编写像<strong>Stream</strong>这样的Lambda表达式，也需要学会如何使用Lambda表达式。<strong>Java 8</strong>中的另一个变化是引入了<strong>默认方法</strong>和接口的<strong>静态方法</strong>。</p>
</blockquote>
<h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h3><p>Java中存在基本类型，而其相伴类型是装箱类型。基本类型内建在语言和运行环境中，是基本的程序构建模块；而装箱类型是普通的Java类，是对基本类型的一种封装。</p>
<p>Java的泛型是基于对泛型类型参数的擦除，其是Object对象的实例，所以只有装箱类型才能作为泛型参数。但是装箱类型是对象，在内存中存在额外开销，例如<code>int</code>在内存中占用4个字节，<code>Integer</code>对象却占用16个字节，甚至整形数组对象中，由于元素是内存中的指针，指向Java堆中的对象，同样大小的数组，<code>Integer[]</code>比<code>int[]</code>多占用6倍内存。</p>
<p>装箱和拆箱都需要额外的开销。对于需要大量数值运算的算法来说，装箱和拆箱的计算开销，以及装箱类型占用的内存开销，会明显减缓程序的运行速度。</p>
<p>为了减少上述内存开销，<strong>Stream</strong>类的某些方法对基本类型和装箱类型做了区分。如下图:</p>
<p><img src="https://images.effiu.cn/blog/java/09.png" alt="png"></p>
<p>目前Java 8中仅仅对整形、长整型和双浮点数做了特殊处理，特殊处理后的系统性能明显提升。上图中的命名规范以及返回类型，可以明白其使用场景。</p>
<ul>
<li>方法的返回为基本类型，则在基本类型前加<strong>To</strong>。例如：<code>ToLongFunction</code>。</li>
<li>如果参数是基本类型，则只需类型名即可。例如<code>LongFunction</code>。</li>
<li>若高阶函数使用其基本类型则在操作后缀To再加基本类型，例如<code>mapToLong()</code>。</li>
</ul>
<p>基本类型都有与之对应的<strong>Stream</strong>。以基本类型名为前缀。例如<code>LongStream</code>。我们应该尽可能多地使用对基本类型做过处理的方法，进而改善性能。这些特殊<strong>Stream</strong>还提供了额外的方法，避免实现一些通用的方法，让代码更能体现出计算的意图。</p>
<p>在基本类型对应的<strong>Stream</strong>中，还有一些非常好用的方法。以<code>LongStream</code>为例:</p>
<ul>
<li><code>min()</code>和<code>max()</code></li>
<li><code>sum()</code></li>
<li><code>count()</code></li>
<li><code>summary</code></li>
<li><code>summaryStatistics()</code>，其返回一个对象，里面包含基本的统计，例如：最小值、最大值、平均值以及数值总和。</li>
<li>·····其他请见api</li>
</ul>
<h3 id="2-重载解析"><a href="#2-重载解析" class="headerlink" title="2. 重载解析"></a>2. 重载解析</h3><p>Java中可以重载方法，造成多个方法有相同的方法名，但是方法签名不一样。这给类型推断带来了问题，系统可能会推断出多种类型，这时<strong>javac</strong>会挑出最具体的类型。当参数为<strong>Lambda</strong>表达式类型时，同样如此。</p>
<p><img src="https://images.effiu.cn/blog/java/10.png" alt="png"></p>
<p><code>overloadedMethod((x, y) -&gt; x + y);</code>会被推断为<code>IntegerBinaryOperator</code>，因<code>IntegerBinaryOperator</code>是<code>BinaryOperator&lt;Integer&gt;</code>的子类。</p>
<p>当存在多个重载方法时，哪个是最具体的类型可能并不准确，编译器会在此时提示编译错误，此时可以将参数强制转化为你所期望的类型。</p>
<p><strong>Lambda</strong>表达式作为参数时，其类型由它的目标类型推导得出，推导过程遵循如下规则:</p>
<ul>
<li>如果只有一个可能的目标类型，由相应函数接口里的参数类型推导得出;</li>
<li>如果有多个可能的目标类型，由最具体的类型推导得出;</li>
<li>如果有多个可能的目标类型且最具体的类型不明确，则需人为指定类型。</li>
</ul>
<h3 id="3-FunctionalInterface"><a href="#3-FunctionalInterface" class="headerlink" title="3. @FunctionalInterface"></a>3. <code>@FunctionalInterface</code></h3><p>每个用作函数接口的接口都应该添加<code> @FunctionalInterface</code>注释。每个用作函数接口的接口都应该添加该注释。Java中有一些只有一个方法的接口，但其并不是为了<strong>Lambda</strong>表达式实现的。例如：有些对象内部可能保存着某种状态，使用带有一个方法的接口可能纯属巧合。<code>java.lang.Comparable </code>和<code>java.io.Closeable</code>就属于这样的情况。</p>
<p>与<code>Closeable</code>等接口不同，为了提高<strong>Lambda</strong>对象的可操作性而引入了各种接口，都需要<strong>Lambda</strong>表达式实现。其意义在于将代码块进行打包。都使用了<code>@FunctionInterface</code>注释。其会强制javac检查一个接口是否符合函数接口的标准。若给该接口添加个枚举类型、类或者接口不仅一个抽象方法，javac就会报错。</p>
<h3 id="4-二进制兼容性"><a href="#4-二进制兼容性" class="headerlink" title="4. 二进制兼容性"></a>4. 二进制兼容性</h3><p><strong>Java 8</strong>对API最大的改进是集合类。虽然Java一直在持续演进，但是一直保持着向后二进制兼容。具体就是Java 1到Java 7编译的类库或者应用，可以在Java 8上运行。</p>
<p>当然也会有错误出现，但是二进制兼容性一直是Java的优势。除非引入新的关键字，如<strong>enum</strong>，达成源代码向后兼容也不是没有可能实现。可以保证，只要是<strong>Java 1</strong>到<strong>Java 7</strong>写出的代码，在<strong>Java 8</strong>中依然可以编译通过。</p>
<p>实际，在<strong>Java 8</strong>中修改了集合类类库后，已经很难实现。Java 8中为<code>Collection</code>接口增加stream方法，这意味着所有实现了<code>Collection</code>接口的类都必须增加这个新方法。对于核心类库来说，增加<code>stream</code>方法，就可以解决。但是对于JDK之外的类(例如继承了ArrayList的类)，也需要实现<code>stream</code>方法，否则无法通过编译。</p>
<p>为了避免上述问题，在<strong>Java 8</strong>中添加了新的语言特性：<strong style='color:red'>默认方法</strong>。</p>
<h3 id="5-默认方法"><a href="#5-默认方法" class="headerlink" title="5. 默认方法"></a>5. 默认方法</h3><p><code>Collection</code>接口中增加了新的<code>stream</code>方法，若其子类中没有实现<code>stream</code>方法，就会默认使用<code>Collection</code>的<code>stream</code>方法。<code>Iterator</code>中也增加了一个默认方法:<code>forEach</code>，与for循环类似，允许用户使用一个Lambda表达式作为循环体。</p>
<p><strong>Java 8</strong>新增了关键子<code>default</code>,这个关键字告诉<strong>javac</strong>用户真正需要的是为接口添加一个新方法。<code>default</code>方法在继承规则和普通方法也有区别，与类不同，接口没有成员变量，因此默认方法只能通过调用子类的方法来修改子类本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A1</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行下面代码</span></span><br><span class="line">B1 b = <span class="keyword">new</span> B1();</span><br><span class="line">b.m();</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">A1</span><br></pre></td></tr></table></figure>

<p>上述代码说明：<strong style="color:red">类中重写的方法优先级高于接口中定义的默认方法</strong>。这是由增加<code>default</code>方法的目的决定的，其主要是为了在接口上向后兼容，这可以简化很多继承问题。假设存在一个<code>MyCustomList</code>，该类中有一个<code>addAll</code>方法，如果新的List接口也增加了一个默认方法<code>addAll</code>，该方法将对列表的操作代理到add方法。如果类中重写的方法没有默认方法的优先级高，那么就会破坏已有的实现。</p>
<h3 id="6-多重继承"><a href="#6-多重继承" class="headerlink" title="6. 多重继承"></a>6. 多重继承</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> <span class="keyword">implements</span>   <span class="title">A</span>,<span class="title">C</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增强的super语法</span></span><br><span class="line">        C.<span class="keyword">super</span>.m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，若<code>C1</code>不重写<code>m</code>方法，会编译报错<code>inherits unrelated defaults for m()</code>,需要我们在类中重写<code>m()</code></p>
<p>对于<code>default</code>默认方法的工作原理，有如下三个规则：</p>
<ul>
<li>类胜于接口，若在继承链中有方法或抽象方法声明，那么就忽略接口中定义的方法。</li>
<li>子类胜于父类，若一个接口继承了另一个接口，且两个接口中都定义了一个默认方法，那么子类中定义的方法胜出</li>
<li>若上述两个规则仍然不能确定，子类就需要实现该方法或者声明为抽象方法。</li>
</ul>
<h3 id="7-接口的静态方法"><a href="#7-接口的静态方法" class="headerlink" title="7. 接口的静态方法"></a>7. 接口的静态方法</h3><p><code>Stream</code>是一个接口，然而<code>Stream.of()</code>却是一个静态方法，这时<strong>Java 8</strong>中新添加的一个语言特性。当一个方法有充分的语义原因和某个概念相关，那么就应该将该方法和相关的类或接口放在一起，而不是放到另一个工具类中。这有助于更好地组织代码，阅读代码的人也更容易找到相关方法，这便是在<code>Stream</code>中加入静态方法的目的。</p>
<ul>
<li><code>of()</code></li>
<li><code>terate()</code></li>
<li><code>concat()</code></li>
</ul>
<h3 id="8-Optional"><a href="#8-Optional" class="headerlink" title="8. Optional"></a>8. <code>Optional</code></h3><p><code>Optional</code>是为核心类库设计的一个数据类型，用来替换<code>null</code>值。使用<code>null</code>代表值不存在的最大问题在于 <code>NullPointerException</code>。而<code>Optional</code>可以完美解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将null值转化为一个对象</span></span><br><span class="line">Optional&lt;Object&gt; o = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 若o内的对象为null，则返回一个默认值</span></span><br><span class="line">Object aNull = o.orElse(<span class="string">&quot;null&quot;</span>);</span><br><span class="line"><span class="comment">// 其他用法</span></span><br><span class="line">List&lt;Long&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Optional.ofNullable(list).filter(p -&gt; p.size() &gt; <span class="number">0</span>).ifPresent(p -&gt; &#123;</span><br><span class="line">    System.out.println(p.size());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-高级集合类和收集器"><a href="#4-高级集合类和收集器" class="headerlink" title="4. 高级集合类和收集器"></a>4. 高级集合类和收集器</h2><h3 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1. 方法引用"></a>1. 方法引用</h3><p>在<strong>Lambda</strong>中，方法调用<code>a -&gt;a.toString()</code>。<strong>Java 8</strong>提供了一个简单的语法：<strong style='color:red'>方法引用</strong>，用来帮助程序员重用已有方法，写法：<code>Classname::methodName</code>，其是一种与Lambda表达式等价的结构。构造函数同样有缩写形式：<code>Classname::new</code>，在选对函数接口的情况下，还支持多个构造参数。数组写法：<code>String[]::new</code>。</p>
<h3 id="2-元素顺序"><a href="#2-元素顺序" class="headerlink" title="2. 元素顺序"></a>2. 元素顺序</h3><p>流中的元素顺序，依赖于集3合和对流的操作。例如，<code>List</code>是有序的，<code>List</code>创建的流是有序的；<code>HashSet</code>创建的流就是无序的，<code>HashSet</code>本身无序。</p>
<p>流的目的不仅仅是在集合类之间做转换，而且同时提供了一组处理数据的通用操作。一些中间操作会产生顺序，比如对值做映射，映射后的值是有序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 顺序得到了保留</span></span><br><span class="line">List&lt;Integer&gt; stillOrdered = numbers.stream() .map(x -&gt; x+<span class="number">1</span>).collect(toList());</span><br><span class="line"><span class="comment">// 进来的流是无序的，所以出去的流也是无序</span></span><br><span class="line">Set&lt;Integer&gt; unordered = <span class="keyword">new</span> HashSet&lt;&gt;(numbers);</span><br><span class="line">List&lt;Integer&gt; stillUnordered = unordered.stream() .map(x -&gt; x+<span class="number">1</span>).collect(toList());</span><br></pre></td></tr></table></figure>

<p>一些流在有序的流上开销很大，调用<code>unordered</code>方法消除这种顺序可以解决问题。大多数操作都是在有序流上面效率更高，如<code>filter</code>、<code>reduce</code>、<code>map</code>等。无序会带来一些意想不到的结果，并行流中<code>forEach</code>方法并不能保证元素执行有序，若要保证元素按序处理，则使用<code>forEachOrdered</code>方法。</p>
<h3 id="3-收集器用法"><a href="#3-收集器用法" class="headerlink" title="3. 收集器用法"></a>3. 收集器用法</h3><blockquote>
<p>  我们使用流时，会经常将其转化为集合，<code>stream.collect(Collectors.toList())</code>，<code>List</code>是从流中生成的最基本的数据结构，其他的例如：<code>Map</code>、<code>Set</code>，甚至定制一个结构。标准类库提供了一些有用的收集器，见<code>java.util.stream.Collectors</code>。</p>
</blockquote>
<h4 id="1-转换成其他集合"><a href="#1-转换成其他集合" class="headerlink" title="1. 转换成其他集合"></a>1. 转换成其他集合</h4><ul>
<li><code>Collectors.toList()</code></li>
<li><code>Collectors.toSet()</code></li>
<li><code>Collectors.toCollect(TreeSet::new)</code></li>
</ul>
<h4 id="2-转换成值"><a href="#2-转换成值" class="headerlink" title="2. 转换成值"></a>2. 转换成值</h4><ul>
<li><p><code>public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator);</code>，集合中最小元素或值</p>
<p>还有<code>double</code>和<code>int</code>类型对应的重载方法。</p>
</li>
<li><p><code>public static &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)</code>，用于求和</p>
</li>
<li><p><code>public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper);</code>，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平均值</span></span><br><span class="line">list.stream().collect(Collectors.averagingLong(p -&gt; p));</span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line">list.stream().collect(Collectors.summingLong(p -&gt; p));</span><br><span class="line"><span class="comment">// 最小值</span></span><br><span class="line">list.stream().collect(Collectors.minBy(Long::compareTo));</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line">list.stream().collect(Collectors.maxBy(Long::compareTo));</span><br><span class="line">System.out.println(<span class="string">&quot;平均值:&quot;</span> + average + <span class="string">&quot;, sum:&quot;</span> + sum + <span class="string">&quot;, 最小值:&quot;</span> + min + <span class="string">&quot;, 最大值:&quot;</span> + max);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果:</span></span><br><span class="line">平均值:<span class="number">45.2</span>, sum:<span class="number">226</span>, 最小值:<span class="number">1</span>, 最大值:<span class="number">112</span></span><br></pre></td></tr></table></figure>

<p>与<code>LongStream.summaryStatistics()</code>相似。</p>
</li>
</ul>
<h4 id="3-数据分块"><a href="#3-数据分块" class="headerlink" title="3. 数据分块"></a>3. 数据分块</h4><p>另外一个常用的流操作是将其分为两个集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// partitioningBy 参数是 Predicate，返回Map(Boolean/List)，key:true:是Predicate为true的集合，false为其余部分。</span></span><br><span class="line">Map&lt;Boolean, List&lt;Long&gt;&gt; map = list.stream().collect(Collectors.partitioningBy(p -&gt; p &gt; <span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h4 id="4-数据分组"><a href="#4-数据分组" class="headerlink" title="4. 数据分组"></a>4. 数据分组</h4><p>数据分组是一种更自然的分割数据操作，与分块操作不同，其是可以以任意值为集合分组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数值按照余数分组</span></span><br><span class="line">Map&lt;Long, List&lt;Long&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(p -&gt; p % <span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h4 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h4><p><strong>Java 8</strong>提供的流和收集器可以用作字符串拼接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = list.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>));</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">[<span class="number">10</span>,<span class="number">1</span>,<span class="number">101</span>,<span class="number">112</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h4 id="6-组合收集器"><a href="#6-组合收集器" class="headerlink" title="6. 组合收集器"></a>6. 组合收集器</h4><p><strong>Java 8</strong>的流和收集器组合起来使用更加强大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合器组合使用</span></span><br><span class="line">Map&lt;Long, Long&gt; collect1 = list.stream().collect(Collectors.groupingBy(p -&gt; p % <span class="number">10</span>, 				Collectors.counting()));</span><br><span class="line">System.out.println(collect1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">&#123;<span class="number">0</span>=<span class="number">1</span>, <span class="number">1</span>=<span class="number">2</span>, <span class="number">2</span>=<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>groupingBy</code>将集合内的元素分组，然后使用下游的另一个收集器收集每块中的元素，即<code>Collectors.counting()</code>收集value中的值的出想要的结果。</p>
<p><code>Collectors.counting()</code>属于下游收集器，其他的例如<code>mapping</code>，另外<code>minBy</code>、<code>summingInt</code>、<code>averagingLong</code>等在<code>IntStream</code>中存在，又在<code>Collectors</code>中加入也是为了作为下游收集器使用。</p>
<h3 id="4-一些细节"><a href="#4-一些细节" class="headerlink" title="4. 一些细节"></a>4. 一些细节</h3><p>Lambda表达式的引入推动了一些新方法加入到集合类。以<code>Map</code>为例:</p>
<ul>
<li><p><code>getOrDefault(K key, V defaultValue)</code>，调用<code>get</code>方法，若为null，则返回默认值。</p>
</li>
<li><p><code>putIfAbsent(K key, V value)</code>，只有当指定key对应值为null时，才会真正执行<code>put</code>方法</p>
</li>
<li><p><code>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</code>，若key对应的值为<code>null</code>，则执行<code>mappingFunction</code>并将结果<code>put</code>到map中</p>
</li>
<li><p><code>forEach</code>方法，用于快速迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            k = entry.getKey();</span><br><span class="line">            v = entry.getValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalStateException ise) &#123;</span><br><span class="line">            <span class="comment">// this usually means the entry is no longer in the map.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException(ise);</span><br><span class="line">        &#125;</span><br><span class="line">        action.accept(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 5. 总结</span><br><span class="line"></span><br><span class="line">1.  方法总结是一种轻量级的语法。</span><br><span class="line">2.  收集器可以用来计算流的最终值，是&#96;reduce&#96;方法的模拟</span><br><span class="line">3.  Java 8提供了收集多种容器的方式，同时允许用户自定义收集器</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F; 部分代码</span><br><span class="line">List&lt;Long&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.add(10L);</span><br><span class="line">list.add(1L);</span><br><span class="line">list.add(101L);</span><br><span class="line">list.add(112L);</span><br><span class="line">list.add(2L);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 平均值</span><br><span class="line">Double average &#x3D; list.stream().collect(Collectors.averagingLong(p -&gt; p));</span><br><span class="line">&#x2F;&#x2F; 和</span><br><span class="line">Long sum &#x3D; list.stream().collect(Collectors.summingLong(p -&gt; p));</span><br><span class="line">&#x2F;&#x2F; 最小值</span><br><span class="line">Long min &#x3D; list.stream().collect(Collectors.minBy(Long::compareTo)).orElse(0L);</span><br><span class="line">&#x2F;&#x2F; 最大值</span><br><span class="line">Long max &#x3D; list.stream().collect(Collectors.maxBy(Long::compareTo)).orElse(0L);</span><br><span class="line">System.out.println(&quot;平均值:&quot; + average + &quot;,sum:&quot; + sum + &quot;, 最小值:&quot; + min + &quot;, 最大值:&quot; + max);</span><br><span class="line">&#x2F;&#x2F; 分块</span><br><span class="line">Map&lt;Boolean, List&lt;Long&gt;&gt; map &#x3D; list.stream().collect(Collectors.partitioningBy(p -&gt; p &gt; 10));</span><br><span class="line">&#x2F;&#x2F; 分组</span><br><span class="line">Map&lt;Long, List&lt;Long&gt;&gt; collect &#x3D; list.stream().collect(Collectors.groupingBy(p -&gt; p % 10));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串拼接</span><br><span class="line">String str &#x3D; list.stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;));</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组合器组合使用</span><br><span class="line">Map&lt;Long, Long&gt; collect1 &#x3D; list.stream().collect(Collectors.groupingBy(p -&gt; p % 10, Collectors.counting()));</span><br><span class="line">System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">StringBuilder builder &#x3D; new StringBuilder(&quot;[&quot;);</span><br><span class="line">list.stream().map(String::valueOf).reduce(builder, (a, b) -&gt; &#123;</span><br><span class="line">    if (a.length() &gt; 1)&#123;</span><br><span class="line">        a.append(&quot;,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return a.append(b);</span><br><span class="line">&#125;, (a, b) -&gt; builder.append(a));</span><br><span class="line">&#x2F;&#x2F; 简化后</span><br><span class="line">String string &#x3D; list.stream().map(String::valueOf).reduce(new StringJoiner(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;), StringJoiner::add, StringJoiner::merge).toString();</span><br><span class="line">System.out.println(&quot;拼接字符串: &quot; + string);</span><br><span class="line">&#x2F;&#x2F; 使用 reduce 实现 sum 方法</span><br><span class="line">Long aSum &#x3D; list.stream().reduce(0L, Long::sum, Long::sum);</span><br><span class="line">Long aCount &#x3D; list.stream().reduce(0L, (a, b) -&gt; a + 1, Long::sum);</span><br><span class="line">System.out.println(&quot;sum:&quot; + aSum + &quot;, count:&quot; + aCount);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="5-数据并行化"><a href="#5-数据并行化" class="headerlink" title="5. 数据并行化"></a>5. 数据并行化</h2><blockquote>
<p>  从之前的外部迭代到<strong>Java 8</strong>的内部迭代，使编写简洁的代码容易了很多，另一个好处则是程序员不需要手动控制迭代过程，甚至只需要轻微的改动，就可以使迭代并行。那么为什么需要并行化以及什么时候并行会带来性能的提升呢？</p>
</blockquote>
<h3 id="1-并行和并发"><a href="#1-并行和并发" class="headerlink" title="1. 并行和并发"></a>1. 并行和并发</h3><p>并行和并发是两个概念，并行是两个任务在同一时间发生，例如运行在多核CPU上；并发则是一个程序要运行多个任务，同一个CPU上分配了不同的时间片运行不同任务。如下图:</p>
<p><img src="https://images.effiu.cn/blog/java/11.png" alt="png"></p>
<p>并行是为了缩短任务执行时间，将一个任务分解成几部分，然后并行执行。与串行任务量一样，只不过是以更多CPU执行该任务，以空间换时间，实际上并行执行时，CPU承载的工作量更大。</p>
<p><strong style='color:red'>数据并行化</strong>是指将数据分成块，为每块数据单元分配单独的处理单元。当需要在大量数据上执行同样的操作时，数据并行化很管用。其将问题分解为可以在多块数据上求解的形式，然后对每块数据执行运算，最后将各数据块上得到的结果汇总，从而得到最终答案。</p>
<p>任务并行化与数据并行化的区别：任务并行化中，线程不同，工作不同。</p>
<h3 id="2-并行化流操作"><a href="#2-并行化流操作" class="headerlink" title="2. 并行化流操作"></a>2. 并行化流操作</h3><p><strong>Java 8</strong>中并行化流只需要改变一个方法调用。<code>stream.parallel()</code>或者直接调用<code>parallelStream()</code>获取并行流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().parallel().forEach(p -&gt; System.out.println(p));</span><br><span class="line">list.parallelStream().forEach(p -&gt; System.out.println(p));</span><br></pre></td></tr></table></figure>

<p>然而实际运算中，并不是并行一定比串行快，而是当需要计算的任务达到一定数量规模后，并行效率才会优于串行。而这个规模是最则依赖任务复杂度。输入流的大小并不是决定并行化是否会带来速度提升的唯一因素，速度性能还会受到编写代码的方式和核的数量的影响。</p>
<h3 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h3><p>影响并行流性能的主要因素有5个：</p>
<ul>
<li>数据大小：输入的数据量大小影响并行对性能的提升，将问题分解之后进行并行处理，再将结果合并会带来额外的开销。因此只有数据足够大、每个数据管道花费的时间足够多时，并行化才有意义。</li>
<li>源数据结构：每个管道的操作都基于一些初始数据源，通常是集合。将不同的数据源分割相对容易，这里的开销影响了在管道中并行处理数据时到底能带来多少性能上的提升。</li>
<li>装箱：处理基本类型比处理装箱类型快</li>
<li>核的数量：若是单核CPU，则不需要并行化。拥有的核数越多，获得的潜在性能提升的幅度就越大。实践中，核的数量不单指机器上的核数，更是指运行时机器能使用多少核，以及若使用多核是否会影响其他进程或者线程。</li>
<li>单元处理开销：执行并行花费时间与分解合并操作开销之间的战争。花在流中每个元素身上的时间越长，并行操作带来的性能提升越明显。</li>
</ul>
<p>并行流的底层是<strong>fork/join</strong>。<strong>fork</strong>递归式分解问题，然后每段并行执行，最终由<strong>join</strong>合并结果，得到最终结果。由于任务需要分解，那么初始数据源的特性变得很重要，其影响了分解的性能。直观上看，能重复将数据结构对半分解的难易程度，决定了分解操作的快慢。</p>
<p>根据分解任务的性能，将核心类库提供的通用数据结构分成以下3种情况：</p>
<ul>
<li>性能好，例如:<code>ArrayList</code>、数组或<code>IntStream.range</code>，这些数据结构支持随机读取，其可以轻而易举地被任意分解</li>
<li>性能一般，HashSet、TreeSet，不易被公平分解，但是是可分解的</li>
<li>性能差，难于分解，甚至需要遍历，复杂度为$O(n)$。例如：<code>LinkedList</code>、<code>Streams.itreate</code>和<code>BufferedReader.lines</code>。</li>
</ul>
<p>理想情况下，流框架将问题分为不同小块，就可以单独处理每一小块，线程之间不需要进一步通信。其实际上有的需要维护状态，所以可能会有额外的开销和限制。</p>
<p>无状态的性能更好，例如<code>map</code>、<code>flatMap</code>、<code>filter</code>等。有状态的<code>sorted</code>、<code>distince</code>、<code>limit</code>等</p>
<h3 id="4-并行化数组操作"><a href="#4-并行化数组操作" class="headerlink" title="4. 并行化数组操作"></a>4. 并行化数组操作</h3><p><strong>Java 8</strong>还引入了一些针对数组的并行操作，脱离流框架也可以使用<strong>Lambda</strong>表达式。与流框架的操作一样，是针对数组的并行化操作。</p>
<p><code>java.util.Arrays</code>类中：</p>
<ul>
<li><code>public static &lt;T&gt; void parallelPrefix(T[] array, BinaryOperator&lt;T&gt; op)</code>，任意给定一个函数，对数组组做计算</li>
<li><code>parallelSetAll</code>，使用<code>Lambda</code>表达式更新数组元素</li>
<li><code>parallelSort</code>，并行化对数组元素排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 掷骰子游戏的概率计算</span></span><br><span class="line">    Map&lt;Integer, Double&gt; collect =</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">100000</span>).parallel().mapToObj(r -&gt; random()).collect(Collectors.groupingBy(s -&gt; s,</span><br><span class="line">                                                                                                    Collectors.summingDouble(n -&gt; <span class="number">1.0</span> / <span class="number">100000</span>)));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] is = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">123</span>, <span class="number">432</span>, <span class="number">113</span>&#125;;</span><br><span class="line">    Arrays.parallelPrefix(is, (a, b) -&gt; a + b);</span><br><span class="line">    System.out.println(<span class="string">&quot;parallelPrefix:&quot;</span> + Arrays.toString(is));</span><br><span class="line">    <span class="comment">// a为数组下标</span></span><br><span class="line">    Arrays.parallelSetAll(is, (a) -&gt; is[a] + <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;setAll:&quot;</span> + Arrays.toString(is));</span><br><span class="line">    Integer[] is1 = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">123</span>, <span class="number">432</span>, <span class="number">113</span>&#125;;</span><br><span class="line">    <span class="comment">// 只能是包装类</span></span><br><span class="line">    Arrays.parallelSort(is1, Comparator.comparingInt(Integer::intValue));</span><br><span class="line">    System.out.println(Arrays.toString(is1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><p>我们有时候在流中需要打印下运行信息，但是有一些过程是惰性求值的，所以很难准确打印每一步的信息。可以使用<code>peek</code>方法，既可以查看每个值，同时可以继续操作流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// peek还可以将输出重定向到log日志中</span></span><br><span class="line"><span class="keyword">int</span> sum = Arrays.stream(is).peek(p -&gt; System.out.println(p)).sum();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O的工作机制(1)</title>
    <url>/blog/2020/03/01/web/2-1-IO%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>I/O问题是当今web应用中面临的主要问题之一。每时每刻都有海量的数据在网络中传输，其整个过程都涉及I/O问题，大部分Web应用系统的瓶颈都是I/O瓶颈。接下来就分析Java I/O类库的基本架构、磁盘I/O的工作机制、网络I/O的工作机制，以网络I/O为重点介绍Java Socket的工作方式。NIO的工作方式，并了解同步和异步、阻塞与非阻塞的区别。</p>
<a id="more"></a>

<h2 id="1-Java的I-O类库的基本架构"><a href="#1-Java的I-O类库的基本架构" class="headerlink" title="1. Java的I/O类库的基本架构"></a>1. Java的I/O类库的基本架构</h2><p>I/O是机器获取和交换信息的主要渠道，现在处于信息大爆炸的时代，IO问题尤为突出。Java IO也一直做持续的优化。</p>
<p>Java的IO操作在包<code>java.io</code>下，大概有将近80个类，主要分成如下三组:</p>
<ul>
<li>基于字节操作的I/O接口：<code>InputStream</code>和<code>OutputStream</code></li>
<li>基于字符操作的I/O接口: <code>Writer</code>和<code>Reader</code></li>
<li>基于磁盘操作的I/O接口: <code>File</code></li>
<li>基于网络操作的I/O接口：<code>Socket</code></li>
</ul>
<p>前两组主要是传输数据的数据格式，后两组是传输数据的方式。<code>Socket</code>类不在<code>java.io</code>下，但仍把其作为IO的一部分，当IO作为网络传输瓶颈的时候，要么是数据格式，要么是传输方式影响IO操作。</p>
<h3 id="1-基于字节的I-O操作"><a href="#1-基于字节的I-O操作" class="headerlink" title="1. 基于字节的I/O操作"></a>1. 基于字节的I/O操作</h3><p>基于字节的I/O操作接口输入和输出分别是<code>InputStream</code>和<code>OutputStream</code>,其类层次结果分别如下：</p>
<p><img src="https://images.effiu.cn/blog/web/InputStream.png" alt="png"></p>
<p><img src="https://images.effiu.cn/blog/web/outputStream.png" alt="png"></p>
<p>具体的使用方法请参考jdk的说明文档</p>
<ul>
<li>操作数据的方式是可以组合使用的。例如<code>new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream(&quot;filePath + fileName&quot;)));</code></li>
<li>必须要指定写到什么地方，要么是磁盘(文件)，要么是写到网络中。</li>
</ul>
<h3 id="2-基于字符的I-O操作"><a href="#2-基于字符的I-O操作" class="headerlink" title="2. 基于字符的I/O操作"></a>2. 基于字符的I/O操作</h3><p>不管是磁盘还是网络传输，最小的存储单元都是字节。但是我们在程序中经常操作的数据都是字符形式的，为了操作方便而提供一个直接写字符的I/O接口。字节到字符要经过编码转换。</p>
<p>基于字符的I/O操作的<code>writer</code>操作涉及的类都提供了一个抽象方法<code>write(char buff[], int off, int len)</code>,UML图如下:</p>
<p><img src="https://images.effiu.cn/blog/web/Writer.png" alt="png"></p>
<p>read操作接口是<code>read(char buff[], int off, int len)</code>,UML类图如下:</p>
<p><img src="https://images.effiu.cn/blog/web/Reader.png" alt="png"></p>
<blockquote>
<p>  上图中的<code>InputStreamReader</code>是字节与字符的转化类。</p>
</blockquote>
<p><font color='red'>无论是<code>Writer</code>类还是<code>Reader</code>类,都是只定义了读取和写入的数据字符的方式，并没有定义写入到那里</font>。后续会讨论基于磁盘和网络的工作机制。</p>
<h3 id="3-字节与字符的转化接口"><a href="#3-字节与字符的转化接口" class="headerlink" title="3. 字节与字符的转化接口"></a>3. 字节与字符的转化接口</h3><p>数据持久化或网络传输都是以字节进行的，所以必须要有从字符到字节或从字节到字符的转化。字符到字节需要转化，读的转化过程如下:</p>
<p><img src="https://images.effiu.cn/blog/web/05.png" alt="png"></p>
<p><code>InputStreamReader</code>类是从字节到字符的转化桥梁,从<code>InputStream</code>到<code>Reader</code>的过程要指定编码字符集,否则将采用系统默认的字符集,可能会出现乱码问题。<code>StreamDecoder</code>是完成从字节到字符的解码的实现类。如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileReader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;filePath + fileName&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (reader.read(cs) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    	buffer.append(cs, <span class="number">0</span>, cs.length);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">  	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileReader</code>类就是按照上图流程读取文件的，<code>FileReader</code>继承了<code>InputStreamReader</code>类，实际上是读取文件流，然后通过<code>StreamDecoder</code>解码成<code>char</code>。</p>
<p>写入也是类似的过程,通过<code>OutputStreamWriter</code>类完成了从字符到字节的编码过程,由<code>StreamEncoder</code>完成编码过程，如下图:</p>
<p><img src="https://images.effiu.cn/blog/web/06.png" alt="png"></p>
<h2 id="2-磁盘I-O工作机制"><a href="#2-磁盘I-O工作机制" class="headerlink" title="2. 磁盘I/O工作机制"></a>2. 磁盘I/O工作机制</h2><h3 id="1-访问文件的几种方式"><a href="#1-访问文件的几种方式" class="headerlink" title="1. 访问文件的几种方式"></a>1. 访问文件的几种方式</h3><p>读取和写入文件I/O操作都调用系统提供的接口，因为磁盘设备是由操作系统管理的，应用程序要访问物理设备智能通过系统调用的方式来完成。读取和写入对应<code>read()</code>和<code>write()</code>两个系统调用,而只要是系统调用就可能存在内核空间地址和用户空间地址切换的问题，这是操作系统为了保护系统本身的运行安全，将内核程序运行使用的内存空间和用户程序运行的内存空间进行隔离导致的。这是为了保证内核程序运行的安全性，所以存在从内核空间到用户空间复制问题。</p>
<p>当发生磁盘I/O时，数据从磁盘复制到内核空间，再从内核空间复制到用户空间，这非常缓慢。操作系统为了加速I/O访问，在内核空间使用缓存机制，就是将从磁盘读取的文件按照一定的组织方式进行缓存，若用户程序访问的是同一段磁盘地址的空间数据，那么操作系统将从内核缓存中直接取出返回给用户程序，这样减少I/O的响应时间。</p>
<h4 id="1-标准访问文件"><a href="#1-标准访问文件" class="headerlink" title="1. 标准访问文件"></a>1. 标准访问文件</h4><p>标准访问文件的方式：当应用程序调用系统<code>read()</code>接口时，操作系统检查在内核的高速缓存中有没有需要的数据，若已经缓存了，那么就直接从缓存中返回，若没有则从磁盘中读取，然后缓存到操作系统的缓存中。</p>
<p>写入方式：用户的应用程序调用<code>write</code>接口将数据从用户地址空间复制到内核地址空间缓存中，这时对于用户程序来说写操作已经完成，具体何时写入到磁盘中由操作系统决定，除非显式调用<code>sync</code>命令。</p>
<p><img src="https://images.effiu.cn/blog/web/07.png" alt="png"></p>
<h4 id="2-直接I-O的方式"><a href="#2-直接I-O的方式" class="headerlink" title="2. 直接I/O的方式"></a>2. 直接I/O的方式</h4><p>直接I/O的方式是应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，减少一次从内核到用户程序缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。例如数据库管理系统，系统明确知道应该缓存那些数据，应该失效哪些数据，甚至可以做一些热点数据预加载，而操作系统并不能完成这些工作(预加载等)。</p>
<p>直接I/O也有负面影响，若访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘中进行加载，这种直接加载会非常缓慢。通常直接I/O与异步I/O结合使用会有更好的性能。</p>
<p>直接I/O的工作方式(<font color='red'>访问磁盘没有经过内核地址空间</font>):</p>
<p><img src="https://images.effiu.cn/blog/web/08.png" alt="png"></p>
<h4 id="3-同步访问文件"><a href="#3-同步访问文件" class="headerlink" title="3. 同步访问文件"></a>3. 同步访问文件</h4><p>同步访问文件是读取和写入都是同步操作，与直接访问文件的方式不同，只有当数据被成功写入到磁盘时才返回给应用程序成功的标志。这种方式性能很差，只有在对一些数据安全性要求高的场景中才会使用。</p>
<h4 id="4-异步访问文件"><a href="#4-异步访问文件" class="headerlink" title="4. 异步访问文件"></a>4. 异步访问文件</h4><p>异步访问文件是指当访问数据的线程发出请求后，线程会接着处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。可以明显提高应用程序的效率，但是不会改变访问文件的效率。</p>
<p>同步和异步访问文件方式如下图：</p>
<p><img src="https://images.effiu.cn/blog/web/09.png" alt="png"></p>
<h4 id="5-内存映射的方式"><a href="#5-内存映射的方式" class="headerlink" title="5. 内存映射的方式"></a>5. 内存映射的方式</h4><p>内存映射是指操作系统将内存中的某一块区域与磁盘中的文件关联起来，当要访问内存中的一段数据时，转换为访问文件的某一段数据，这种方式的目的同样是为了减少数据从内核空间缓存到用户空间缓存的数据复制操作，因为这两个空间的数据是共享的。</p>
<p><img src="https://images.effiu.cn/blog/web/10.png" alt="png"></p>
<h3 id="2-Java访问磁盘文件"><a href="#2-Java访问磁盘文件" class="headerlink" title="2. Java访问磁盘文件"></a>2. Java访问磁盘文件</h3><p>数据在磁盘中唯一最小描述就是文件，上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的最小单元。但是Java中通常的<code>File</code>并不代表一个真实存在的文件对象，当你指定一个路径描述符时，它就会返回一个代表这个路径的对象，可能是一个真实存在的文件或者一个包含多个文件的目录(<code>new File()</code>并不会抛出异常,在<code>new FileInputStream(new File())</code>时会抛出<code>FileNotFoundException</code>)。类似于手机通讯录中的电话号码，在拨打电话时并不关心手机号码的真实性。</p>
<p>只有当真正要读取文件时，才会关注文件是否存在。<code>FileInputStream</code>类是操作一个文件的接口，在创建一个<code>FileInputStream</code>对象时会创建一个<code>FileDescriptor</code>对象，这个对象是真正代表一个存在的文件对象的描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//········ 省略代码</span></span><br><span class="line">    fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    fd.attach(<span class="keyword">this</span>);</span><br><span class="line">    path = name;</span><br><span class="line">    open(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在操作一个文件对象时可以通过<code>FileInputStream.getDF()</code>方法获取真正与操作系统底层系统相关联的文件描述。例如<code>FileDescriptor.sync()</code>可以将操作系统缓存中的数据强制刷新到物理磁盘中。</p>
<p>下面以前面读取文件的程序为例介绍如何从磁盘读取一段文本字符：</p>
<p><img src="https://images.effiu.cn/blog/web/11.png" alt="png"></p>
<p>当传入一个文件路径时，将会根据这个路径创建一个<code>File</code>对象来标识这个文件，然后根据这个<code>File</code>对象创建真正读取文件的操作对象(关联真实存在的磁盘文件描述符<code>FileDescriptor</code>)，通过这个对象可以直接控制这个磁盘文件。由于我们需要读取的是字符格式，所以需要<code>StreamDecoder</code>(由<code>FileReader</code>类创建)类将<code>byte</code>解码为<code>char</code>格式。从磁盘读取数据文件，操作系统会帮我们完成。</p>
<h3 id="3-Java序列化技术"><a href="#3-Java序列化技术" class="headerlink" title="3. Java序列化技术"></a>3. Java序列化技术</h3><p>Java序列化就是讲一个对象转化成一串二进制表示的字节数组，通过保存或转移这些字节数据来达到持久化的目的，对象必须继承<code>Serializable</code>接口，反序列化是相反的过程，将这个字节数组在重新构造成对象。</p>
<p>当反序列化时必须有原始类作为模板，才能将对象还原，所以序列化的数据并不像<code>class</code>文件那样保存类的完整结构信息。</p>
<p>序列化举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileOutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/zhangshuai/Desktop/test.class&quot;</span>);</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">    EssayApplication essayApplication = <span class="keyword">new</span> EssayApplication();</span><br><span class="line">    oos.writeObject(essayApplication);</span><br><span class="line">    oos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上面代码，将下面对象输出到test.class文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.effiu.essay;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EssayApplication</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">430403713023387894L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String abc = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EssayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>序列化后：</p>
<p><img src="https://images.effiu.cn/blog/web/12.png" alt="png"></p>
<ol>
<li><p>序列化文件头，类似于<code>class</code>文件头</p>
<p><code>aced</code>: 是STREAM_MAGIC生命是用来序列化协议，</p>
<p><code>0005</code>: 是STREAM_VERSION序列化版本</p>
<p><code>73</code>: TC_Object声明是一个新对象</p>
</li>
<li><p>序列化的类的描述</p>
<p><code>72</code>: TC_CLASSDESC生命是开始一个新class</p>
<p><code>0020</code>: class名字长度是32个字节</p>
<p><code>636F6D2E 65666669 752E6573 7361792E 45737361 79417070 6C696361 74696F6E</code>：即<code>com.effiu.essay.EssayApplication</code>表示全限定类名</p>
<p><code>05F919E5 88C4A8F6</code>:是<code>serialVersionUID</code>，其十进制为<code>430403713023387894</code></p>
<p><code>02</code>: 标记号，表示该对象支持序列化</p>
<p><code>0001</code>: 表示该类所包含的域的个数</p>
</li>
</ol>
<ul>
<li><p>对象中各个属性的描述</p>
<p><code>4C</code>: 即L表示对象类型</p>
<p><code>0003</code>: 域名字长度为3</p>
<p><code>616263</code>: 即<code>abc</code>,成员变量的名称</p>
<p><code>74</code>: 表示对象的开始</p>
<p><code>0012</code>: 即十进制的18,表示后面18位用来描述<code>abc</code>对象的类型,即<code>4C6A6176 612F6C61 6E672F53 7472696E 673B</code>表示<code>Ljava/lang/String;</code></p>
</li>
<li><p>输出该对象的父类信息描述，若存在则与序列化类的描述结构一致</p>
</li>
<li><p>序列化类描述结束标志</p>
<p><code>78</code>: TC_ENDBLOCKDATA,对象块结束的标志</p>
<p><code>70</code>: TC_NULL, 说明没有超类</p>
</li>
<li><p>输出对象的属性项的实际值，若是对象那么还将继续序列化该对象</p>
<p><code>74</code>: 对象描述开始</p>
<p><code>0001</code>: 长度为1</p>
<p><code>31</code>: 即十进制中的49，对应ASCII中的1</p>
</li>
</ul>
<p>经过分析还发现序列化中丢失了类的注解,可见Java序列化只携带了类的属性信息。</p>
<p>Java序列化能够保证对象的持久保存，但是其有局限性。</p>
<ul>
<li>当父类继承<code>Serializable</code>接口时，所有子类都可以被序列化</li>
<li>子类实现<code>Serializable</code>接口，父类没有，那么父类中的属性不能被序列化(不报错数据会丢失)，子类中的属性仍能正确序列化。</li>
<li>序列化对象仍是对象，那么该对象也需要实现<code>Serializable</code>接口，否则会报错</li>
<li>在反序列化时，若对象的属性有修改或者删除，则修改的部分属性会丢失，但不会报错</li>
<li>反序列化时，若<code>serialVersionUID</code>被修改,则反序列化会失败</li>
</ul>
<p>在纯Java环境，Java序列化能够很好地工作，但是多语言环境中，Java序列化存储后，很难用其他语言还原。所以建议用其他通用的数据结构,例如JSON和XML。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web 请求过程</title>
    <url>/blog/2019/12/22/web/1-Web%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>Web2.0使得互联网的网络架构从C/S架构转为更加方便、快捷的B/S架构,B/S架构大大简化了用户网络应用的难度。B/S架构带来了两方面的好处：</p>
<ul>
<li>客户端使用统一的浏览器(Browser)。由于浏览器具有统一性，不需要特殊的配置和网络连接，有效地屏蔽了不同服务器提供商提供给用户使用服务的差异性。浏览器的交互特性使得用户使用它非常方便，且用户行为的可继承性非常强，即只要用户学会了上网，那么所有基于浏览器的操作界面都大同小异，所以相当于具有了使用经验。</li>
<li>服务端(Server)基于统一的HTTP。与传统的C/S架构使用自定义的应用层协议不同，B/S架构使用的是统一的HTTP。使用统一的HTTP为服务提供商简化了开发模式，节省了开发成本。基于HTTP的服务器也有很多，Apache、IIS、Nginx、Tomcat、JBoss等，也使得服务开发者只需要关注服务提供商的应用逻辑。</li>
</ul>
<p>B/S网络架构不仅降低了普通用户的使用难度，还为互联网参与者、服务使用者和服务开发者降低了学习成本。但是作为互联网的开发者，我们要清楚从B/S架构的流程(用户在浏览器单击链接到服务器返回结果)，在这个过程中发生了什么？</p>
<a id="more"></a>

<h3 id="1-B-S网络架构概述"><a href="#1-B-S网络架构概述" class="headerlink" title="1. B/S网络架构概述"></a>1. B/S网络架构概述</h3><p>B/S网络架构从前端到后端都得到了简化，基于统一的HTTP协议来交互数据，与传统C/S互联网应用程序采用长连接的交互方式不同，HTTP采用无状态的短链接的通信方式，一次就完成了数据交互，其通常也对应一个业务逻辑，然后连接就会断开(request/response)。HTTP协议既可以满足海量用户的访问请求，还保持了快速响应。</p>
<p>当用户在浏览器输入URL时：</p>
<ul>
<li>请求DNS把这个域名解析成对应的IP地址，</li>
<li>根据这个IP地址在互联网上找到对应的服务器并发送请求(request)，</li>
<li>服务器返回默认的数据给访问的用户。</li>
</ul>
<p>上述每一步都可以拓展得非常复杂。例如：服务器可能有多台，需要负载均衡等等。无论网络请求过程多么复杂，始终有一些不变的原则需要遵守：</p>
<ul>
<li>互联网所有资源都用一个URL(Uniform Resource Locator, 统一资源定位符)表示。URL是互联网架构的精髓。</li>
<li>基于HTTP与服务端交互。无论访问任何资源，文本数据、流媒体等等，都必须按照HTTP协议来完成。</li>
<li>数据展示在浏览器中完成。</li>
</ul>
<h3 id="2-如何发起一个HTTP请求"><a href="#2-如何发起一个HTTP请求" class="headerlink" title="2. 如何发起一个HTTP请求"></a>2. 如何发起一个HTTP请求</h3><p>发起一个HTTP请求只需要我们在浏览器中输入一个合法URL就可以。那么不借助浏览器的方式是什么？即需要我们自己组装一个符合HTTP请求的数据包，二是有哪些可以发起HTTP请求的方式？</p>
<p>发起HTTP请求与发起Socket连接区别不大，只需要<code>outputStream.write</code>写入的二进制字节符合HTTP要求。在浏览器中输入URL后，是需要浏览器根据地址栏中输入的域名DNS解析成IP地址后，再根据这个IP地址和默认的80端口与IP所属服务器建立Socket连接，然后浏览器根据URL的其他信息组装成一个符合HTTP的请求头，通过<code>outputStream.write</code>发送到目标服务器，等待服务器通<code>inputStream.read</code>返回数据，然后断开连接。</p>
<p>发起HTTP请求的本质就是建立Socket连接，所以可以使用Java原声的<code>Socket</code>完成，还可以使用开源的HTTP工具包完成。还可以使用linux中的<code>curl</code>命令。</p>
<ul>
<li><input disabled="" type="checkbox"> 使用Socket发送HTTP请求</li>
</ul>
<h3 id="3-HTTP解析"><a href="#3-HTTP解析" class="headerlink" title="3. HTTP解析"></a>3. HTTP解析</h3><p>理解HTTP，最重要的是熟悉HTTP中的HTTP header, HTTP header控制着用户浏览器的渲染行为和服务器的执行逻辑。常见的HTTP请求头、响应头以及状态吗如下：</p>
<p>HTTP请求头：</p>
<table>
<thead>
<tr>
<th align="center">请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Accept-Charset</code></td>
<td>用于指定用户接受的字符集</td>
</tr>
<tr>
<td align="center"><code>Accept-Encoding</code></td>
<td>用于指定用户接受的内容编码，例如<code>Accept-Encoding:gzip.deflate</code></td>
</tr>
<tr>
<td align="center"><code>Accept-Language</code></td>
<td>用于指定一种自然语言，如<code>Accept-Language:zh-cn</code></td>
</tr>
<tr>
<td align="center"><code>Host</code></td>
<td>用于指定被请求资源的Internet主机和端口号，如Host:<a href="http://www.effiu.cn/">www.effiu.cn</a></td>
</tr>
<tr>
<td align="center"><code>User-Agent</code></td>
<td>客户端将它的操作系统、浏览器和其他属性告诉服务器</td>
</tr>
<tr>
<td align="center"><code>Connection</code></td>
<td>当前连接是否保持，如<code>Connection:Keep-Alive</code></td>
</tr>
</tbody></table>
<p>HTTP响应头：</p>
<table>
<thead>
<tr>
<th>响应头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Server</code></td>
<td>使用的服务器名称，如<code>Server:Apache/1.3.6(Unix)</code></td>
</tr>
<tr>
<td><code>Content-Type</code></td>
<td>指定发送给接收者的实体正文的媒体类型,如<code>Content-type:text/html;charset=GBK</code></td>
</tr>
<tr>
<td><code>Content-Encoding</code></td>
<td>与请求报头<code>Accept-Encoding</code>对应，告诉浏览器服务端采用的是什么压缩编码</td>
</tr>
<tr>
<td><code>Content-Language</code></td>
<td>描述了资源所用的自然语言，与<code>Accpet-Encoding</code>对应</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>指明实体正文的长度，用以字节方式存储的十进制数字表示</td>
</tr>
<tr>
<td><code>Keep-Alive</code></td>
<td>保持连接的时间，如<code>Keep-Alive:timeout=5,max=120</code></td>
</tr>
</tbody></table>
<p>HTTP状态码:</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td>客户端请求成功</td>
</tr>
<tr>
<td align="center">302</td>
<td>临时跳转，跳转的地址通过<code>Location</code>指定</td>
</tr>
<tr>
<td align="center">400</td>
<td>客户端语法错误，不能被服务器识别</td>
</tr>
<tr>
<td align="center">403</td>
<td>服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td align="center">404</td>
<td>请求的资源不存在</td>
</tr>
<tr>
<td align="center">500</td>
<td>服务器发生不可预期的错误</td>
</tr>
</tbody></table>
<p>可以通过浏览器的debug模式查看请求头<code>F12</code>。</p>
<p>浏览器缓存是一个非常重要的机制。一般浏览页面发现有异常：一是因为浏览器做了缓存，<code>Ctrl + F5</code>或者<code>Shift + Command + R</code>可以使浏览器直接向目标URL请求，不使用浏览器缓存；二是请求正常到了服务端，但是访问到的是服务端缓存的数据。</p>
<p>在我们使用<code>Ctrl + F5</code>或者<code>Shift + Command + R</code>刷新页面时，HTTP的请求头重会增加一些请求头，告诉浏览器要获取最新数据而不是缓存。HTTP Header中会多出如下请求头：</p>
<p><img src="https://images.effiu.cn/blog/web/01.png" alt="请求头"></p>
<h5 id="1-Cache-Control-Pragma"><a href="#1-Cache-Control-Pragma" class="headerlink" title="1. Cache-Control/Pragma"></a>1. Cache-Control/Pragma</h5><p>这个HTTP Header字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令，通过该参数可以控制浏览器，还可以控制和HTTP相关的缓存或者代理服务器。其可选值如下：</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Public</code></td>
<td>所有内容将被缓存，在响应头中设置</td>
</tr>
<tr>
<td><code>Private</code></td>
<td>内容只缓存到私有缓存中，在响应头中设置</td>
</tr>
<tr>
<td><code>no-cache</code></td>
<td>所有内容都不会被缓存，在请求头和响应头中设置</td>
</tr>
<tr>
<td><code>no-store</code></td>
<td>所有内容都不会被缓存到缓存或者Internet临时文件中，在响应头中设置</td>
</tr>
<tr>
<td><code>must-revalidation/proxy-revalidation</code></td>
<td>若缓存内容失效，请求必须发送到服务器/代理以进行重新验证，在请求头中设置</td>
</tr>
<tr>
<td><code>max-age=xxx</code></td>
<td>缓存的内容将在xxx秒后失效，只在HTTP1.1中可用和Last-Modified一起使用时优先级较高，在响应头中设置</td>
</tr>
</tbody></table>
<p><code>Cache-Control</code>请求头中字段被各个浏览器支持的较好，而且它的优先级也比较高，和其他请求字段(<code>Expires</code>)同时出现时，<code>Cache-Control</code>会覆盖其他字段。</p>
<p><code>Pragma</code>字段与<code>Cache-Control</code>作用类似，也是在HTTP头中包含一个特殊的指令，使相关的服务器遵守该指令，最常用的是<code>Pragma:no-cache</code>和<code>Cache-Control:no-cache</code>作用一致。</p>
<h5 id="2-Expires"><a href="#2-Expires" class="headerlink" title="2. Expires"></a>2. Expires</h5><p>Expires通常的使用格式是<code>Expires: Sat, 19 Dec 2019 23:22:17 GMT</code>,后面跟着一个日期和时间，超过这个时间后，缓存的内容将失效，浏览器在发出请求前会检查该字段，若过期就会重新向服务器发出请求。</p>
<h5 id="3-Last-Modified-Etag"><a href="#3-Last-Modified-Etag" class="headerlink" title="3. Last-Modified/Etag"></a>3. Last-Modified/Etag</h5><p><code>Last-Modified</code>字段一般用于表示一个服务器上的资源的最后修改时间，可以是静态资源(静态内容自动加上``Last-Modified<code>字段)或者动态内容(如</code>Servlet<code>提供了一个</code>getLastModified`方法用于检查某个动态内容是否已经更新)，通过这个最后修改时间可以判断当前请求的资源是否是最新的。</p>
<p>一般服务端会在响应头中返回一个<code>Last-Modified</code>，告诉浏览器这个页面的最后修改时间，浏览器会在请求服务端时在请求头中增加一个<code>If-Modified-Since: Sat, 20 Dec 2019 23:22:17 GMT</code>，询问当前服务器缓存的页面是否时最新的，如果是最新的就返回304状态，告诉浏览器其缓存的内容是最新的，服务器也不会传输新的数据。</p>
<p><code>Etag</code>与<code>Last-Modified</code>有类似的功能，作用是让服务器给每个页面分配一个唯一的编号，然后通过这个编号区分当前这个页面是否时最新的。其比<code>Last-Modified</code>更加灵活，但是后端Web服务器有多台时比较难处理，因为每个Web服务器要记住网站的所有资源，否则浏览器传输编号就没有意义了。</p>
<h3 id="4-DNS域名解析"><a href="#4-DNS域名解析" class="headerlink" title="4. DNS域名解析"></a>4. DNS域名解析</h3><p>互联网是通过URL来发布和请求资源的，而URL中的域名需要解析成IP地址才可以与远程主机建立连接，将域名解析成IP地址就是DNS解析的工作范畴。</p>
<h5 id="1-DNS域名解析的过程"><a href="#1-DNS域名解析的过程" class="headerlink" title="1. DNS域名解析的过程"></a>1. DNS域名解析的过程</h5><p>当我们输入<code>www.effiu.cn</code>时，DNS解析将近有10个步骤：</p>
<ul>
<li><p>浏览器会坚持缓存中有没有这个域名对应的ip地址，若有则直接DNS解析过程结束。</p>
<p>浏览器缓存的域名一般有时间限制，没有缓存大小限制，域名缓存的时间可以通过TTL属性来设置，通常是几分钟到几小时不等，时间太长若域名解析到的IP有变化，可能会导致该域名不能被正常解析。</p>
</li>
<li><p>若用户浏览器中没有缓存，浏览器会查找系统缓存中是否有这个域名对应的DNS解析,即hosts文件。</p>
</li>
<li><p>当上述两个步骤都没有拿到域名对应的IP时，浏览器会根据网络配置中的“DNS服务器地址”获取域名对应的IP地址。本地区的域名服务器(LDNS, Local Domain Name System)，这个DNS服务器一般会缓存域名解析结果，其缓存时间是受域名解析失效时间控制的，一般缓存空间不是缓存失效的主要因素，80%以上的域名解析过程到这里就结束了</p>
</li>
<li><p>若LDNS仍然没有命中，就直接到<code>Root Server</code>域名服务器请求解析。</p>
</li>
<li><p>根域名服务器返回给本地域名服务器一个所查询域的主域名服务器(Generic top-level Domain Server, gTLD Server，国际顶级域名服务器)地址，例如：<code>com</code>、<code>cn</code>等。</p>
</li>
<li><p>本地域名服务器(Local DNS Server)再向上一步返回的gTLD服务器发送请求。</p>
</li>
<li><p>接受请求的gTLD服务器查找并返回此域名对应的<code>Name Server</code>域名服务器的地址，这个<code>Name Server</code>通常就是我们注册域名的服务器。</p>
</li>
<li><p><code>Name Server</code>域名服务器会查询存储的域名IP的映射关系表，正常情况下根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器</p>
</li>
<li><p>返回该域名对应的IP和TTL值，LDNS会缓存这个域名和IP的对应关系，缓存的时间由TTL控制</p>
</li>
<li><p>把解析结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。</p>
</li>
</ul>
<p>在实际的域名解析过程中，可能并不只10步，Name Server可能存在多级，或者有个GTM来负载均衡控制等等，都会影响域名解析的过程。</p>
<p><img src="https://images.effiu.cn/blog/web/02.png" alt="DNS解析过程"></p>
<h5 id="2-跟踪域名解析过程"><a href="#2-跟踪域名解析过程" class="headerlink" title="2. 跟踪域名解析过程"></a>2. 跟踪域名解析过程</h5><p><code>nslookup</code>命令查询域名的解析结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192:~ zhangshuai$ nslookup</span><br><span class="line">&gt; www.effiu.cn</span><br><span class="line">Server:		192.168.1.1</span><br><span class="line">Address:	192.168.1.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	www.effiu.cn</span><br><span class="line">Address: 47.93.44.41</span><br></pre></td></tr></table></figure>

<p>linux中还可以使用<code>dig</code>命令查询DNS解析过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192:~ zhangshuai$ dig www.effiu.cn</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; www.effiu.cn</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 50572</span><br><span class="line">;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.effiu.cn.			IN	A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.effiu.cn.		564	IN	A	47.93.44.41</span><br><span class="line"></span><br><span class="line">;; Query time: 43 msec</span><br><span class="line">;; SERVER: 192.168.1.1#53(192.168.1.1)</span><br><span class="line">;; WHEN: Sat Dec 21 23:50:55 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 46</span><br></pre></td></tr></table></figure>

<p>可以通过增加<code>+trace</code>参数跟踪这个域名的解析过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192:~ zhangshuai$ dig www.effiu.cn +trace</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; www.effiu.cn +trace</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.			178960	IN	NS	i.root-servers.net.</span><br><span class="line">.			178960	IN	NS	j.root-servers.net.</span><br><span class="line">.			178960	IN	NS	b.root-servers.net.</span><br><span class="line">.			178960	IN	NS	f.root-servers.net.</span><br><span class="line">.			178960	IN	NS	k.root-servers.net.</span><br><span class="line">.			178960	IN	NS	d.root-servers.net.</span><br><span class="line">.			178960	IN	NS	l.root-servers.net.</span><br><span class="line">.			178960	IN	NS	e.root-servers.net.</span><br><span class="line">.			178960	IN	NS	a.root-servers.net.</span><br><span class="line">.			178960	IN	NS	g.root-servers.net.</span><br><span class="line">.			178960	IN	NS	c.root-servers.net.</span><br><span class="line">.			178960	IN	NS	h.root-servers.net.</span><br><span class="line">.			178960	IN	NS	m.root-servers.net.</span><br><span class="line">;; Received 228 bytes from 192.168.1.1#53(192.168.1.1) in 43 ms</span><br><span class="line"></span><br><span class="line">cn.			172800	IN	NS	g.dns.cn.</span><br><span class="line">cn.			172800	IN	NS	ns.cernet.net.</span><br><span class="line">cn.			172800	IN	NS	f.dns.cn.</span><br><span class="line">cn.			172800	IN	NS	e.dns.cn.</span><br><span class="line">cn.			172800	IN	NS	c.dns.cn.</span><br><span class="line">cn.			172800	IN	NS	b.dns.cn.</span><br><span class="line">cn.			172800	IN	NS	d.dns.cn.</span><br><span class="line">cn.			172800	IN	NS	a.dns.cn.</span><br><span class="line">cn.			86400	IN	DS	57724 8 2 5D0423633EB24A499BE78AA22D1C0C9BA36218FF49FD95A4CDF1A4AD 97C67044</span><br><span class="line">cn.			86400	IN	RRSIG	DS 8 1 86400 20200103050000 20191221040000 22545 . d1nPbFmZHVn2KpW4WrHWVrkTpTsJ63GPNtOs+gVA2UW0PqPbTHAZyxwp +crIQv2m&#x2F;p3a20Jqg0hOfsvyUirvuSD89QuC4hy7kgrYpB2oQYRWvIsM QGtnoQ4QfzIbQe42OBeg0u0X6erPzRTRr6qrXe0UeF1HH0J3+GjUH1iu mwp+cNZgiT3Qu&#x2F;6fUNHk8GfK7m1YW2D5dJQ1cMg&#x2F;HFoOaNu8ukVRAELV tDosFiwHYCF5DZl4xifVNBo2Y7+sctK3DaHoeP5fNhx1k7tlubhmCbhz LR2wTlY3J8ip40MQbpqy8KQ8QWJ1OX0a0Zq+4shHItov&#x2F;W8NGJNtNQ2E 3FJNEg&#x3D;&#x3D;</span><br><span class="line">;; Received 703 bytes from 192.33.4.12#53(c.root-servers.net) in 274 ms</span><br><span class="line"></span><br><span class="line">effiu.cn.		86400	IN	NS	dns18.hichina.com.</span><br><span class="line">effiu.cn.		86400	IN	NS	dns17.hichina.com.</span><br><span class="line">3QDAQA092EE5BELP64A74EBNB8J53D7E.cn. 21600 IN NSEC3 1 1 10 AEF123AB 3QLMP0QRNQ96G5AFGOPNB7U7IJ4MBP4B  NS SOA RRSIG DNSKEY NSEC3PARAM</span><br><span class="line">3QDAQA092EE5BELP64A74EBNB8J53D7E.cn. 21600 IN RRSIG NSEC3 8 2 21600 20200101065432 20191202062424 38388 cn. oFAeE9H34W7CjRHFrdHRrynWgA837Pgu&#x2F;vLk9CneIuZn7W8SfYq13wDi x46ovL7PGmVBc9vMkcb67VMw+1qpOkQ4D4djxbMgy7N+QdG7hR3xkDk4 6hzDbYESgX87C0G239makcSBxYHn4GEOluChDaTftrv3No29p5G3tjvY RKk&#x3D;</span><br><span class="line">JC6NUT570N3QHIFT13HQMGKSAHVDGMHK.cn. 21600 IN NSEC3 1 1 10 AEF123AB JC9LRV8ERLF97O8994NMP07BAT6UT3A9  CNAME RRSIG</span><br><span class="line">JC6NUT570N3QHIFT13HQMGKSAHVDGMHK.cn. 21600 IN RRSIG NSEC3 8 2 21600 20200101070305 20191202062116 38388 cn. ZHEERQcOwnz90k0tS5lGjVbMg4R+nJu8Eyl0ajzJXl4faxPoOb8Q1LQf rFOY6Z&#x2F;XRANpnM&#x2F;6H2Nb3Na3mG1R64OQadGVfFl3nm43CTJGJKQxRKG8 HAsjXeU9UHvWWVD1TbOg6SWNBoMcRvqDBo3P4VGqbz1ojWXPJt+XTZan Pqc&#x3D;</span><br><span class="line">;; Received 583 bytes from 195.219.8.90#53(f.dns.cn) in 366 ms</span><br><span class="line"></span><br><span class="line">www.effiu.cn.		600	IN	A	47.93.44.41</span><br><span class="line">;; Received 57 bytes from 106.11.141.128#53(dns18.hichina.com) in 41 ms</span><br></pre></td></tr></table></figure>

<h5 id="3-清除缓存的域名"><a href="#3-清除缓存的域名" class="headerlink" title="3. 清除缓存的域名"></a>3. 清除缓存的域名</h5><p>DNS域名解析后会缓存解析结果，其中主要在两个地方缓存结果，一个是LDNS Server，另一个是用户的本地机器，这两个缓存都是TTL值和本机缓存大小控制的，但是最大缓存时间是TTL值，一般我们只能控制本机的DNS缓存。</p>
<p>Windows下使用<code>ipconfig/flushdns</code>命令可以刷新缓存。</p>
<p>Linux下使用<code>/etc/init.d/nscd restart</code>来清除缓存。</p>
<p>在Java应用中JVM也会缓存DNS解析结果，这个缓存是在<code>InetAddress</code>类中完成的，其缓存策略是：正确解析结果缓存和失败的解析结果缓：这两个缓存时间由<code>%JAVA_HOME/lib/security/java.securith</code>文件中配置的，其分别是<code>networkaddress.cache.ttl</code>和<code>networkaddress.cache.negative.ttl</code>，默认值分别为-1(用不失效)和10(缓存10s)，若要修改其缓存时间可以修改<code>java.security</code>文件或者增加启动参数：<code>-Dsun.net.inetaddr.ttl=xxx</code>来修改默认值、通过<code>InetAddress</code>类动态修改。</p>
<p>若我们需要<font color="red">使用<code>InetAddress</code>类解析域名，必须是单例模式，否则会有严重的性能问题</font>。</p>
<h5 id="4-几种域名解析方式"><a href="#4-几种域名解析方式" class="headerlink" title="4. 几种域名解析方式"></a>4. 几种域名解析方式</h5><p>域名解析记录主要分为：A记录、MX记录、CNAME记录、NS记录和TXT记录。</p>
<ul>
<li>A记录，A代表的是Address，用来指定域名对应的IP地址，其可以将多个域名解析到一个IP地址。</li>
<li>MX记录，表示的是Mail Exhange，就是可以将某个域名下的邮件服务器指向自己的Mail Server。如，<code>effiu.cn</code>域名的A记录IP地址是<code>47.93.44.41</code>，那么若将MX地址设置为<code>47.93.44.40</code>，即<code>xxx@effiu.cn</code>的邮件路由，DNS会将邮件发送到<code>47.93.44.40</code>所在的服务器，正常通过Web的请求仍然会解析到A记录的IP地址</li>
<li>CNAME记录，全称是<code>Canonical Name</code>(别名解析)。别名解析就是可以为一个域名设置多个别名。</li>
<li>NS记录，为某个域名指定的DNS解析服务器，即这个域名有指定的IP地址的DNS服务器去解析。</li>
<li>TXT记录，为某个主机名或域名设置说明</li>
</ul>
<h3 id="5-CDN工作机制"><a href="#5-CDN工作机制" class="headerlink" title="5. CDN工作机制"></a>5. CDN工作机制</h3><p>CDN是一种内容分布网络(Content Delivery Network)，是构筑在现有网络上的一种先进的流量分配网络。目的是通过在现有的Internet中增加一层新的网络架构，将网站内容发布到最接近用户的网络“边缘”，使用户可以就近取得多所需的内容，提高用户访问网站的响应速度。CDN=镜像(Mirror)+缓存(Cache)+整体负载均衡(GSLB)，所以可以明显提高网络中信息流动的效率。</p>
<p>目前CDN都以缓存网站中的静态数据为主，如CSS、js、图片和静态页面等数据。用户再从服务器中拿到动态内容后，从CDN上下载这些静态数据，从而加速网页数据的下载速度。</p>
<p>CDN要达到以下几个目标：</p>
<ul>
<li>可扩展(Scalability)。性能可扩展性：可以应对新增的大量数据、用户和事物的扩展能力，成本可扩展性，用低廉的运营成本提供动态的服务能力和高质量的内容分发。</li>
<li>安全性(Security)。强调提供物理设备、网络、软件、数据和服务过程的安全，减少因为DDoS攻击或者其他恶意行为造成商业网站的业务中断。</li>
<li>可靠性、响应和执行(Reliablity、Responsiveness、Performance)。服务可用性指能够处理可能的故障和用户体验下降的问题，通过负载均衡及时提供网络的容错机制</li>
</ul>
<h5 id="1-CDN架构"><a href="#1-CDN架构" class="headerlink" title="1. CDN架构"></a>1. CDN架构</h5><p><img src="https://images.effiu.cn/blog/web/03.png" alt="CDN架构"></p>
<p>当用户请求静态文件时，首先需要向LDNS服务器发起请求，经过迭代解析后回到这个域名的注册服务器去解析，一般每个公司都会有一个DNS解析服务器。这是这个DNS服务器通常会把它重新CNAME解析到另外一个域名，这个域名最终会被指向CDN全局中的DNS负载均衡服务器，再由这个GTM来最终分配是哪个地方的用户，返回给离这个访问用户最近的CND节点。若CDN中不存在该文件，就会再去原站获取这个文件，然后再返回给用户。</p>
<h5 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2. 负载均衡"></a>2. 负载均衡</h5><p>负载均衡(Load Balance)是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，它们共同完成任务。可以提高服务器响应速度及利用效率，避免软硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，提高用户访问体验等等。</p>
<p>通常有3种负载均衡架构，链路负载均衡、集群负载均衡和操作系统负载均衡。</p>
<ul>
<li><p>链路负载均衡是前面提到的DNS解析成不同的IP的过程，然后用户根据IP来访问不同的目标服务器。</p>
<p>负载均衡是由DNS解析完成的，用户最终访问哪个Web Server是由DNS Server来控制的。优点是用户会直接访问目标服务器，而不需要经过其他的代理服务器，访问速度更快。缺点是DNS在用户本地和LDNS都会缓存IP，一旦某台服务器挂掉，那么很难及时更新用户的域名解析结构。</p>
</li>
<li><p>集群负载是一种非常流行的负载方式，一般分为硬件负载(如：F5)和软件负载均衡，软件负载是最普遍的一种负载方式，特点是成本低、一次访问要经过多次代理服务器，会增加网络延时。</p>
</li>
<li><p>操作系统负载，是利用操作系统级别的软中断或者硬件终端来达到负载均衡，例如设置多队列网卡等来实现。</p>
</li>
</ul>
<h5 id="3-CDN动态加速"><a href="#3-CDN动态加速" class="headerlink" title="3. CDN动态加速"></a>3. CDN动态加速</h5><p>CDN的动态加速原理是在CDN的DNS解析中通过动态的链路探测来寻找回源最好的一条路径，然后经过CDN调度将所有请求调度到选定的这条路径上回源。</p>
<p><img src="https://images.effiu.cn/blog/web/04.png" alt="CDN动态加速"></p>
<p>由于CDN节点是遍布全国的，所以用户接入一个CND节点后，可以选择一条从离用户最近的CDN节点到源站链路最好的路径让用户走。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm 基础</title>
    <url>/blog/2019/12/09/algorithm/1-algorithm-basis/</url>
    <content><![CDATA[<p><strong>算法</strong>(algorithm)是任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出，即把输入转换为输出的计算步骤的一个序列。也可以把算法当做用于<strong>求良解说明</strong>的<strong>计算问题</strong>的工具。一般问题陈述说明了期望的输入/输出关系，而算法则描述一个特定的计算过程来实现该输入/输出关系。</p>
<p>以插入排序说明了算法中的一些概念以及算法分析过程。</p>
<a id="more"></a>

<h2 id="1-algorithm"><a href="#1-algorithm" class="headerlink" title="1. algorithm"></a>1. algorithm</h2><h3 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h3><p><strong>算法</strong>(algorithm)是任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出，即把输入转换为输出的计算步骤的一个序列。也可以把算法当做用于<strong>求良解说明</strong>的<strong>计算问题</strong>的工具。一般问题陈述说明了期望的输入/输出关系，而算法则描述一个特定的计算过程来实现该输入/输出关系。</p>
<p>许多程序将排序作为一个中间步，<strong>排序</strong>是计算机科学中的一个基本操作。现在已经有很多排序算法，排序算法的好坏依赖于以下因素：被排序的项数、这些项被稍微排序的程度、项值的可能限制、计算机的体系结构，以及使用的存储设备的种类(内存、磁盘等)。</p>
<p>算法解决的并不仅仅是计算问题，算法在实际应用中无处不在。例如：</p>
<ul>
<li>给定一个交通图，找出从一个十字路口到另一个十字路口的最短道路。</li>
<li>基因工程中，确定构成人类DNA的30亿个化学基对的序列，在数据库中存储这类信息并为数据分析开发工具。</li>
<li>互联网使得全世界的人都可以快速访问与检索大量信息。借助于算法，互联网上的网站能够管理和处理这些海量数据。</li>
<li>······</li>
</ul>
<p>上述问题共同点：存在许多候选解，但是绝大部分候选解都没有真正解决问题。寻找一个真正的解或一个最好的解可能是很大的挑战。算法解决的每个问题并不都有一个容易识别的候选解集。</p>
<p><strong>算法是当代计算机中使用大多数技术的核心</strong>。</p>
<h3 id="2-算法基础"><a href="#2-算法基础" class="headerlink" title="2. 算法基础"></a>2. 算法基础</h3><p><a href="https://github.com/algorithm-visualizer/algorithm-visualizer">algorithm-visualizer</a>，一个算法可视化工具。</p>
<h4 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1. 插入排序"></a>1. <a name=insertSort></a>插入排序</h4><blockquote>
<p>以<strong>插入排序</strong>为例，说明算法证明过程，以及相关概念，插入排序过程省略，<a href="https://dev.tencent.com/u/effiu/p/essay-project/git/blob/master/src/main/java/com/effiu/essay/algorithm/sort/InsertSort.java">Insertion sort</a>其伪代吗如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始默认第一个数有序，数组为A</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to A.length - <span class="number">1</span></span><br><span class="line">	key = A[j]</span><br><span class="line">	<span class="comment">// 第一个无序的索引</span></span><br><span class="line">	j = i</span><br><span class="line">	<span class="keyword">while</span> i &gt; <span class="number">0</span> and A[i - <span class="number">1</span>] &gt; key</span><br><span class="line">		A[i] = A[i-<span class="number">1</span>]</span><br><span class="line">		i--</span><br><span class="line">    A[i] = key</span><br></pre></td></tr></table></figure>

<p>假设数组为A，长度为n，那么每次迭代开始时A[0..i-1]是当前已经排序好的有序数组。把A[0..i-1]的这些性质形式的表示为<strong>循环不变式</strong>。<strong>循环不变式</strong>主要用来帮助我们理解算法的正确性，其必须证明三条性质：</p>
<ul>
<li><strong>初始化</strong>：循环的第一次迭代前，为真</li>
<li><strong>保持</strong>：若循环的某次迭代前为真，那么下次迭代之前仍为真。</li>
<li><strong>终止</strong>：循环终止时，不变式为我们提供了一个有用的性质，该性质有助于证明算法是正确的。</li>
</ul>
<p>当前两条成立时，在循环的每次迭代之前循环不变式为真。可以使用数学归纳法，为了证明某条性质成立，需要证明一个基本情况和一个归纳步。证明第一次迭代之前循环不变式成立对应于基本情况，证明从一次迭代到下一次迭代循环不变式成立对应于归纳步。</p>
<p>第三条是最重要的，使用循环不变式证明其正确性。需要和导致循环终止的条件一起使用循环不变式。终止性不同于数学归纳法的做法，在归纳法中，归纳步是无限地使用的，当循环终止时，停止归纳。</p>
<p>对于插入排序，其证明过程如下：</p>
<ul>
<li><strong>初始化</strong>：证明第一次循环之前(<code>i=1</code>)，循环不变式成立。有序数组由A[0]组成，有序。说明第一次迭代前循环不变式成立。</li>
<li><strong>保持</strong>：证明每次迭代保持循环不变式。假设当前<code>for</code>循环执行到第i次。那么<code>while</code>循环会将A[i-1]、A[i-2]、A[i-3]等向右移动一个位置，之后将A[i]的值插入到该位置，这时子数组由原来的有序数组A[1..i-1]变成了A[1..i]，仍然有序。那么对于下一次迭代之前将<strong>保持循环不变式</strong>。上述过程可以用归纳详细说明。</li>
<li><strong>终止</strong>：循环不变式终止的条件是迭代到数组最后一个元素。当迭代到最后一个元素时，说明A[1..n]有序。</li>
</ul>
<h4 id="2-分析算法"><a href="#2-分析算法" class="headerlink" title="2. 分析算法"></a>2. 分析算法</h4><p>分析算法的结果意味着预测算法需要的资源。虽然有时主要关系内存、通信带宽或计算机硬件等资源，但是绝大部分时候考虑的是<strong>计算时间</strong>。通过分析求解某个问题几种候选算法，我们可以选出一种最有效的算法，即使有时候可能不止一个可行的候选算法，但是往往可以抛弃几个较差的算法。</p>
<p>分析算法之前，我们必须有一个要使用的“实现技术”的模型，包括描述所用资源及代价的模型。以单处理器计算模——RAM(random-access machine)来作为实现技术，RAM模型中，指令是一条接一条的执行，没有并发操作。</p>
<p>RAM模型包含真实计算机中常见的指令，每条指令所需时间都为常量，具体指令如下：</p>
<ul>
<li><strong>算术指令</strong>，加、减、乘、除、取余、向下取整、向上取整</li>
<li><strong>数据移动指令</strong>，装入、存储、复制</li>
<li><strong>控制指令</strong>，条件与无条件转移、子程序调用与返回</li>
</ul>
<p>RAM模型中，数据类型包含整数型和浮点实数型。</p>
<p>真实计算机中包含一些上面未列出的指令，例如：<strong>指数运算指令</strong>，其一般情况下执行所需时间非常量，但是在某些情况下，指数运算是一个常量操作，使用位运算左移k位等价于将该整数乘以$2^k$，所以当k足够小时，将把$2^k$的计算作为一个常量时间的操作。</p>
<p>RAM模型中，并没有对当代计算机中常见的内存层次进行建模，即没有对高速缓存和虚拟内存进行建模。但是RAM模型通常能够很好地预测实际计算机上的性能。</p>
<p>RAM模型即使分析一个简单的算法也可能是一个挑战，需要数学工具可能包括组合学、概率论、代数技巧等，以及识别一个公式中最有意义的项的能力。对每个可能的输入，算法的行为可能不同，所以我们需要一种方法以简单的、易于理解的公式的形式总结那样的行为。</p>
<hr>
<h6 id="插入排序算法分析"><a href="#插入排序算法分析" class="headerlink" title="插入排序算法分析"></a>插入排序算法分析</h6><p>插入排序算法需要的时间依赖于输入：</p>
<ul>
<li>排序1000个数的时间比排序三个数需要更长的时间</li>
<li>依赖于已被排序的程度，可能需要不同的时间排序两个相同规模的输入序列</li>
</ul>
<p>算法需要的实际与输入的规模同步增长，通常把一个程序<strong>运行时间</strong>描述成其<strong>输入规模</strong>的函数。</p>
<p><strong>输入规模</strong>的概念依赖于研究的问题。例如：</p>
<ul>
<li>排序和傅里叶变换等，量度是输入中的项数</li>
<li>两个数相乘，输入规模的最佳量度是用通常的二进制记号表示输入所需的总位数(乘法的量度以位数为量度)</li>
<li>有时候需要用两个数描述输入规模，例如图，输入规模可以用该图中的定点数和边数描述。</li>
</ul>
<p><strong>运行时间</strong>，算法的运行时间是指执行的基本操作数或步数。定义“步”的概念以便尽量独立于机器，分析算法需要假定<strong>每行伪代码需要常量时间</strong>。</p>
<table>
<thead>
<tr>
<th>INSERTION-SORT(A)</th>
<th align="center">代价</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>for i = 1 to A.length - 1</td>
<td align="center">$c_1$</td>
<td>n</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;key = A[j]</td>
<td align="center">$c_2$</td>
<td>n-1</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;j = i    // 第一个无序的索引</td>
<td align="center">$c_3$</td>
<td>n-1</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;while i &gt; 0 and A[i - 1] &gt; key</td>
<td align="center">$c_4$</td>
<td>$\sum^{n}_{j=2}{t_i}$</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[i] = A[i-1]</td>
<td align="center">$c_5$</td>
<td>$\sum^{n}_{j=2}(t_i-1)$</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i–</td>
<td align="center">$c_6$</td>
<td>$\sum^{n}_{j=2}(t_i-1)$</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;A[i] = key</td>
<td align="center">$c_7$</td>
<td>n-1</td>
</tr>
</tbody></table>
<p>算法的运行时间是每条语句的执行时间之和。代价与次数求积之和为：</p>
<p>$$<br>T(n) = c_1n + c_2(n-1) + c_3(n-1) + c_4\sum^{n}<em>{j=2}(t_i) + c_5\sum^{n}</em>{j=2}(t_i-1) + c_6\sum^{n}_{j=2}(t_i-1) + c_7(n-1)<br>$$<br>即使是给定规模的输入，一个算法的运行时间也可能依赖于给定的是该规模下哪个输入。在插入算法中，当输入数组以排好序，则会出现最佳情况，在第四行当 $j == i$ 时，有 $A[i-1] &lt;= key$。此时运行时间为：</p>
<p>$$<br>\begin {align}<br>T(n) &amp;= c_1n + c_2(n-1) + c_3(n-1) + c_4(n-1) + c_7(n-1) \<br>     &amp;= (c_1 + c_2 + c_3 + c_4 + c_7)n - (c_2 + c_3 + c_4 + c_7)<br>\end {align}<br>$$<br>若输入数组已经反向排序，即按递减序排好序，则会导致最坏情况。必须将每个元素与整个以排序数组 $A[0..i-1]$ 中的每个元素进行比较，即当$i=1,2,3,4···，n-1$，有 $t_i = j$  (<strong>个人认为是</strong>$t_j = j-1$)。所以 $\sum^n_{j=2}j=\frac{n(n+1)}2-1$、$\sum^n_{j=2}{j-1}=\frac{n(n-1)}2$，此时插入算法的运行时间为：</p>
<p>$$<br>\begin{align}<br>T(n) &amp;= c_1n + c_2(n-1) + c_3(n-1) + c_4(\frac{n(n+1)}2-1) + c_5\frac{n(n-1)}2 + c_6\frac{n(n-1)}2 + c_7(n-1) \ &amp;=(\frac{c_4 + c_5 + c_6}2)n^2 + (c_1 + c_2 + c_3 + c_7 + \frac{c_4}2 - \frac{c_5}2 - \frac{c_6}2)n - (c_2 + c_3 + c_4 + c_7)<br>\end{align}<br>$$<br>可以把最坏的情况表示为 $an^2 + bn + c$，其中a、b、c又依赖于语句代价$c_i$，所以其是$n$的二次函数。</p>
<h6 id="最坏情况与平均情况分析"><a href="#最坏情况与平均情况分析" class="headerlink" title="最坏情况与平均情况分析"></a>最坏情况与平均情况分析</h6><p>上述分析插入排序的最佳情况与最坏情况。其实往往只需要求<strong>最坏运行时间</strong>。理由如下：</p>
<ul>
<li>一个算法的最坏运行时间给出了任何输入的运行时间的一个上界。</li>
<li>某些算法，最坏情况经常出现。例如，当数据库检索一条特定信息时，若该信息不在数据库中出现，则检索算法的最坏情况将会经常出现。</li>
<li>“平均”情况往往与最坏情况大致一样差。例如，上述插入排序中假定在有序子数组$A[1..i-1]$中的一半元素小于$A[i]$，那么平均来说，$t_j = \frac{j}2$，其时间约等于最坏情况的一半，同样是一个$n$的二次函数。</li>
</ul>
<p>只有在某些特定情况下，才会对算法的平均情况运行时间感兴趣。</p>
<h6 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h6><p>上述分析过程中，我们使用了某些简化的抽象来使插入排序的分析更加容易：</p>
<ul>
<li>使用常量$c_j$表示执行时间代价忽略每条语句的实际代价</li>
<li>这些常量提供了比我们真正需要的更多细节</li>
<li>插入排序中，把最坏情况的运行时间表示为$an^2 + bn + c$，其中常量a、b、c依赖于语句代价$c_i$,不但忽略了实际的语句代价，也忽略了抽象的代价$c_i$。</li>
</ul>
<p>基于上述情况，我们做出了更简化的抽象：即对算法运行时间真正影响的是<strong>增长率</strong>或<strong>增长量级</strong>。当n非常大时，低阶项相对来说不重要，所以可以只考虑$an^2 + bn +c$中的$an^2$。也可以忽略重要项的常系数($an^2$中的$a$)，对于大的输入，确定计算效率时常量因子不如增长率重要。这时只剩下最重要项中的因子$n^2$，我们记插入排序具有最坏情况运行时间$\Theta(n^2)$。</p>
<p>当一个算法的最坏情况运行时间比另一个算法更低的增长量级，那么通常认为前者更有效率。</p>
<h4 id="3-选择排序分析过程"><a href="#3-选择排序分析过程" class="headerlink" title="3. 选择排序分析过程"></a>3. 选择排序分析过程</h4><p>选择排序描述(数组为A，长度为n)：</p>
<ul>
<li>从A中找出最小元素并将其与A[1]互换。</li>
<li>在未排序序列中，找出最小元素，存放到排序序列的最小位置</li>
<li>重复上述步骤</li>
</ul>
<p>选择排序伪代码如下：</p>
<table>
<thead>
<tr>
<th>SELECT-SORT(A)</th>
<th align="center">代价</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>for i = 0 to A.length - 1</td>
<td align="center">$c_1$</td>
<td>n</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;j = i</td>
<td align="center">$c_2$</td>
<td>n</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;for m = i + 1 to A.length - 1</td>
<td align="center">$c_3$</td>
<td>$\sum^{n-1}_{j=1}t_m$</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if A[m] &lt; A[j]</td>
<td align="center">$c_4$</td>
<td>$\sum^{n-1}_{j=1}t_m$</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = m</td>
<td align="center">$c_5$</td>
<td>$\sum^{n-1}_{j=1}t_m$</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;if j != i</td>
<td align="center">$c_6$</td>
<td>n</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp = A[j]</td>
<td align="center">$c_7$</td>
<td>n-1</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[j] = A[i]</td>
<td align="center">$c_8$</td>
<td>n-1</td>
</tr>
<tr>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[i] = tmp</td>
<td align="center">$c_9$</td>
<td>n-1</td>
</tr>
</tbody></table>
<p>那么最坏情况下选择排序执行时间为：</p>
<p>$$<br>\begin{align}<br>T(n) &amp;= c_1n+ c_2n + c_3(\frac{(n-1)n}2 + c_4\frac{(n-1)n}2 + c_5\frac{(n-1)n}2 + c_6n + c_7(n-1) + c_8(n-1) + c_9(n-1) \ &amp;= (\frac{c_3}2 + \frac{c_4}2 + \frac{c_5}2)n^2 + (c_1 + c_2 + c_6 + c_7 + c_8 + c_9 - \frac{c_3}2 - \frac{c_4}2 - \frac{c_5}2)n -3<br>\end{align}<br>$$<br>抽象简化为$an^2 + bn + c$，即时间复杂度为 $\Theta(n^2)$。</p>
<h3 id="3-分治法"><a href="#3-分治法" class="headerlink" title="3. 分治法"></a>3. 分治法</h3><blockquote>
<p>上一节中<a href='#insertSort'>插入排序</a>, 使用了<strong>增量</strong>序法，实际算法设置方法有很多。增量法: 在排子字数组$A[1..j-1]$后，将单个元素$A[j]$插入到指定位置，产生排序好的子数组$A[1..j]$。另一种设计方法是<strong>分治法</strong>，其最坏情况比插入排序少得多。</p>
</blockquote>
<p>分治法在结构上是<strong>递归的</strong>：为了解决一个问题，算法一次或者多次递归的调用其自身以解决紧密相关的若干自问题。<strong>分治法</strong>：将原问题分解为几个规模较小的问题，递归地求解这些问题，然后再合并这些子问题的解来建立原问题的解。其在递归时有以下三个步骤:</p>
<ul>
<li><strong>分解</strong>，将原问题分解为若干子问题，其是原问题的规模较小的实例</li>
<li><strong>解决</strong>，递归地求解子问题。当子问题规模很小时，则直接求解</li>
<li><strong>合并</strong>，合并这些子问题的解成原问题的解。</li>
</ul>
<h4 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h4><p>归并排序完全遵循分治模式，其可以理解为：</p>
<ul>
<li><strong>分解</strong>，将长度为$n$的待排序数组分为$n/2$个元素的两个子序列</li>
<li><strong>解决</strong>，使用递归排序递归地排序两个子序列</li>
<li><strong>合并</strong>，合并两个已排序的子序列已产生已排序的答案</li>
</ul>
<p>当排序的子序列长度为1时，递归开始回升，然后就需要合并两个子序列。代码见<a href="https://dev.tencent.com/u/effiu/p/essay-project/git/blob/master/src/main/java/com/effiu/essay/algorithm/sort/MergingSort.java">归并排序</a>。</p>
<h4 id="2-归并排序的算法分析"><a href="#2-归并排序的算法分析" class="headerlink" title="2. 归并排序的算法分析"></a>2. 归并排序的算法分析</h4><p>假设排序长度为$n$的数组需要$T(n)$的时间，那么归并排序一个元素需要常量的时间。当$n&gt;1$时，分解运行时间如下：</p>
<ul>
<li><strong>分解</strong>，分解过程主要是计算子数组的中间位置，需要常量的时间，即$D(n) = \theta(1)$。</li>
<li><strong>解决</strong>，递归的求解两个规模为$n/2$的子问题，将贡献$2T(n/2)$的运行时间</li>
<li><strong>合并</strong>，从代码中分析可得，具有$n$个元素的子数组merge需要$\theta(n)$的时间，即$C(n) = \theta(n)$</li>
</ul>
<p>$$<br>T(n) =<br>\begin{cases}\theta(1) &amp;若n=1\<br>2T(n/2) + \theta(n) + \theta(1) &amp;若n &gt; 1\end{cases}<br>$$</p>
<p>后续会证明$T(n)=\theta(n\log n)$，$\log n = \log_2 n$，对数增长率比线性函数慢，所以对于足够大的输入，$\theta(n\log n)$的排序时间将比$\theta(n^2)$的效率快。其推导过程如下：</p>
<p><img src="https://images.effiu.cn/blog/algorithm/01.jpg" alt="证明过程"></p>
<p>第$i$层有$n/i$个节点，所以第$i$层的代价为$i * c(n/i) = cn$，总层数为$log n + 1$。当$n = 2^i$时，具有$i + 1$层。综上所述，归并排序的代价是$\theta(nlog n)$</p>
<h3 id="4-练习题"><a href="#4-练习题" class="headerlink" title="4. 练习题"></a>4. 练习题</h3><ol>
<li>说明归并排序在数组$A=[3,41,52,26,38,57,9,49]$上的操作？<a href="https://dev.tencent.com/u/effiu/p/essay-project/git/blob/master/src/main/java/com/effiu/essay/algorithm/chapter2/Exercise2.java">归并排序</a></li>
<li>使用数学归纳法证明：当$n$刚好为2的幂时，以下递归的解是$T(n) = n log n$。</li>
</ol>
<p>$$<br>T(n) =<br>\begin{cases} 2 &amp;若n=2\<br>2T(n/2) + n &amp;若n = 2^k, k &gt; 1 \end{cases}<br>$$</p>
<ol start="3">
<li>把插入排序表示为一个递归的过程。为了排序$A[1..n]$，我们递归地排序$A[1..n-1]$，然后把$A[n]$插入已排序的数组$A[1..n-1]$。为插入排序的这个递归版本的最坏情况运行时间写一个递归式。</li>
<li>若序列A有序，就可以将该序列的中点与$v$进行比较。根据比较结果，原序列中有一半就可以不用再做进一步的考虑。<strong>二分查找</strong>就是重复这个过程，每次将序列剩余部分减半。为二分查找写出迭代或者递归的代码。证明：二分查找最坏情况运行时间为$\theta(lgn)$。</li>
<li>上面<a href="#insertSort">插入排序</a>中，<code>while</code>循环采用一种线性查找反向扫描已排序好的子数组$A[1..j-1]$。我们可以使用二分查找来把插入排序的最坏情况改进到$\theta(n log n)$么？</li>
<li>描述一个运行时间为$\theta(n log n)$的算法，给定$n$个整数的集合$S$和另一个整数$x$，该算法能确定$S$中是否存在两个其和刚好为$x$的元素?</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO</title>
    <url>/blog/2019/09/22/java/java_io/</url>
    <content><![CDATA[<p>IO基本类；IO底层核心操作技巧；同/异步 + 阻塞/非阻塞的性能区别； BIO、NIO、AIO区别；</p>
<ul>
<li><input disabled="" type="checkbox"> NIO 操作Socket时的多路复用？</li>
</ul>
<a id="more"></a>

<h3 id="1-IO"><a href="#1-IO" class="headerlink" title="1. IO"></a>1. IO</h3><h4 id="1-File"><a href="#1-File" class="headerlink" title="1. File"></a>1. File</h4><p><code>File</code>类既能代表一个特定文件的名称，又能代表一个目录下一组文件的名称。<a href="http://www.matools.com/api/java8">文档地址</a>，部分api说明如下：</p>
<ul>
<li><code>File.separator</code>，返回当前系统的文件分隔符”/“、”\“等。</li>
<li><code>list()</code>，返回一个由此抽象路径名表示的目录中的文件和目录字符串组成的数组。</li>
<li><code>list(FilenameFilter filter)</code>，返回一个由此抽象路径名表示的目录中满足指定过滤器的文件和目录组成的数组。<code>FilenameFilter </code>是一个接口，建议使用匿名内部类的方式实现。</li>
</ul>
<p><code>java.nio.file.Files</code>包含对文件，目录或其他类型文件进行操作的静态方法。在大多数情况下，这里定义的方法将委托给相关的文件系统提供程序来执行文件操作。</p>
<h4 id="2-输入和输出"><a href="#2-输入和输出" class="headerlink" title="2. 输入和输出"></a>2. 输入和输出</h4><p>Java中的流，代表任何有能力产出数据的数据源对象或者有能力接收数据的接收端对象。“流”屏蔽了实际的I/O设备中处理数据的细节。</p>
<p>Java类库中的I/O类分为输入和输出两种：</p>
<ul>
<li>任何继承自<code>java.io.InputStream</code>或者<code>java.io.Reader</code>派生而来的类都含有名为<code>read()</code>的基本方法，用于读取单个字节或者字节数组。</li>
<li>任何继承自<code>java.io.OutputStream</code>或者<code>java.io.Writer</code>派生而来的类都含有名为<code>write()</code>的基本方法，用于写单个字节或者字节数组。</li>
</ul>
<p><code>read()</code>和<code>write()</code>方法的存在并不是为了供使用，而是为了别的类使用，用来提供更有效的接口。实际上，很少使用单一的类创建流对象，而是通过叠加多个对象来提供所期望的功能(装饰器设计模式)。</p>
<h5 id="1-InputStream类型"><a href="#1-InputStream类型" class="headerlink" title="1. InputStream类型"></a>1. InputStream类型</h5><p>作用是用来表示从不同数据源产生输入的类。数据源主要包括：</p>
<ul>
<li>字节数组</li>
<li>String对象</li>
<li>文件</li>
<li>管道，工作方式与实际管道相似</li>
<li>一个由其他种类的流组成的序列，便于我们将其合并到一个流内</li>
<li>其他数据源，如Internet连接等。</li>
</ul>
<p>每种数据源都有对应的<code>InputStream</code>类，<code>FilterInputStream</code>也属于一种<code>InputStream</code>，为装饰器类提供基类，装饰器类可以把属性或者有用的接口与输入流连接在一起。<code>InputStream</code>类型如下：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数</th>
</tr>
</thead>
<tbody><tr>
<td><code>ByteArrayInputStream</code></td>
<td>允许将内存的缓冲区作为<code>InputStream</code>使用</td>
<td>缓冲区，字节将从中取出<br />作为一种数据源：将其与<code>FilterInputStream</code>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><code>StringBufferInputStream</code></td>
<td>将<code>String</code>转化成<code>InputStream</code></td>
<td>字符串，底层实现使用<code>StringBuffer</code><br />作为一种数据源：将其与<code>FilterInputStream</code>对象相连以提供有用接口</td>
</tr>
<tr>
<td><code>FileInputStream</code></td>
<td>用于从文件中读取信息</td>
<td>字符串，表示文件名或者路径；<code>FileDescriptor</code>对象<br />作为一种数据源：将其与<code>FilterInputStream</code>对象相连以提供有用接口</td>
</tr>
<tr>
<td><code>PipedInputStream</code></td>
<td>产生用于写入相关<code>PipedOutputStream</code>的数据，实现<strong>管道化</strong>概念</td>
<td><code>PipedOutputStream</code><br />作为多线程中数据源：将其与<code>FilterOutputStream</code>对象相连以提供有用接口</td>
</tr>
<tr>
<td><code>SequenceInputStream</code></td>
<td>将两个或者多个<code>InputStream</code>对象转换成单一<code>InputStream</code></td>
<td>两个<code>InputStream</code>对象或一个容纳<code>InputStream</code>对象的容器<code>Enumeration</code><br />作为一种数据源：将其与<code>FilterInputStream</code>对象相连以提供有用接口</td>
</tr>
<tr>
<td><code>FilterInputStream</code></td>
<td>抽象类，作为装饰器接口。其中装饰器为其他的<code>InputStream</code>类提供有用功能</td>
<td>见下表</td>
</tr>
</tbody></table>
<h5 id="2-OutputStream类型"><a href="#2-OutputStream类型" class="headerlink" title="2. OutputStream类型"></a>2. OutputStream类型</h5><p>该类别的类决定了输出所要去往的目标：字节数组、文件或者管道。<code>FilterOutputStream</code>为装饰器类提供的一个基类，装饰器把属性或者有用的接口与输出流连接了起来。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数</th>
</tr>
</thead>
<tbody><tr>
<td><code>ByteArrayOutputStream</code></td>
<td>在内存中创建缓冲区，所有送往流的数据都要放置在此缓冲区</td>
<td>缓冲区初始化大小<br />用于指定数据目的地，其与<code>FilterOutputStream</code>相连以提供有用的接口</td>
</tr>
<tr>
<td><code>FileOutputStream</code></td>
<td>用于将信息写至文件</td>
<td>字符串，表示文件名、文件或者<code>FileDescriptor</code>对象。<br />指定数据的目的地，其与<code>FilterOutputStream</code>对象相连以提供有用接口</td>
</tr>
<tr>
<td><code>PipedOutputStream</code></td>
<td>任何写入其中的信息都会自动作为相关<code>PipedInputStream</code>的输出，实现<strong>管道化</strong>概念</td>
<td><code>PipedInputStream</code><br />作为多线程中数据源：将其与<code>FilterOutputStream</code>对象相连以提供有用接口</td>
</tr>
<tr>
<td><code>FilterOutputStream</code></td>
<td>抽象类，作为装饰器接口。其中装饰器为其他的<code>OutputStream</code>类提供有用功能</td>
<td>见下表</td>
</tr>
</tbody></table>
<h4 id="3-添加属性和有用接口"><a href="#3-添加属性和有用接口" class="headerlink" title="3. 添加属性和有用接口"></a>3. 添加属性和有用接口</h4><p><strong>Java I/O</strong> 类库需要多种不同功能的组合，这也是使用装饰者模式的理由所在。<strong>Java I/O</strong> 类库存在<code>Filter</code>类的原因是抽象类<code>filter</code>是所有装饰类的基类。装饰器必须具有与其所装饰的对象相同的接口，也可以拓展接口。装饰器模式缺点：提供了灵活性的同时，增加了代码的复杂性。</p>
<p><code>FilterInputStream</code>和<code>FilterOutputStream</code>是用来提供装饰器类接口以控制特定输入(<code>InputStream</code>)和输出流(<code>OutputStream</code>)的两个类，其分别是由<code>InputStream</code>和<code>OutputStream</code>两个基类派生而来。</p>
<h5 id="1-FilterInputStream"><a href="#1-FilterInputStream" class="headerlink" title="1. FilterInputStream"></a>1. <strong>FilterInputStream</strong></h5><table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataInputStream</code></td>
<td>与<code>DataOutputStream</code>搭配使用，可以按照可移植方式从流读取基本数据类型以及<code>String</code>对象</td>
<td><code>InputStream</code><br />包含用于读取基本类型数据的全部接口</td>
</tr>
<tr>
<td><code>BufferedInputStream</code></td>
<td>可以防止每次读取时都进行实际写操作，使用缓冲区</td>
<td><code>InputStream</code>，缓冲区大小<br /></td>
</tr>
<tr>
<td><code>LineNumberInputStream</code></td>
<td>跟踪输入流中的行号。可以使用<code>getLineNumber()</code>和<code>setLineNumber(int)</code></td>
<td><code>InputStream</code><br />仅仅增加了行号，因此可能要与接口对象搭配使用</td>
</tr>
<tr>
<td><code>PushbackInputStream</code></td>
<td>具有可以弹出一个字节的缓冲区，可以将读到的最后一个字符回退</td>
<td><code>InputStream</code><br /></td>
</tr>
</tbody></table>
<h5 id="2-FilterOutputStream"><a href="#2-FilterOutputStream" class="headerlink" title="2. FilterOutputStream"></a>2. <strong>FilterOutputStream</strong></h5><table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataOutputStream</code></td>
<td>与<code>DataInputStream</code>搭配使用，按照可移植的方式向流中写入基本类型</td>
<td><code>OutputStream</code><br />包含写入基本数据类型的全部接口</td>
</tr>
<tr>
<td><code>PrintStream</code></td>
<td>用于产生格式化输出。其中<code>DataOutputStream</code>处理数据的存储，<code>PrintStream</code>处理显示</td>
<td><code>OutputStream</code>，用布尔值指示是否在每次换行执行时清空缓冲区，是对<code>OutpustStream</code>对象的<code>final</code>封装</td>
</tr>
<tr>
<td><code>BufferOutputStream</code></td>
<td>避免每次发送数据时都要进行实际的写操作，代表使用缓冲区，<code>flush()</code>清空缓冲区</td>
<td><code>InputStream</code>，缓冲区大小<br /></td>
</tr>
</tbody></table>
<p><code>PrintStream</code>目的是为了以可视化格式打印所有的基本数据类型以及<code>String</code>对象</p>
<h4 id="4-Reader和Writer"><a href="#4-Reader和Writer" class="headerlink" title="4. Reader和Writer"></a>4. <strong>Reader</strong>和<strong>Writer</strong></h4><p><strong>Reader</strong>和<strong>Writer</strong>提供兼容Unicode与面向字符的I/O功能，当我们“字节”层次结构中的类和“字符”层次结构中的类结合使用时，要用到适配器类：<code>InputStreamReader</code>和<code>OutputStreamReader</code>。<strong>Reader</strong>和<strong>Writer</strong>主要是为了国际化。</p>
<h4 id="5-RandomAccessFile"><a href="#5-RandomAccessFile" class="headerlink" title="5. RandomAccessFile"></a>5. RandomAccessFile</h4><p><strong>RandomAccessFile</strong> 适用于由大小已知的记录组成的文件，以便我们可以使用 <code>seek()</code> 将记录从一处转移到另一处，然后读取或者修改记录。文件中记录的大小不一定都相同，只要我们能够确定那些记录有多大以及它们在文件中的位置即可。 </p>
<p><code>RandomAccessFile</code> 不是<code>InputStream</code>或者<code>OutputStream</code>继承层次结构中的一部分。除了实现了<code>DataInput</code> 和 <code>DataOutput</code> 接口（DataInputStream 和 DataOutputStream 也实现了这两个接口）之外，它和这两个继承层次结构没有任何关联。它甚至不使用 InputStrean 和 OutputStream 类中已经存在的任何功能。它是一个完全独立的类，从头开始编写其所有方法的类。</p>
<h4 id="6-管道流"><a href="#6-管道流" class="headerlink" title="6. 管道流"></a>6. 管道流</h4><p><code>PipedInputStream</code>、<code>PipedOutputStream</code>、<code>PipedReader</code>及<code>PipedWriter</code>只有在我们开始理解多线程之后才会使用，因为管道流用于线程之间的通信。</p>
<h4 id="7-标准I-O"><a href="#7-标准I-O" class="headerlink" title="7. 标准I/O"></a>7. 标准I/O</h4><p>标准I/O，其意义在于<strong style='color:red'>可以很容易把程序串联起来，一个程序所有标准输出可以称为另外一程序的标准输入</strong>。</p>
<ul>
<li>程序所有输入都可以来自于标准输入</li>
<li>程序所有输出也都可以发送到标准输出</li>
<li>程序所有错误信息都可以发送到标准错误</li>
</ul>
<h5 id="1-从标准输入中读取"><a href="#1-从标准输入中读取" class="headerlink" title="1. 从标准输入中读取"></a>1. 从标准输入中读取</h5><p>Java提供了<code>System.in</code>、<code>System.out</code>、<code>System.err</code>。其中<code>System.out</code>、<code>System.err</code>已经被包装成了<code>PrintStream</code>。<code>System.in</code>是一个未被包装加工的<code>InputStream</code>，所以使用<code>System.in</code>之前需要对其进行包装。例如：使用<code>InputStreamReader</code>把<code>System.in</code>包装成<code>Reader</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader stdin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br></pre></td></tr></table></figure>

<h5 id="2-System-out转成PringWriter"><a href="#2-System-out转成PringWriter" class="headerlink" title="2. System.out转成PringWriter"></a>2. System.out转成PringWriter</h5><p><code>System.out</code>是<code>PrintStream</code>，其本质是一个<code>OutputStream</code>，PrintWrite有可以接受<code>OutputStream</code>作为参数的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out, <span class="keyword">true</span>);  <span class="comment">// true开启自动清空功能</span></span><br></pre></td></tr></table></figure>

<h5 id="3-I-O重定向"><a href="#3-I-O重定向" class="headerlink" title="3. I/O重定向"></a>3. I/O重定向</h5><p>Java的<code>System</code>提供了一些静态方法调用，允许我们对标准输入、输入和错误I/O流进行重定向:</p>
<ul>
<li><code>setIn(InputStream)</code></li>
<li><code>setOut(PrintStream)</code></li>
<li><code>setErr(PrintStream)</code></li>
</ul>
<h3 id="2-NIO"><a href="#2-NIO" class="headerlink" title="2. NIO"></a>2. NIO</h3><p><strong>JDK1.4</strong>中的<code>java.nio.*</code>中引入了新的Java I/O类，其目的在于提高速度。实际上旧的IO包已经使用nio重新实现过，以便充分速度提高速度，因此实际上不显式使用nio，也能提高速度。</p>
<p>提高速度在文件I/O和网络I/O(在《Thinking in Enterpise Java》中有说明)中都有可能发生。网络I/O的速度提升体现在NIO的单线程轮询事件的机制。以文件I/O进行说明：速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式：<strong>通道</strong>和<strong>缓冲器</strong>。实际过程是当发生I/O操作时，仅仅与缓冲器进行交互，并把缓冲器发送到通道。通道要么从缓冲器中获得数据，要么向缓冲器发送数据。</p>
<p>缓冲区(Buffer)就是在内存中预留指定大小的存储空间用来对输入/输出(I/O)的数据作临时存储，这部分预留的内存空间就叫做缓冲区，其有两个作用：</p>
<ul>
<li>减少实际的物理读写次数</li>
<li>在创建时就会分配内存，这块区域会一直被重用，减少动态分配和回收内存的次数</li>
</ul>
<p>唯一与通道交互的缓冲器是<code>ByteBuffer</code>，其是可以存储未加工字节的缓冲器，其是非常基础的类：通过告知分配多少存储空间创建一个<code>ByteBuffer</code>对象，还有一个方法选择集，用于以原始字节形式或基本数据类型输出和读取数据，但是没有办法输出或者读取对象。</p>
<p>旧的Java I/O中修改了三个类，用以产出<code>FileChannel</code>：<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>RandomAccessFile</code>。<code>Reader</code>、<code>Writer</code>字符流不能产生通道(<code>ByteBuffer</code>用以以原始形式或者基本数据类型输入和输出数据)。<code>java.nio.channels.Channels</code>提供了方法用于在通道中产生<code>Reader</code>和<code>Writer</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(file.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wirte a file</span></span><br><span class="line">        FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;text.txt&quot;</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">&quot;12345&quot;</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add to the end of the file</span></span><br><span class="line">        fc = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">&quot;123123&quot;</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the file</span></span><br><span class="line">        fc = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;text.txt&quot;</span>).getChannel();</span><br><span class="line">        <span class="comment">// 用于分配ByteBuffer，必须指定大小</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="comment">// read告知FileChannel向FileChannel存储字节，调用flip让其做好被读取的准备</span></span><br><span class="line">        <span class="comment">// clear()方法为read做准备</span></span><br><span class="line">        fc.read(buffer);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述三种流中的<code>getChannel()</code>方法产生了一个<code>FileChannel</code>对象。通道是一种相当基础的东西，可以向它传递用于读写的<code>ByteBuffer</code>，并且可以锁定文件的某些区域用于独占式的访问(<code>fc.lock()</code>)。</p>
<p><code>ByteBuffer</code>的常用方法如下：</p>
<ul>
<li><p><code>put</code>和<code>get</code>用于填充或者获取字节或者基本数据类型</p>
</li>
<li><p><code>wrap()</code>用于将已经存在的字节数组包装到<code>ByteBuffer</code>中，其不会不复制byte数据，而是把其作为所产生的<code>ByteBuffer</code>的存储器。</p>
</li>
<li><p><code>allocate</code>用于显式分配<code>ByteBuffer</code>，便于快速移动大量数据</p>
</li>
<li><p><code>read()</code>告知<code>FileChannel</code>向<code>ByteBuffer</code>存储字节，调用<code>flip()</code>让其做好被读取的准备，<code>clear()</code>方法为<code>read()</code>做准备，即当重复使用<code>read</code>是，必须先执行<code>clear()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;text.txt&quot;</span>).getChannel();</span><br><span class="line">FileChannel channel1 = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;text1.txt&quot;</span>).getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line"><span class="comment">// read将数据输入到缓冲器中</span></span><br><span class="line"><span class="keyword">while</span> (channel.read(buffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// flip准备缓冲器方便信息由write提取</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">// 提取后，信息仍然在buffer中</span></span><br><span class="line">    channel1.write(buffer);</span><br><span class="line">    <span class="comment">// 对所有内部指针重新安排，便于缓冲器在另一个read操作期间能够接收数据</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>transferTo()</code>和<code>transferFrom()</code>则允许我们将一个通道和另一个通道直接相连</p>
</li>
</ul>
<h4 id="1-转换数据"><a href="#1-转换数据" class="headerlink" title="1. 转换数据"></a>1. 转换数据</h4><p>当我们使用nio处理字符时，使用<code>ByteBuffer</code>不太方便，所以可以使用<code>CharBuffer</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;default encode: &quot;</span> + System.getProperty(<span class="string">&quot;file.encoding&quot;</span>));</span><br><span class="line">String fileName = <span class="string">&quot;text.txt&quot;</span>;</span><br><span class="line">FileChannel fc = <span class="keyword">new</span> FileOutputStream(fileName).getChannel();</span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">&quot;some text: 测试&quot;</span>.getBytes()));</span><br><span class="line">fc.close();</span><br><span class="line"></span><br><span class="line">fc = <span class="keyword">new</span> FileInputStream(fileName).getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">fc.read(buffer);</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="comment">// 直接调用ByteBuffer接口输出char, 失败(编码问题)</span></span><br><span class="line">System.out.println(buffer.asCharBuffer());</span><br><span class="line"><span class="comment">// 对 ByteBuffer进行解码后输出</span></span><br><span class="line">System.out.println(<span class="string">&quot;decode use utf-8: &quot;</span> + Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(buffer));</span><br><span class="line"><span class="comment">// 在输入时对其进行编码</span></span><br><span class="line">fc = <span class="keyword">new</span> FileOutputStream(fileName).getChannel();</span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">&quot;some text: 测试&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">fc.close();</span><br><span class="line">fc = <span class="keyword">new</span> FileInputStream(fileName).getChannel();</span><br><span class="line">buffer.clear();</span><br><span class="line">fc.read(buffer);</span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println(buffer.asCharBuffer());</span><br><span class="line"><span class="comment">// 输入时使用CharBuffer进行编码</span></span><br><span class="line">fc = <span class="keyword">new</span> FileOutputStream(fileName).getChannel();</span><br><span class="line">buffer.clear();</span><br><span class="line">buffer.asCharBuffer().put(<span class="string">&quot;some text: 测试&quot;</span>);</span><br><span class="line">fc.write(buffer);</span><br><span class="line">fc.close();</span><br><span class="line">fc = <span class="keyword">new</span> FileInputStream(fileName).getChannel();</span><br><span class="line">buffer.clear();</span><br><span class="line">fc.read(buffer);</span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println(buffer.asCharBuffer());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="keyword">default</span> encode: UTF-<span class="number">8</span></span><br><span class="line">獯浥⁴數琺⃦떋</span><br><span class="line">decode use utf-<span class="number">8</span>: some text: 测试</span><br><span class="line">獯浥⁴數琺⃦떋		<span class="comment">// 不确定失败原因</span></span><br><span class="line">some text: 测试  </span><br></pre></td></tr></table></figure>

<p>缓冲器容纳的是普通的字节，若我们需要把其转换为字符，要么在输入时进行编码，要么在从缓冲器输出时进行解码。</p>
<h4 id="2-ByteBuffer转换为其他类型"><a href="#2-ByteBuffer转换为其他类型" class="headerlink" title="2. ByteBuffer转换为其他类型"></a>2. ByteBuffer转换为其他类型</h4><p><code>ByteBuffer</code>只能保存最基本的字节类型，但是其可以从其所容纳的字节中产生各种不同基本类型值的方法。</p>
<ul>
<li><code>rewind()</code>用于从返回到数据开始部分。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">bb.asXXXBuffer().put(obj);</span><br><span class="line">bb.getXXX()</span><br></pre></td></tr></table></figure>

<p>向<code>ByteBuffer</code>插入基本类型数据的方法有<code>asCharBuffer()</code>、<code>asShortBuffer</code>等获取该缓冲器上的视图，然后使用视图的<code>put()</code>方法。其适用于所有除了<code>asShortBuffer()</code>之外的所有基本类型。使用<code>ShortBuffer</code>的<code>put()</code>方法时需要类型转换。</p>
<h4 id="3-视图缓冲器"><a href="#3-视图缓冲器" class="headerlink" title="3. 视图缓冲器"></a>3. 视图缓冲器</h4><p><strong>视图缓冲器</strong>(view buffer)可以让我们通过某个特定的基本数据类型的视窗查看器底层的<code>ByteBuffer</code>。<code>ByteBuffer</code>依然是实际存储数据的地方。对视图的任何修改都会映射成为对<code>ByteBuffer</code>中数据的修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">IntBuffer intBuffer = bb.asIntBuffer().put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>, <span class="number">42</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">143</span>, <span class="number">811</span>, <span class="number">1016</span>&#125;);</span><br><span class="line">System.out.println(intBuffer.get(<span class="number">3</span>));</span><br><span class="line">intBuffer.put(<span class="number">3</span>, <span class="number">98</span>);</span><br><span class="line">intBuffer.flip();</span><br><span class="line"><span class="keyword">while</span> (intBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print(intBuffer.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其结果如下:</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">11</span>, <span class="number">42</span>, <span class="number">47</span>, <span class="number">98</span>, <span class="number">143</span>, <span class="number">811</span>, <span class="number">1016</span>,</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>put()</code>和<code>get()</code>是<code>IntBuffer</code>重载后的方法，其最直接访问底层<code>ByteBuffer</code>中的某个整数位置</p>
</blockquote>
<p>一旦底层的<code>ByteBuffer</code>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写到通道中了。视图缓冲器可以把任何数据都转化为某一特定的基本类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">while</span> (bb.hasRemaining()) &#123;</span><br><span class="line">    System.out.print(bb.position() + <span class="string">&quot;-&gt;&quot;</span> + bb.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// char</span></span><br><span class="line">CharBuffer charBuffer = ((ByteBuffer) bb.rewind()).asCharBuffer();</span><br><span class="line"><span class="keyword">while</span> (charBuffer.hasRemaining())&#123;</span><br><span class="line">    System.out.print(charBuffer.position() + <span class="string">&quot;-&gt;&quot;</span> + charBuffer.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// int</span></span><br><span class="line">IntBuffer intBuffer = ((ByteBuffer) bb.rewind()).asIntBuffer();</span><br><span class="line"><span class="keyword">while</span> (intBuffer.hasRemaining())&#123;</span><br><span class="line">    System.out.print(intBuffer.position() + <span class="string">&quot;-&gt;&quot;</span> + intBuffer.get() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">0</span>, <span class="number">1</span>-&gt;<span class="number">0</span>, <span class="number">2</span>-&gt;<span class="number">0</span>, <span class="number">3</span>-&gt;<span class="number">0</span>, <span class="number">4</span>-&gt;<span class="number">0</span>, <span class="number">5</span>-&gt;<span class="number">0</span>, <span class="number">6</span>-&gt;<span class="number">0</span>, <span class="number">7</span>-&gt;<span class="number">97</span>, </span><br><span class="line"><span class="number">0</span>-&gt; , <span class="number">1</span>-&gt; , <span class="number">2</span>-&gt; , <span class="number">3</span>-&gt;a, </span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">0</span>, <span class="number">1</span>-&gt;<span class="number">97</span>, </span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>ByteBuffer</code>通过一个被包装的8字节数组产生，然后通过各种不同的基本类型的视图缓冲器显示出来。不同类型的视图缓冲器读取时，数据显示的方式也不同。</p>
<p><img src="https://images.effiu.cn/blog/java/01.png" alt="view buffer"></p>
<h4 id="4-缓冲器操作数据"><a href="#4-缓冲器操作数据" class="headerlink" title="4. 缓冲器操作数据"></a>4. 缓冲器操作数据</h4><p>下图表明了nio类之间的关系，便于我们理解移动和转换数据。例如：若我们想把一个字节数组写到文件中去，应该使用<code>ByteBuffer.wrap()</code>方法包装字节数组，然后用<code>FileOutputStream.getChannel()</code>打开通道，然后将数据写入到<code>FileChannel</code>中。</p>
<p><code>ByteBuffer</code>是将数据移进移出通道的唯一方式。</p>
<p><img src="https://images.effiu.cn/blog/java/02.png" alt="nio类之间的关系"></p>
<h4 id="5-缓冲器的细节"><a href="#5-缓冲器的细节" class="headerlink" title="5. 缓冲器的细节"></a>5. 缓冲器的细节</h4><p><code>Buffer</code>由数据和可以高效地访问操纵这些数据的四个索引组成：</p>
<ul>
<li><code>mark</code>，标记</li>
<li><code>position</code>，位置</li>
<li><code>limit</code>，界限</li>
<li><code>capacity</code>，容量</li>
</ul>
<p>以下是设置和复位索引以及查询它们值的方法：</p>
<ul>
<li><code>capacity()</code>：返回缓冲区容量</li>
<li><code>clear()</code>：清空缓冲区，将<code>position</code>设置为0，<code>limit</code>设置为<code>capacity</code>。</li>
<li><code>flip()</code>：将<code>limit</code>设置为<code>position</code>，<code>position</code>设置为0，用于准备从缓冲区中读取已经写入的数据</li>
<li><code>limit()</code>：返回<code>limit()</code>值</li>
<li><code>limit(int lim)</code>：设置<code>limit</code>的值</li>
<li><code>mark()</code>：将<code>mark</code>设置为<code>position</code></li>
<li><code>position()</code>：返回<code>position</code>的值</li>
<li><code>position(int pos)</code>：设置<code>position</code>的值</li>
<li><code>remaining()</code>：返回（limit-position）</li>
<li><code>hasRemaining()</code>：若存在介于<code>position</code>和<code>limit</code>之间的元素，则返回<code>true</code></li>
</ul>
<p>在缓冲器中插入和提取数据会更新这些索引，用于反映发生的变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingBuffers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">symmertricScramble</span><span class="params">(CharBuffer cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cb.hasRemaining()) &#123;</span><br><span class="line">            <span class="comment">// mark，将mark设置为position的值</span></span><br><span class="line">            cb.mark();</span><br><span class="line">            <span class="keyword">char</span> c = cb.get();</span><br><span class="line">            <span class="keyword">char</span> c1 = cb.get();</span><br><span class="line">            <span class="comment">// reset将position设置为mark的值</span></span><br><span class="line">            cb.reset();</span><br><span class="line">            cb.put(c1).put(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data = <span class="string">&quot;UsingBuffers&quot;</span>.toCharArray();</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(data.length * <span class="number">2</span>);</span><br><span class="line">        CharBuffer charBuffer = bb.asCharBuffer().put(data);</span><br><span class="line">        charBuffer.flip();</span><br><span class="line">        System.out.println(charBuffer);</span><br><span class="line">        symmertricScramble(charBuffer);</span><br><span class="line">        System.out.println(charBuffer.rewind());</span><br><span class="line">        symmertricScramble(charBuffer);</span><br><span class="line">        System.out.println(charBuffer.rewind());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下:</span></span><br><span class="line">UsingBuffers</span><br><span class="line">sUniBgfuefsr</span><br><span class="line">UsingBuffers</span><br></pre></td></tr></table></figure>

<p>上述代码中，当进入<code>symmertricScramble()</code>方法时缓冲器如下：</p>
<p><img src="https://images.effiu.cn/blog/java/03.png" alt="ByteBuffer细节"></p>
<p>调用<code>get()</code>和<code>put()</code>方法其<code>position</code>指针会改变。<code>get(int pos)</code>和<code>put(int pos)</code>不会改变<code>position</code>指针。</p>
<p><code>hasRemaining()</code>循环到<code>position</code>等于<code>limit</code>。</p>
<p>执行<code>mark()</code>，将<code>mark</code>值设置为<code>position</code>的值。</p>
<p><img src="https://images.effiu.cn/blog/java/04.png" alt="ByteBuffer细节"></p>
<p>两个<code>get()</code>方法后：</p>
<p><img src="https://images.effiu.cn/blog/java/05.png" alt="ByteBuffer细节"></p>
<p>调用<code>reset()</code>，将<code>position</code>设置为<code>mark</code></p>
<p><img src="https://images.effiu.cn/blog/java/06.png" alt="ByteBuffer细节"></p>
<p>调用两次<code>put()</code>设置值</p>
<p><img src="https://images.effiu.cn/blog/java/07.png" alt="ByteBuffer细节"></p>
<p>while循环结束后，<code>position</code>等于<code>limit</code>，由于打印时只会打印<code>position</code>和<code>limit</code>之间的值，所以打印时需要调用<code>rewind()</code>方法把<code>position</code>设置到开始位置。下面是循环结束后缓冲器内容。</p>
<p><img src="https://images.effiu.cn/blog/java/03.png" alt="ByteBuffer细节"></p>
<h4 id="6-内存映射文件"><a href="#6-内存映射文件" class="headerlink" title="6. 内存映射文件"></a>6. 内存映射文件</h4><p>内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件。使用内存映射文件，我们可以就可以假定整个文件都放在内存中，可以把其当做非常大的数组访问，即将文件的某一段内容写入到内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MappedByteBuffer out = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;text.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel()</span><br><span class="line">    	.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, lenght)  <span class="comment">// length是写入到内存的大小</span></span><br></pre></td></tr></table></figure>

<p><code>MappedByteBuffer</code>是<code>ByteBuffer</code>子类。</p>
<p>尽管BIO在用NIO实现后性能有所提高，但是”映射文件访问”往往可以更加显著地加快速度。</p>
<h4 id="7-文件加锁"><a href="#7-文件加锁" class="headerlink" title="7. 文件加锁"></a>7. 文件加锁</h4><p>JDK4引入了文件加锁机制，其允许我们同步访问某个作为共享资源的文件。竞争同一文件的两个线程可能在不同的Java虚拟机上；或者一个是Java线程，另一个是操作系统中其他某个本地线程。文件锁对其他操作系统进程是可见的，因为Java的文件加锁直接映射到了本地操作系统的加锁工具。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">    FileChannel channel = fos.getChannel();</span><br><span class="line">    FileLock fileLock = channel.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Locked File&quot;</span>);</span><br><span class="line">        fileLock.release();</span><br><span class="line">        System.out.println(<span class="string">&quot;Release File&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileChannel</code>的<code>tryLock()</code>、<code>lock()</code>可以获得整个文件的FileLock。<code>tryLock()</code>是非阻塞式的，其尝试获得锁，若获取失败(其他线程持有相同的锁，其不共享时)，将直接从调用方法返回。<code>lock()</code>是阻塞式的，其要阻塞进程直到获得锁或者调用<code>lock()</code>的线程中断或者调用<code>lock()</code>的通道关闭。<code>release()</code>可以释放锁。</p>
<p><code>tryLock(long position, long size, boolean shared)</code>或者<code>lock(long posotion, long size, boolean share)</code>用于对文件的一部分加锁。</p>
<p>对文件加共享锁或者独占锁必须由底层操作系统提供。如操作系统不支持共享锁，那么就只能使用独占锁。</p>
<h3 id="3-BIO、NIO、AIO比较"><a href="#3-BIO、NIO、AIO比较" class="headerlink" title="3. BIO、NIO、AIO比较"></a>3. BIO、NIO、AIO比较</h3><ul>
<li><input disabled="" type="checkbox"> IO概念的比较</li>
</ul>
<ul>
<li>BIO是传统的<code>java.io</code>包，是基于流模型实现的，交互方式是同步、阻塞，即在输入或者输出流时，在完成之前，线程会一直阻塞，其调用顺序非常可靠。<font color='red'>特点</font>：代码简单、直观；IO效率和扩展性低，容易成为应用性能瓶颈。</li>
<li>NIO是Java4引入的<code>java.nio</code>包，提供了<code>Channel</code>、<code>Selector</code>、<code>Buffer</code>等新的抽象，可以构建多路复用、同步非阻塞IO程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO(Asynchronous IO)是Java7引入的包，是NIO的升级版本，提供了异步非阻塞的IO操作方式，异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞，后台处理完成后，操作系统会通知相应的线程进行后续操作。</li>
</ul>
<blockquote>
<p>NIO需要使用者线程不停的轮询IO对象，来确定是否有数据准备好可以读了; AIO则是在数据准备好之后，才会通知数据使用者，不需要不停地轮询。</p>
</blockquote>
<table>
<thead>
<tr>
<th>组合方式</th>
<th>性能分析</th>
</tr>
</thead>
<tbody><tr>
<td>同步阻塞</td>
<td>最常用、最简单。IO性能一般，CPU大部分时间处于空闲状态。<code>java.io</code></td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>提示IO性能的常用手段，尤其网络IO是长连接，同时传输数据不是很多的情况下，提升非常有效，但是会增加CPU消耗。需要考虑增加的IO性能能否补偿CPU消耗。</td>
</tr>
<tr>
<td>异步阻塞</td>
<td>在分布式数据库中经常使用，应用于主从复制上。异步阻塞可以提升网络IO的效率</td>
</tr>
<tr>
<td>异步非阻塞</td>
<td>在一些非常负责的分布式情况下使用，集群之间的消息同步机制使用异步非阻塞机制。适合要传多分相同的数据到集群中不同的机器，同时传输数据流不大但却很频繁的情况。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 知识点</title>
    <url>/blog/2019/09/02/interview/spring/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="1-Spring-AOP"><a href="#1-Spring-AOP" class="headerlink" title="1. Spring AOP"></a>1. Spring AOP</h3><h5 id="1-AOP技术"><a href="#1-AOP技术" class="headerlink" title="1. AOP技术"></a>1. AOP技术</h5><ul>
<li>静态代理，使用AOP框架提供的命令进行编译，在编译阶段就可以生成AOP代理类，<strong>编译时增强</strong>。<ul>
<li>编译时编织，通过特殊编译器实现</li>
<li>类加载时编织，通过特殊类加载器实现</li>
</ul>
</li>
<li>动态代理，在运行时在内存中生成AOP动态代理类，<strong>运行时增强</strong>。目前Spirng的动态代理库：<ul>
<li>JDK动态代理，JDK动态代理通过反射接收被代理类，被代理类必须实现一个接口。核心是<code>InvacationHandler</code>和<code>Proxy</code>类</li>
<li>cglib(code generation library)，其是一个代码生成类库，可以在运行时动态生成某个类的子类，即通过继承的方式代理，因此不能使用cglib代理<code>final</code>类。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>与AspectJqub</li>
</ol>
<ul>
<li>代理方式不同<ul>
<li>Spring AOP 基于动态代理方式实现。</li>
<li>AspectJ AOP 基于静态代理方式实现。</li>
</ul>
</li>
<li>PointCut 支持力度不同<ul>
<li>Spring AOP <strong>仅</strong>支持方法级别的 PointCut 。</li>
<li>AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li>
</ul>
</li>
</ul>
<h3 id="2-Spring-Transaction"><a href="#2-Spring-Transaction" class="headerlink" title="2. Spring Transaction"></a>2. Spring Transaction</h3><h5 id="1-事务管理类型："><a href="#1-事务管理类型：" class="headerlink" title="1. 事务管理类型："></a>1. 事务管理类型：</h5><ul>
<li>声明式事务：通过使用注解或基于XML的配置事务，从而事务管理与业务代码分离。</li>
<li>编程试事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li>
</ul>
<h5 id="2-Spring事务如何和不同的数据持久层框架做集成"><a href="#2-Spring事务如何和不同的数据持久层框架做集成" class="headerlink" title="2. Spring事务如何和不同的数据持久层框架做集成"></a>2. Spring事务如何和不同的数据持久层框架做集成</h5><ol>
<li>Spring 事务的管理，是通过<code>org.springframework.transaction.PlatformTransactionManager</code>进行管理。</li>
<li>其有抽象子类<code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code>，基于<a href="https://blog.csdn.net/carson_ho/article/details/54910518">模板方法模式</a>，实现事务整体逻辑的骨架，而抽象<code>#doCommit(DefaultTransactionStatus status)</code>、<code>#doRollback(DefaultTransactionStatus status)</code>等等方法，交由子类类来实现。</li>
<li><strong>不同的数据持久层框架，会有其对应的<code>PlatformTransactionManager</code>实现类</strong>。如下图：</li>
</ol>
<p><img src="https://images.effiu.cn/blog/spring/01.png" alt="Spring事务持久层实现"></p>
<ol start="4">
<li><p><code>@Transactional</code> 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。Spring建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， <code>@Transactional</code>注解应该只被应用到<code>public</code>方法上，这是由 Spring AOP 的本质决定的。如果你在 <code>protected</code>、<code>private</code>或者默认可见性的方法上使用<code>@Transactional</code>注解，这将被忽略，也不会抛出任何异常。</p>
</li>
<li><p><code>@Transactional</code> 注解的属性，会解析成 <code>org.springframework.transaction.TransactionDefinition</code> 对象，即事务定义。TransactionDefinition 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; <span class="comment">// 事务的传播行为</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; <span class="comment">// 事务的隔离级别</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>; <span class="comment">// 事务的超时时间</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 事务是否只读</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 事务的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Transactional</code>注解的<code>rollbackFor</code>、<code>rollbackForClassName</code>、<code>noRollbackFor</code>、<code>noRollbackForClassName</code> 体现在<code>TransactionDefinition</code>的实现类<code>RuleBasedTransactionAttribute</code>中。</p>
</li>
</ol>
<h5 id="3-Spring-事务传播级别"><a href="#3-Spring-事务传播级别" class="headerlink" title="3. Spring 事务传播级别"></a>3. Spring 事务传播级别</h5><p>在<code>TransactionDefinition</code>接口中，定义了<strong>三类七种</strong>传播级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransactionDefinition.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则以非事务的方式继续运行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 不支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的事务。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 其他情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则等价于 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_REQUIRED&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h5 id="4-TransactionStatus"><a href="#4-TransactionStatus" class="headerlink" title="4. TransactionStatus"></a>4. TransactionStatus</h5><p>记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransactionStatus.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是新创建的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有 Savepoint</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_NESTED&#125; 传播级别使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 flush 操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否事务已经完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题知识点整理</title>
    <url>/blog/2019/09/01/interview/interview/</url>
    <content><![CDATA[<h4 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1. Spring"></a>1. Spring</h4><ul>
<li><a href="http://www.iocoder.cn/Fight/Interview-poorly-asked-Spring-IOC-process-1/">面试问烂的 Spring IOC 过程</a></li>
<li><a href="http://www.iocoder.cn/Fight/Interview-poorly-asked-Spring-AOP-principles/">面试问烂的 Spring AOP 原理</a></li>
<li><a href="http://www.iocoder.cn/Fight/Interview-poorly-asked-SpringMVC-process/">面试问烂的 Spring MVC 原理</a></li>
</ul>
<h4 id="2-Dubbo"><a href="#2-Dubbo" class="headerlink" title="2. Dubbo"></a>2. Dubbo</h4><h4 id="3-Java"><a href="#3-Java" class="headerlink" title="3. Java"></a>3. Java</h4><h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h4><ul>
<li><a href="https://www.cnkirito.moe/spi/">JAVA拾遗–关于SPI机制</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo</title>
    <url>/blog/2019/09/01/interview/dubbo/</url>
    <content><![CDATA[<p>Dubbo常见知识点。</p>
<a id="more"></a>

<h4 id="1-框架的分层方式"><a href="#1-框架的分层方式" class="headerlink" title="1. 框架的分层方式"></a>1. 框架的分层方式</h4><p><img src="https://images.effiu.cn/blog/dubbo/01.png" alt="dubbo框架"></p>
<ul>
<li>共有10层。左侧淡蓝背景为服务消费方使用的接口；右侧淡绿色背景为服务提供方使用的接口；中轴线上是双方都使用的接口。</li>
<li>从上至下分为10层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系。Service和Config均为API，其余为SPI(Service Provider Interface,一种服务发现机制)。</li>
</ul>
<p>各层说明：</p>
<ul>
<li><p><strong>Service业务层</strong>：业务代码的接口与实现。</p>
</li>
<li><p><strong>Config配置层</strong>：对外配置接口，以<code>ServiceConfig</code>、<code>ReferenceConfig</code>为中心，可以直接初始化配置类，也可以通过Spring解析配置生成配置类。</p>
</li>
<li><p><strong>Proxy服务代理层</strong>：服务接口透明代理，生成服务的客户端Stub和服务端Skeleton，以<code>ServiceProxy</code>为中心，扩展接口为<code>ProxyFactory</code>。Dubbo会为provider和consumer生成代理，代理之间进行网络通信。</p>
</li>
<li><p><strong>registry注册中心层</strong>：封装服务地址的注册与发现，以服务URL为中心，扩展接口为<code>RegistryFactory</code>、<code>Registry</code>、<code>RegistryService</code>。</p>
</li>
<li><p><strong>cluster路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以<code>Invoker</code>为中心，扩展接口为<code>Cluster</code>、<code>Directory</code>、<code>Router</code>、<code>LoadBalance</code>。</p>
</li>
<li><p><strong>monitor监控层</strong>：RPC调用次数和时间监控，以<code>Statistics</code>为中心，扩展接口为<code>MonitorFactory</code>、<code>MonitorService</code>、<code>Monitor</code>。</p>
</li>
<li><p><strong>protocol远程调用层</strong>：封装RPC调用，以<code>Invocation</code>、<code>Result</code>为中心，扩展接口为<code>Protocol</code>、<code>Invoker</code>、<code>Exporter</code></p>
</li>
<li><p><strong>exchange信息交换层</strong>：封装请求响应模式，同步转异步，以<code>Request</code>、<code>Response</code>为中心，扩展接口为<code>Exchanges</code>、<code>ExchangeChannel</code>、<code>ExchangeClient</code>、<code>ExchangeServer</code>。</p>
</li>
<li><p><strong>transport网络传输层</strong>：抽象mima和netty为统一接口，以<code>Message</code>为中心，扩展接口为<code>Channel</code>、<code>Transport</code>、<code>Client</code>、<code>Server</code>、<code>Codec</code></p>
</li>
<li><p><strong>serialize数据序列化层</strong>，可复用的一些工具，扩展接口为<code>Serialization</code>、<code>ObjectInput</code>、<code>ObjectOutput</code>、<code>ThreadPool</code></p>
</li>
</ul>
<p><img src="https://images.effiu.cn/blog/dubbo/02.png" alt="dubbo依赖关系"></p>
<p><img src="https://images.effiu.cn/blog/dubbo/03.png" alt="Dubbo的调用过程"></p>
<h4 id="2-中的Filter"><a href="#2-中的Filter" class="headerlink" title="2. 中的Filter"></a>2. 中的Filter</h4><ul>
<li>Dubbo的异常处理核心为Provider的异常过滤器<code>ExceptionFilter</code>对调用结果各种情况的处理。具体见<a href="http://svip.iocoder.cn/Dubbo/filter-exception-filter/">dubbo异常处理</a></li>
<li>参数校验功能，通过参数校验过滤器 alidationFilter 来实现。在 Dubbo Provider和Consumer都可生效。<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/parameter-validation.html">dubbo参数校验</a></li>
<li>Dubbo通过CacheFilter过滤器，提供结果缓存的功能，且既可以适用于Consumer也可以适用于Provider。<a href="http://svip.iocoder.cn/Dubbo/filter-cache-filter/">dubbo Cache</a></li>
</ul>
<h4 id="3-优雅停机"><a href="#3-优雅停机" class="headerlink" title="3. 优雅停机"></a>3. 优雅停机</h4><p>Dubbo是通过JDK的<code>ShutdownHook</code>来完成优雅停机的，所以如果用户使用<code>kill -9 PID</code>等强制关闭指令，是不会执行优雅停机的。<code>kill PID</code>，才会执行。</p>
<p>服务提供方优雅停机过程：</p>
<ul>
<li>停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。</li>
<li>然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。</li>
</ul>
<p>服务消费方的优雅停机过程：</p>
<ul>
<li><p>停止时，不再发起新的调用请求，所有新的调用在客户端即报错。</p>
</li>
<li><p>然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。</p>
</li>
</ul>
<p>设置优雅停机：<code>dubbo.service.shutdown.wait=15000</code>。</p>
<p>若<code>ShudownHook</code>不能生效，可以自行调用，使用tomcat等容器部署的场景，建议通过扩展<code>ContextListener</code>等自行调用<code>ProtocolConfig.destroyAll();</code>实现优雅停机。</p>
<h4 id="4-通信框架"><a href="#4-通信框架" class="headerlink" title="4. 通信框架"></a>4. 通信框架</h4><ul>
<li>Netty3</li>
<li>Netty4</li>
<li>Mina</li>
<li>Grizzly</li>
</ul>
<p>默认是<strong>Netty4</strong>。</p>
<h4 id="5-序列化方式"><a href="#5-序列化方式" class="headerlink" title="5. 序列化方式"></a>5. 序列化方式</h4><p>对应<strong>serialize数据序列化层</strong>，Dubbo 目前支付如下 7 种序列化方式：</p>
<ul>
<li>Hessian2 ：基于 Hessian 实现的序列化拓展。<strong>dubbo</strong>协议的默认序列化方案。</li>
<li>Dubbo ：Dubbo 自己实现的序列化拓展。 <a href="http://svip.iocoder.cn/Dubbo/serialize-2-dubbo/">《精尽 Dubbo 源码分析 —— 序列化（二）之 Dubbo 实现》</a> 。</li>
<li>Kryo ：基于<strong>kryo</strong>实现的序列化拓展。 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/serialization.html">《Dubbo 用户指南 —— Kryo 序列化》</a></li>
<li>FST ：基于<strong>FST</strong>实现的序列化拓展。 <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/serialization.html">《Dubbo 用户指南 —— FST 序列化》</a></li>
<li>JSON ：基于 <a href="https://www.oschina.net/p/fastjson">Fastjson</a> 实现的序列化拓展。</li>
<li>NativeJava ：基于 Java 原生的序列化拓展。</li>
<li>CompactedJava ：在 <strong>NativeJava</strong> 的基础上，实现了对 ClassDescriptor 的处理。</li>
</ul>
<h4 id="6-负载均衡策略"><a href="#6-负载均衡策略" class="headerlink" title="6. 负载均衡策略"></a>6. 负载均衡策略</h4><p>对应Cluster路由层的<strong>loadBalance</strong>组件。Dubbo有4钟负载均衡策略。默认使用random随机调用策略。</p>
<ul>
<li>Random LoadBalance，随机，按照权重设置随机概率。</li>
<li>RoundRobin LoadBalance，轮询，按照公约后的权重设置轮询比率。存在慢的提供者请求累积问题。</li>
<li>LeastActive LoanBalance，最少活跃调用数，相同活跃的随机，活跃数指调用计数差。慢的提供者收到更少的请求。</li>
<li>ConsistentHash LoadBalance，一致性hash，相同参数的请求总是发到同一提供者。</li>
</ul>
<h4 id="7-集群容错策略"><a href="#7-集群容错策略" class="headerlink" title="7. 集群容错策略"></a>7. 集群容错策略</h4><p>对应Cluster路由层的<strong>Cluster</strong>组件，Dubbo有6种容错策略：</p>
<ul>
<li><strong>failOver Cluster</strong>，失败自动切换，出现失败时，重试其他服务器。通常用于<strong>读操作</strong>，重试会带来延迟。可以设置重试次数<code>retries=2</code></li>
<li><strong>failfast Cluster</strong>，快速失败，只发起一次调用，失败立即报错。通常用于<strong>非幂等性的写操作</strong>。</li>
<li><strong>failsafe Cluster</strong>，失败安全，出现异常时，直接忽略。通常用于<strong>写入审计日志等操作</strong>。</li>
<li><strong>failback Cluster</strong>，失败自动恢复，后台记录失败请求，定时重发。通常用于<strong>消息通知操作</strong>。</li>
<li><strong>forking Cluster</strong>，并行调用多个服务器，只要一个成功即返回。用于<strong>实时性较高的读操作</strong>，会浪费更多的资源。设置最大并行次数<code>fork=2</code></li>
<li><strong>broastcast Cluster</strong>，广播调用所有提供者，逐个调用，任意一台报错则报错。用于<strong>通知所有提供者更新缓存或者日志等本地资源</strong>。</li>
</ul>
<h4 id="8-动态代理策略"><a href="#8-动态代理策略" class="headerlink" title="8. 动态代理策略"></a>8. 动态代理策略</h4><p>对应Proxy代理层。Dubbo动态代理使用了Javassist和JDK两种方式。默认是Javassist，可以通过SPI方式切换为JDK。</p>
<p>Javassist代理的<strong>字节码bytecode</strong>生成代理类性能最好。</p>
<h4 id="9-SPI的设计思想"><a href="#9-SPI的设计思想" class="headerlink" title="9. SPI的设计思想"></a>9. SPI的设计思想</h4><p><a href="https://www.cnkirito.moe/spi/">JAVA拾遗–关于SPI机制</a></p>
<ul>
<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。Dubbo 有很多的拓展点，且每个扩展点有多个实现</li>
<li>如果扩展点加载失败，连扩展点的名称都拿不到了。</li>
<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>
</ul>
<h4 id="10-服务监控和惯例"><a href="#10-服务监控和惯例" class="headerlink" title="10. 服务监控和惯例"></a>10. 服务监控和惯例</h4><ul>
<li>Dubbo 管理平台 + 监控平台，<strong>Dubbo Monitor</strong>监控平台。<strong>Dubbo admin</strong>基于注册中心的管理平台。</li>
</ul>
<ol>
<li><p>dubbo服务降级</p>
<p>比如说服务A调用服务B，结果服务B挂掉了。服务A再重试几次调用服务B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。Dubbo中实现降级有两种方式：</p>
<ul>
<li>Dubbo自带的服务降级功能，并不能实现现代微服务的<strong>熔断器</strong>的功能</li>
<li>引入支持服务降级的组件<ul>
<li>Alibaba Sentinel</li>
<li>Netflix Hystrix，已停止维护，且与Dubbo集成度不高。</li>
</ul>
</li>
</ul>
</li>
<li><p>dubbo限流</p>
<p>Alibaba Sentinel。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Sentinel、Codis和Cluster</title>
    <url>/blog/2019/08/26/redis/10_cluster/</url>
    <content><![CDATA[<p><strong>Redis Sentinel</strong>(哨兵)是一个抵抗节点故障的高可用方案，当故障发生时进行主从切换，程序可以不用重启。</p>
<p>在大数据高并发场景下，单个Redis实例在内存上和CPU利用率上都不能满足海量数据的存取。所以Redis集群方案应运而生—<strong>Codis</strong>，其可以将分布在多台机器上的众多CPU核心计算能力聚集到一起，完成海里数据存储和高并发读写操作。</p>
<p><strong>Redis Cluster</strong>是Redis自己提供的Redis集群化方案。</p>
<a id="more"></a>

<h3 id="1-Sentinel"><a href="#1-Sentinel" class="headerlink" title="1. Sentinel"></a>1. Sentinel</h3><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h4><p>Redis Sentinel集群可以当做一个zookeeper集群，是集群高可用的心脏，其一般由3~5个节点组成，即使挂了某些节点集群仍然可以正常运转。</p>
<p>Sentinel负责监控主从节点的健康，当主节点挂掉时，自动选择一个最优的节点切换为主节点。客户端连接集群时，会首先连接sentinel，通过sentinel查询主节点的地址，然后再去连接主节点进行数据交互。若主节点发生故障时，客户端会重新向sentinel要地址，sentinel会将最新的主节点地址告诉客户端。如此应用程序不需要重启即可自动完成节点切换。</p>
<p><img src="https://images.effiu.cn/blog/redis/33.png" alt="Sentinel主从切换"></p>
<p>当master 挂掉后原先的主从复制断开了，客户端与主节点也断开了。从节点被提升为新的主节点，其它从节点开始和新的主节点建立复制关系。客户端通过新的主节点继续进行交互。Sentinel会持续监控已经挂掉的节点，直到其恢复正常，集群会将其恢复为从节点，并从新的主节点那里建立复制关系。</p>
<p><img src="https://images.effiu.cn/blog/redis/34.png" alt="sentinel"></p>
<h4 id="2-消息丢失"><a href="#2-消息丢失" class="headerlink" title="2. 消息丢失"></a>2. 消息丢失</h4><p>Redis主从复制采用异步复制，意味着当主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就会丢失，但是也要尽量保证少丢失，其有两个选项可以限制主从延迟过大</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 1	## 表示至少有一个节点正在进行复制，否则停止对外写服务</span><br><span class="line">min-slaves-max-lag 10	## 异常复制指若10s没有收到从节点的反馈，就意味着节点同步异常(网络断开或者未反馈)</span><br></pre></td></tr></table></figure>

<h4 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h4><p>客户端通过sentinel发现主从节点的地址，然后通过这些地址建立响应的连接进行数据存取操作。</p>
<p>Sentinel进行主从切换时，客户端如何更新地址呢？连接池建立新连接时，会查询主库地址，然后与内存中的主库地址进行比对，若变更了则断开之前所有连接，重新使用新地址建立连接。若旧的主库挂掉了，那么所有正在使用的连接都会被关闭，然后重连接时就会用上新地址。主从切换后，原来的主库会被降级到从库，所有修改性指令都会抛出<code>ReadonlyError</code>，若没有修改性指令，连接不会切换。</p>
<ul>
<li><input disabled="" type="checkbox"> sentinel集群搭建</li>
</ul>
<h3 id="2-Codis"><a href="#2-Codis" class="headerlink" title="2. Codis"></a>2. Codis</h3><h4 id="1-Codis"><a href="#1-Codis" class="headerlink" title="1. Codis"></a>1. Codis</h4><p>Codis是Redis的集群方案之一。是由中国人开发并开源的。</p>
<p><img src="https://images.effiu.cn/blog/redis/35.png" alt="Codis"></p>
<p>Codis是一个代理中间件，与Redis一样也使用Redis协议对外提供服务，当客户端向Codis发生指令时，Codis负责将指令转发到后面的Redis实例执行，并将返回结果再转回给客户端。</p>
<p>Codis上挂载的所有Redis实例构成一个Redis集群，可以动态改变Redis实例。</p>
<p>Codis是无状态的，其只是一个转发代理中间件，意味着我们可以启动多个Codis实例，供客户端使用，每个Codis节点都是对等的。单个Codis可以支撑的QPS有限，可以通过启动多个Codis代码增加整体的QPS能力，同时增加容错率。</p>
<p><img src="https://images.effiu.cn/blog/redis/36.png" alt="Codis"></p>
<h4 id="2-Codis分片原理"><a href="#2-Codis分片原理" class="headerlink" title="2. Codis分片原理"></a>2. Codis分片原理</h4><p>Codis要负责将特定key转发到特定的Redis实例，其实现如下：Codis将所有的key默认分为1024个槽位(slot)，首先对客户端传送过来的key进行crc32运算疾患哈希值，然后将hash值对1024进行求余运算，余数为对应key的槽位。槽位数量默认为1024，是可以配置的。</p>
<p><img src="https://images.effiu.cn/blog/redis/37.png" alt="slot"></p>
<p>每个槽位都唯一映射到后面的多个Redis实例之一，Codis会在内存中维护槽位和Redis实例的映射关系。这样当Codis接收到一个读写请求时，就知道转发到那个Redis实例中了。</p>
<h4 id="3-Codis实例之间槽位关系同步"><a href="#3-Codis实例之间槽位关系同步" class="headerlink" title="3. Codis实例之间槽位关系同步"></a>3. Codis实例之间槽位关系同步</h4><p>若Codis槽位映射关系只存储在内存中，那么不同的Codis实例之间的槽位关系无法得到同步。所有Codis需要一个分布式配置存储数据库专门持久化槽位关系。</p>
<p><img src="https://images.effiu.cn/blog/redis/38.png" alt="slot 同步"></p>
<p>Codis将槽位关系存储在zk中，提共了一个Dashboard可以用来观察和修改槽位关系，若槽位关系发生变化，Codis Proxy将会监听到变化并同步槽位关系。</p>
<h4 id="4-扩容"><a href="#4-扩容" class="headerlink" title="4. 扩容"></a>4. 扩容</h4><p>当Redis集群扩容时，需要对槽位关系进行调整，将一半槽位划分到新的节点。这意味着需要对一般的槽位对应的key进行迁移，迁移到新Redis实例。</p>
<p>Codis需要找到槽位对应的所有key，所以Codis对Redis进行了改造，增加了<code>SLOTSSCAN</code>命令，可以遍历执行slot下所有的key，Codis通过<code>SLOTSSCAN</code>扫描出所有待迁移槽位的key，然后迁移每个key到新的Redis节点。</p>
<p>在迁移过程中，Codis还是会接受到新的请求打在当前槽位上，因为当前槽位的数据同时存在于新旧两个槽位中。当Codis接收到位于正在迁移的key后，会立即加强对当前单个kdy迁移，玩抽后在将请求和转发给新的Redis实例中。</p>
<h4 id="5-Codis代价"><a href="#5-Codis代价" class="headerlink" title="5. Codis代价"></a>5. Codis代价</h4><p>Codis给Redis带来了扩容的同时，也会损失一些其他特性，因为Codis所有的key分布在不同的Redis实例中，所有不能支持事务了，事务只能在但实例中完成。<code>rename</code>操作也很危险，它的参数时两个key，若两个key在不同的Redis实例中，其时无法完成的。Codis也给出了一系列不支持的命令列表。</p>
<p>同样为了扩容，单个key的内容不宜过大，因为集群迁移的最小单位时key，对于一个hash结构，其会使用<code>hgetall</code>指令拉取所有内容，然后使用<code>hmset</code>放置到另一个节点。若<code>hash</code>内部K和V太多，会带来迁移卡顿。官方建议总字节量不超过1M。</p>
<p>Codis作为Proxy增加了中间层，所以开销比单个Redis大，因为数据包多走了一个网络节点。</p>
<p>Codis的集群配置使用zk实现，意味着在部署上增加了zk运维代价。</p>
<h4 id="6-Codis优点"><a href="#6-Codis优点" class="headerlink" title="6. Codis优点"></a>6. Codis优点</h4><p>Codis涉及上比Redis Cluster简单很多，其将分布式问题交给了三方zk/etcd去负责，而Redis Cluster内部实现非常复杂，为了实现去中心化，混合使用了Raft和Gossip协议，以及大量需要调优的配置参数。集群出现问题时，一般无从下手。</p>
<h3 id="3-Cluster"><a href="#3-Cluster" class="headerlink" title="3. Cluster"></a>3. Cluster</h3><h4 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1. 原理"></a>1. 原理</h4><h5 id="1-Cluster"><a href="#1-Cluster" class="headerlink" title="1. Cluster"></a>1. Cluster</h5><p>Redis Cluster是去中心化的，如下图。该集群有3个Redis节点，每个节点负责整个集群的一部分数据。三个节点相互连接组成一个对等的集群，节点之间通过一种特殊的二进制协议相互交互集群信息。</p>
<p><img src="https://images.effiu.cn/blog/redis/39.png" alt="cluster"></p>
<p>Redis Cluster将所有数据划分为16384(2^14)个slot，每个节点负责部分槽位。槽位信息存储在每个节点中，所以其不需要另外的存储介质存储节点槽位信息。</p>
<p>当Redis Cluster的客户端连接集群时，其会得到一份集群槽位配置信息。这样客户端定位key时，可以直接定位到模板节点，但也会出现槽位信息在客户端与服务端不一致的情况，所以需要纠正机制来实现槽位信息的校验调整。</p>
<p>Redis Cluster 的每个节点会将集群的配置信息持久化到配置文件中，所以需要确保配置文件是可写的。</p>
<h5 id="2-槽位定位算法"><a href="#2-槽位定位算法" class="headerlink" title="2. 槽位定位算法"></a>2. 槽位定位算法</h5><p>Cluster 默认会对key进行crc16算法进行hash得到一个整数值，然后用这个整数值对2^14进行取模运算得到具体槽位。Cluster允许用户强制某个key挂载特定的槽位上，通过在key字符串中嵌入tag标记，强制key在某个槽位中。</p>
<h5 id="3-跳转"><a href="#3-跳转" class="headerlink" title="3. 跳转"></a>3. 跳转</h5><p>当客户端向一个错误的节点发出指令，该节点会发现指令的key所在的槽位并不数据自己，这时会向客户端发送一个特殊的跳转指令携带模板操作的节点地址，告诉客户端去连这个节点获取数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET x</span><br><span class="line">-MOVED 3999 127.0.0.1:6381</span><br></pre></td></tr></table></figure>

<p><code>MOVED</code>指令第一个参数是key对应的槽位编号，第二个是目标节点地址。<code>-</code>表示是错误消息，客户端收到<code>MOVEN</code>指令后，要立即纠正本地槽位映射表。</p>
<h4 id="2-迁移"><a href="#2-迁移" class="headerlink" title="2. 迁移"></a>2. 迁移</h4><p>Redis Cluster提供了<code>redis-trib</code>工具让运维人员收到调整槽位分配情况，其是使用<strong>Ruby</strong>语言开发，通过组合各种原生的Redis Cluster指令实现。</p>
<p><img src="https://images.effiu.cn/blog/redis/40.png" alt="迁移过程"></p>
<p>Redis的迁移单位是slot，Redis一个槽一个槽进行迁移，当一个槽正在迁移时，这个槽就处于重疾过度状态。原节点状态为<code>migrating</code>，目标节点状态为<code>importing</code>，表示数据整从源流向目标。</p>
<p><font color='red'>迁移过程</font>：迁移工具<code>redis-trib</code>首先在源和目标节点设置好中间状态，然后一次性获取源节点槽位的所有key列表(<code>keysinslot</code>指令，可以部分获取)，再挨个进行迁移。每个key迁移过程是以源节点作为目标节点的“客户端”进行的。源节点对当前key执行dump指令得到序列化内容，通过源节点向目标节点发送指令<code>restore</code>携带序列化内容作为参数，目标节点再进行反序列化就可以将内容恢复到目标节点内存中，返回返回客户端OK，源节点再将当前节点的key信息删除掉。</p>
<ul>
<li>从源节点获取内容</li>
<li>存到目标节点</li>
<li>从源节点删除内容</li>
</ul>
<p>整个迁移过程是同步的，在目标节点执行<code>restore</code>指令到源节点删除key之间，源节点的主线程会处于阻塞状态，直到key被删除。</p>
<p>若迁移过程出现网络分区，整个slot迁移了一半，那么这两个节点处于中间过渡状态，下次迁移工作重新连上时，会提示用户继续迁移。</p>
<p>迁移过程中若每个key的内容都很小，那么<code>migrate</code>会非常快，也不会影响客户端的正常访问，若key非常大，那么因为<code>migrate</code>指令是阻塞指令，所以会同时影响源节点和目标节点，所以在集群环境中应尽量避免大key的产生。</p>
<p>迁移过程中，客户端的访问流程会发生变化，如上图。因为新旧两个节点对应的槽位都存在部分key数据。</p>
<ul>
<li>客户端先尝试访问旧节点，若对应数据还在槽里，那么旧节点正常处理。</li>
<li>若对应的数据不在旧节点里，那么要么该数据在新节点中，要么根本不存在。旧节点不确定是哪种情况，所以会向客户端返回一个<code>-ASK targetNodeAddr</code>重定向指令</li>
<li>客户端收到重定向指令后，先去目标节点执行一个不带任何参数的<code>asking</code>指令</li>
<li>若目标节点收到指令后，返回OK，那么在向目标节点重新执行操作指令。</li>
<li>否则查询失败。</li>
</ul>
<p>在迁移过程中，迁移完成之前，迁移中的槽位不归目标节点管理，所以若向目标节点发送该槽位指令，节点是不认识的，其会向客户端返回<code>-MOVED</code>重定向到源目标节点，这时就会形成重定向循环。<code>asking</code>指令就是打开目标节点的选项，告诉目标节点处理当前指令(即使当前槽位仍不归目标节点管理)。</p>
<p>迁移过程影响了服务效率。</p>
<h4 id="3-容错"><a href="#3-容错" class="headerlink" title="3. 容错"></a>3. 容错</h4><p>Redis Cluster可以为每个主节点设置若干个从节点，单节点故障时，集群会自动将其中某个节点提升为主节点。若某个主节点没有从节点，那么当其发生故障时，集群将处于不可用状态。Redis提供了一个参数<code>cluster-require-full-coverage</code>允许部分节点故障。</p>
<p>Redis Cluster提供了<code>cluster-node-timeout</code>参数，当某个节点处于网络抖动(网络不稳定状态)而失联时，若失联时间超过<code>timeout</code>，那么可以认为该节点出现故障，需要进行主从切换。若没有该设置，那么网络抖动将会导致频繁的主从切换。<code>cluster-slave-validity-factor</code>作为倍乘系数放大该<code>timeout</code>。</p>
<p>Redis Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有节点都认为其失联。所以集群经过一个协商过程，只有大多数节点都认为该节点失联，集群才会认为该节点需要进行主从切换容错。</p>
<p>Redis集群节点采用<code>Gossip</code>协议广播自己的状态以及自己对整个集群认知的改变。若一个节点A发现节点B失联(PFAIL，Possibly Fail)，那么其会将这条信息进行集体广播，其他节点也会收到这个失联信息。若某个节点收到了节点B失联的数量已经达到了集群的大多数，就可以标记为确定失联状态(Fail)，然后向整个集群广播，强迫其他节点也接受该节点以下线的事实，并立即对该节点进行主从切换。</p>
<h4 id="4-槽位迁移感知"><a href="#4-槽位迁移感知" class="headerlink" title="4. 槽位迁移感知"></a>4. 槽位迁移感知</h4><p>当Cluster中某个槽位迁移完成后，client如何感知槽位的变化呢？</p>
<p>客户端保留了槽位和节点映射关系表，其需要即时更新，才可以保证某条指令发的正确的节点中。</p>
<p>前面例子中，有两个特殊指令<code>moved</code>和<code>asking</code>。两个都是重定向指令。</p>
<p><code>moved</code>是用来纠错的。如果我们将指令发送到了错误的节点，该节点发现对应的指令槽位不归自己管理，就会将目标节点的地址随同 <code>moved</code> 指令回复给客户端通知客户端去目标节点去访问。客户端就会刷新自己的槽位关系表，然后重试指令，后续所有打在该槽位的指令都会转到目标节点。</p>
<p><code>asking</code>是用来纠正槽位的。当旧节点收到客户端的请求后，若旧节点不存在该数据，就会给客户端返回一个<code>asking_error</code>携带上目标节点地址。客户端收到后，就回去目标节点去尝试。客户端不会刷新槽位映射关系表，因为它只是临时纠正该指令的槽位信息，不影响后续指令。</p>
<h4 id="5-集群变更感知"><a href="#5-集群变更感知" class="headerlink" title="5. 集群变更感知"></a>5. 集群变更感知</h4><p>若服务器节点变更，客户端应该即时得到通知以便实时刷新节点关系表：</p>
<ul>
<li>目标节点挂掉了，客户端会抛出一个 <code>ConnectionError</code>，紧接着会随机挑一个节点来重试，这时被重试的节点会通过 <code>moved error</code> 告知目标槽位被分配到的新的节点地址。</li>
<li>运维手动修改了集群信息，将 master 切换到其它节点，并将旧的 master 移除集群。这时打在旧节点上的指令会收到一个 <code>ClusterDown</code> 的错误，告知当前节点所在集群不可用 (当前节点已经被孤立了，它不再属于之前的集群)。这时客户端就会关闭所有的连接，清空槽位映射关系表，然后向上层抛错。待下一条指令过来时，就会重新尝试初始化节点信息。</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 扩展</title>
    <url>/blog/2019/08/26/redis/11_extension/</url>
    <content><![CDATA[<p>Redis 5.0增加了很多特色功能，其中最大的新特性就是新的数据结构——Stream，其是一个新的强大的支持多播的可持久化消息队列。<font color='red'>Stream 弥补了Pub/Sub的不能持久化的缺陷</font>。</p>
<p><code>info</code>指令用于查看Redis内部一些列运行参数。</p>
<p>通过<code>set</code>指令设置随机数加锁，通过<strong>luascript</strong>解锁的方式，<a href="/blog/2019/08/19/redis/2_distribute_lock/">具体见分布式锁</a>，仍然存在缺陷。在Sentine集群环境中，若主节点挂掉，从节点升级为主节点后，可能会丢失部分数据，若丢失了锁(客户端A加的锁)，那么在新节点没有锁，当客户端B请求加同样的锁时，就会成功。这种不安全也仅仅是在主从发生<code>failover</code>的情况下才会产生，而且持续时间极短，业务系统多数情况下可以容忍。</p>
<p>Redis所有数据结构都可以设置过期时间。</p>
<a id="more"></a>

<h3 id="1-Stream"><a href="#1-Stream" class="headerlink" title="1. Stream"></a>1. Stream</h3><h4 id="1-Stream-原理"><a href="#1-Stream-原理" class="headerlink" title="1. Stream 原理"></a>1. Stream 原理</h4><p><img src="https://images.effiu.cn/blog/redis/41.png" alt="stream"></p>
<p>Redis Stream 结构如上图所示，其有一个消息队列，每个消息都有一个唯一id和对应的内容。消息是支持持久化后，即Redis重启后消息还在。</p>
<p>每个Stream都有一个唯一名称，即Redis的key。在使用<code>xadd</code>追加消息时自动创建。</p>
<p>每个stream都可以挂多个消费组，每个消费组都有一个游标<code>last_delivered_id</code>，在Stream上往前移动，表示当下消费组消费到哪条消息了。每个消费组都有一个Stream内唯一的名称，消费组不会自动创建，需要单独的指令<code>xgroup_create</code>进行创建，需要指定从Stream的哪个消息ID开始消费，该ID用来初始化<code>last_delivered_id</code>。</p>
<p>每个消费组的状态都是独立的，即同一个Stream内部的消息会被每个消费组都消费。</p>
<p>同一个消费组可以挂载多个消费者，这些消费者之间是竞争关系，任意一个消息只能被同一消费组消费一次(被消费组中某个消费者消费)，每个消费组都有组内唯一名称。</p>
<p>消费者内部有维护一个状态变量<code>pending_ids</code>，记录了当前已经被客户的读取的消息，但未收到<code>ack</code>。若客户端没有<code>ack</code>，<code>pending_ids</code>内的消息id会越来越多，一旦收到<code>ack</code>，<code>pending_ids</code>中的消息id就会减少。Redis官方称<code>ack</code>为<code>PEL</code>(Pending Entries List)，用来保证客户端至少消费了该消息一次。</p>
<p>消息ID的形式是<code>timestampInMills-sequence</code>，例如：<code>1527846880572-5</code>，其表示当前消息在毫秒时间戳<code>1527846880572</code>时产生的第5个消息。消息ID有服务器生成，也可以由客户端自己指定，但格式必须是<code>整数-整数</code>，且后面加入的ID必须大于前面的ID。</p>
<p>消息内容是键值对形式。</p>
<h4 id="2-Stream-命令"><a href="#2-Stream-命令" class="headerlink" title="2. Stream 命令"></a>2. Stream 命令</h4><h5 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h5><ul>
<li><code>xadd</code>，追加消息</li>
<li><code>xdel</code>，删除消息，删除仅仅是设置标志位，不影响消息总长度</li>
<li><code>xrange</code>，获取消息列表，会自动过滤已删除的消息</li>
<li><code>xlen</code>，消息长度</li>
<li><code>del</code>，删除Stream</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># * 号表示自动生成消息ID，后面是 key/value</span></span></span><br><span class="line">127.0.0.1:6379&gt; xadd stream * name a age 27</span><br><span class="line">1527849609889-0  # 生成的消息 ID</span><br><span class="line">127.0.0.1:6379&gt; xadd stream * name b age 29</span><br><span class="line">1527849629172-0</span><br><span class="line">127.0.0.1:6379&gt; xlen stream</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> -表示最小值 , + 表示最大值</span></span><br><span class="line">127.0.0.1:6379&gt; xrange stream - +</span><br></pre></td></tr></table></figure>

<h5 id="2-独立消费"><a href="#2-独立消费" class="headerlink" title="2. 独立消费"></a>2. 独立消费</h5><p>可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令<code>xread</code>,可以将Stream当成普通消息队列使用。使用<code>xread</code>可以忽略消费组的存在。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从Stream头部取两个信息</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 2 streams stream 0-0</span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从 Stream 尾部读取一条消息</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 streams codehole $</span><br><span class="line">......</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来，block单位是ms</span></span><br><span class="line">127.0.0.1:6379&gt; xread block 0 count 1 streams codehole $</span><br></pre></td></tr></table></figure>

<p>客户端若是使用<code>xread</code>消费消息，一定要记录消费ID，下次消费时就可以以上次消费ID为起点继续消费。</p>
<h5 id="3-创建消费组"><a href="#3-创建消费组" class="headerlink" title="3. 创建消费组"></a>3. 创建消费组</h5><p><img src="https://images.effiu.cn/blog/redis/42.png" alt="创建消费组"></p>
<ul>
<li><code>xgroup create stream cg1 0-0</code>，cg1是Consumer Group名，0-0表示从头开始消费。</li>
<li><code>xinfo stream stream</code>，获取 Stream 信息，第二个stream是Stream名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  表示从头开始消费</span></span><br><span class="line">127.0.0.1:6379&gt; xgroup create stream cg1 0-0</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> $ 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略</span></span><br><span class="line">127.0.0.1:6379&gt; xgroup create stream cg2 $</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取 Stream 信息</span></span><br><span class="line">127.0.0.1:6379&gt; xinfo stream stream</span><br></pre></td></tr></table></figure>

<h5 id="4-消费"><a href="#4-消费" class="headerlink" title="4. 消费"></a>4. 消费</h5><p>Stream提供了<code>xreadgroup</code>指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和其实消息ID。与<code>xread</code>一样，也可以阻塞等待新消息，对应的消息ID会进入到PEL结构中，客户端处理完毕后使用<code>xack</code>指令通知服务器，本条消息被消费完毕，该消息ID就会从PEL中移除</p>
<p><code>xreadgroup GROUP cg1 c1 count 1 streams stream &gt;</code>，消费组为<code>cg1</code>、消费组名称为<code>c1</code>，队列名为Stream，<code>&gt;</code>表示从消息组的<code>last_delivered_id</code>后面开始读</p>
<h4 id="3-Stream-分析"><a href="#3-Stream-分析" class="headerlink" title="3. Stream 分析"></a>3. Stream 分析</h4><h5 id="1-Stream消息堆积"><a href="#1-Stream消息堆积" class="headerlink" title="1. Stream消息堆积"></a>1. Stream消息堆积</h5><p><code>xdel</code>不会删除消息，其只是修改标志位，那么Stream消息队列可能会特别长，Redis为了避免Stream过长，提供了一个定长Stream功能。在<code>xadd</code>中提供一个定长长度<code>maxlen</code>，就可以将老的消息干掉，确保不会超出最大长度。</p>
<h5 id="2-消息ACK丢失"><a href="#2-消息ACK丢失" class="headerlink" title="2. 消息ACK丢失"></a>2. 消息ACK丢失</h5><p>Stream在每个消费者结构中保存了正在处理的消息ID列表PEL，若消费者收到了消息处理完了但没有回复ack，就会导致PEL变长</p>
<p><img src="https://images.effiu.cn/blog/redis/43.png" alt="PEL"></p>
<h5 id="3-如何避免消息丢失"><a href="#3-如何避免消息丢失" class="headerlink" title="3. 如何避免消息丢失"></a>3. 如何避免消息丢失</h5><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID。待客户端重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 <code>xreadgroup</code> 的起始消息 ID 不能为参数<code>&gt;</code>，而必须是任意有效的消息 ID，一般将参数设为 <code>0-0</code>，表示读取所有的 PEL 消息以及自<code>last_delivered_id</code>之后的新消息。</p>
<h5 id="4-Stream-高可用"><a href="#4-Stream-高可用" class="headerlink" title="4. Stream 高可用"></a>4. Stream 高可用</h5><p>Stream的高可用是建立在主从复制的基础上的，其和其他数据结构的复制机制没有区别。在Sentinel和Cluster集群环境下，Stream是支持高可用的。不过鉴于Redis指令复制是异步的，所以在<code>failover</code>发生时，Redis可能会丢失小部分消息。</p>
<h5 id="5-分区-Partition"><a href="#5-分区-Partition" class="headerlink" title="5. 分区 Partition"></a>5. 分区 Partition</h5><p>Redis服务器没有原生支持分区能力，如想要使用分区，就需要分配多个Stream，然后在客户端使用一定的策略生产消息到不同的Stream中。</p>
<h3 id="2-info"><a href="#2-info" class="headerlink" title="2. info"></a>2. info</h3><h4 id="1-基本命令-1"><a href="#1-基本命令-1" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h4><p><code>info [select]</code>命令返回Redis服务器的各种信息和统计数值。</p>
<ul>
<li><code>info server</code>：Redis运行的环境参数</li>
<li><code>info clients</code>：已连接客户端信息</li>
<li><code>info memory</code>：内存统计数据</li>
<li><code>info persistence</code>：RDB和AOF相关信息</li>
<li><code>info stats</code>：一般统计信息</li>
<li><code>info replication</code>：主从复制信息</li>
<li><code>info cpu</code>：CPU计算量统计信息</li>
<li><code>info commandstats</code>：Redis命令统计信息</li>
<li><code>info cluster</code>：Redis集群信息</li>
<li><code>info keyspace</code>：数据库相关统计信息</li>
</ul>
<p>直接使用<code>info</code>可以一次性获取所有信息。<a href="https://redis.io/commands/info">Redis官方文档</a></p>
<h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><ul>
<li><p><code>info stats | grep ops</code>，ops(operation per second)，每秒操作数，对应<code>instantaneous_ops_per_sec</code>属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info stats</span><br><span class="line"><span class="meta">#</span><span class="bash"> Stats</span></span><br><span class="line">......</span><br><span class="line">instantaneous_ops_per_sec:0			## 每秒请求数</span><br><span class="line">total_net_input_bytes:3982648</span><br><span class="line">total_net_output_bytes:521174</span><br><span class="line">instantaneous_input_kbps:0.00</span><br><span class="line">instantaneous_output_kbps:0.00</span><br><span class="line">rejected_connections:0				## 拒绝连接数</span><br><span class="line">sync_full:0							## 主从全量同步次数</span><br><span class="line">sync_partial_ok:0					## 增量同步成功数</span><br><span class="line">sync_partial_err:0					## 增量同步失败数</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>info clients</code>，用于观察当前客户端连接数，判断这个数量是否正常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info clients</span><br><span class="line"><span class="meta">#</span><span class="bash"> Clients</span></span><br><span class="line">connected_clients:1				## 客户端连接数</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line">127.0.0.1:6379&gt; client list		## 查看当前连接信息</span><br><span class="line">id=53 addr=127.0.0.1:52918 fd=8 name= age=68 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>info memory</code>，分析内存占用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> Memory</span></span><br><span class="line">used_memory:835568				## 内存分配器 (jemalloc) 从操作系统分配的内存总量</span><br><span class="line">used_memory_human:815.98K</span><br><span class="line">used_memory_rss:4636672			## 操作系统看到的内存占用 ,top 命令看到的内存</span><br><span class="line">used_memory_rss_human:4.42M</span><br><span class="line">used_memory_peak:2578272		## Redis 内存消耗的峰值</span><br><span class="line">......</span><br><span class="line">used_memory_lua_human:37.00K	## lua 脚本引擎占用的内存大小</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>info replication</code>，复制积压缓冲区大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">......</span><br><span class="line">repl_backlog_size:1048576	## 积压缓冲区大小</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>复制积压缓冲区非常重要，其严重影响主从复制的效率。当从库因为网络流量原因临时断开主库的复制时，网络恢复重连后，这段断开时间内发生在master上的修改指令都会放在积压缓冲区中，这样从库可以通过积压缓冲区恢复中断的主从复制过程。</p>
<p>积压缓冲区是环形的，后来的指令会覆盖前面的指令。若从库断开时间过长，或者缓冲区太小，都会因为修改指令被覆盖导致从库无法恢复中断的主从同步过程，就会导致全量同步的产生。</p>
<p>积压缓冲区是共享的，不会因为有多个从库存在而线性增长。<code>info stats</code>中的<code>sync_partial_err</code>可以用来查看同步信息，决定是否需要扩大积压缓冲区。</p>
</li>
</ul>
<h3 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3. 分布式锁"></a>3. 分布式锁</h3><p>针对主从发生<code>failover</code>的情况，产生了<strong>Redlock</strong>算法。<strong>Redlock</strong>使用了大多数机制，当加锁时，其会向过半节点发送<code>set(key, value, nx=true, ex=xxx)</code>指令，只要过半节点<code>set</code>成功，那就认为加锁成功。锁释放时，则向所有节点发送<code>del(key)</code>指令。</p>
<p>Redlock使用大多数机制，所以需要有多个Redis实例。</p>
<p>若有高可用性非常重要的业务场景，就应该使用<strong>Redlock</strong>锁，即时挂掉一台也不受影响。</p>
<h3 id="4-过期策略"><a href="#4-过期策略" class="headerlink" title="4. 过期策略"></a>4. 过期策略</h3><p>Redis 所有的数据结构都可以设置过期时间。那么会不会出现同一时间太多key过期(Redis是单线程的)，需要回收key，导致线上读写出现卡顿呢？</p>
<p>Redis会将每个设置了过期时间的key放到一个独立的字典中，之后会定时遍历这个字典来删除到期的key。另外，还会设置惰性策略删除过期的key，惰性策略指的是客户端访问这个key时，redis对key的过期时间进行检查，过期了就立即删除，定时删除是集中处理，惰性删除是零散处理。</p>
<ol>
<li>定时扫描策略</li>
</ol>
<p>Redis默认每秒进行10次过期扫描，过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略。</p>
<ul>
<li>从过期字典中随机20个key</li>
<li>删除这20个key中已过期的key</li>
<li>若过期比率超过1/4，那就重复步骤1</li>
</ul>
<p>同时为了避免出现过渡循环，导致线程卡死，算法还增加了扫描时间上限，默认不会超过25ms。</p>
<p>若Redis实例中，同一时间出现大量过期key，Redis会持续扫描过期字典，直到过期字典中过期的key变得稀疏，才会停止。这就会导致线上读写请求出现明显卡顿现象。导致卡顿的另外一种原因是内存管理器需要频繁回收内存页，也会产生一定的CPU消耗。</p>
<p>若在服务器处于过期扫描状态，客户端请求将至少等待25ms后才会进行业务处理，若客户端将超时时间设置较短，甚至会出现大量连接因超时而关闭。</p>
<p>所以业务开发一定要注意过期时间，若有大量key过期，<strong>要给过期时间设置一个随机范围，而不是在同一时间过期，分散过期处理的压力</strong>。</p>
<ol start="2">
<li>从库的过期策略</li>
</ol>
<p>从库是不会进行过期扫描的，从库对过期的处理是被动的。主库在key到期时，会在AOF文件中增加<code>del</code>指令，同步到所有从库。主从同步是异步进行的，所以主库过期的key若没有及时同步到从库，会出现主从数据的不一致。</p>
<h3 id="5-LRU"><a href="#5-LRU" class="headerlink" title="5. LRU"></a>5. LRU</h3><p>当Redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换(Swap)。交换会使Redis性能急剧下降，对于访问频繁的Redis来说，这样的存取效率基本等于不可用。因为Redis本质是为了提高读写速度，其是把数据存储在内存中，当产生频繁的内存与磁盘交换时，就违背了使用Redis的初衷。</p>
<p>生产环境中，是不允许Redis中出现内存与磁盘交换的行为的，为了限制最大使用内存，Redis提供了配置参数<code>maxmemory</code>大小。当实际内存超出<code>maxmemory</code>时，Redis提供了几种可选策略来让用户自己决定如何腾出空间支持读写服务的。</p>
<ul>
<li><strong>noeviction</strong>，不会继续服务写请求(<code>del</code>可以进行)，读请求可以继续进行。可以保证不会丢失数据，但是会导致生产业务不能持续进行，默认的淘汰策略。</li>
<li><strong>volatile-lru</strong>，尝试淘汰设置了过期时间的key，最少使用的key优先被淘汰。没有设置过期的key不会被淘汰，这样保证了需要持久化的数据不被丢失。</li>
<li><strong>volatile-ttl</strong>，与<strong>volatile-lru</strong>一样，淘汰策略不是LRU，而是key的剩余寿命ttl的值，ttl越小越优先被淘汰</li>
<li><strong>volatile-random</strong>，与<strong>volatile-ttl</strong>一样，淘汰的key是过期key集合中随机key。</li>
<li><strong>allkeys-lru</strong>，淘汰的key是全体的key集合，不是过期key的集合。没有设置过期时间的key也会被淘汰</li>
<li><strong>allkeys-random</strong>，与上面一致，淘汰策略是随机key</li>
</ul>
<p><strong>volatile-xxx</strong>是只针对带过期时间的key，<strong>allkeys-xxx</strong>策略会对所有key进行淘汰。若只是把Redis用来做缓存，那选择<strong>allkeys-xxx</strong>，即使淘汰为过期key，也不会影响业务。若Redis有持久化功能，那么使用<strong>volatile-xxx</strong>，可以保证永久的key不会被淘汰</p>
<p>LRU算法除了需要key/value之外，还需要附加一个链表，链表中的元素按照一定顺序排列。当空间满时，会移除链表尾部的元素。当字典中元素被访问时，其在链表中的位置会被移动到表头。链表顺序就是元素最近被访问的顺序。链表尾部就是不被重用的元素。</p>
<p>Redis使用的是近似LRU算法。其不适用LRU是因为LRU需要消耗大量内存维护链表。近似LRU算法：在现有数据结构的基础上使用随机采样法淘汰元素，可以达到与LRU近似的效果。Redis为了实现近似LRU算法，给每个key加了一个额外的24bit的字段，即最后一次被访问的时间戳。</p>
<p>Redis的近似LRU算法是懒惰处理方式。当Redis执行写操作时，发现内存超出<code>maxmemory</code>时，就会执行一次LRU淘汰算法，其会随机采样出5个key，淘汰掉最旧的key，若淘汰后仍是超出<code>maxmemory</code>，就会继续随机采样淘汰，直到内存低于<code>maxmemory</code>为止。</p>
<blockquote>
<p>Java使用LinkedHashMap实现LRU算法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    LRU(<span class="keyword">int</span> size)&#123;</span><br><span class="line">        <span class="comment">// true表示会在get(k)后，调用afterNodeAccess，对链表排序</span></span><br><span class="line">        <span class="comment">// afterNodeAccesshui把最新访问的元素排在链表头部</span></span><br><span class="line">        <span class="keyword">super</span>(size, <span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.INITIAL_SIZE = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;String, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LinkedHashMap中put方法成功后，会调用此方法判断是否需要移除链表尾部元素</span></span><br><span class="line">        <span class="comment">// put -&gt; putVal -&gt; afterNodeInsertion -&gt; removeEldestEntry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.size() &gt; INITIAL_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-懒惰删除"><a href="#6-懒惰删除" class="headerlink" title="6. 懒惰删除"></a>6. 懒惰删除</h3><p>Redis是单线程程序，单线程为Redis带来了代码的简洁性和丰富多样的数据结构。不过Redis内部实际上并不是只有一个主线程，其有几个异步线程专门用来处理一些耗时操作。</p>
<h5 id="1-unlink"><a href="#1-unlink" class="headerlink" title="1. unlink"></a>1. unlink</h5><p>Redis的删除指令<code>del</code>会直接释放对象的内存，大部分情况下是非常迅速的。但是当key是大对象时，那么删除操作会造成单线程卡顿。Redis在4.0引入了<code>unlink</code>指令，可以对删除操作进行懒惰处理，丢给后台线程异步操作。</p>
<p>当<code>unlink</code>操作执行后，该<code>key</code>就已经不能被访问了，所以没有多线程并发问题(不会有其他线程修改该key的问题)。</p>
<h5 id="2-flush"><a href="#2-flush" class="headerlink" title="2. flush"></a>2. flush</h5><p>Redis提供了<code>flushdb</code>和<code>flushall</code>指令，用来清空数据库，这是两个非常缓慢的操作。Redis 4.0同样支持异步化，在指令后增加<code>sync</code>，就会把其交给后台线程处理</p>
<h5 id="3-异步队列"><a href="#3-异步队列" class="headerlink" title="3. 异步队列"></a>3. 异步队列</h5><p>主线程任务交给异步线程后，主线程会将该key标记为不可访问对象，会将这个key的内存回收操作包装为一个任务，放到异步队列，后台线程会从这个异步队列中取任务。异步线程和主线程是同时操作的，所以必须是一个线程安全的队列。</p>
<p><img src="https://images.effiu.cn/blog/redis/45.png" alt="异步队列"></p>
<h5 id="4-AOF-sync"><a href="#4-AOF-sync" class="headerlink" title="4. AOF sync"></a>4. AOF sync</h5><p>Redis的主从同步中的AOF增量同步日志到磁盘，其需要调用<code>sync</code>函数，这个操作比较耗时，会导致主线程效率下降，所以Redis也将其迁移到异步线程来完成。AOF sync操作的线程是一个独立的异步线程，同样也有独属于自己的异步队列。</p>
<h5 id="5-其他异步操作"><a href="#5-其他异步操作" class="headerlink" title="5. 其他异步操作"></a>5. 其他异步操作</h5><p>Redis回收内存操作除了<code>del</code>和<code>flush</code>之外，还有key过期、LRU淘汰、rename指令及从库全量同步时接受完rdb文件会立即进行<code>flush</code>操作等。Redis也在4.0版本为这些删除点带来了异步删除机制，代开这些需要额外的配置项：</p>
<ul>
<li><code>slave-lazy-flush</code>：从库接受完rdb文件后的flush操作</li>
<li><code>lazyfree-lazy-eviction</code>：内存达到<code>maxmemory</code>时进行淘汰</li>
<li><code>lazyfree-lazy-expire key</code>：过期删除</li>
<li><code>lazyfree-lazy-server-del</code>：<code>rename</code>指令删除destKey</li>
</ul>
<h3 id="7-Redis指令安全"><a href="#7-Redis指令安全" class="headerlink" title="7. Redis指令安全"></a>7. Redis指令安全</h3><p>Redis有一些非常危险的指令，其会对Redis稳定和数据安全造成非常严重的影响。例如：<code>keys</code>、<code>flushdb</code>和<code>flushall</code>等操作。</p>
<p>Redis在配置文件中提供了<code>rename-command</code>指令用于将某些危险操作修改成特别的名称，避免人为误操作。</p>
<p><code>rename-command keys abckeys</code>，只有用户输入<code>abckeys</code>才会执行<code>keys</code>相关命令。</p>
<p><code>rename-command flushall &quot;&quot;</code>，会完全封杀<code>flushall</code>指令。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis PubSub、小对象压缩和主从同步</title>
    <url>/blog/2019/08/26/redis/9_pubsub_object_compression_master_slav_sync/</url>
    <content><![CDATA[<p>前面有说到的Redis消息队列的使用，但是Redis消息队列有个不足，其不支持消息的多播机制。</p>
<p>Redis所有数据都放在内存中，所以非常耗内存，我们必须注意节约使用。Redis本身也为了节省内存占用，优化了数据结构。</p>
<a id="more"></a>

<h3 id="1-PubSub"><a href="#1-PubSub" class="headerlink" title="1. PubSub"></a>1. PubSub</h3><h4 id="1-消息多播"><a href="#1-消息多播" class="headerlink" title="1. 消息多播"></a>1. 消息多播</h4><p><img src="https://images.effiu.cn/blog/redis/27.png" alt="消息多播"></p>
<p>消息多播，允许生产者生产一次消息，中间件负责将消息复制到多个消息队列，每个消息队列由相应的消费组进行消费。其是分布式系统常用的一种解耦方式，用于将消费组的逻辑拆分。支持消息多播，多个消息组就可以放到不同的子系统中。</p>
<h4 id="2-PubSub"><a href="#2-PubSub" class="headerlink" title="2. PubSub"></a>2. PubSub</h4><p>为了支持消息多播，Redis单独使用了一个模块支持消息多播，即PubSub(Publisher/Subscriber)发布者/订阅者模型。</p>
<p><img src="https://images.effiu.cn/blog/redis/28.png" alt="PubSub"></p>
<blockquote>
<p>如下：有1个发布者，两个订阅者</p>
</blockquote>
<ol>
<li>订阅者订阅消息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>发布者发布消息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel al</span><br><span class="line">(integer) 1							###表示发布成功</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>订阅者1接受消息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) &quot;al&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) &quot;ceshi&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>订阅者2接收消息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) &quot;ceshi&quot;</span><br></pre></td></tr></table></figure>

<p>要求先启动消费者，然后启动发布者，消费者可以启动多个，pubsub保证其收到的消息是相同的消息序列。</p>
<h4 id="3-模式订阅"><a href="#3-模式订阅" class="headerlink" title="3. 模式订阅"></a>3. 模式订阅</h4><p>上面的例子是通过名称订阅的。消费者订阅一个主题必须明确指定主题的名称。若要订阅多个主题，那就<code>subscribe</code>多个名称。<code>subscribe channel [channel ...]</code></p>
<p>例如：<code>subscribe channel 1 channel2 channel3 channel4</code>等等。主题非常多。为了简化订阅模式的繁琐，Redis提供了模式订阅功能<code>Pattern Subscribe</code>，这样就可以同时订阅多个主题，即使新增了主题，只要符合<code>pattern</code>，消费者也可以立即接收到消息。<code>subscribe channel*</code>。</p>
<h4 id="4-消息结构"><a href="#4-消息结构" class="headerlink" title="4. 消息结构"></a>4. 消息结构</h4><p>上面例子中，我们接收到的消息如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel&quot;</span><br><span class="line">3) &quot;ceshi&quot;</span><br></pre></td></tr></table></figure>

<p>消息的结构如下：</p>
<ul>
<li><code>type</code>：消息的类型，普通消息是<code>message</code>；控制消息(指令反馈)是<code>subscribe</code>；订阅模式的反馈是<code>psubscribe</code>；取消订阅指令的反馈是<code>unsubscribe</code>和<code>punsubscribe</code>。</li>
<li><code>channel</code>：表示当前订阅模式的主题名称。</li>
<li><code>data</code>：消息的内容，一个字符串。</li>
<li><code>pattern</code>：表示当前消息使用的订阅模式。<code>subscribe</code>订阅，<code>pattern</code>为空</li>
</ul>
<h4 id="5-PubSub缺点"><a href="#5-PubSub缺点" class="headerlink" title="5. PubSub缺点"></a>5. PubSub缺点</h4><p>PubSub传递过来的消息，Redis会直接找到相应的消费者传递过去。若一个消费者都没有，那么消息直接丢弃。若开始有3个消费者，突然挂掉一个消费者，那么消息仍然可以正常发布，但是挂掉的消费者重新连上时，期间的消息已经彻底丢失。</p>
<p>Redis宕机，PubSub不支持持久化，其相当于没有消费者，会直接丢弃所有消息。</p>
<p>实际上PubSub没有太多应用场景。</p>
<h3 id="2-小对象压缩"><a href="#2-小对象压缩" class="headerlink" title="2. 小对象压缩"></a>2. 小对象压缩</h3><h4 id="1-32bit"><a href="#1-32bit" class="headerlink" title="1. 32bit"></a>1. 32bit</h4><p>Redis如果使用32bit进行编译，内部所有数据结构使用的指针空间占用会少一半，若对Redis使用内存不超过4G，可以考虑使用32bit进行编译，大量节约内存成本。</p>
<h4 id="2-小对象压缩存储"><a href="#2-小对象压缩存储" class="headerlink" title="2. 小对象压缩存储"></a>2. 小对象压缩存储</h4><p>若Redis内部管理的数据集合结构很小，其会使用紧凑存储形式压缩存储。</p>
<p>例如，<code>HashMap</code>其本来是二维数据结构，但如果内部元素较少，使用二维结构反而浪费空间。</p>
<h5 id="1-ziplist"><a href="#1-ziplist" class="headerlink" title="1. ziplist"></a>1. ziplist</h5><p>Redis的ziplist是一个紧凑的字节数组结构，如下所示：</p>
<p><img src="https://images.effiu.cn/blog/redis/29.png" alt="ziplist"></p>
<p>其内部每个元素都紧挨着。<a href="http://redisbook.com/preview/ziplist/list.html">压缩列表</a></p>
<p>若其存储的是hash结构，那么其key和value会做为一个entry连在一起。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hash key value</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding hash</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<p><code>object</code>命令用于从内部查看给定key的Redis对象。</p>
<h5 id="2-intset"><a href="#2-intset" class="headerlink" title="2. intset"></a>2. intset</h5><p>Redis的<code>intset</code>是一个紧凑的整数数组结构，用于存放元素都是整数且元素个数较少的set集合。</p>
<p><img src="https://images.effiu.cn/blog/redis/30.png" alt="intset"></p>
<p>若整数可以用unit16表示，那么intset的元素就是16位的数组，若超过unit16的表示范围，就是用unit32位表示，如新加入元素超过unit32，就是用unit64位表示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd intset 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding intset</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<p>若set内存储的是字符串，那么sadd立即升级为hash结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd intset a1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding intset</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>当集合内部的元素不断增加，或者某个value值过大，小对象存储也会被升级为标准结构。Redis规定小对象存储的限制条件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hash-max-ziplist-entries 512	# hash的元素个数超过512个必须使用标准结构</span><br><span class="line">hash-max-ziplist-value 64		# hash的任意元素的key/value长度超过64必须使用标准结构</span><br><span class="line">list-max-ziplist-entries 512	# list的元素个数超出512个必须使用标准结构</span><br><span class="line">list-max-ziplist-value 64		# list的任意元素长度超过64必须使用标准结构</span><br><span class="line">zset-max-ziplist-entries 128	# zset的元素个数超过128个必须使用标准结构</span><br><span class="line">zset-max-ziplist-value 64		# zset的任意元素长度超过64必须使用标准结构</span><br><span class="line">zset-max-intset-entries 512		# set的整数元素个数超过512个必须使用标准结构</span><br></pre></td></tr></table></figure>

<h4 id="3-内存回收机制"><a href="#3-内存回收机制" class="headerlink" title="3. 内存回收机制"></a>3. 内存回收机制</h4><p>Redis并不是将空闲的内存立即归还给操作系统</p>
<p>如果当前Redis内存有10G，当你删除了1GB的key后，再去观察内存，你会发现内存变化不会太大。原因是<strong>操作系统回收内存是以页为单位，如果这个页上只要有一个key还在使用，那么它就不能被回收</strong>。Redis虽然删除了1GB的key，但是这些key分散到了很多页面中，每个页面都还有其它key存在，这就导致了内存不会立即被回收。</p>
<p>若执行了<code>flushdb</code>，然后在观察内存会发现内存确实已经被回收了。原因是所有的key都删除了，大部分之前使用的页面都干净了，会立即被操作系统回收。</p>
<p>Redis虽然不能立即释放已删除key的内存，但是其会重用那些尚未被回收的空闲内存。</p>
<h4 id="4-内存回收算法"><a href="#4-内存回收算法" class="headerlink" title="4. 内存回收算法"></a>4. 内存回收算法</h4><p>内存分配是一个复杂的课题。需要适当的算法划分内存页，需要考虑内存碎片，需要平衡性能和效率。</p>
<p>Redis为了保持自身结构的简单性，将内存分配的细节交给了三方内存分配库去实现。目前Redis可用的<code>jemalloc</code>(facebook)和<code>tcmalloc</code>(google)。<code>jemalloc</code>更优一些。</p>
<p><code>info memory</code>命令可以查看Redis使用的内存分配库信息。</p>
<p><code>info [select]</code>命令返回Redis服务器的各种信息和统计数值。</p>
<ul>
<li><code>info server</code>：返回Redis服务器信息</li>
<li><code>info clients</code>：已连接客户端信息</li>
<li><code>info memory</code>：内存信息</li>
<li><code>info persistence</code>：RDB和AOF相关信息</li>
<li><code>info stats</code>：一般统计信息</li>
<li><code>info replication</code>：主从复制信息</li>
<li><code>info cpu</code>：CPU计算量统计信息</li>
<li><code>info commandstats</code>：Redis命令统计信息</li>
<li><code>info cluster</code>：Redis集群信息</li>
<li><code>info keyspace</code>：数据库相关统计信息</li>
</ul>
<h3 id="3-主从同步"><a href="#3-主从同步" class="headerlink" title="3. 主从同步"></a>3. 主从同步</h3><h4 id="1-CAP原理"><a href="#1-CAP原理" class="headerlink" title="1. CAP原理"></a>1. CAP原理</h4><p>CAP原理是分布式存储的理论基石。</p>
<ul>
<li>C，Consistent，一致性</li>
<li>A，Availability，可用性</li>
<li>P，Partition tolerance，分区容忍性</li>
</ul>
<p>分布式系统的节点往往分布在不同机器上进行网络隔离开的，意味着必然有网络断开的风险，网络断开的场景的专业词汇叫做<strong>网络分区</strong>。</p>
<p>在网络分区发生时，分布式节点之间无法进行通信，我们对一个节点的操作无法同步到另外一个节点，所以将不满足数据的一致性。除非我们牺牲可用性，暂停分布式节点服务，在网络分区发生时，不再提供数据修改功能，直到网络完全恢复正常为止。<strong>网络分区发生时，一致性和可用性不可兼得</strong>。</p>
<p><img src="https://images.effiu.cn/blog/redis/31.png" alt="主从同步"></p>
<h4 id="2-最终一致性"><a href="#2-最终一致性" class="headerlink" title="2. 最终一致性"></a>2. 最终一致性</h4><p>Redis的主从数据是异步同步的，所以分布式系统并<strong>不满足一致性</strong>要求，当Redis的主节点修改了数据后，会立即返回，即使发生网络分区，主节点依旧可以正常对外提供服务，所以Redis满足可用性。</p>
<p>Redis可以保证<strong>最终一致性</strong>。最终从节点的状态会与主节点保持一致。当发生网络分区时，主从节点的数据将会发生大量不一致，一旦网络恢复，从节点将会采取多种策略与主节点保持一致。</p>
<h4 id="3-主从同步-1"><a href="#3-主从同步-1" class="headerlink" title="3. 主从同步"></a>3. 主从同步</h4><p>Redis支持主从同步和从从同步。为了减轻主节点的负担，后续增加了从从同步。</p>
<h4 id="4-增量同步"><a href="#4-增量同步" class="headerlink" title="4. 增量同步"></a>4. 增量同步</h4><p>Redis同步的是指令流，主节点会将对自己状态产生影响的指令记录在本地<strong>buffer</strong>中，然后异步将<strong>buffer</strong>中的指令同步到从节点，从节点边执行同步指令流边边向主节点反馈同步偏移量。</p>
<p>内存的<strong>buffer</strong>是有限的，所以Redis主库不能将所有指令都记录在内存buffer中。Redis的主从同步buffer是一个定长的环形数组，若内存数组满了就会从头开始覆盖前面的内容。</p>
<p><img src="https://images.effiu.cn/blog/redis/32.png" alt="增量同步环形数组"></p>
<p>若网络环境不稳定，主节点短时间内无法和从节点同步，那么当网络状况恢复时，Redis的主节点中没有同步的指令可能在内存buffer中可能已经被覆盖了，从节点将无法通过指令流进行同步，这时就需要另外一种同步策略——<strong>快照同步</strong>。</p>
<h4 id="5-快照同步"><a href="#5-快照同步" class="headerlink" title="5. 快照同步"></a>5. 快照同步</h4><p>快照同步非常消耗资源，首先需要在主库上进行一次<code>bgsave</code>将当前内存中的数据全部快照到磁盘文件中，然后将快照文件的内容全部传送到从节点。从节点在将快照文件接收完毕后，会先将内存中的数据清空，然后执行一次全量加载。加载完成后通知主节点进行增量同步。</p>
<p>在从节点进行快照同步过程中，其主节点中主从复制buffer不断向前移动，若快照同步时间过长或者buffer太小，可能还会导致同步期间的增量指令被覆盖掉，会导致快照同步完成后无法进行增量同步，然后会再次发起快照痛殴过不，如此既有可能会陷入死循环。</p>
<p>尽量配置一个合适的buffer，避免快照同步死循环。</p>
<p>当新节点加入到集群中时，需要先进行一次快照同步，然后继续进行增量同步。</p>
<h4 id="6-无盘复制"><a href="#6-无盘复制" class="headerlink" title="6. 无盘复制"></a>6. 无盘复制</h4><p>主节点在进行快照同步时，会发生频繁的IO文件操作，特别是非SSD磁盘存储时，会对系统造成较大影响。特别是当系统正在进行AOF的<code>fsync</code>操作时发生快照同步，<code>fsync</code>将会被推迟进行，会严重影响主节点的效率。</p>
<p>Redis从2.8.18提供了无盘复制，指主服务器直接通过套接字快照将内容发送到从节点，生成快照是一个遍历过程，主机节点会边遍历内存边将序列化的内容发送到从节点。从节点是现将快照内容存储到磁盘文件中，然后进行一次性加载</p>
<h4 id="7-wait指令"><a href="#7-wait指令" class="headerlink" title="7. wait指令"></a>7. wait指令</h4><p>Redis的复制是异步进行的，<code>wait</code>指令可以让异步复制变身为同步复制，确保系统的强一致性（不严格）。</p>
<p><code>wait</code>指令提供了两个参数：从库的数量N，时间T(ms)。表示等待wait指令之前的所有写操作同步到N个从库(确保N个从库的同步没有落后)，最多等待时间T。若T=0则表示无线等待直到N个从库同步完成达到一致。</p>
<p>若此时出现了网络分区，<code>wait</code>指令的时间为0，主从同步无法继续执行，<code>wait</code>指令将会永久阻塞。</p>
<h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p>Redis主从赋值是Redis分布式的基础，Redis的高可用离开了主从复制将无法继续进行。若Redis只用来做缓存，那么主从复制非必需。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化、管道和事务</title>
    <url>/blog/2019/08/25/redis/8_persistence_pipeline_transaction/</url>
    <content><![CDATA[<p>Redis数据全部在内存中，那么当系统宕机，数据就会全部丢失，因此必须有一种机制来保证Redis的数据不会因故障而丢失，这种机制就是Redis的持久化机制。</p>
<p>Redis的管道并不是Redis服务器直接提供的技术，而是由客户端通过改变读写顺序带来的性能的巨大提升。</p>
<p>Redis也具有事务，其非常简单，所以其事务模型不严格。</p>
<a id="more"></a>

<h3 id="1-Redis持久化"><a href="#1-Redis持久化" class="headerlink" title="1. Redis持久化"></a>1. Redis持久化</h3><p>Redis的持久化机制有两种：</p>
<ul>
<li>快照：是一次全量备份，是内存数据的二进制序列化形式，存储上非常紧凑</li>
<li>AOF日志：是连续的增量备份，AOF日志记录的是内存数据修改的指令记录文本。在长期运行过程中会变得非常大，Redis重启时需要加载AOF日志进行指令重放，这个时间会非常长。所以AOF需要定期重写AOF日志瘦身。</li>
</ul>
<h4 id="1-快照"><a href="#1-快照" class="headerlink" title="1. 快照"></a>1. 快照</h4><h5 id="1-快照原理"><a href="#1-快照原理" class="headerlink" title="1. 快照原理"></a>1. 快照原理</h5><p>Redis是单线程程序，这个线程要负责客户端套接字的并发读写和内存数据结构逻辑读写。</p>
<p>若在处理客户端请求时还要进行内存快照是不现实的，这会严重拖垮服务器请求的性能，因为其是单线程程序，而内存快照要求Redis进行文件IO操作，可很明显文件IO操作不能使用多路复用API。所以<font color='red'>为了不阻塞线上业务，需要边持久化边相应客户端请求</font>。</p>
<p>但是，在持久化过程中，内存中的数据还在改变，所以Redis使用操作系统的<strong>多进程COW</strong>(Copy On Write)机制来实现快照持久化。</p>
<h5 id="2-fork-多进程"><a href="#2-fork-多进程" class="headerlink" title="2. fork(多进程)"></a>2. fork(多进程)</h5><p>Redis在持久化时会调用glibc函数<code>fork</code>产生一个子进程，快照持久化完全交给子进程处理，而父进程继续处理客户端请求。当子进程刚刚产生时，其和父进程共享内存中的代码和数据段，这是Linux的机制，为了节约资源，所以在进程刚刚分离时，内存增加几乎没有变化。</p>
<p>子进程做持久化，其不会修改在现有的数据结构，只是对数据结构进行遍历读取，然后序列化写到磁盘中。而同时父进程还在处理客户端的请求，然后对内存数据结构进行修改，这时就会用到操作系统的COW机制进行数据段页面的分离。数据段是由很多操作系统的页面组成，父进程对一个页面进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改，同时子进程持久化的页面是没有修改的。</p>
<p>随着父进程修改操作的持续进行，会有越来越多的页面被分离出来，所以内存是持续增长的。但是基本不会超过原来的2倍大小，因为Redis中冷数据的比例一般比较高，所以基本不会出现所有页面被分离的情况。</p>
<p>子进程看到的数据，在子进程产生的瞬间就固化了。</p>
<h4 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2. AOF"></a>2. AOF</h4><h5 id="1-AOF原理"><a href="#1-AOF原理" class="headerlink" title="1. AOF原理"></a>1. AOF原理</h5><p>AOF日志存储的是Redis的顺序执行指令序列，<font color='red'>只记录对内存进行修改的指令记录</font>。</p>
<p>Redis会在收到客户端修改指令后，进行参数校验和逻辑处理后，就会立即将指令文本存储到AOF日志中，即先执行后存储。</p>
<h5 id="2-AOF重写"><a href="#2-AOF重写" class="headerlink" title="2. AOF重写"></a>2. AOF重写</h5><p>Redis在长期运行过程中，AOF的日志会越来越长。当系统宕机后，重放整个AOF日志会非常耗时，导致Redis长时间无法对外提供服务。所以需要对AOF日志瘦身。</p>
<p>Redis提供了<code>bgrewriteaof</code>对AOF日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换出一系列Redis操作指令，序列化到新的AOF日志文件中。序列化完成后再将操作期间发生的增量AOF日志追加到新的AOF日志文件中，追加完成后就会替代旧的日志文件，瘦身完成。</p>
<h5 id="3-fsync"><a href="#3-fsync" class="headerlink" title="3. fsync"></a>3. fsync</h5><p>AOF日志是以文件的形式存在的，当进程对AOF文件进行写操作时，实际上是将内存写到内核为文件描述符分配的内存缓存中，然后内核会异步将数据写到磁盘中。</p>
<p>这就意味着若发生系统宕机，AOF日志可能会出现未写回到磁盘中的情况，造成日志丢失。Linux的glibc提供了<code>fsync(int fd)</code>函数可以将指定文件内容强制从内核缓存刷新的磁盘。只要Redis服务调用<code>fsync</code>函数就可以保证AOF日志不会丢失，但是<code>fsync</code>函数是磁盘IO操作，很慢，所以不能一个指定调用一个<code>fsync</code>。</p>
<p>在生产环境中，Redis通常是每1s左右执行一次<code>fsync</code>操作，这是可以配置的。这是在数据安全和性能之间做的一次折中，在保证高性能的同时，尽量避免数据丢失。</p>
<h5 id="4-运维"><a href="#4-运维" class="headerlink" title="4. 运维"></a>4. 运维</h5><p>快照是通过开启子进程的方式进行的，是一个比较好资源的操作：</p>
<ul>
<li>遍历整个内存，频繁写入磁盘会加重系统负载</li>
<li>AOF的<code>fsync</code>是非常耗时的磁盘IO操作，会降低Redis性能，增加系统负担。</li>
</ul>
<p>所以通常Redis主节点是不会进行持久化的，持久化操作在从节点进行。从节点是备份节点，没有来着客户端请求的压力。</p>
<p>一般考虑到网络问题，从节点可能连不上主节点，就会出现数据不一致的情况，所以在生产环境要做好监控，保证网络通畅或者能快速修复。另外可以多增加一个从节点增加容错率。</p>
<h5 id="5-混合持久化"><a href="#5-混合持久化" class="headerlink" title="5. 混合持久化"></a>5. 混合持久化</h5><p>当我们重启Redis时，使用快照的方式恢复内存状态，会造成数据大量丢失，而使用AOF日志重放通畅会非常耗时。</p>
<p>Redis混合持久化。将rdb文件的内容和增量AOF日志文件存放在一起。AOF不再是全量日志，而是自持久化开始到持久化结束这段时间发生的增量AOF日志，通常会很小。</p>
<p><img src="https://images.effiu.cn/blog/redis/21.png" alt="混合持久化"></p>
<p>在Redis重启时会先加载RDB文件，然后重放AOF日志，效率会得到大幅提升。</p>
<h3 id="2-Redis管道"><a href="#2-Redis管道" class="headerlink" title="2. Redis管道"></a>2. Redis管道</h3><h4 id="1-Redis的信息交互"><a href="#1-Redis的信息交互" class="headerlink" title="1. Redis的信息交互"></a>1. Redis的信息交互</h4><p>当我们使用Redis客户端对Redis做操作时，客户端将请求发送给服务器，服务器处理完成后，再将请求返回给客户端，花费一个网络数据包的时间。</p>
<p><img src="https://images.effiu.cn/blog/redis/22.png" alt="Redis客户端请求过程"></p>
<p>若有连续多个指令，那就会花费多个网络数据包。</p>
<p><img src="https://images.effiu.cn/blog/redis/23.png" alt="Redis客户端请求过程"></p>
<p>在这多个数据包发送过程中，客户端经历了写-读-写-读的过程。</p>
<p><img src="https://images.effiu.cn/blog/redis/24.png" alt="Redis客户端请求过程"></p>
<p>若我们可以调整写的顺序，改为写-写-读-读，就会只花费一个网络来回，就类似于将<code>write</code>和<code>read</code>操作合并了。</p>
<p><img src="https://images.effiu.cn/blog/redis/25.png" alt="Redis客户端请求过程"></p>
<p>这便是管道操作的本质，服务端没有做任何处理，而是客户端通过对管道中的指令列表改变读写顺序而大幅节省IO时间。管道中的指令越多，效果越好。</p>
<h4 id="2-管道本质"><a href="#2-管道本质" class="headerlink" title="2. 管道本质"></a>2. 管道本质</h4><p>一个Redis请求的交互过程，非常复杂。要经过网络协议栈，需要深入内核。</p>
<p><img src="https://images.effiu.cn/blog/redis/19.png" alt="请求过程"></p>
<p>上图是一个完整的请求过程。具体如下：</p>
<ol>
<li>客户端调用<code>write</code>将消息写入到操作系统内核为套接字分配的发送缓冲<code>send buffer</code>中</li>
<li>客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过网际(网际网络是指在广域网与广域网之间互相连接的网络)路由发送到服务端的网卡</li>
<li>服务器操作系统内核将网卡收到的数据放到内核为套接字分配的接收缓冲<code>recv buffer</code></li>
<li>服务器进程调用<code>read</code>从接收缓冲中取出消息进行处理</li>
<li>服务器进程调用<code>write</code>将响应消息写入到内核为套接字分配的发送缓冲<code>send buffer</code>中</li>
<li>服务器操作系统内核将发送缓冲中的内容发送到网卡，网卡硬件将数据通过网际路由发送到客户端的网卡</li>
<li>客户端操作系统内核将网卡收到的数据放到内核为套接字分配的接收缓冲<code>recv buffer</code></li>
<li>服务器进程调用<code>write</code>从接收缓冲区中取出消息返回给上层业务逻辑进行处理</li>
</ol>
<p>其中1<del>4和5</del>8其实是一样的，只不过一个是请求过程，一个是响应过程</p>
<p><code>write</code>操作并不是等到接收到消息才返回的，其只负责将数据写到操作系统为内核分配的缓冲区就会返回，剩下的事交给操作系统内核异步将数据发送到目标机器，若发送缓冲慢了，那么就需要等待缓冲区空出来了，这是写IO操作的真正耗时。</p>
<p><code>read</code>操作只负责将数据从本地操作系统内核缓冲区中取出数据。但若缓冲区为空，那么就需要等待数据到来，这是读IO操作的真正耗时。</p>
<p>例如：<code>value=redis.get(key)</code>一个简单的请求。<code>write</code>操作几乎没有耗时，直接写到发送缓冲区，而<code>read</code>就会比较耗时，因为其要等待消息经过网络路由到目标机器处理后的响应消息，再发送回到当前内核读缓冲才可以返回，这才是一个网络请求真正开销。</p>
<p>对于管道来说，连续的<code>write</code>操作几乎没有耗时，之后第一个<code>read</code>操作会等待一个网络开销，然后所有的消息就回到内核缓冲中了，后续的<code>read</code>操作就可以直接从缓冲中拿到结果。</p>
<h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h3><h4 id="1-事务的基本使用"><a href="#1-事务的基本使用" class="headerlink" title="1. 事务的基本使用"></a>1. 事务的基本使用</h4><p>Redis的事务与数据库类似，分别是</p>
<ul>
<li><code>multi</code>，事务的开始</li>
<li><code>exec</code>，事务的执行</li>
<li><code>discard</code>，事务的丢弃</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### a的初始化为1</span></span></span><br><span class="line">27.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr a</span><br><span class="line">QUEUED					   ## QUEUED是简单字符串，表示指令已经被服务器缓存到队列里了</span><br><span class="line">127.0.0.1:6379&gt; exec		## exec之前，其他客户端执行&quot;get a&quot;操作返回值为1</span><br><span class="line">1) (integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>

<p>开启事务后，所有的指令都会缓存在服务器的一个事务队列中，服务器收到<code>exec</code>指令后，才开始执行整个事务队列，执行完毕后一次性返回所有执行结果。Redis是单线程程序，所以其执行过程中不会被其他指令打断，<strong>具有原子性</strong>。</p>
<p><img src="https://images.effiu.cn/blog/redis/26.png" alt="Redis的事务"></p>
<h4 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2. 原子性"></a>2. 原子性</h4><p>Redis事务的原子性也比较特殊。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set b a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr b</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set c d</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 2</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line">3) OK</span><br></pre></td></tr></table></figure>

<p>执行<code>exec</code>后，第二个指令执行失败了，但是第三个确成功了。事务在执行过程中遇到失败，后面的指令还会继续执行。所以<font color='red'>Redis的事务的“原子性”，仅仅是有不能被其他事务打断的特性</font>。</p>
<h4 id="3-discard"><a href="#3-discard" class="headerlink" title="3. discard"></a>3. discard</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>

<p><code>discard</code>后，<code>incr a</code>指令并没有被执行。</p>
<h4 id="4-使用方式"><a href="#4-使用方式" class="headerlink" title="4. 使用方式"></a>4. 使用方式</h4><p>Redis事务在每发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部指令较多时，需要网络IO时间也会很长。所以Redis事务要结合<strong>pipeline</strong>(管道)一起使用，这样可以将多次IO操作压缩为一个IO操作。例如：springboot提供的redis starter中也支持pipeline，如下是开启了<strong>事务+pipeline</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; results = redisTemplate.executePipelined(<span class="keyword">new</span> SessionCallback&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;K, V&gt; <span class="function">String <span class="title">execute</span><span class="params">(RedisOperations&lt;K, V&gt; operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">                valueOperations.increment(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                valueOperations.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5-watch"><a href="#5-watch" class="headerlink" title="5. watch"></a>5. watch</h4><p>Redis提供了watch机制，其是一种乐观锁，用于解决并发问题。</p>
<p>假如有一种业务场景：Redis存储了账户余额，其是一个整数。现在有两个并发的客户端要对账户余额进行修改操作，且修改不是简单的incrby指令，而是要对余额*倍数，Redis没有提供<code>multiplyby</code>这样的指令，所以我们只能先取出余额，再将结果写回Redis。这就会产生并发问题，多个客户端进行并发操作。</p>
<p>我们可以通过使用Redis分布式锁避免冲突，但分布式锁是一种悲观锁。</p>
<p><code>watch</code>会在事务开始之前关注一个或者多个变量，当服务器执行<code>exec</code>指令执行缓存的事务队列时，Redis会检查关键变量自<code>watch</code>之后，是否被修改过(包括当前事务所在的客户端)。若有改动，<code>exec</code>指令就会返回null告知客户端执行失败，客户端一般会选择重试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch a		## 开启watch，监听变量a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr a		## a被改动</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; multi		## 开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec		## 执行事务，执行失败</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;11&quot;</span><br></pre></td></tr></table></figure>

<p>Redis禁止在<code>multi</code>和<code>exec</code>之间执行<code>watch</code>指令，必须在<code>multi</code>之前<code>watch</code>变量。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理之IO模型与通信协议</title>
    <url>/blog/2019/08/25/redis/7_redis_principle/</url>
    <content><![CDATA[<p>Redis是单线程程序。为什么单线程运行这么快？单线程如何处理高并发的客户端请求？答案是<strong>多路复用API</strong>。</p>
<p>Redis认为数据库的瓶颈不是网络流量而是内部逻辑，所以即使Redis使用了浪费流量的文本协议，依然有超高的访问性能。Redis将所有数据都放到内存中，用一个单线程对外提供服务，单个节点跑满CPU核心的情况下，甚至可以达到10w/s的超高QPS。Redis的协议是**RESP(Redis Serialiation Protocol)**。</p>
<a id="more"></a>

<h3 id="1-线程IO模型"><a href="#1-线程IO模型" class="headerlink" title="1. 线程IO模型"></a>1. 线程IO模型</h3><p>Redis是单线程程序，<strong>Node.js</strong>、<strong>nginx</strong>也是单线程程序，但其都是高性能的典范。</p>
<p>Redis内所有数据都在内存中，所有运算都是内存级别的运算，所以尽快Redis是单线程程序，但是其仍然是高性能的，可以应对来着高并发的客户端请求。但是也要小心使用Redis指令，尤其是时间复杂度为O(n)的指令，例如：<code>scan</code>、<code>keys</code>，可能会导致Redis卡顿。</p>
<h4 id="1-非阻塞IO"><a href="#1-非阻塞IO" class="headerlink" title="1. 非阻塞IO"></a>1. 非阻塞IO</h4><p>当我们调用套接字的读写方法时，默认是阻塞的。例如<code>read(n)</code>表示要传递n个字节，若当前一个字节没有，那么线程会阻塞，知道有新的数据到来或者连接关闭，线程才会继续执行。而<code>write</code>方法则一般不会阻塞，除非内核为套接字分配的缓冲区已满(<code>write</code>会阻塞，直到缓冲区中有空闲空间)。</p>
<p><img src="https://images.effiu.cn/blog/redis/19.png" alt="非阻塞IO模型"></p>
<p>非阻塞IO则在套接字基础上提供了一个选项<strong>Non_Blocking</strong>，当这个选项打开时，读写不会阻塞，而是能读多少算多少，能写多少算多少。读取上限取决于内核为套接字分配的读缓冲区内部数据字节数，写上限也是内核为套接字分配的写缓冲区空闲空间字节数。读方法和写方法都会通过返回值告知程序实际读写字节数。</p>
<p>有了非阻塞IO意味着线程在读写IO时可以不必阻塞了，读写可以瞬间完成。</p>
<h4 id="2-时间轮询-多路复用"><a href="#2-时间轮询-多路复用" class="headerlink" title="2. 时间轮询(多路复用)"></a>2. 时间轮询(多路复用)</h4><p>非阻塞IO通用存在问题，即线程读取数据，若读取一部分返回了，线程如何继续读。当数据来时，线程如何得到通知。写同样，当写缓冲区满了时，写不完，剩下的字节数何时才能继续写，线程也应该得到通知。</p>
<p><img src="https://images.effiu.cn/blog/redis/20.png" alt="多路复用"></p>
<p>时间轮询API就是解决上述问题的。最简单的轮询API是<code>select</code>函数，其是操作系统提供给用户的API。输入是读写描述符列表<code>read_fds &amp; write_fds</code>，输出是与之对应的可读可写的事件，同时提供了<code>timeout</code>参数，若没有任何事件到来，就立即返回；时间过了，没有任何事件到来，同样立即返回。拿到事件后线程会挨个处理相应的事件。处理完了继续轮询。线程处于一个死循环状态，称为事件循环，一次循环称为一个循环周期。</p>
<p>通过<code>select</code>系统调用同时处理多个通道描述符的读写事件，因此将这类系统调用统称为多路复用API。现代操作系统的多路复用API已经不再使用<code>select</code>系统调用，而是<code>epoll(linux)</code>和<code>kqueue(fress &amp; macosx)</code>，<code>select</code>系统调用的性能在描述符特别多时性能会变差。但是其本质是一样的。</p>
<p>服务端套接字<code>serversocket</code>对象的读操作是调用<code>accept</code>接受客户端新连接，其也是通过<code>select</code>系统调用读事件得到通知的。事件轮询API其实就是<strong>Java NIO</strong>技术。</p>
<h4 id="3-指令队列"><a href="#3-指令队列" class="headerlink" title="3. 指令队列"></a>3. 指令队列</h4><p>Redis会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列顺序处理。</p>
<h4 id="4-响应队列"><a href="#4-响应队列" class="headerlink" title="4. 响应队列"></a>4. 响应队列</h4><p>Redis会为每个客户端套接字关联一个响应队列。Redis客户端通过响应队列将指令的返回结果返回给客户端。若队列为空，则说明连接暂时处于空闲状态，不需要获取事件，也可以将当前客户端描述符从<code>write_fds</code>中移除，等队列数据不为空，再将描述符放回。避免<code>select</code>系统调用立即返回写事件，而并没有返回结果，出现这种情况会立即飙高CPU</p>
<h4 id="5-定时任务"><a href="#5-定时任务" class="headerlink" title="5. 定时任务"></a>5. 定时任务</h4><p>服务器要处理响应IO事件之外，还有其他事情。例如，若线程阻塞在<code>select</code>系统调用上，定时任务将无法得到准确的时间调度。那么定时器是如何解决的呢？</p>
<p>Redis的定时任务会记录在一个最小堆的数据结构中，在这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期中，Redis都会将最小堆中已经到点的任务立即进行处理。处理完成后，将最快要执行的任务还需要执行的时间记录下来，这个时间就是<code>select</code>系统调用的<code>timeout</code>参数。Redis知道未来<code>timeout</code>时间内，没有其他定时任务需要处理，所以可以阻塞<code>timeout</code>时间。</p>
<h3 id="2-通信协议"><a href="#2-通信协议" class="headerlink" title="2. 通信协议"></a>2. 通信协议</h3><h4 id="1-RESP"><a href="#1-RESP" class="headerlink" title="1. RESP"></a>1. RESP</h4><p>RESP(Redis Serialiation Protocol)是Redis序列化协议的简写。其是一种直观的文本协议，优势是实现简单，解析性能好。Redis协议将传输的结构分为5种最小单元类型，单元结束是统一加上回车换行符号<code>\r\n</code>。具体如下：</p>
<ul>
<li>单行字符串以<code>+</code>符号开头</li>
<li>多行字符串以<code>$</code>字符串开头，后面跟字符串长度</li>
<li>整数值以<code>:</code>开头，后跟整数字符串形式</li>
<li>错误消息以<code>-</code>符号开头</li>
<li>数组以<code>*</code>开头，后跟数组的长度</li>
</ul>
<p>具体例子如下：</p>
<ul>
<li>单行字符串 hello world：<code>+hello world\r\n</code></li>
<li>多行字符串 hello world：<code>$11\r\nhello world\r\n</code>。多行也可以表示单行</li>
<li>整数 1024：<code>:1024\r\n</code></li>
<li>错误 参数类型错误：<code>-WRONGTYPE Operation against a key holding the wrong kind of value\r\n</code></li>
<li>数组 [1,2,3]：<code>*3\r\n:1\r\n:2\r\n:3\r\n</code></li>
<li><code>NULL</code>用多行字符串表示，长度为-1：<code>$-1\r\n</code></li>
<li>空串用多行字符串表示，长度为0：<code>$0\r\n\r\n</code>，<code>\r\n</code>中间隔的是空字符串</li>
</ul>
<h4 id="2-服务端-gt-客户端"><a href="#2-服务端-gt-客户端" class="headerlink" title="2. 服务端 -&gt; 客户端"></a>2. 服务端 -&gt; 客户端</h4><p>服务端向客户端回复的响应要支持多种数据结构，有5中基本类型：</p>
<ul>
<li><p>单行字符响应，如下：OK便是响应。即<code>+OK</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set x a</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误响应，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr x</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></table></figure>
</li>
<li><p>整数响应</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr a</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行字符串响应，使用双引号括起来的就是多行字符串响应</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get a2</span><br><span class="line">&quot;x&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组响应</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys a*</span><br><span class="line">1) &quot;a2&quot;</span><br><span class="line">2) &quot;a&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套，如下：<code>scan</code>命令用来扫描服务器中包含的key列表以游标的形式获取，一次只获取一部分。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match a* count 10000</span><br><span class="line">1) &quot;7167&quot;</span><br><span class="line">2) 1) &quot;a&quot;</span><br><span class="line">   2) &quot;a2&quot;</span><br></pre></td></tr></table></figure>

<p><code>scan</code>其返回的是一个嵌套数组。数组的第一个值是游标的值，值为0说明已经遍历完毕。否则可以使用这个游标继续遍历下去。数组的第二个值又是一个数组，即key值列表</p>
</li>
</ul>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>Redis协议中有大量冗余的回车换行符，但这不影响其是互联网技术领域中非常受欢迎的文本协议。很多开源项目适应RESP作为它的通信协议。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis GeoHash And Scan</title>
    <url>/blog/2019/08/24/redis/6_geohash_scan/</url>
    <content><![CDATA[<p>Redis在3.2版本后增加了<strong>地理位置GEO模块</strong>，我们可以用Redis实现“附近的人”、“附近的店”等等功能。</p>
<p>在Redis的日常运维中，有时候需从Redis中找出符合特定条件的key列表手动处理数据。<code>keys</code>指令用来列出所有符合条件的key。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys x*</span><br><span class="line">1) &quot;x3&quot;</span><br><span class="line">2) &quot;x2&quot;</span><br><span class="line">3) &quot;x&quot;</span><br></pre></td></tr></table></figure>

<p>其使用非常简单，但是有两个明显的缺点：</p>
<ul>
<li>没有<code>offset</code>、<code>limit</code>参数，一次性吐出所有满足条件的key，若结果太多，会非常不方便处理问题。</li>
<li><code>keys</code>是遍历算法，复杂度是<code>O(n)</code>，若实例中有千万级的key，就会导致Redis服务卡顿，所有Redis的其他指令都会被延后甚至卡顿，因为Redis是单线程程序，顺序执行所有指令，其他指令必须等当前keys指令执行完了才可以继续。</li>
</ul>
<p>为了解决上述问题：Redis提供了<code>scan</code>指令</p>
<a id="more"></a>

<h3 id="1-GeoHash"><a href="#1-GeoHash" class="headerlink" title="1. GeoHash"></a>1. GeoHash</h3><h4 id="1-用数据库计算“附近的”"><a href="#1-用数据库计算“附近的”" class="headerlink" title="1. 用数据库计算“附近的”"></a>1. 用数据库计算“附近的”</h4><p>地图元素的位置数据使用经纬度表示。当两个元素距离不是很远时，可以直接使用勾股定理计算得到元素之间的距离。例如，“附近的人”，元素距离都不大，勾股定理计算的到的距离完全可以。实际上经纬度坐标的密度不一样，勾股定理计算后，需要按照一定的系数比例加权求和。</p>
<p><img src="https://images.effiu.cn/blog/redis/13.png"></p>
<p>假如元素的经纬度使用关系数据库存储，那么该如何计算两个元素之间的位置？</p>
<p>我们<strong>肯定不能</strong>通过遍历计算所有的元素和目标元素的距离然后排序。一般方法是通过矩形区域限定元素的数量，然后对区域内的元素进行全量计算在排序，我们可以指定一个半径，以元素位置为中心的半径范围内。然后为了满足高性能的查询，还需要对经纬度上的坐标加上(x,y)双向索引。</p>
<h4 id="2-GeoHash"><a href="#2-GeoHash" class="headerlink" title="2. GeoHash"></a>2. GeoHash</h4><p>现在比较通用的地理位置距离排序算法是GeoHash算法。Redis也提供了GeoHash算法。GeoHash算法将二维经纬度数据映射到一维的整数，将所有元素放在一条线上，距离很近的坐标映射到一维上也会很近。当我们查找“附近的”时，首先将目标映射到线上，在一维的线上获取“附近的”功能。</p>
<p>GeoHash将整个地球看出一个平面，然后分为一系列正方形的方格，所有元素的坐标都放置于一个方格中，方格越小，坐标越精确，然后对方格进行整数编码，越靠近的方格整数编码越接近。编码方式如下，好比切蛋糕，两刀下去，四个小蛋糕为：<code>00</code>、<code>01</code>、<code>10</code>、<code>11</code>四个二进制整数，继续对小蛋糕进行切割，方格会越来越小，二进制会越来越长，同时精确度也会越来越高。</p>
<p>上面说明时是二刀法，实际算法可能有很多刀，最终编码出的整数数字也不一样。</p>
<p><img src="https://images.effiu.cn/blog/redis/14.gif"></p>
<p>编码后，每个地图元素都是一个整数，整数可以还原出元素的坐标，整数越长，还原出的坐标越准确。</p>
<p>GeoHash算法会对这个整数做一次base32的编码(<code>0~9</code>、<code>a~z</code>中去掉<code>a</code>、<code>i</code>、<code>l</code>、<code>o</code>)变成一个字符串。在Redis中经纬度使用52位整数进行编码，放到<code>zset</code>中，<code>zset</code>的<code>value</code>元素是元素的<code>key</code>，<code>score</code>是<code>GeoHash</code>的52位整数。<code>zset</code>的<code>score</code>是浮点数，但是对于52位整数值，可以无损存储。</p>
<p>在使用Geo查询时，我们要时刻想到它的内部是一个<code>zset</code>(skiplist)。通过<code>zset</code>的<code>score</code>排序就可以得到坐标附近的其他元素，通过<code>score</code>还原成坐标就可以得到元素的原始坐标</p>
<h4 id="3-Geo指令的使用"><a href="#3-Geo指令的使用" class="headerlink" title="3. Geo指令的使用"></a>3. Geo指令的使用</h4><p>Redis提供的Geo指令有6个：</p>
<ul>
<li><p><code>geoadd</code>，增加。<code>geoadd key member1 score1 member2 score2 ...</code>，最多加入3个元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd  company 116.48105 39.996794 juejin</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geodist</code>，距离。可以用来计算两个元素之间的距离。<code>geodist key member1 member2 [unit]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km</span><br><span class="line">&quot;10.5501&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader m</span><br><span class="line">&quot;10550.0768&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geopos</code>，位置。获取元素位置。<code>geopos key memeber [member...]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos company ireader juejin</span><br><span class="line">1) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br><span class="line">2) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br></pre></td></tr></table></figure>

<p>可以发现，<code>geopos</code>的到的坐标与<code>geoadd</code>进去的坐标有轻微误差，原因是<code>geohash</code>对二维坐标进行一维运算的映射是有损的，所以还原回来会有较小的差别。</p>
</li>
<li><p><code>geohash</code>，元素的hash值，获取元素经纬度base32编码字符串。<code>geohash key memeber [member ...]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash company ireader</span><br><span class="line">1) &quot;wx4g52e1ce0&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以直接去<a href="http://geohash.org/wx4g52e1cekk">geohash.org</a>去查询。</p>
</li>
<li><p><code>georadiusbymember</code>，查询指定元素附近的其他元素，参数较复杂。<code>georadiusbymember key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STROE key] [STOREDIST key]</code>。<code>withdist</code>显示距离；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc</span><br><span class="line">1) &quot;ireader&quot;</span><br><span class="line">2) &quot;juejin&quot;</span><br><span class="line">3) &quot;meituan&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withdist count 3 asc</span><br><span class="line">1) 1) &quot;ireader&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">2) 1) &quot;juejin&quot;</span><br><span class="line">   2) &quot;10.5501&quot;</span><br><span class="line">3) 1) &quot;meituan&quot;</span><br><span class="line">   2) &quot;11.5748&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>georadius </code>，根据经纬度查询“附近的”。<code>georadius key longitude latitute raduis m|km|ft|mi  [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STROE key] [STOREDIST key]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius company 116.514202 39.905409 20 km count 3 desc</span><br><span class="line">1) &quot;meituan&quot;</span><br><span class="line">2) &quot;juejin&quot;</span><br><span class="line">3) &quot;ireader&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h4><p>在实际应用中，用Redis的GeoHash存储数据，会将其放到一个<code>zset</code>中，其数据流非常大。而在Redis集群中，集合可能会从一个节点迁移到另一个节点，若单个key太大，会对集群的迁移工作造成较大影响，集群环境中单个key的大小不宜超过1M，否则会影响集群的迁移，造成卡顿。建议Geo数据使用单独的Redis实例部署。</p>
<h3 id="2-Scan"><a href="#2-Scan" class="headerlink" title="2. Scan"></a>2. Scan</h3><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><p><code>scan</code>与<code>keys</code>相比有以下优势：</p>
<ul>
<li><code>scan</code>复杂度O(n)，但是其是通过游标分布进行的，不会阻塞线程。</li>
<li><code>limit</code>参数，可以控制每次返回的结果，<code>limit</code>是一个<code>hint</code>，返回的结果可多可少</li>
<li>同<code>keys</code>一样，提供匹配功能</li>
<li>服务器不需要为游标保存状态，游标的唯一状态是<code>scan</code>返回给客户端的游标整数</li>
<li>返回的结果可能会有重复，需要客户端去重</li>
<li>遍历的过程中若有数据修改，改动后的数据能不能遍历到是不确定的</li>
<li>单次返回的结果是空的，并不意味着遍历结束，而要看返回的游标值是否为0</li>
</ul>
<p><code>scan cursor [mathch pattern] [COUNT count]</code>，<code>cursor</code>整数值；<code>pattern</code>key的正则模式；<code>count</code>遍历的limit hint。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match scan9* count 10</span><br><span class="line">1) &quot;3072&quot;</span><br><span class="line">2) 1) &quot;scan9945&quot;</span><br><span class="line">   2) &quot;scan9469&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 3072 match scan9* count 10</span><br><span class="line">1) &quot;15872&quot;</span><br><span class="line">2) 1) &quot;scan9877&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 15872 match scan9* count 10</span><br><span class="line">1) &quot;11008&quot;</span><br><span class="line">2) 1) &quot;scan9551&quot;</span><br><span class="line">   2) &quot;scan9804&quot;</span><br></pre></td></tr></table></figure>

<p>第一次遍历时，<code>cursor</code>为0，然后将返回结果的下一整数值作为下一次遍历的<code>cursor</code>，一直遍历到返回的<code>cursor</code>值为0时结束。<code>limit</code>为10，并不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数(约等于)</p>
<h4 id="2-字典的结构"><a href="#2-字典的结构" class="headerlink" title="2. 字典的结构"></a>2. 字典的结构</h4><p>Redis中所有的key都存储在一个很大的字典里，字典结构与<code>HashMap</code>一样，是一维数组+二维链表结构，第一维数组的大小总是<code>z^n</code>，扩容一次空间加倍。</p>
<p><img src="https://images.effiu.cn/blog/redis/15.png" alt="字典结构"></p>
<p><code>sacn</code>指令返回的游标就是一维数组的位置索引，称为<code>slot</code>。若不考虑字典的扩容缩容，直接按数组下标挨个遍历槽就行。<code>limit</code>表示需要遍历的槽的数量。每次遍历都会将<code>limit</code>数量的槽位上挂接的链表元素进行匹配过滤后，一次性返回给客户端。</p>
<h4 id="3-scan遍历顺序"><a href="#3-scan遍历顺序" class="headerlink" title="3. scan遍历顺序"></a>3. scan遍历顺序</h4><p>scan的遍历顺序是采用<strong>高位加法</strong>，不是从一维数组的0位开始遍历。这是考虑到了字典的扩容和缩容避免槽位的遍历重复和遗漏。正常加法与高位加法区别(从左侧开始加)：</p>
<p><img src="https://images.effiu.cn/blog/redis/16.gif" alt="正常加法与高位加法区别"></p>
<h4 id="4-字典扩容"><a href="#4-字典扩容" class="headerlink" title="4. 字典扩容"></a>4. 字典扩容</h4><p>Java中<code>HashMap</code>有扩容的概念，当<code>loadFactor</code>达到阈值时，需要重新分配一个新的2倍大小的数组，将所有元素rehash到新的数组中。rehash是将数元素的hash值对数组长度进行取模运算，因为长度变了，所有每个元素挂接的槽位可能也发生了变化。又因为数组长度是2的n次方，所以取模运算等于位于操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a mod <span class="number">8</span> = a &amp; (<span class="number">8</span>-<span class="number">1</span>) = a &amp; <span class="number">7</span>;</span><br><span class="line">a mod <span class="number">16</span> = a &amp; (<span class="number">16</span>-<span class="number">1</span>) = a &amp; <span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<p>7,15称之为字典的mask值，作用是保留hash值的低位，高位置为0(高位肯定是其整数倍)。</p>
<p>假设字典数组长度由8变为16，那么3号槽位<code>011</code>将会被rehash为<code>0011</code>和<code>1011</code>(高位+1)，槽位中约有一半元素保留在原来3号槽位，另一半分配到了<code>11</code>号槽位。</p>
<p><img src="https://images.effiu.cn/blog/redis/17.png" alt="扩容"></p>
<p>即扩容前操作为xxxx，那么扩容后为<code>0xxxx</code>和<code>1xxxx</code>两个槽位。</p>
<p><img src="https://images.effiu.cn/blog/redis/18.png" alt="扩容前后遍历顺序"></p>
<p>上图是采用高位加法扩容后的槽位分布。假设当前遍历到<code>110</code>时发生扩容，那么新槽位是<code>0110</code>和<code>1110</code>，我们可以在<code>0110</code>这个位置继续遍历(<code>0110</code>之前的槽位都是遍历过的)，避免扩容后对已遍历过的槽位重复遍历。假设遍历到<code>110</code>发生缩容，那么<code>110</code>与<code>010</code>新槽位为<code>10</code>，我们只需要从<code>10</code>开始重新遍历就可以。</p>
<p>Java的<code>HashMap</code>扩容时会一次性将旧数组下挂接的元素全部转移到新数组下，<code>HashMap</code>中数组特别多，线程会出现卡顿现象。Redis采用了渐进式rehash，避免了卡顿问题。其同时会保留新数组和旧数组，然后在定时任务中以及后续hash指令操作中渐渐将旧数组中挂接的链表移动到新数组上。这便是rehash过程中，需要同时访问新旧两个数组。若在旧数组中找不到元素，还需要去新数组中查找。</p>
<p><code>scan</code>时，若出现扩容或者缩容，就需要同时扫描新旧槽位，将结果合并后返回。</p>
<h4 id="5-scan其他指令"><a href="#5-scan其他指令" class="headerlink" title="5. scan其他指令"></a>5. scan其他指令</h4><p><code>scan</code>是一系列指令，除了可以遍历所有key之外，还可以对指定容器集合进行遍历。</p>
<ul>
<li><code>zscan</code>遍历<code>zset</code></li>
<li><code>hscan</code>遍历<code>hash</code></li>
<li><code>sscan</code>遍历<code>set</code></li>
</ul>
<p>其原理与<code>scan</code>类似，<code>hash</code>底层是字典，<code>set</code>也是特殊的hash(所有的value，指向同一个元素)，<code>zset</code>内部也使用了字典存储所有的元素内容。Reids把所有的key存储在一个特殊的字典中。</p>
<h4 id="6-大key扫描"><a href="#6-大key扫描" class="headerlink" title="6. 大key扫描"></a>6. 大key扫描</h4><p>有时候会因为业务人员使用不当，Redis中出现很大的对象。大对象对于Redis集群的数据迁移带来很大的问题，在集群环境下，对象太大会导致数据迁移卡顿。Redis扩容时，也会一次为大对象分配更大的一块内存，也会导致卡顿。大对象被删除时，内存会被一次性回收，也会造成卡顿现象。</p>
<p>工作中，尽量避免大Key产生，若出现Redis内存的大起大落，可能是因为大对象产生的，这时候就需要定位出具体是哪个key，进一步定位出具体的来源，改善代码设计。</p>
<p>使用<code>scan</code>指令定位大key，对于扫描出的key，使用<code>type</code>指令确认类型，然后使用对应数据结构的<code>size</code>或者<code>len</code>方法确认大小。不过该过程需要写脚本。</p>
<p>redis-cli提供了扫描功能，可以直接使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6379 -h host -bigkeys</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-cli -p 6379 -h host -bigkeys -i 0.1</span><br></pre></td></tr></table></figure>

<p>每隔 100 条 scan 指令就会休眠 0.1s，不过时间会变长。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 限流算法</title>
    <url>/blog/2019/08/23/redis/5_limiting/</url>
    <content><![CDATA[<p>限流算法在分布式领域是一个很重要的知识点，当系统处理能力有限时，如何阻止计划外的请求继续对系统施压，非常重要。限流除了控制流量还被用于控制用户行为，避免垃圾请求。例如，控制用户的发帖、回复、点赞等行为，一般是限制用户某种行为在规定时间内允许的次数，超过次数就是非法行为。</p>
<ul>
<li>滑窗限流</li>
<li>漏斗限流</li>
</ul>
<a id="more"></a>

<h3 id="1-滑窗限流"><a href="#1-滑窗限流" class="headerlink" title="1. 滑窗限流"></a>1. 滑窗限流</h3><p>简单限流，要求存在一个滑动窗口，利用<code>zset</code>数据结构的<code>score</code>值，可以通过<code>score</code>来确定时间窗口。我们只要保留这个时间窗口，窗口之外的数据都可以砍掉，<code>zset</code>的value只需要保证唯一性即可。</p>
<p><img src="https://images.effiu.cn/blog/redis/12.png" alt="滑窗算法"></p>
<p>如上图，用一个<code>zset</code>记录用户行为，每个行为都在<code>zset</code>中保存下来，一个用户一个行为用一个key保存。为了节省内存，我们只需要保留时间窗口内的行为记录，若用户是冷用户，滑动窗口内的行为是空记录，那么<code>zset</code>就可以从内存中移除。统计滑动窗口内的行为数量与阈值<code>max_count</code>进行比较就可以得出当前行为是否允许，滑窗算法Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">&quot;simpleLimit&quot;</span>;</span><br><span class="line">    ZSetOperations zSetOperations = redisTemplate.opsForZSet();</span><br><span class="line">    redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    String value = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> millis = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> second = millis / <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 删除5s之前的数据</span></span><br><span class="line">        zSetOperations.removeRangeByScore(key, <span class="number">0</span>, second - <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 随机数，模拟访问时间的随机性</span></span><br><span class="line">        <span class="keyword">int</span> r = random.nextInt(<span class="number">5</span>);</span><br><span class="line">        SleepUtils.second(r);</span><br><span class="line">        <span class="comment">// 当前5s内访问次数</span></span><br><span class="line">        Long count = zSetOperations.count(key, second - <span class="number">5</span>, second);</span><br><span class="line">        <span class="comment">// 5s内最多允许3个</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;zset has full, skip &quot;</span> + i + <span class="string">&quot; sleep &quot;</span> + r);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;zset &quot;</span> + value + <span class="string">&quot;&quot;</span> + i);</span><br><span class="line">        zSetOperations.add(key, value + <span class="string">&quot;&quot;</span> + i, second);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(zSetOperations.zCard(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zset value0</span><br><span class="line">zset value1</span><br><span class="line">zset value2</span><br><span class="line">zset value3</span><br><span class="line">zset has full, skip <span class="number">4</span> sleep <span class="number">0</span></span><br><span class="line">zset has full, skip <span class="number">5</span> sleep <span class="number">2</span></span><br><span class="line">zset value6</span><br><span class="line">zset value7</span><br><span class="line">zset value8</span><br><span class="line">zset value9</span><br><span class="line">zset has full, skip <span class="number">10</span> sleep <span class="number">0</span></span><br><span class="line">zset has full, skip <span class="number">11</span> sleep <span class="number">3</span></span><br><span class="line">zset value12</span><br><span class="line">zset value13</span><br><span class="line">zset value14</span><br><span class="line">zset value15</span><br><span class="line">zset value16</span><br><span class="line">zset value17</span><br><span class="line">zset value18</span><br><span class="line">zset value19</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果(5s内只允许3个请求)，20个请求中过滤掉了4个请求。</p>
<p>思路为：每当一个请求到来时，都维护一个时间窗口，删除该窗口之前的数据。<code>zset</code>中的<code>score</code>为用户请求的时间。其他<a href="https://book.onee.top/redis/articles/apply-6.html">滑窗算法</a></p>
<p>上述是限流的简单应用，还有很大的扩展空间</p>
<h3 id="2-漏斗限流"><a href="#2-漏斗限流" class="headerlink" title="2. 漏斗限流"></a>2. 漏斗限流</h3><h4 id="1-漏斗原理"><a href="#1-漏斗原理" class="headerlink" title="1. 漏斗原理"></a>1. 漏斗原理</h4><p>漏斗限流是最常用的限流方法之一，其灵感来自于漏斗结构。漏斗容量有限，若漏嘴流水速度大于灌水速度，那么漏斗永远不会满，当大于的时候，漏斗满了，就需要暂停并等待。</p>
<ul>
<li>漏斗的剩余空间，代表当前可以持续进行的数量</li>
<li>漏斗的流水速度，代表系统允许的该行为最大频率</li>
<li>漏斗容量，代表最大空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunnelLimiting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 漏斗最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 漏斗流水速度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 剩余空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> leftSpace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上次漏水时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastWater;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FunnelLimiting</span><span class="params">(<span class="keyword">long</span> capacity, <span class="keyword">double</span> rate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">        <span class="comment">// 剩余空间等于初始容量</span></span><br><span class="line">        leftSpace = capacity;</span><br><span class="line">        lastWater = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 漏斗流水,核心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watering</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity - leftSpace &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 漏斗已空</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 漏斗未满时</span></span><br><span class="line">        <span class="keyword">long</span> millis = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 时间间隔</span></span><br><span class="line">        <span class="keyword">long</span> delta = millis - lastWater;</span><br><span class="line">        <span class="keyword">long</span> deltaQuota = (<span class="keyword">long</span>) (delta * rate);</span><br><span class="line">        <span class="comment">// 当前时间小于上次漏水时间或者间隔太短</span></span><br><span class="line">        <span class="keyword">if</span> (deltaQuota &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        leftSpace = (deltaQuota + leftSpace) &gt; capacity ? capacity : leftSpace + deltaQuota;</span><br><span class="line">        System.out.println(<span class="string">&quot;流出:&quot;</span> + deltaQuota);</span><br><span class="line">        lastWater = millis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 漏斗加水</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWater</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加水之前，先流水</span></span><br><span class="line">        watering();</span><br><span class="line">        <span class="keyword">if</span> (leftSpace &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            leftSpace -= <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求&quot;</span> + i + <span class="string">&quot;加水成功, leftSpace:&quot;</span> + leftSpace);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求&quot;</span> + i + <span class="string">&quot;加水失败&quot;</span>);</span><br><span class="line">        <span class="comment">//水满</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 容量100，速率0.2(5s流尽)</span></span><br><span class="line">        FunnelLimiting fl = <span class="keyword">new</span> FunnelLimiting(<span class="number">5</span>, <span class="number">0.2</span>);</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 1次请求</span></span><br><span class="line">            fl.addWater(i);</span><br><span class="line">            SleepUtils.second(r.nextInt(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请求<span class="number">1</span>加水成功, leftSpace:<span class="number">4</span></span><br><span class="line">请求<span class="number">2</span>加水成功, leftSpace:<span class="number">3</span></span><br><span class="line">请求<span class="number">3</span>加水成功, leftSpace:<span class="number">2</span></span><br><span class="line">请求<span class="number">4</span>加水成功, leftSpace:<span class="number">1</span></span><br><span class="line">请求<span class="number">5</span>加水失败</span><br><span class="line">请求<span class="number">6</span>加水失败</span><br><span class="line">流出:<span class="number">1</span></span><br><span class="line">请求<span class="number">7</span>加水成功, leftSpace:<span class="number">1</span></span><br><span class="line">请求<span class="number">8</span>加水失败</span><br><span class="line">请求<span class="number">9</span>加水失败</span><br><span class="line">请求<span class="number">10</span>加水失败</span><br></pre></td></tr></table></figure>

<p>上述代码的核心是，<code>watering()</code>方法，每次加水之前都要先流出水。流出的水量，是根据上次流水至今的时间以及流水速率。</p>
<blockquote>
<p>考虑问题时，先不要考虑太复杂，简化问题，然后就会发现简化后的代码，每个方法内的大部分代码都是可扩展的。</p>
</blockquote>
<h4 id="3-Redis实现"><a href="#3-Redis实现" class="headerlink" title="3. Redis实现"></a>3. Redis实现</h4><p>Reids也提供了漏斗算法的实现。我们可以将<code>FunnelLimiting</code>对象的内容按字段长度存储到一个<code>hash</code>中，加水和流水取出<code>hash</code>计算完成后，再将数据放回到<code>hash</code>中。但是从取出hash数据，到运算，再到放回到Redis中，这个过程需要保证原子性。所以需要加锁控制，但仍会存在加锁失败的情况，重试又会导致性能下降，放弃可能会影响用户体验。</p>
<p>Redis提供了Redis-Cell模块，其内部包含漏斗算法。安装过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@vdevops zips]# wget https:&#x2F;&#x2F;github.com&#x2F;brandur&#x2F;redis-cell&#x2F;releases&#x2F;download&#x2F;v0.2.4&#x2F;redis-cell-v0.2.4-x86_64-unknown-linux-gnu.tar.gz</span><br><span class="line"></span><br><span class="line">[root@vdevops zips]# tar -zxvf redis-cell-v0.2.4-x86_64-unknown-linux-gnu.tar.gz</span><br><span class="line">libredis_cell.d</span><br><span class="line">libredis_cell.so</span><br></pre></td></tr></table></figure>



<p>启用<code>redis-cell</code>需要在连接redis后，执行<code>module load /usr/local/redis-4.0.6/redis-cell/libredis_cell.so</code>。其提供了原子指令<code>cl.throttle</code>，其参数和返回值：</p>
<ul>
<li><code>cl.throttle key capacity molecule Denominator [quota]</code><ul>
<li><code>capacity</code>，容量</li>
<li><code>molecule </code>，分子；<code>Denominator </code>，分母。<code>molecule/Denominator </code>为流失速率。</li>
<li><code>quota</code>，配额，默认为1</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; module load /usr/local/redis-4.0.6/redis-cell/libredis_cell.so</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; cl.throttle x 10 2 10 1</span><br><span class="line">(error) Cell error: cannot parse integer from empty string</span><br><span class="line">127.0.0.1:6379&gt; cl.throttle x1 10 2 10 1</span><br><span class="line">1) (integer) 0			# 0表示允许；1表示拒绝</span><br><span class="line">2) (integer) 11			# 漏斗容量，capacity</span><br><span class="line">3) (integer) 10			# 漏斗剩余空间</span><br><span class="line">4) (integer) -1			# 如果拒绝了，需要多长时间后再试(漏斗有空间了，单位秒)</span><br><span class="line">5) (integer) 5			# 多长时间后，漏斗完全空出来(单位秒)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis HyperLogLog和布隆过滤器</title>
    <url>/blog/2019/08/22/redis/4_hyperloglog_bloom_filter/</url>
    <content><![CDATA[<p>若需要统计网站网页的UV和PV数据，如何实现呢？</p>
<p>PV我们需要给每个网页加一个独立的Redis计数器就可以，Key为网页+日期组成。</p>
<p>UV则需要去重，一个用户一天无论请求多少次都只计算一次，这就要求每个网页请求都要带上用户唯一标识，最简单的方法使用<code>set</code>集合存储当天所有访问过此页面的用户Id。<code>sadd</code>统计用户标识，<code>scard</code>可以取出集合大小。但是当访问量大时，比如几千万的UV，那就就需要很大的set集合统计，浪费空间。若页面非常多，所需要的存储空间非常大。</p>
<p>Redis提供了<code>HyperLogLog</code>数据结构就是用来解决这种统计问题的。<code>HyperLogLog</code>提供不精确的去重计数方案，其标准误差是<code>0.81%</code>，这样的精确度已经完全满足UV统计需求了。<code>HyperLogLog</code>是Redis的高级数据结构，非常有用，<font color='red'><code>HyperLogLog</code>数据结构来进行估数，它非常有价值，可以解决很多精确度不高的统计需求</font>。</p>
<p>但是我们无法知道<code>HyperLogLog</code>数据结构内是否存在某个值，因为其为提供相关方法。若有个需要判断值是否在Redis中存在的业务场景，如何处理呢？例如：新闻客户端中，每次推荐都要去掉那些已经看过的内容，新闻客户端如何去重呢？</p>
<ul>
<li>服务端有统计用户访问记录，直接从用户历史记录中进行筛选，当用户量大，新闻又多的情况下，性能会很差。需要频繁的在数据库中进行<code>exists</code>操作。</li>
<li>缓存，将历史记录缓存起来，这回浪费很大的存储空间，且存储空间会随着时间线性增长</li>
<li><strong>布隆过滤器</strong>(Bloom Filter)，专门用来解决去重问题，且还会节省90%以上的空间，但存在误判的情况。</li>
</ul>
<a id="more"></a>

<h3 id="1-HyperLogLog"><a href="#1-HyperLogLog" class="headerlink" title="1. HyperLogLog"></a>1. HyperLogLog</h3><h4 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h4><p><code>HyperLogLog</code>提供了两个指令<code>pfadd</code>和<code>pfcount</code></p>
<ul>
<li><code>pfadd</code>：增加计数，与<code>sadd</code>类似</li>
<li><code>pfcount</code>：获取计数，与<code>scard</code>类似</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd x 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount x</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd x 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount x</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; pfadd x 1	# 重复值，不计入HyperLogLog中</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; pfcount x</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>使用spring-boot-starter-redis，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pfadd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">&quot;hyper&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1000</span>;</span><br><span class="line">    String[] values = <span class="keyword">new</span> String[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        values[i % length] = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % (length / <span class="number">10</span>) == (length / <span class="number">10</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">            hyperLogLogOperation.pfadd(key, values);</span><br><span class="line">            System.out.println(<span class="string">&quot;pfadd&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;, pfcount:&quot;</span> + hyperLogLogOperation.pfcount(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hyperLogLogOperation.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>100</th>
<th>1000</th>
<th>100000</th>
</tr>
</thead>
<tbody><tr>
<td>pfadd:10, pfcount:10<br/>pfadd:20, pfcount:20<br/>pfadd:30, pfcount:30<br/>pfadd:40, pfcount:40<br/>pfadd:50, pfcount:50<br/>pfadd:60, pfcount:60<br/>pfadd:70, pfcount:70<br/>pfadd:80, pfcount:80<br/>pfadd:90, pfcount:90<br/>pfadd:100, pfcount:100</td>
<td>pfadd:100, pfcount:100<br/>pfadd:200, pfcount:200<br/>pfadd:300, pfcount:299<br/>pfadd:400, pfcount:401<br/>pfadd:500, pfcount:502<br/>pfadd:600, pfcount:603<br/>pfadd:700, pfcount:701<br/>pfadd:800, pfcount:800<br/>pfadd:900, pfcount:901<br/>pfadd:1000, pfcount:999</td>
<td>pfadd:10000, pfcount:9890<br/>pfadd:20000, pfcount:19897<br/>pfadd:30000, pfcount:29565<br/>pfadd:40000, pfcount:39270<br/>pfadd:50000, pfcount:49511<br/>pfadd:60000, pfcount:59126<br/>pfadd:70000, pfcount:69588<br/>pfadd:80000, pfcount:79667<br/>pfadd:90000, pfcount:89596<br/>pfadd:100000, pfcount:99681</td>
</tr>
</tbody></table>
<p>上表是代码中length长度为<code>1000</code>、<code>10000</code>、<code>10000</code>时的<code>pfcount</code>的结果</p>
<ul>
<li>发现当<code>length</code>小于<code>100</code>时是精确统计</li>
<li>当<code>length</code>大于<code>100</code>时会出现误差。当<code>length</code>为<code>100000</code>时误差为0.319%。</li>
<li><code>length</code>为<code>10000</code>时，执行多次，其五误差几乎没有区别</li>
</ul>
<p><code>HyperLogLog</code>除了<code>pfadd</code>和<code>pfcount</code>之外，还有<code>pfmerge</code>指令，用于将多个pf计数值累加在一起形成一个新的pf值</p>
<p><code>HyperLogLog</code>数据结构需要占据一定12K的存储空间，其不适合统计单个用户相关的数据。当计数较小时，其存储空间采用稀释矩阵存储，占用空间小。当计数变大后，稀疏矩阵占用空间超过阈值时就会变为稠密矩阵(12K空间)</p>
<blockquote>
<p>矩阵中，若数值为0的元素数目远远多于非0的数目，且非0元素分布没有规律时，则成为稀疏矩阵，反之则为稠密矩阵。非零元素的总数比上矩阵所有元素总数为矩阵的稠密度。</p>
</blockquote>
<h4 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h4><p><code>HyperLogLog</code>实现原理非常复杂。</p>
<p><img src="https://images.effiu.cn/blog/redis/09.png"></p>
<p>上图的意思是，给定一系列随机整数，记录下低位连续零位的最大长度K，通过这个K值可以估算出随机数的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">28000</span>;</span><br><span class="line"><span class="comment">// 生成随机数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000</span>; i &lt; value; i += <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxbit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; i; n++) &#123;</span><br><span class="line">        <span class="keyword">long</span> nextLong = ThreadLocalRandom.current().nextLong(<span class="number">2L</span> &lt;&lt; <span class="number">32</span>);</span><br><span class="line">        <span class="comment">// 计算最右侧位的0的个数</span></span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 右移后左移，比较，不一致则说明到达非0位</span></span><br><span class="line">            <span class="keyword">if</span> (nextLong &gt;&gt; j &lt;&lt; j != nextLong) &#123;</span><br><span class="line">                bit = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bit &gt; maxbit) &#123;</span><br><span class="line">            maxbit = bit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%d %.2f %d\n&quot;</span>, i, Math.log(i) / Math.log(<span class="number">2</span>), maxbit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17000 14.05 14</span><br><span class="line">18000 14.14 14</span><br><span class="line">19000 14.21 18</span><br><span class="line">20000 14.29 16</span><br><span class="line">21000 14.36 13</span><br><span class="line">22000 14.43 13</span><br><span class="line">23000 14.49 13</span><br><span class="line">24000 14.55 13</span><br><span class="line">25000 14.61 15</span><br><span class="line">26000 14.67 15</span><br><span class="line">27000 14.72 16</span><br></pre></td></tr></table></figure>

<p>可以发现约等于<code>N = 2^K</code>，当然也不能直接使用<code>2^K</code>得出结果，误差太大，所以使用加权估计，得出一个比较准确的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">1000000</span>;</span><br><span class="line"><span class="comment">// 生成随机数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100000</span>; i &lt; value; i += <span class="number">100000</span>) &#123;</span><br><span class="line">    <span class="comment">// 用于统计，加权求平均</span></span><br><span class="line">    <span class="keyword">int</span>[] maxbits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; i; n++) &#123;</span><br><span class="line">        <span class="keyword">long</span> nextLong = ThreadLocalRandom.current().nextLong(<span class="number">1L</span> &lt;&lt; <span class="number">32</span>);</span><br><span class="line">        <span class="comment">// 计算最右侧位的0的个数</span></span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 右移后左移，比较，不一致则说明到达非0位</span></span><br><span class="line">            <span class="keyword">if</span> (nextLong &gt;&gt; j &lt;&lt; j != nextLong) &#123;</span><br><span class="line">                bit = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((nextLong &amp; <span class="number">0xfff0000</span>) &gt;&gt; <span class="number">16</span>) % <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> (bit &gt; maxbits[index]) &#123;</span><br><span class="line">            maxbits[index] = bit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加权</span></span><br><span class="line">    <span class="keyword">double</span> sum = Arrays.stream(maxbits).mapToDouble(p -&gt; <span class="number">1.0</span> / (<span class="keyword">double</span>) p).sum();</span><br><span class="line">    <span class="keyword">double</span> v = Math.pow(<span class="number">2</span>, <span class="number">1024</span> / sum) * <span class="number">1024</span>;</span><br><span class="line">    System.out.printf(<span class="string">&quot;%d %.2f %f\n&quot;</span>, i, v, Math.abs(v - i) / i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中，统计低位连续零位长度，计算平均数使用了调和平均(倒数的平均)，普通的平均可能因为个别离群值对平均结果产生较大影响，调和平均可以有效平滑离群值的影响。</p>
<p>数字，HyperLogLog结果，误差分别如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 10000 ~ 10000</span><br><span class="line">10000 1024.00 0.897600</span><br><span class="line">20000 13969.31 0.301534</span><br><span class="line">30000 23489.89 0.217004</span><br><span class="line">40000 33584.74 0.160381</span><br><span class="line">50000 45875.72 0.082486</span><br><span class="line">60000 52604.23 0.123263</span><br><span class="line">70000 63463.54 0.093378</span><br><span class="line">80000 71176.03 0.110300</span><br><span class="line">90000 82269.44 0.085895</span><br><span class="line"></span><br><span class="line"># 100000 ~ 1000000</span><br><span class="line">100000 90529.35 0.094707</span><br><span class="line">200000 198486.87 0.007566</span><br><span class="line">300000 297014.96 0.009950</span><br><span class="line">400000 388669.03 0.028327</span><br><span class="line">500000 487944.01 0.024112</span><br><span class="line">600000 584373.50 0.026044</span><br><span class="line">700000 702676.54 0.003824</span><br><span class="line">800000 841088.37 0.051360</span><br><span class="line">900000 920170.04 0.022411</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以得出，当HyperLogLog为10万级别以上后，其误差非常小。也可以调高桶进行计算</p>
</blockquote>
<p>上述算法中，使用了1024个桶进行独立计数，不过在Redis的HyperLogLog中用到的是16384(z^14)个桶，每个桶的<code>maxbits</code>需要6个bits存储，最大可以表示63，所以一共有<code>2^14*6</code>个bit位，即<code>2^10*2*6</code>个bit位，即12K。</p>
<p><code>HyperLogLog</code>提供了<code>pfadd</code>和<code>pfcount</code>，但是没有提供<code>pfcontains</code>这种方法，所以我们无法知道某个值是否在<code>HyperLogLog</code>数据结构中。</p>
<h3 id="2-布隆过滤器"><a href="#2-布隆过滤器" class="headerlink" title="2. 布隆过滤器"></a>2. 布隆过滤器</h3><p><strong>布隆过滤器</strong>可以理解位一个不精确的<code>set</code>结构，当使用<strong>布隆过滤器</strong>的<code>contains</code>方法判断对象是否存在时，可能会误判，但也可以把误差控制在很小范围内。布隆过滤器判断某个值存在时，其可能不存在，但当判断为不存在时，那肯定不存在。</p>
<p>其应用到新闻去重中，布隆过滤器能准确判断已经看过的内容。没看过的内容也可能会漏掉(误判)一部分，但是能保证绝大多数新内容都能准确识别。这样就能保证推荐给用户的内容是无重复的。</p>
<h4 id="1-使用方法-1"><a href="#1-使用方法-1" class="headerlink" title="1. 使用方法"></a>1. 使用方法</h4><p>布隆过滤器有两个基本指令，</p>
<ul>
<li><code>bf.add</code>添加元素，与<code>set</code>集合中<code>sadd</code>类似，但一次只能添加一个元素。</li>
<li><code>bf.exists</code>，查询元素是否存在，用法与<code>set</code>集合的<code>sismember</code>差不多。</li>
<li><code>bf.madd</code>，添加元素，可以一次添加多个。</li>
<li><code>bf.mexists</code>，查询多个元素是否存在，</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bf.add x a1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add x a2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add x a3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists x a1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists x a2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists x a4</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h4 id="2-安装方法"><a href="#2-安装方法" class="headerlink" title="2. 安装方法"></a>2. 安装方法</h4><p>Redis 官方提供的<strong>布隆过滤器</strong>是从 Redis 4.0开始提供的。其安装过程如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/RedisBloom/RedisBloom</span><br><span class="line">cd RedisBloom/</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>修改启动脚本，在start启动命令中，加<code>$BLOOM_FILTER</code>配置，<code>INITIAL_SIZE</code>用来设置默认容量，<code>ERROR_RATE</code>默认错误率</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">REDISPORT=****</span><br><span class="line">PASSWORD=****</span><br><span class="line">EXEC=/usr/local/bin/redis-server</span><br><span class="line">CLIEXEC=/usr/local/bin/redis-cli</span><br><span class="line"></span><br><span class="line">PIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pid</span><br><span class="line">CONF=&quot;/usr/local/redis-4.0.6/redis.conf&quot;</span><br><span class="line">BLOOM_FILTER=&quot;--loadmodule /usr/local/redis-4.0.6/RedisBloom/redisbloom.so INITIAL_SIZE 100000 ERROR_RATE 0.001&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        if [ -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE exists, process is already running or crashed&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;Starting Redis server...&quot;</span><br><span class="line">                $EXEC $CONF $BLOOM_FILTER</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        if [ ! -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE does not exist, process is not running&quot;</span><br><span class="line">        else</span><br><span class="line">                PID=$(cat $PIDFILE)</span><br><span class="line">                echo &quot;Stopping ...&quot;</span><br><span class="line">                $CLIEXEC -a $PASSWORD -p $REDISPORT shutdown</span><br><span class="line">                while [ -x /proc/$&#123;PID&#125; ]</span><br><span class="line">                do</span><br><span class="line">                    echo &quot;Waiting for Redis to shutdown ...&quot;</span><br><span class="line">                    sleep 1</span><br><span class="line">                done</span><br><span class="line">                echo &quot;Redis stopped&quot;</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    clistart)</span><br><span class="line">	if [ ! -f $PIDFILE ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;$PIDFILE does not exist, process is not running&quot;</span><br><span class="line">	else</span><br><span class="line">		echo &quot;redis is connecting ...&quot;</span><br><span class="line"><span class="meta">		$</span><span class="bash">CLIEXEC -p <span class="variable">$REDISPORT</span> -a <span class="variable">$PASSWORD</span></span></span><br><span class="line">	fi</span><br><span class="line">	;;</span><br><span class="line">    *)</span><br><span class="line">    echo &quot;Please use start, stop or clistart as first argument&quot;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>目前版本spring-boot-starter-redis未提供布隆过滤器，此处省略代码实现。感兴趣的，可以使用<code>Lettuce</code>计算下错误率。</p>
<p>直接使用布隆过滤器，就会在我们第一次<code>bf.add</code>时使用默认参数构建(如上文的<code>INITIAL_SIZE 100000 ERROR_RATE 0.001</code>)。Redis还提供了自定义参数的布隆过滤器。在<code>bf.add</code>之前使用<code>bf.reserve</code>指令显式创建。若对应的key已存在，<code>bf.reserve</code>报错。其参数：<code>key</code>、<code>error_rate</code>、<code>initial_size</code>。错误率越低，需要的空间越大。<code>initial_size</code>表示预计放入的元素数量，当实际数量超出该值时，错误率会明显上升。</p>
<p>布隆过滤器的<code>initial_size</code>估计的过大，会浪费存储空间，估计的过小，会影响准确率，所以在使用前一定要尽可能精确估计好元素数量，还需要加一定的冗余空间以避免实际元素可能会意外高出估计值很多。<code>error_rate</code>越小，需要的存储空间越大。</p>
<h4 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h4><p><img src="https://images.effiu.cn/blog/redis/10.png" alt="布隆过滤器原理"></p>
<p>布隆过滤器对应到Redis的数据结构里就是一个大型的位数组和几个不一样的无偏hash函数，无偏指的是可以把元素的hash值算的比较均匀。</p>
<p>向布隆过滤器中添加<code>key</code>时，会使用多个<code>hash</code>函数对<code>key</code>进行<code>hash</code>算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个<code>hash</code>函数都会算得一个不同的位置。再把位数组的这几个位置都置为<code>1</code>就完成了<code>add</code>操作。</p>
<p>向布隆过滤器询问<code>key</code>是否存在时，与<code>bf.add</code>一致，也会把<code>hash</code>的几个位置算出来，看看位数组中这些位置是否为<code>1</code>，只要<code>1</code>个为<code>0</code>，那就说明布隆过滤器中这个<code>key</code>不存在；若都为<code>1</code>，那就说明这个<code>key</code>极有可能存在，并不是肯定存在，因为有可能这些位被置为1是因为其他key存在导致的。位数组越稀疏，准确率越高，越拥挤则准确率越低。</p>
<p>使用布隆过滤器时，不要让实际元素大于初始化大小，当实际元素数开始超出初始化大小时，应对布隆过滤器进行重建，重新分配一个<code>size</code>更大的过滤器，再将所有历史元素批量<code>add</code>进去。<code>error_rate</code>不会因为数量超出就急剧增加，这给我们重建过滤器提供了较为宽松的时间。</p>
<h4 id="4-占用空间估计"><a href="#4-占用空间估计" class="headerlink" title="4. 占用空间估计"></a>4. 占用空间估计</h4><p>布隆过滤器占用空间有一个简单的计算公式。布隆过滤器有两个参数：</p>
<ul>
<li>n，预计元素的数量</li>
<li>f，错误率</li>
</ul>
<p>由以上两个输入可以得到两个输出：</p>
<ul>
<li>l，需要的存储空间大小，bit</li>
<li>k，hash函数的最佳数量，hash函数会直接影响错误率，最佳的数量会有最低的错误率</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">k = <span class="number">0.7</span> * (l / n)</span><br><span class="line">f = <span class="number">0.6185</span> ^ (l / n)	# 可以计算出l</span><br></pre></td></tr></table></figure>

<p>从公式可以得出：</p>
<ul>
<li>位数组越长，错误率越低</li>
<li>位数组越长，hash函数越多，越影响计算效率</li>
<li>当一个元素平均需要8bit指纹空间时，错误率大约为2%</li>
<li>错误率为10%，一个元素平均需要4.793 bit</li>
<li>错误率为1%，一个元素需要9.585 bit</li>
<li>错误率为0.1%，一个元素需要14.377 bit</li>
</ul>
<p>可以发现一个元素仅仅需要15bit就能控制错误率在0.1%。布隆过滤器存储的是元素的指纹，需要15bit，而元素的内容甚至可以达到几百字节，而且元素本身需要一个指针被set集合来引用，所以布隆过滤器的空间优势是非常明显的</p>
<p>目前已经由网站支持布隆过滤器相关计算，例如[布隆计算器](<a href="https://krisives.github.io/bloom-calculator/]">https://krisives.github.io/bloom-calculator/]</a></p>
<p>当元素超出时，误判率会发生变化。引入参数t，表示实际元素和预计元素的倍数。公式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f&#x3D;(1-0.5^t)^k  # 极限近似，k 是 hash 函数的最佳数量</span><br></pre></td></tr></table></figure>

<p>当t增加时，错误率f会增大，分别选择错误率为10%、1%、0.1%的k值，曲线如下：</p>
<p><img src="https://images.effiu.cn/blog/redis/11.png" alt="曲线"></p>
<p>从上图可以发现：错误率的变化情况，当t为2时(实际元素比预计元素)，错误率会明显上升。</p>
<h4 id="5-其他应用场景"><a href="#5-其他应用场景" class="headerlink" title="5. 其他应用场景"></a>5. 其他应用场景</h4><ol>
<li>爬虫系统，对URL进行去重，已经爬过的网页不需要继续爬</li>
<li>NoSQL，当用户来查询某个Row时，可以先通过布隆过滤器过滤掉大量不存在的Row请求，显著降低IO请求</li>
<li>邮箱系统，垃圾邮件过滤，误判很低</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis延时队列和位图</title>
    <url>/blog/2019/08/20/redis/3_delay_queue_bit/</url>
    <content><![CDATA[<ul>
<li><p>常用的消息队列中间件是RabbitMQ、Kafka、RocketMQ等，给应用程序之间增加异步消息传递功能。Redis也可以实现基本的消息队列，其没有太多高级特性，没有ack保证，但是也能满足大部分业务需求。</p>
</li>
<li><p>平时开发过程中，会有一些<code>bool</code>型数据需要存取，比如用户的签到记录，签到为1，不签到为0，要记录365天，若使用普通的key/value，浪费存储空间。Redis提供了<strong>位图</strong>数据结构，每天只占据1个位，这样可以大大节省存储空间。</p>
</li>
</ul>
<a id="more"></a>

<h3 id="1-异步消息队列"><a href="#1-异步消息队列" class="headerlink" title="1. 异步消息队列"></a>1. 异步消息队列</h3><p>Redis的list数据结构常用来作为异步消息队列使用，<code>rpush</code>/<code>lpush</code>操作入队列，<code>lpop</code>/<code>rpop</code>出队列</p>
<p><img src="https://images.effiu.cn/blog/redis/07.png" alt="消息队列"></p>
<p>客户端通过<code>lpop</code>和<code>rpop</code>操作获取消息，然后进行处理。处理完了继续获取消息，在进行处理。这就是客户端作为队列消费者的客户端声明周期。</p>
<ol>
<li><p>若队列空了，就会陷入<code>pop</code>死循环，非常浪费资源(拉高了客户端的CPU，Redis的QPS也会被拉高)。所有使用<code>sleep</code>解决问题。<code>Thread.sleep(1000)</code></p>
</li>
<li><p>睡眠会导致消息延迟增大。<code>blpop</code>/<code>brpop</code>，<strong>阻塞读</strong>可以解决问题。阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻唤醒，消息延迟位0。</p>
</li>
<li><p>使用<code>blpop</code>/<code>brpop</code>仍然不完美，空闲连接问题。其会造成线程一直被阻塞，产生Redis空闲连接，闲置过久，服务器会主动断开连接，减少资源占用，这时<code>blpop</code>/<code>brpop</code>还会抛出异常。</p>
</li>
</ol>
<h4 id="锁冲突处理"><a href="#锁冲突处理" class="headerlink" title="锁冲突处理"></a>锁冲突处理</h4><p><a name='#timeout'></a>分布式锁中客户端在处理请求时加锁失败如何解决：</p>
<ul>
<li>直接抛出异常，通知用户稍后重试。适合由用户直接发起的请求，从弹出错误到用户重试有个缓冲时间，考虑到用户体验，还可以由后台代替进行延迟重试控制。本质上是对当前请求的放弃，由用户决定是否发起新的请求。</li>
<li>sleep，一会重试。sleep会阻塞当前线程，会导致队列的后续消息出现延迟。若碰撞比较频繁或者队列里消息过多，不建议使用sleep。若出现加锁失败的线程，还会导致线程堵死。</li>
<li>将请求转移至延时队列，一会重试。比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理以避开冲突。</li>
</ul>
<h4 id="队列延时的实现"><a href="#队列延时的实现" class="headerlink" title="队列延时的实现"></a>队列延时的实现</h4><p>延时队列可以通过Redis的zset实现，将消息序列化为一个字符串做为zset的<code>value</code>，消息的到期处理时间作为score，然后轮询获取到期的任务进行处理。若要为了保障程序的可用型，则使用多线程轮询，但同时也要考虑并发争抢任务，确保任务不能被多执行。Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDelayingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskItem</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    	<span class="keyword">public</span> String id;</span><br><span class="line">    	<span class="keyword">public</span> T msg;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// fastjson 序列化对象中存在 generic 类型时，需要使用 TypeReference</span></span><br><span class="line">  	<span class="keyword">private</span> Type TaskType = <span class="keyword">new</span> TypeReference&lt;TaskItem&lt;T&gt;&gt;() &#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">private</span> Jedis jedis;</span><br><span class="line">  	<span class="keyword">private</span> String queueKey;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">RedisDelayingQueue</span><span class="params">(Jedis jedis, String queueKey)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">    	<span class="keyword">this</span>.queueKey = queueKey;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(T msg)</span> </span>&#123;</span><br><span class="line">    	TaskItem&lt;T&gt; task = <span class="keyword">new</span> TaskItem&lt;T&gt;();</span><br><span class="line">    	task.id = UUID.randomUUID().toString(); <span class="comment">// 分配唯一的 uuid</span></span><br><span class="line">    	task.msg = msg;</span><br><span class="line">    	String s = JSON.toJSONString(task); <span class="comment">// fastjson 序列化</span></span><br><span class="line">    	jedis.zadd(queueKey, System.currentTimeMillis() + <span class="number">5000</span>, s); <span class="comment">// 塞入延时队列 ,5s 后再试</span></span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 轮询获取到期任务</span></span><br><span class="line">    	<span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">      		<span class="comment">// 只取一条。zrangeByScore()获取指定(0, System.currentTimeMillis())，即到期的任务。</span></span><br><span class="line">      		Set&lt;String&gt; values = jedis.zrangeByScore(queueKey, <span class="number">0</span>, System.currentTimeMillis(), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">      		<span class="keyword">if</span> (values.isEmpty()) &#123;</span><br><span class="line">        		<span class="keyword">try</span> &#123;</span><br><span class="line">          			Thread.sleep(<span class="number">500</span>); <span class="comment">// 歇会继续</span></span><br><span class="line">        		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">       			<span class="keyword">continue</span>;</span><br><span class="line">      		&#125;</span><br><span class="line">      		String s = values.iterator().next();</span><br><span class="line">            <span class="comment">// zrem争抢消费任务</span></span><br><span class="line">      		<span class="keyword">if</span> (jedis.zrem(queueKey, s) &gt; <span class="number">0</span>) &#123; <span class="comment">// 抢到了</span></span><br><span class="line">            	TaskItem&lt;T&gt; task = JSON.parseObject(s, TaskType); <span class="comment">// fastjson 反序列化</span></span><br><span class="line">        		<span class="comment">// 任务处理</span></span><br><span class="line">          		<span class="keyword">this</span>.handleMsg(task.msg);</span><br><span class="line">      		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="comment">// 任务处理，应该捕获异常，防止单个任务异常导致的消费任务线程退出</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMsg</span><span class="params">(T msg)</span> </span>&#123;</span><br><span class="line">    	System.out.println(msg);</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">    	RedisDelayingQueue&lt;String&gt; queue = <span class="keyword">new</span> RedisDelayingQueue&lt;&gt;(jedis, <span class="string">&quot;q-demo&quot;</span>);</span><br><span class="line">    	Thread producer = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">      		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        	  		queue.delay(<span class="string">&quot;codehole&quot;</span> + i);</span><br><span class="line">        		&#125;</span><br><span class="line">      		&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	Thread consumer = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                queue.loop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	producer.join();</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            consumer.interrupt();</span><br><span class="line">            consumer.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis的<code>zrem</code>命令是多线程争抢任务的关键，其返回值决定了当前实例是否抢到任务。<code>loop</code>方法可能被多线程、多个进程调用，同一任务可能被多个线程线程抢到，通过<code>zrem</code>决定唯一消费线程。</p>
<h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><p>上述代码中仍然有个缺陷，即当<code>zrangebyscore</code>得到任务后，使用<code>zrem</code>争抢，没抢到的线程会浪费资源，需要使用Luascript优化逻辑，集成<code>zrangebyscore</code>和<code>zrem</code>为原子操作，多个进程之间争抢任务就不会出现浪费了。</p>
<h3 id="2-位图"><a href="#2-位图" class="headerlink" title="2. 位图"></a>2. 位图</h3><p>位图不是特殊的数据结构，其就是普通的字符串，<code>byte</code>数组。可以使用普通的<code>get</code>/<code>set</code>指令直接获取和设置整个位图的内容，也可以使用<code>getbit</code>/<code>setbit</code>等当成<code>byte</code>数组处理</p>
<p>我们需要统计月活时，也可以使用位图标记用户的活跃状态。每个用户都在位图上有一个确定的位置，到月底就看可以直接遍历位图得到用户活跃度。但是当用户活跃度不高时，可能会得不偿失。</p>
<h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><p>Redis的位数组是自动扩展，若设置了某个偏移位置超出现有的内容范围，就会自动将位数组进行零位扩充。</p>
<p>例如，字符<code>h</code>位ASCII码的对应为<code>01101000</code>(104)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit x 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit x 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit x 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get x</span><br><span class="line">&quot;h&quot;</span><br></pre></td></tr></table></figure>

<p>上面例子为零存整取，另外还有零存零取，整存领取。零存是用<code>setbit</code>对位置设置，整存就是使用<code>set</code>命令设置字符串。</p>
<p>常用命令：</p>
<ul>
<li><code>setbit x 1 1</code>，零存</li>
<li><code>set x h</code>，整存</li>
<li><code>getbit x 1</code>，零取</li>
<li><code>getbit x</code>，整取</li>
</ul>
<h4 id="2-统计和查找"><a href="#2-统计和查找" class="headerlink" title="2. 统计和查找"></a>2. 统计和查找</h4><p>Redis提供了位图统计指令<code>bitcount</code>和位图查找指令<code>bitpos</code>，<code>bitcount</code>用来统计指定范围内1的个数，<code>bitpos</code>用来查找指定范围内出现的第一个0或者1。</p>
<p>例如，我们可以使用<code>bitcount</code>统计用户签到天数，通过<code>bitpos</code>指令查找用户从哪一天开始签到。若指定了参数范围<code>[start, end]</code>，就可以统计在某个时间范围内用户签到天数，从哪一天开始签到。<code>start</code>和<code>end</code>参数是字节索引，指定范围必须是8的倍数(一个字节占8位)。<code>bitcount</code>和<code>bitpos</code>命令如下：</p>
<ul>
<li><code>bitcount key [start end]</code> ，指定范围内1的个数</li>
<li><code>bitpos key bit [start] [end]</code>，指定范围内出现的0或者1的个数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set x h</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitcount x</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; bitcount x 0 0   ## x中1的个数</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; bitpos x 0		## x中第一个0位</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitpos x 1		## x中第一个1位</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitpos x 1 0 0	## x中第0个字符起，第1个1位(实际上就是第0个字符的第一个1位)</span><br><span class="line">(integer) 1		</span><br></pre></td></tr></table></figure>

<h4 id="3-魔术指令bitfield"><a href="#3-魔术指令bitfield" class="headerlink" title="3. 魔术指令bitfield"></a>3. 魔术指令<code>bitfield</code></h4><p><code>setbit</code>/<code>getbit</code>指定位是单个的，若要一次操作多个位则需要使用<code>bitfield</code>。<code>bitfield</code>有3个子指令<code>get</code>/<code>set</code>/<code>incr</code>，都可以对指定片段进行读写，但最多只能处理64个连续的位，超过64位，就需要使用多个子指令。<code>bitfield</code>支持多个子指令。</p>
<p><img src="https://images.effiu.cn/blog/redis/08.png"></p>
<p>命令：<code>bitfield key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</code></p>
<p>举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get u4 0		# 取w中第一位开始的四个位，结果为无符号数，0110为6</span><br><span class="line">1) (integer) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield w get i4 0		# 取w中第一位开始的四个位，结果为有符号数</span><br><span class="line">1) (integer) 6</span><br></pre></td></tr></table></figure>

<p>有符号数时获取的位数组中第一个位为符号位，剩下的才是值。符号位为1，则表示负数。无符号位表示非负数，获取的位数组全部为值。有符号位最大可以获取64位，无符号为最大获取63位(Redis协议中integer是有符号数，第一位为符号位，所以不能传递64位无符号值)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitfield w get u4 0 get u3 2 get i4 0 get i3 2</span><br><span class="line">1) (integer) 6</span><br><span class="line">2) (integer) 5</span><br><span class="line">3) (integer) 6</span><br><span class="line">4) (integer) -3</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitfield w set u8 8 97	#从第 9 个位开始，将接下来的 8 个位用无符号数 97 替换</span><br><span class="line">1) (integer) 101</span><br><span class="line">127.0.0.1:6379&gt; get w</span><br><span class="line">&quot;hallo&quot;</span><br></pre></td></tr></table></figure>

<p><code>incrby</code>用来对指定范围的位进行自增操作。自增可能会溢出。Redis默认的溢出规则是折返(WRAP)，出现溢出则将溢出位丢掉。例如：8位无符号位255(11111111)，加1后为<code>100000000</code>，丢弃溢出位1，得0。8位有符号位127(01111111)，加1后溢出<code>10000000</code>，即-128</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w incrby u4 2 1	# 从第3位开始，对后面的4个比特位加1 1010 -&gt; 1011</span><br><span class="line">1) (integer) 11</span><br><span class="line">127.0.0.1:6379&gt; bitfield w incrby u4 2 5	# 1011 -&gt; 10000，折返为0</span><br><span class="line">1) (integer) 0</span><br></pre></td></tr></table></figure>

<p><code>bitfield</code>提供了3种溢出策略指令：</p>
<ul>
<li><p><code>wrap</code>：折返，折返如上。</p>
</li>
<li><p><code>fail</code>：失败报错不执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitfield w overflow fail incrby u4 2 6</span><br><span class="line">1) (nil)</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get w</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sat</code>：饱和截断</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield w overflow sat incrby u4 2 6	# 1010 -&gt; 10000，饱和截断 -&gt; 1111</span><br><span class="line">1) (integer) 15</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式锁</title>
    <url>/blog/2019/08/19/redis/2_distribute_lock/</url>
    <content><![CDATA[<p>在分布式应用中进行业务逻辑处理经常会遇到并发问题。这时就需要使用分布式锁限制程序的并发执行。Redis分布式锁应用非常广泛。</p>
<a id="more"></a>

<h3 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1. 分布式锁"></a>1. 分布式锁</h3><p>分布式锁本质上要实现的目标就是在Redis里占一个位置，当其他进程或线程也要访问时，发现已被占用，则放弃或者稍后再试。</p>
<p>占位置是使用<code>setnx</code>(set if not exists)指令，只允许被一个客户端占用，用完了使用<code>del</code>指令删除。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> setnx lock:codehole <span class="literal">true</span></span></span><br><span class="line">···do something critical···</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> del lock:codehole</span></span><br></pre></td></tr></table></figure>

<p>上述过程会产生一个问题，逻辑执行过程中出现异常，可能会导致<code>del</code>指令不会被调用，导致死锁。所以拿到锁之后，给锁加过期时间，保证及时业务逻辑出现异常，也不会死锁。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> setnx lock:codehole <span class="literal">true</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> expire lock:codehole 5</span></span><br><span class="line">···do something critical···</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> del lock:codehole</span></span><br></pre></td></tr></table></figure>

<p>上述逻辑仍然有问题，因为<code>setnx</code>和<code>expire</code>为两个操作，非原子性。不能使用Redis事务解决问题，因为<code>setnx</code>不一定成功，即<code>expire</code>是依赖于<code>setnx</code>执行结果的，而事务中是没有if-else的。</p>
<p>Redis2.8中引入了<code>set</code>指令的扩展参数，使得<code>setnx</code>和<code>expire</code>指令可以一起执行。如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> lock:codehole <span class="literal">true</span> ex 5 nx</span></span><br><span class="line">··· do something critical ···</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> del lock:codehole</span></span><br></pre></td></tr></table></figure>

<p>上述仍然存在超时问题，即加锁和释放锁之间逻辑执行太长，以至于超出锁的超时限制，这时第一个线程持有锁到期，临界区逻辑未执行完成，第二个线程持有了锁。所以Redis分布式锁不能用于处理较长时间的任务。</p>
<p>有一个稍微安全的方式是为<code>set</code>指令的<code>value</code>设置一个随机数，释放锁时先匹配随机数是否一致，然后删除key，这是为了确保当前线程占有的锁不会被其他线程释放，除非key过期。但是匹配value和删除key非原子操作，Redis中也没有delifequals这种指令，所以需要<strong>Lua脚本</strong>处理，Lua脚本可以保证连续多个指令的原则性执行。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>但是仍然存在超时问题。<a href='/blog/2019/08/20/redis/3_delay_queue_bit#timeout' target='_blank'>建议方案</a></p>
<h3 id="2-可重入性"><a href="#2-可重入性" class="headerlink" title="2. 可重入性"></a>2. 可重入性</h3><p>可重入性是指线程在持有锁的情况下再次请求加锁，若一个锁支持同一个线程多次加锁，那么该锁就是可重入的，例如:<code>ReentrantLock</code>。Redis分布式锁若支持可重入，需要对set方法进行包装，使用线程的<code>ThreadLocal</code>变量存储当前持有锁的计数。Java版代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisWithReentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ThreadLocal&lt;Map&lt;String, Integer&gt;&gt; lockers = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RedisWithReentrantLock</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">_lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jedis.set(key, <span class="string">&quot;&quot;</span>, <span class="string">&quot;nx&quot;</span>, <span class="string">&quot;ex&quot;</span>, <span class="number">5L</span>) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">_unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    jedis.del(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title">currentLockers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; refs = lockers.get();</span><br><span class="line">    <span class="keyword">if</span> (refs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> refs;</span><br><span class="line">    &#125;</span><br><span class="line">    lockers.set(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> lockers.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; refs = currentLockers();</span><br><span class="line">    Integer refCnt = refs.get(key);</span><br><span class="line">    <span class="keyword">if</span> (refCnt != <span class="keyword">null</span>) &#123;</span><br><span class="line">      refs.put(key, refCnt + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">this</span>._lock(key);</span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    refs.put(key, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; refs = currentLockers();</span><br><span class="line">    Integer refCnt = refs.get(key);</span><br><span class="line">    <span class="keyword">if</span> (refCnt == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    refCnt -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (refCnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      refs.put(key, refCnt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      refs.remove(key);</span><br><span class="line">      <span class="keyword">this</span>._unlock(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">    RedisWithReentrantLock redis = <span class="keyword">new</span> RedisWithReentrantLock(jedis);</span><br><span class="line">    System.out.println(redis.lock(<span class="string">&quot;codehole&quot;</span>));</span><br><span class="line">    System.out.println(redis.lock(<span class="string">&quot;codehole&quot;</span>));</span><br><span class="line">    System.out.println(redis.unlock(<span class="string">&quot;codehole&quot;</span>));</span><br><span class="line">    System.out.println(redis.unlock(<span class="string">&quot;codehole&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是真正的可重入锁，还需要考虑内存锁计数的过期问题，代码复杂度非常高，不建议使用，其加重了客户端的复杂性。完全可以通过调整业务逻辑代替使用重入锁。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础数据结构</title>
    <url>/blog/2019/08/19/redis/1_basic_structure/</url>
    <content><![CDATA[<p>Redis有5种数据结构，分别为：<code>string</code>(字符串)、<code>list</code>(列表)、<code>set</code>(集合)、<code>hash</code>(哈希)、<code>zset</code>(有序集合)。</p>
<p>Redis所有的数据结构都是以唯一的key字符串作为名称，然后通过这个唯一key值获取对应的value数据，不同类型的数据结构的差异就在于value的结构不一样。</p>
<a id="more"></a>

<h3 id="1-string-字符串"><a href="#1-string-字符串" class="headerlink" title="1. string(字符串)"></a>1. string(字符串)</h3><p><strong>string字符串</strong>是Redis中最简单的数据结构。字符串使用非常广泛，常见的是缓存用户信息。将用户信息结构体使用JSON序列化成为字符串，然后将序列化后的字符串放入Redis中缓存。获取用户信息经过一次反序列化的过程。</p>
<p>Redis字符串是动态字符串，是可以修改的字符串，内部结构实现类似于Java的ArrayList，采用预分配冗余空间的方式减少内存的频繁分配。字符串实际分配的空间一般高于字符串长度。字符串长度小于1M时，扩容都是加倍现有空间，超过1M扩容只会多扩1M空间，字符串最大长度为512M。</p>
<ul>
<li><p>常用命令：</p>
<ul>
<li><code>set key value</code></li>
<li><code>get key</code></li>
<li><code>exists key</code>，存在返回1</li>
<li><code>del key</code>，成功返回1</li>
</ul>
</li>
<li><p>字符串相关</p>
<ul>
<li><code>strlen key</code>，字符串长度</li>
<li><code>getrange key 28 34</code>，获取28到34位的字符串</li>
<li><code>setrange key 28 value</code>，覆盖28位及以后字符串(具体根据value长度)</li>
<li><code>append key value1</code>，在原字符串后追加value1</li>
</ul>
</li>
<li><p>批量对多个字符串读写，节省网络耗时开销</p>
<ul>
<li><code>mget key1 key2</code>，返回列表</li>
<li><code>mset key1 value1 key2 value2</code></li>
</ul>
</li>
<li><p>过期和<code>set</code>命令扩展，可以对key设置过期时间，一般用来控制缓存失效时间</p>
<ul>
<li><code>expire key 5</code>，5s后过期</li>
<li><code>setex key 5</code>，等价于<code>set + expire</code></li>
<li><code>setnx key value</code>，若key不存在则执行set创建</li>
</ul>
</li>
<li><p>计数，value为整数时，可以进行则增操作，为<code>Long.MIN_VALUE</code>到<code>Long.MAX_VALUE</code>之间</p>
<ul>
<li><code>incr key</code>，自增1</li>
<li><code>incrby key 5</code>，增加5</li>
<li><code>incrby key -5</code>，减少5</li>
<li><code>decrby key 5</code>，减少5</li>
</ul>
</li>
</ul>
<p>字符串由多个字节组成，每个字节由8bit组成，所以一个字符串就是很多bit。</p>
<h3 id="2-list-列表"><a href="#2-list-列表" class="headerlink" title="2. list(列表)"></a>2. list(列表)</h3><p>Redis中的列表相当于Java中的LinkedList，是双向链表。list的插入和删除操作非常快，时间复杂度为O(1)，索引定位很慢为O(n)。</p>
<p>链表元素使用自然数<code>1,2,3,4,5····n-1</code>表示，还可以使用负数<code>-1,-2 ····· -n</code>表示，<code>-1</code>表示最后一个</p>
<p>Redis的列表结构常用来做异步队列使用。将需要延后处理的任务结构体系序列化成字符串放到Redis的list结构中，另一个线程从这个列表中轮询数据进行处理。</p>
<ul>
<li><p>常用命令：</p>
<ul>
<li><code>rpush key value</code>，右侧插入</li>
<li><code>rpop key</code>，右侧弹出</li>
<li><code>lpush key value</code>，左侧插入</li>
<li><code>lpop key</code>，左侧弹出</li>
<li><code>llen key</code>，list的长度</li>
</ul>
<blockquote>
<p>可以使用上述命令构建队列和堆栈</p>
</blockquote>
</li>
<li><p>满操作</p>
<ul>
<li><code>lindex key index</code>，相当于Java链表中的<code>get(int)</code>方法，需要遍历链表，性能随着index增大而变差</li>
<li><code>ltrim key start_index end_index</code>，保留<code>start_index</code>到<code>end_index</code>之间的数据，其他丢弃。</li>
</ul>
</li>
</ul>
<p>Redis的list数据结构不是简单的<code>LinkedList</code>，而是快速链表quickList的一个结构。在列表元素较少时使用一块连续的内存存储<code>ziplist</code>，即压缩列表。将所有元素紧挨着一起存储，分配的是一块连续内存。数量较多时会改成quicklist。因为普通链表需要附加指针空间太大，比较浪费空间，且会加重内存碎片化。例如列表内存储的是<code>int</code>，然而从结构上还需要<code>prev</code>和<code>next</code>两个指针。所以Redis将链表和<code>ziplist</code>结合起来组成了quicklist。即将多个<code>ziplist</code>使用双向指针串起来。既满足快速插入删除性能，由不会出现太大冗余空间。</p>
<p><img src="https://images.effiu.cn/blog/redis/01.png" alt="quicklist"></p>
<h3 id="3-hash-字典"><a href="#3-hash-字典" class="headerlink" title="3. hash(字典)"></a>3. hash(字典)</h3><p>Redis中的hash相当于Java中的HashMap，是无序字典。其内部实现是数组+链表。第一维hash数组碰撞时，就会将碰撞的元素使用链表串接起来。</p>
<p><img src="https://images.effiu.cn/blog/redis/02.png" alt="quicklist"></p>
<p>Redis字典的值只能是字符串，另外rehash的方式有区别。Java的<code>HashMap</code>在字典很大时，rehash是耗时操作，需要一次性全部rehash。Redis为了提高性能，采用了渐进式的rehash策略。渐进式rehash会在rehash时，保留新旧两个hash结构，查询时同时查询两个hash结构，然后在后续的定时任务中以及hash操作指令中，循序渐进地将旧hash内容迁移到新hash结构中。当迁移完成后，就会使用新的hash结构取而代之，旧的hash在移除完最后一个元素后，会自动被删除。</p>
<p><img src="https://images.effiu.cn/blog/redis/03.png" alt="rehash策略"></p>
<p>hash结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash可以对用户结构中每个字段单独存储，这样也可以单独获取部分信息。以整个字符串的形式缓存用户信息就只能一次性全部读取，浪费网络流量。</p>
<p>hash结构的存储消耗要高于单个字符串，使用hash还是字符串，可以根据以下判断：</p>
<ul>
<li>使用简单的字符串，适用于大多数访问中使用大多数字段</li>
<li>使用hash，大多数访问中仅使用单个字段</li>
</ul>
<p>常用命令：</p>
<ul>
<li><code>hset key key1 value1</code>，value若包含空格，要用引号括起来</li>
<li><code>hgetall key</code>，返回结果是 key和value间隔出现。</li>
<li><code>hlen key</code></li>
<li><code>hget key key1</code></li>
<li><code>hmset key key1 value1 key2 value2</code>，批量set</li>
<li><code>hincrby key key1 1</code>，key中key1增加1</li>
</ul>
<h3 id="4-set-集合"><a href="#4-set-集合" class="headerlink" title="4. set(集合)"></a>4. set(集合)</h3><p>Redis的set集合相当于Java中的<code>HashSet</code>，内部键值对是无序唯一的，内部实现相当于一个特殊字典，字典中所有value均为<code>NULL</code>。set集合中最后一个元素移除后，数据自动删除，内存被回收。</p>
<p>set结构可以用来存储活动中奖用户的id，因为有去重功能，可以保证同一用户不会中奖两次</p>
<p>常用命令：</p>
<ul>
<li><code>sadd key value1</code>，成功返回1，已存在返回0</li>
<li><code>sadd key value2 value3</code>，返回成功的个数</li>
<li><code>smembers key</code></li>
<li><code>sismember key value1</code>，查询某个value1是否存在</li>
<li><code>scard key</code></li>
<li><code>spop key</code>，弹出一个</li>
</ul>
<h3 id="5-zset-有序集合"><a href="#5-zset-有序集合" class="headerlink" title="5. zset(有序集合)"></a>5. zset(有序集合)</h3><p>zset是Redis中最有特色的数据结构，类似于Java中的<code>SortedSet</code>和<code>HashMap</code>的结合体。zset其是一个set，保证了内部value的唯一性，还为每个value赋值了一个score，代表这个value的排序权重。内部实现是一种跳跃列表</p>
<p>zset可以用来存储学生成绩，value是学生id，score是学生分数，可以对成绩按分数进行排序就可以看到他的名次</p>
<p>常用命令：</p>
<ul>
<li><code>zadd key score value</code></li>
<li><code>zrange key 0 -1</code>，按score排序列出，参数区间为排名范围</li>
<li><code>zrevrange key 0 -1</code>，按score逆序列出，参数区间为排名范围</li>
<li><code>zcard key</code>，zset集合内成员数</li>
<li><code>zscore key value</code>，指定value的score</li>
<li><code>zrank key value</code>，指定value的排名</li>
<li><code>zrangebyscore key 0 10</code>，根据score遍历zset集合</li>
<li><code>zrangebyscore books -inf 8.91 withscores</code>，<code>-inf</code>即infinite，无穷大的意思，返回结果为value、score相间输出</li>
<li><code>zrem key value</code>，移除指定value</li>
</ul>
<p>zset内部的排序功能是通过跳跃列表数据结构实现的，结构比较复杂。zset要支持随机的插入和删除，所以不能用数组，只能用链表表示。</p>
<p><img src="https://images.effiu.cn/blog/redis/04.png" alt="链表"></p>
<p>需要这个链表按照score排序，当新元素插入时，要定位到特定位置的插入点，保证链表有序，但是链表定位插入点需要遍历，不能快速定位，所以有了<strong>跳跃列表</strong>。</p>
<p><img src="https://images.effiu.cn/blog/redis/05.png" alt="链表"></p>
<p>最下面一层所有元素都会串起来，然后每隔几个元素挑选出一个代表，再将这几个代表使用另外一级指针串起来，在这些代表里挑出二级代表，再串起来。</p>
<p><strong>跳跃列表</strong>，其内部元素可能“身兼数职”，同时处于多层，可以快速在不同橙子之间进行跳跃。</p>
<p>定位插入点时，先在顶层定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插入进去。跳跃列表采取一个随机策略来决定新元素可以兼职到几层。例如：</p>
<p>首先，L0层是100%，L1层只有50%的概率，L2层只有25%的概率，L3层只有12.5%的概率，一直随机到L31层。列表中的元素越多，能够深入的层次越深。</p>
<h3 id="6-容器型数据结构的通用规则"><a href="#6-容器型数据结构的通用规则" class="headerlink" title="6. 容器型数据结构的通用规则"></a>6. 容器型数据结构的通用规则</h3><p>list/set/hash/zset都是容器型数据结构，其共享下面两条通用规则：</p>
<ul>
<li>create if not exist，容器不存在则创建。</li>
<li>drop if no elements，容器内没有元素，立即删除容器</li>
</ul>
<h3 id="7-过期时间"><a href="#7-过期时间" class="headerlink" title="7. 过期时间"></a>7. 过期时间</h3><p>Redis所有数据结构都可以设置过期时间。过期时间是以对象为单位(key)。当设置过期时间后，使用set方法修改后，过期时间会消失。</p>
<h3 id="8-扩展"><a href="#8-扩展" class="headerlink" title="8. 扩展"></a>8. 扩展</h3><h4 id="1-压缩列表"><a href="#1-压缩列表" class="headerlink" title="1. 压缩列表"></a>1. 压缩列表</h4><p>压缩列表是列表键和哈希键的底层实现之一，为了优化数据存储，列表、哈希、有序集合底层实现都使用了压缩列表</p>
<ul>
<li>当一个列表键只包含少量列表项，且每个列表项要么就是小整数值，要么就是长度比较短的字符串，Redis就会使用压缩列表来做列表键的底层实现。</li>
<li>当一个哈希键只包含少量键时，且每个键值对的键和值要么就是小整数值，要么是长度较短的字符串时，那么Redis就会使用压缩列表来做哈希键的底层实现</li>
</ul>
<p>压缩列表是Redis为了节省内存开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表包含多个节点，每个节点可以保存一个字节数组或一个整数值。</p>
<p><img src="https://images.effiu.cn/blog/redis/06.png" alt="压缩列表"></p>
<p>压缩列表各个部分说明如下：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">长度</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>zlbytes</code></td>
<td align="center"><code>unit32_t</code></td>
<td align="center">4</td>
<td>记录整个压缩列表的长度：在对压缩列表进行内存重分配或则计算zlend的位置时使用</td>
</tr>
<tr>
<td align="center"><code>zltail</code></td>
<td align="center"><code>unit32_t</code></td>
<td align="center">4</td>
<td>记录压缩列表表尾节点距离压缩列表起始地址的偏移量。通过该偏移量可以直接访问压缩列表尾节点的地址</td>
</tr>
<tr>
<td align="center"><code>zlen</code></td>
<td align="center"><code>unit16_t</code></td>
<td align="center">2</td>
<td>记录压缩列表包含的节点数：当该值小于<code>unit16_t</code>的最大值(65536)时，该属性的值就是压缩列表包含的节点数量，大于时，节点的真实属性需要遍历整个压缩列表才能计算出</td>
</tr>
<tr>
<td align="center"><code>entryX</code></td>
<td align="center">列表节点</td>
<td align="center"></td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td>
</tr>
<tr>
<td align="center"><code>zlend</code></td>
<td align="center"><code>unit8_t</code></td>
<td align="center">1</td>
<td>特殊值<code>0xFF</code>十进制的255，用于标记压缩列表的末端</td>
</tr>
</tbody></table>
<blockquote>
<p>Reids文档-<a href="http://redisbook.com/preview/ziplist/list.html">压缩列表</a></p>
</blockquote>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的锁</title>
    <url>/blog/2019/08/19/mysql/11_lock/</url>
    <content><![CDATA[<p><strong>MySQL</strong>为了提高性能而舍弃了部分隔离性。<strong>MVCC</strong>(Muti-Version Concurrency Control)可以保证不同事务的读写、写读操作并发执行。</p>
<p>实际中存在一些业务场景不允许读取旧的版本，只允许读取记录的最新版本。例如，银行存款业务，必须以最新账户余额为准(读取余额 + 存款数据 = 实际余额)。<strong>MVCC</strong>不能满足该要求，所以就需要<strong>锁</strong>保证业务正常。</p>
<p>并发事务带来的问题：</p>
<ul>
<li>读-读，并发事务读取相同记录，不会产生任何问题</li>
<li>写-写，并发事务相继对相同事务做出修改，通过加锁保证事务排队执行。</li>
<li>读-写、写-读，一个事务进行读取操作，另一个事务进行修改操作，使用<strong>MVCC</strong>或者<strong>锁</strong>保证业务正常</li>
</ul>
<p>下面说明<strong>锁</strong>相关知识点</p>
<a id="more"></a>

<h3 id="1-解决并发问题的两种方式"><a href="#1-解决并发问题的两种方式" class="headerlink" title="1. 解决并发问题的两种方式"></a>1. 解决并发问题的两种方式</h3><h4 id="1-锁"><a href="#1-锁" class="headerlink" title="1. 锁"></a>1. 锁</h4><p>当一个事务对某条记录做出改动时，首先会看内存中有没有与这条记录关联的<strong>锁结构</strong>。若没有就会在内存中生成一个锁结构与之关联。</p>
<p><img src="https://images.effiu.cn/blog/mysql/41.png" alt="锁"></p>
<p>在锁结构中有两个属性，保证对记录做改动时是否可以修改。</p>
<ul>
<li>trx信息，代表锁结构属于哪个事务</li>
<li><code>is_waiting</code>，代表当前事务是否在等待</li>
</ul>
<p>上图中，事务<strong>T1</strong><code>update</code>这条记录前，会生成一个锁结构与之关联，若这条记录当前没有其它锁，则把<code>is_waiting</code>置为<code>false</code>，即获取锁成功，或者加锁成功，然后执行<code>update</code>操作。在事务<strong>T1</strong>提交前，事务<strong>T2</strong>也要<code>update</code>这条记录，但会发现有一个锁与之关联，然后会生成一个锁结构与之关联，但是<code>is_waiting</code>为<code>true</code>，表示当前事务需要等待，即生成锁结构成功，获取锁失败，如下图：</p>
<p><img src="https://images.effiu.cn/blog/mysql/42.png" alt="锁"></p>
<p>当事务<strong>T1</strong>提交后，就会把该事务生成的锁结构释放掉，然后看看是否存在别的事务在等待获取锁，若存在则把对应所结构的<code>is_waiting</code>设置为<code>false</code>，唤醒事务对应的线程，此时事务<strong>T2</strong>会获取到锁，如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/43.png" alt="锁"></p>
<p>所以我们有几种选择：</p>
<ul>
<li><p>不加锁，不需要再内存中生成对应的锁结构，可以直接操作执行</p>
</li>
<li><p>获取锁成功或者加锁成功，内存中生成对应的锁结构，而锁结构对应的<code>is_waiting</code>为<code>false</code>，事务可以继续执行</p>
</li>
<li><p>获取锁失败或者加锁失败，内存中生成对应的锁结构，锁结构对应的<code>is_waiting</code>为<code>true</code>，也就是事务需要等待，不可以继续执行操作</p>
</li>
<li><p>读-写或者写-读的情况，一个事务进行读取操作，另一个进行改动操作。这种情况下，会产生幻读、脏读、不可重复读的问题。</p>
<blockquote>
<p><a name='phantom'></a>幻读是某个事务读取了一个范围的记录，之后别的事务在该范围内插入新记录，该事务范围记录时，可以读到新插入的事务，<strong>幻读问题并不是因为读取和写入一条相同记录而产生的</strong>。</p>
</blockquote>
<p><a href='/blog/2019/08/07/mysql/10_transaction_isolation#isolationLevel'><code>MySQL</code>中事务的隔离级别</a></p>
<p>解决脏读、不可重复读、幻读有两种方案：</p>
<ul>
<li>读操作利用<a href='/blog/2019/08/07/mysql/10_transaction_isolation#mvcc'>多版本并发控制</a>(<strong>MVCC</strong>)，写操作进行<strong>加锁</strong></li>
<li>读写操作都使用<strong>加锁</strong>的方式<ul>
<li>脏读，事务A读取事务B未提交的记录。当事务B给记录加锁后，事务A就无法继续读取该记录了。</li>
<li>不可重复度，事务A读取一条记录后，事务B修改并提交了该记录，事务A再次读取时会获得不同的结果。当事务A读取记录时给记录加锁，那么事务B就不能修改该记录。</li>
<li><a href='#phantom'>幻读</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>MVCC</strong>方式，读-写操作并不冲突，性能更高。采用<strong>加锁</strong>方式，读写操作彼此需要排队执行，影响性能。</p>
<h4 id="2-一致性读"><a href="#2-一致性读" class="headerlink" title="2. 一致性读"></a>2. 一致性读</h4><p>事务利用<strong>MVCC</strong>进行的读取操作称为<strong>一致性读</strong>或者<strong>快照读</strong>。所有普通的<code>SELECT</code>语句在<strong>READ COMMITTED</strong>和<strong>REPEATABLE READ</strong>隔离级别下都是<strong>一致性读</strong>。</p>
<h4 id="3-锁定读-Lock-Reads"><a href="#3-锁定读-Lock-Reads" class="headerlink" title="3. 锁定读(Lock Reads)"></a>3. 锁定读(Lock Reads)</h4><h5 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h5><p>在使用加锁的方式解决问题时，既要保证读-读不受影响，又要求写-写、读-写、写-读操作相互阻塞。所有MySQL提供了两类锁：</p>
<ul>
<li>共享锁(Share Locks)，简称<strong>S锁</strong>。在事务读取一条记录时，需要首先获取记录的S锁。</li>
<li>独占锁(Exclusive Locks)，简称<strong>X锁</strong>。再事务修改一条记录时，需要首先获取记录的X锁。</li>
</ul>
<p>假如事务T1首先获取了一条记录的S锁后，事务T2接着也要访问这条记录：</p>
<ul>
<li>如果事务T2要查询该记录，那么事务T2也会获得该S锁，T1和T2可以同时持有该记录的锁</li>
<li>如果事务T2要修改该记录，那么T2会尝试获得X锁，此操作会被阻塞，直到事务T1提交之后将S锁释放</li>
</ul>
<p>假如事务T1首先获得了该记录的X锁，那么不管事务T2是查询还是修改该记录(S锁或者X锁)都会被阻塞，直到事务T1提交。</p>
<p>综上X锁和S锁的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center">X锁</th>
<th align="center">S锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X锁</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center">S锁</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<h5 id="锁定读的语句"><a href="#锁定读的语句" class="headerlink" title="锁定读的语句"></a>锁定读的语句</h5><p><strong>加锁</strong>的方式解决<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>时，需要给记录加<strong>S锁</strong>或者<strong>X锁</strong>。</p>
<ul>
<li><p>对读取记录加<strong>S锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<p>在事务中，<code>SELECT</code>语句后加<code>LOCK IN SHARE MODE</code>，其会为记录加<strong>S锁</strong>，允许其他事务继续获取这些记录的<strong>S锁</strong>，但是不能获取这些记录的<strong>X锁</strong>，会被阻塞，直到<strong>S锁</strong>释放。</p>
</li>
<li><p>对读取的记录加<strong>X锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>在事务中，<code>SELECT</code>语句后加<code>FOR UPDATE</code>，会为读取到的记录加<strong>X锁</strong>，当其他事务尝试加S锁和X锁时，会被阻塞，直到T2事务释放X锁。</p>
</li>
</ul>
<h4 id="4-写操作"><a href="#4-写操作" class="headerlink" title="4. 写操作"></a>4. 写操作</h4><p>写操作包括<code>UPDATE</code>、<code>INSERT</code>、<code>DELETE</code>三种</p>
<ul>
<li><p><code>DELETE</code></p>
<p>对一条记录做<code>DELETE</code>过程：现在B+树中定位记录位置，然后获取记录的X锁，然后执行<code>delete mask</code>操作。删除过程是获取<strong>X锁</strong>的锁定读。</p>
</li>
<li><p><code>UPDATE</code></p>
<ul>
<li>未修改记录键值且被更新列占用的存储空间在修改后未发生变化，先在B+树中定位这条记录的位置，然后获取一下记录的X锁，最后在原纪录位置做修改操作。可以认为是获取<strong>X锁</strong>的锁定读。</li>
<li>未修改记录键值且至少有一个被更新的列占用的存储空间发生变化，现在B+树种定位记录位置，然后获取X锁，之后将记录删除掉(移入垃圾链表)，最后插入一条新记录。定位到删除记录的过程，可以看作是获取X锁的锁定读，插入过程是由<code>INSERT</code>提供的<strong>隐式锁</strong>进行保护。</li>
<li>修改了记录的键值，则相当于<code>DELETE</code>操作之后进行一次<code>INSERT</code>操作。</li>
</ul>
</li>
<li><p><code>INSERT</code></p>
<p>新插入记录不需要加锁，而是使用隐式锁保护，新插入的记录在本事务提交前不被别的事务访问。</p>
</li>
</ul>
<h3 id="2-多粒度锁"><a href="#2-多粒度锁" class="headerlink" title="2. 多粒度锁"></a>2. 多粒度锁</h3><p>上文中的锁是针对记录的，即<strong>行锁</strong>，对一条记录加锁影响的就是一条记录。一个事务可以对表加锁，即<strong>表锁</strong>，其影响的是整个表中的记录，粒度比较粗。<strong>表锁</strong>也分为共享锁和独占锁。<font color='red'>其规则与行锁一致</font>。</p>
<p>给表加<strong>s锁</strong>：</p>
<ul>
<li>其他事务仍然可以获取该表的S锁</li>
<li>其他事务可以继续获取表中某些记录的S锁</li>
<li>其他事务不可以获取该表的X锁</li>
<li>其他事务不可以继续获取表中某些记录的X锁</li>
</ul>
<p>给表加<strong>X锁</strong>(独占表)：</p>
<ul>
<li><p>其他事务不可以获取该表的S锁</p>
</li>
<li><p>其他事务不可以获取表中某些记录的S锁</p>
</li>
<li><p>其他事务不可以获取该表的X锁</p>
</li>
<li><p>其他事务不可以继续获取表中某些记录的X锁</p>
</li>
</ul>
<p>当我们给表加锁时，无法知道是否存在行锁，不能依次检查每条记录是否存在锁，所以有了<strong>意向锁</strong>：</p>
<ul>
<li><strong>意向共享锁(Intention Shared Lock)**，简称</strong>IS锁**。当事务准备在某条记录上加S锁时，需要先在表级加IS锁。</li>
<li><strong>意向独占锁(Intention Exclusive Lock)**，简称</strong>IX锁**。当事务准备在某条记录上加X锁时，需要先在表级加IX锁。</li>
</ul>
<p>IX锁、IS锁是表级锁，是为了在之后加表级别的X锁和S锁时可以快速判断表中记录是否存在锁(防止遍历表记录判断是否存在锁)。以下是IS锁、IX锁、S锁、X锁兼容性：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<h3 id="3-MySQL中的行锁和表锁"><a href="#3-MySQL中的行锁和表锁" class="headerlink" title="3. MySQL中的行锁和表锁"></a>3. MySQL中的行锁和表锁</h3><p><strong>MySQL</strong>支持多种存储引擎，不同存储引擎对锁的支持是不一样的。</p>
<h4 id="1-其他存储引擎中的锁"><a href="#1-其他存储引擎中的锁" class="headerlink" title="1. 其他存储引擎中的锁"></a>1. 其他存储引擎中的锁</h4><p><strong>MyISAM</strong>、<strong>MEMORY</strong>、<strong>MERGE</strong>这些存储引擎只支持表级锁，不支持事务，所以这些存储引擎的锁一般是针对当前会话的。上述存储引擎同一时刻只允许一个会话对表进行写操作，所以这些存储引擎最好用在只读或者大部分都是读操作，或单用户场景下。</p>
<h4 id="2-InnoDB存储引擎中的锁"><a href="#2-InnoDB存储引擎中的锁" class="headerlink" title="2. InnoDB存储引擎中的锁"></a>2. InnoDB存储引擎中的锁</h4><p><strong>InnoDB</strong>中既支持表锁，也支持行锁。表锁实现简单，占用资源少，粒度粗，性能差。行锁粒度细，可以实现更精确的并发控制。</p>
<h5 id="1-InnoDB中的表锁"><a href="#1-InnoDB中的表锁" class="headerlink" title="1. InnoDB中的表锁"></a>1. InnoDB中的表锁</h5><ul>
<li><p>表级别X锁、S锁</p>
<p>普通的<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>是不会对表添加表级别的S锁或者X锁。</p>
<p>对表执行DDL语句时(<code>ALTER TABLE</code>、<code>DROP TABLE</code>等)，其他事务对表执行DML(<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>)等操作会被阻塞；当存在事务对表执行DML时，也会阻塞DDL语句。上述过程是通过在server层使用<strong>元数据锁</strong>(Metadata Locks)实现的，一般不是通过表级别的X锁、S锁实现</p>
<blockquote>
<p>DDL语句执行时会隐式提交当前会话中的事务，这主要是DDL语句执行一般是在若干特殊事务中完成，且开开启特殊事务之前，要把当前会话中事务提交。</p>
</blockquote>
<p><strong>InnoDB</strong>中的表级的S锁和X锁，没有太多作用。</p>
</li>
<li><p>表级的IS锁、IX锁</p>
<p>我们在对表中某些记录加S锁、X锁时，要先对表加IS锁、IX锁。IS和IX锁的使命是为了后续在加表级别的S锁和X锁时判断表中是否存在加锁的记录，避免遍历表判断。</p>
</li>
<li><p>表级别的<strong>AUTO-INC</strong>锁</p>
<p><strong>MySQL</strong>中，若表中某列是<strong>AUTO_INCREMENT</strong>属性，则之后插入记录时，可以不指定该列的值，系统会自动为其赋值。原理如下：</p>
<ul>
<li>采用<strong>AUTO-INC</strong>锁，即执行插入语句时就在表级别加<strong>AUTO-INC锁</strong>，然后为每条待插入记录的<strong>AUTO_INCREMENT</strong>修饰的列分配递增的值，语句执行结束后释放<strong>AUTO-INC锁</strong>。当一个事务持有<strong>AUTO-INC锁</strong>时，其他插入语句会被阻塞，保证分配的递增值是连续的。若插入语句在执行前不确定具体要插入多条记录，例如<code>INSERT ···· SELECT</code>、<code>REPLACE ··· SELECT</code>、<code>LOAD DATA</code>等语句，一般使用<strong>AUTO-INC</strong>锁位<strong>AUTO-INCREMENT</strong>列生成对应的值。<strong>AUTO-INC锁</strong>的作用范围是单个语句，语句插入执行玩抽，锁就被释放了。</li>
<li>采用轻量级的锁，为插入语句生成<strong>AUTO-INCREMENT</strong>修饰修饰的列的值时获取一下这个轻量级锁，然后本次插入语句需要用到的AUTO-INCREMENT列的值后，释放该轻量级锁，不需要等插入语句完成后释放锁。当插入语句在执行前就确定具体插入记录时，一般采用轻量级锁的方式，避免锁表，提高性能</li>
</ul>
<blockquote>
<p><strong>InnoDB</strong>中有一个<code>innodb_autoinc_lock_mode</code>的系统变量控制到底采用那种方式赋值。0采用AUTO-INC锁；2采用轻量级锁；1采用两种方式混合使用(确定插入记录数时轻量级锁，不确定时<strong>AUTO-INC锁</strong>)</p>
<p>当值为2时，可能会产生AUTO-INCREMENT列值交叉的情况，且主从复制环境下不安全。</p>
</blockquote>
</li>
</ul>
<h5 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2. InnoDB中的行锁"></a><font color='red'>2. InnoDB中的行锁</font></h5><p>行锁，即记录锁。行锁有多种类型，不同类型的行锁，作用不同。准备工作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO hero VALUES</span><br><span class="line">    (1, &#39;l刘备&#39;, &#39;蜀&#39;),</span><br><span class="line">    (3, &#39;z诸葛亮&#39;, &#39;蜀&#39;),</span><br><span class="line">    (8, &#39;c曹操&#39;, &#39;魏&#39;),</span><br><span class="line">    (15, &#39;x荀彧&#39;, &#39;魏&#39;),</span><br><span class="line">    (20, &#39;s孙权&#39;, &#39;吴&#39;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>name</code>列内容前家字符是为了保证有序，因为utf8中汉字顺序并不是按照首字母排序的。</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/mysql/44.png" alt="聚簇索引简化图"></p>
<h6 id="1-Records-Locks"><a href="#1-Records-Locks" class="headerlink" title="1. Records Locks"></a>1. Records Locks</h6><p>记录锁(<code>LOCK_REC_NOT_GAP</code>)，即仅仅把一条记录锁上。行锁区分S锁和X锁。例如，当我们给<code>number</code>值为8的记录加锁示意图如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/45.png" alt="聚簇索引简化图"></p>
<h6 id="2-Gap-Locks"><a href="#2-Gap-Locks" class="headerlink" title="2. Gap Locks"></a>2. Gap Locks</h6><p><strong>MySQL</strong>在REPEATABLE READ隔离级别下可以解决幻读问题，其方案有两种：MVCC和加锁。但加锁有个大问题，事务在第一次执行读取操作时，记录不存在，所以无法给记录加锁。所以有了<strong>Gap Locks</strong>(<code>LOCK_GAP</code>)的概念。</p>
<p><img src="https://images.effiu.cn/blog/mysql/46.png" alt="聚簇索引简化图"></p>
<p>上图中，为<code>number</code>为8的记录加了gap锁，意味着不允许别的事务在<code>number</code>为8的记录前的间隙(3,8)区间插入新记录。例如，插入<code>number</code>为4的记录，InnoDB会定位到该记录的下一条记录<code>number</code>值为8，且该记录存在gap锁，就会阻塞插入操作，直到该锁被释放。gap锁是为了防止插入新记录产生的，共享gap锁和独占gap锁的作用是相同的，当某条记录存在gap锁，那么并不会限制其他事务对该记录加行锁，gap锁仅仅是为了解决幻读问题。</p>
<p>gap锁是不允许其他事务对这条记录前的间隙插入新记录，那么对于最后一条记录后的间隙如何加锁呢？数据页结构有7部分，其中一个是<strong>Infimum</strong>和<strong>Supermum</strong>：</p>
<ul>
<li><strong>Infimum记录</strong>，表示该页面最小记录</li>
<li><strong>Supermum记录</strong>，表示该页面最大记录</li>
</ul>
<p>我们需要给Supermum记录加锁就可以锁定最后一条记录后面的间隙。</p>
<p><img src="https://images.effiu.cn/blog/mysql/47.png" alt="聚簇索引简化图"></p>
<h6 id="3-Next-Key-Locks"><a href="#3-Next-Key-Locks" class="headerlink" title="3. Next Key Locks"></a>3. Next Key Locks</h6><p>当我们既想锁住某条记录，又想阻止其他事务在该记录前面插入数据时，就需要使用<code>LOCK_ORDINARY</code>。其本质是<code>LOCK_REC_NOT_GAP</code>和<code>LOCK_GAP</code>的合体。</p>
<p><img src="https://images.effiu.cn/blog/mysql/48.png" alt="聚簇索引简化图"></p>
<h6 id="4-Insert-Intention-Locks"><a href="#4-Insert-Intention-Locks" class="headerlink" title="4. Insert Intention Locks"></a>4. Insert Intention Locks</h6><p>当我们要插入一条新纪录时，需要判断一下插入位置是否被别的事务加了<code>LOCK_GAP</code>锁，若存在锁，则事务等待，直到拥有<code>LOCK_GAP</code>锁的事务提交(释放锁)。但是插入记录的事务在等待时也需要在内存中生成一个锁结构，表明有事务想在间隙中插入新纪录。官方命名为:<code>LOCK_INSERT_INTENTION</code>，即<strong>插入意向锁</strong>。</p>
<p><img src="https://images.effiu.cn/blog/mysql/49.png" alt="聚簇索引简化图"></p>
<p>例如，事务T1持有<code>LOCK_GAP</code>锁，所以T2和T3需要生成一个插入意向锁的所结构且处于等待状态。当T1提交事务后会释放其获取到的锁，并唤醒其他等待的锁结构(<code>is_waiting</code>为false)，T2和T3就能获取到对应的插入意向锁。T2和T3并不会阻塞，其可以同时获取到<code>number</code>值为8的插入意向锁，然后执行插入操作。<font color='red'>插入意向锁并不会阻塞别的事务继续获取该记录上任何类型的锁</font>。</p>
<p><img src="https://images.effiu.cn/blog/mysql/50.png" alt="聚簇索引简化图"></p>
<blockquote>
<p>锁结构中新添了一个type属性，表明该锁的类型。</p>
</blockquote>
<h6 id="5-隐式锁"><a href="#5-隐式锁" class="headerlink" title="5. 隐式锁"></a>5. 隐式锁</h6><p>在执行<code>INSERT</code>操作时，如即将插入的间隙已被<code>LOCK_GAP</code>锁住，那么本次<code>INSERT</code>会被阻塞，且当前事务会在间隙上加插入意向锁，否则一般情况<code>INSERT</code>操作不会加锁。</p>
<p>当一个事务插入了一条记录(此时并没有与该记录相关的锁结构)，另一个事务：</p>
<ul>
<li>立即使用<code>SELECT ··· LOCK IN SHARE MODE</code>语句读取该事务，即获取该条记录的S锁；或者使用<code>SELECT ··· FOR UPDATE</code>语句读取这个事务或者直接修改该记录，即获取该记录的X锁。上述两种情况均不允许发生，否则会产生<strong>脏读</strong>问题</li>
<li>立即修改这条记录，即获取该记录的X锁，也不允许发生，否则会产生<strong>脏写</strong>问题。</li>
</ul>
<p>MySQL使用事务ID解决上述问题。具体如下：</p>
<ul>
<li>对于聚餐索引来说，有一个<code>trx_id</code>隐藏列，其记录着最后改动该记录的事务ID，若当前在事务中新插入一条聚餐记录后，该记录的<code>trx_id</code>隐藏列代表的是当前事务的事务ID，其他事务加S锁或者X锁，会先查看该记录的事务ID代表的事务当前是否处于活跃状态，若是则帮助当前事务(事务Id对应的事务)创建一个X锁(<code>is_waiting</code>为<code>false</code>)，然后自己进入等待状态(自己创建一个锁结构，<code>is_waiting</code>为<code>true</code>)。</li>
<li>对于二级索引来说，本身没有<code>trx_id</code>隐藏列，但是二级索引的Page Header部分有<code>PAGE_MAX_TRX_ID</code>属性，其代表对该页面做出最大改动的事务Id，若<code>PAGE_MAX_TRX_ID</code>属性值小于当前活跃事务Id，那说明对当前页面做出的修改已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后通过回表确定对应的聚餐索引记录，继续按照聚餐索引规则判断。</li>
</ul>
<p>一个事务对于新插入的记录可以不显式的加锁(生成一个锁结构)，但是由于事务ID的存在，相当于加了隐式锁。其他事务对着条记录加锁时，会由于隐式锁的存在，帮助该事务生成一个锁结构，然后自己生成一个锁结构进入等待状态。</p>
<h4 id="3-InnoDB锁的内存结构"><a href="#3-InnoDB锁的内存结构" class="headerlink" title="3. InnoDB锁的内存结构"></a>3. InnoDB锁的内存结构</h4><p>对一条记录加锁的本质是在内存中创建一个锁结构与之关联。那么当一个事务需要对多个事务加锁呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM hero LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<p>上述查询不可能对所有记录加锁，InnoDB中符合下述条件的被放到一个锁结构中：</p>
<ul>
<li>在同一个事务中进行加锁操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型一样</li>
<li>等待状态一样的</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/51.png" alt="InnoDB中事务锁结构"></p>
<ul>
<li><p>锁所在的事务信息：记录的是生成锁的事务的信息，其在内存结构中是一个指针，通过指针可以获取更多的事务信息</p>
</li>
<li><p>索引信息：对于行锁来说，加锁的记录是属于哪个索引的，也是指针</p>
</li>
<li><p>表锁/行锁信息：表锁结构与行锁结构在这个位置的内容是不同的。</p>
<ul>
<li>表锁，记录的是对哪个表加的锁，以及其他信息</li>
<li>行锁，记录了三个重要信息<ul>
<li><code>Space_ID</code>：记录所在表空间</li>
<li><code>Page Number</code>：记录所在页号</li>
<li><code>n_bits</code>：对于<strong>行锁</strong>来说，一个记录就是一个比特位，一个页面中有多条记录，用不同比特位区分到底哪一条记录加锁。在锁结果末尾放置了一堆比特位，<code>n_bits</code>属性代表使用多少比特位。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>type_mode</code>：是一个32位数，分为：<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三部分，如下图：</p>
<p><img src="https://images.effiu.cn/blog/mysql/52.png" alt="InnoDB中事务锁结构"></p>
<ul>
<li><code>lock_mode</code>：锁模式，占用低4位，可选值如下：<ul>
<li><code>LOCK_IS</code>(<code>0000</code>)：表示共享意向锁，即IS锁</li>
<li><code>LOCK_IX</code>(<code>0001</code>)：表示独占意向锁，即IX锁</li>
<li><code>LOCK_S</code>(<code>0010</code>)：表示共享锁，即S锁</li>
<li><code>LOCK_X</code>(<code>0011</code>)：表示独占锁，即X锁</li>
<li><code>LOCK_AUTO_INC</code>(<code>0100</code>)：表示<code>AUTO_INC</code>锁</li>
</ul>
</li>
<li><code>lock_type</code>：占用5~8位，目前只有第5和第6为被使用<ul>
<li><code>LOCK_TABLE</code>：第5个比特位为1时，表示表级锁</li>
<li><code>LOCK_REC</code>：第6个比特位为1时，表示行锁</li>
</ul>
</li>
<li><code>rec_lock_type</code>，行锁的具体类型，使用其余位表示，只有当<code>lock_type</code>为行锁(<code>LOCK_REC</code>)时，即只有当该锁为行锁时，才会被细分为具体类型<ul>
<li><code>LOCK_ORDINARY</code>：十进制的0，表示<code>next-key</code>锁</li>
<li><code>LOCK_GAP</code>：十进制的512，第10个比特位为1时，表示gap锁</li>
<li><code>LOCK_REC_NOT_GAP</code>：十进制的1024，第11个比特位为1时，表示记录锁</li>
<li><code>LOCK_INSERT_INTENTION</code>：十进制的2048，第12个比特位为1时，表示插入意向锁</li>
<li>其他类型的锁</li>
</ul>
</li>
</ul>
<p><code>is_waiting</code>属性在<code>type_mode</code>这个32位数字中：</p>
<ul>
<li><code>LOCK_WAIT</code>：十进制的256，第9个比特位为1时，表示<code>is_waiting</code>为true，即当前事务未持有锁，处在等待状态；该比特位为0时，当前事务获取锁成功。</li>
</ul>
</li>
<li><p>其他信息</p>
</li>
<li><p>一堆比特位，若是<strong>行锁结构</strong>，该锁结构末尾会放置一堆比特位，比特位的数量由<code>n_bits</code>属性表示。InnoDB记录结构中，页面中每条记录在记录头信息中包含一个<code>heap_no</code>属性，伪记录<strong>Infimum</strong>的<code>heap_no</code>为0，Superemum的<code>heap_no</code>为1，之后每插入一条记录，<code>heap_no</code>加1。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>。</p>
</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/53.png" alt="InnoDB中事务锁结构"></p>
<p>举例：两个事务T1和T2想对<code>hero</code>表中的记录进行加锁，<code>hero</code>表中的记录较少，假设存储在所在表空间号为67，页号为3的页面上，那么:</p>
<ul>
<li><p>T1想对<code>number</code>值为15的这条记录加S锁，在对记录加锁之前，需要先加表级别的IS锁，会生成一个表级别的锁结构，下面是生成行锁的过程：</p>
<ul>
<li><p>事务T1要加锁，所以锁结构的锁所在事务指的是T1</p>
</li>
<li><p>直接对聚餐索引加锁，所以索引信息指的其实是<code>PRIMARY</code>索引</p>
</li>
<li><p>由于是行锁，所以需要记录以下3个信息：</p>
<ul>
<li><code>Space_ID</code>，表空间号为67</li>
<li><code>Page Number</code>：页号为3</li>
<li><code>n_bits</code>：<code>hero</code>表中只插入了5条记录，但是在初始分配比特位时会多分配一些，为了之后新增记录时不需要频繁分配比特位，计算<code>n_bits</code>的公式：<code>n_bits = (1 + ((n_recs + LOCK_PAGE_BITMAP_MARGIN) / 8)) * 8</code>。<code>n_recs</code>表示页面中的记录数(算是伪记录和垃圾链表中的记录)，<code>LOCK_PAGE_BITMAP_MARGIN</code>固定为64。例如表中有5条记录，那么<code>n_bits</code>为72</li>
</ul>
</li>
<li><p><code>type_mode</code>由3部分组成</p>
<ul>
<li><code>lock_mode</code>：对记录加S锁，值为<code>LOCK_S</code></li>
<li><code>lock_type</code>：对记录进行加锁，值为<code>LOCK_REC</code></li>
<li><code>rec_lock_type</code>：锁为记录锁，类型为<code>LOCK_REC_NOT_GAP</code>，由于当前没有其他事务对记录加锁，所以<code>is_waiting</code>为<code>false</code></li>
</ul>
<p>综上所述：<code>type_mode = lock_mode | lock_type | rec_lock_type</code>即<code>······10000100010 = 1058</code></p>
</li>
<li><p>其他信息</p>
</li>
<li><p>一堆bit位，<code>number</code>值为15的记录的<code>heap_no</code>为5，根据上面的<code>heap_no</code>映射图看是从低位往高位数第6个位置为1</p>
</li>
</ul>
<p>综上，事务T1为<code>number</code>值为5的记录加锁生成的锁结构如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/54.png" alt="InnoDB中事务锁结构"></p>
</li>
<li><p>T2想对<code>number</code>值为<code>3</code>、<code>8</code>、<code>15</code>的这三条记录加<code>X型的next-key锁</code>，在对记录加行锁之前，需要先加表级别的<code>IX</code>锁，也就是会生成一个表级锁的内存结构，T2对记录加锁的过程如下：</p>
<p>T2要对三条记录加锁，<code>2</code>、<code>8</code>两条记录，由于没有锁结构，所以可以成功获取锁结构(X型的next-key锁)，<code>is_waiting</code>为<code>false</code>，<code>number</code>为<code>15</code>已经被T1加锁，不能获取到锁结构，所以<code>is_waiting</code>为<code>true</code>。因为等待状态不同所以会先生成两个锁结构，如下：</p>
<ul>
<li>对事物T2进行加锁，锁所在事务信息为T2</li>
<li>直接就对聚餐索引加锁，所以锁引信息为<code>PRIMARY</code>索引</li>
<li>属于行锁，那么<code>Space ID</code>为67，<code>Page Number</code>为3，<code>n_bits</code>为72(同上)</li>
<li><code>type_mode</code>，是对记录加<strong>X型next-key锁</strong>，<code>lock_mode</code>为X锁，<code>lock_type</code>为行锁，<code>rec_lock_type</code>对记录加<code>next-key</code>锁，类型为<code>LOCK_ORIDINARY</code></li>
<li>其他信息</li>
</ul>
<p>不同属性如下：</p>
<ul>
<li><code>number</code>为<code>3</code>、<code>8</code>的记录生成锁结构：<ul>
<li><code>type_mode</code>的值，可以获取到锁，所以<code>is_waiting</code>为<code>false</code>，所以<code>type_mode</code>为<code>······00100011</code>即35</li>
<li>一堆比特位，<code>number</code>为<code>3</code>、<code>8</code>的记录对应<code>heap_no</code>为3和4，所以从低位往高位数第4、5比特位为1</li>
</ul>
</li>
</ul>
<p>综上事务T2对<code>3</code>和<code>8</code>加锁为：</p>
<p><img src="https://images.effiu.cn/blog/mysql/55.png" alt="InnoDB中事务锁结构"></p>
<ul>
<li><p>为<code>number</code>为15的记录生成锁结构：</p>
<ul>
<li><code>type_mode</code>值，<code>is_waiting</code>为<code>true</code>，<code>LOCK_WAIT</code>代表的二进制位为1，所以<code>type_mode</code>为<code>······10100100010</code>即291</li>
<li>一堆bit位，<code>number</code>值为<code>15</code>的记录的<code>heap_no</code>为5，所以应该是第一个字节从低位往高位数第6个比特位被置为1</li>
</ul>
<p>所以，<code>number</code>为15的锁结构，如下图：</p>
<p><img src="https://images.effiu.cn/blog/mysql/56.png" alt="InnoDB中事务锁结构"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全与锁优化</title>
    <url>/blog/2019/08/17/jvm/13_thread_safe_lolck_optimization/</url>
    <content><![CDATA[<p>在软件业早期，程序编写是以算法为和核心的，程序员会把数据和过程分别作为独立部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维是直接站立在计算机的角度抽象问题和解决问题，称为<strong>面向过程</strong>的编程思想。</p>
<p><strong>面向对象</strong>则是站在现实世界的角度去抽象和解决问题，其把数据和行为都看作是对象的一部分。这样可以让程序员以符合现实的思维方式编写和组织程序。</p>
<p>对于并发来讲，我们要先保证其正确性，然后在此基础上实现高效。下面说明如何保证并发的正确性以及如何实现线程安全。</p>
<p>线程安全涉及到的概念和分类、同步实现的方式及虚拟机的底层运作原理，介绍了虚拟机为了实现高效并发采取 的一些列措施。</p>
<a id="more"></a>

<h3 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h3><p><a name='threadSafe'></a><strong>线程安全</strong>的一个比较恰当的定义是(Brian Goetz的《Java Concurrency In Practice》)：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
<p>上述定义比较严谨，其要求线程有一个特征：代码本身封装了所有必要的正确性保障手段(如互斥同步等)，令调用者无须关心多线程的问题，也不需要自己采取任何措施保证多线程的正确调用。这非常难以实现。我们<font color='red'>把这个定义弱化</font>后：把“调用这个对象的行为”限定为“单次调用”，然后再加上其他描述能够成立，则可以称为线程安全。</p>
<h4 id="1-Java语言中的线程安全"><a href="#1-Java语言中的线程安全" class="headerlink" title="1. Java语言中的线程安全"></a>1. Java语言中的线程安全</h4><p>Java语言中的线程安全，前提是多个线程之间存在共享数据访问。按照线程安全的“安全程度”由强至弱排序，可以将Java语言中各种操作共享的数据分为以下5类：</p>
<ul>
<li>不可变</li>
<li>绝对线程安全</li>
<li>相对线程安全</li>
<li>线程兼容</li>
<li>线程对立</li>
</ul>
<h5 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1.不可变"></a>1.不可变</h5><p>Java中，不可变的对象一定是线程安全的，无论对象的方法实现还是方法的调用者，都不需要在采取任何线程安全保障措施。“不可变”带来的安全性是最简单和最纯粹的。</p>
<p><code>final</code>关键字带来的可见性，只要一个不可变的对象被正确构建出来(没有发生<code>this</code>引用逃逸时)其外部的可见状态永远不会改变，也永远不会看到其在多个线程中不一致的状态。若共享数据是基本数据类型，那么只要使用<code>final</code>修饰，就可以保证其是不可变的。若共享数据是一个对象，就需要保证对象的行为不会对其状态产生任何影响。</p>
<p>保证对象行为不影响自己状态方法有很多种，其中最简单的就是把对象中带有状态的变量声明为<code>final</code>，保证其不可变。Java API中符合不可变要求的类型：<code>java.lang.String</code>、枚举类型、<code>java.lang.Number</code>的部分子类(<code>Long</code>和<code>Double</code>等数值包装类型，<code>BigInteger</code>和<code>BigDecimal</code>等大数据类型)，但<code>java.lang.Number</code>的原子类<code>AtomicInteger</code>和<code>AtomicLong</code>则并非不可变。</p>
<ul>
<li><input disabled="" type="checkbox"> <code>AtomicInteger</code>和<code>AtomicLong</code>为什么不用<code>final</code>修饰常量</li>
</ul>
<h5 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2. 绝对线程安全"></a>2. 绝对线程安全</h5><p>绝对线程安全是符合<a href='#threadSafe'>Brian Goetz</a>对线程安全的定义。其对一个类的要求非常高(不管运行环境如何，调用者都不需要任何额外的同步措施)，这需要付出很大甚至不切实际的代价。Java API中线程安全的类，大部分都不是绝对的线程安全。例如：<code>java.util.Vector</code>类，其是线程安全的容器，且<code>add()</code>、<code>get()</code>、<code>size()</code>这类方法是被<code>synchronized</code>修饰，其是安全的。但即使这样也不能保证永远都不需要同步手段。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vector.size(); j++) &#123;</span><br><span class="line">                    vector.remove(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vector.size(); j++) &#123;</span><br><span class="line">                    System.out.println(vector.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 防止同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 减少资源消耗，睡眠0.1s</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，尽管<code>add()</code>、<code>remove()</code>、<code>size()</code>方法是同步的，但是多线程环境中，任然不是证线程安全的。因为当经过<code>printThread</code>线程<code>for</code>循环后，可能会打印一个<code>remove()</code>掉的元素，此时会抛出<code>ArrayIndexOutOfBoundsException</code>，<code>Vector</code>中的<code>synchronized</code>保证的是同一时刻只有一个线程访问其对象，但是无法保证<code>for</code>循环的执行，所以<code>vector.get(j)</code>，中的<code>j</code>并不是线程安全的。要保证代码执行下去，就需要保证同一时刻只有一个线程执行<code>for</code>循环。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vector.size(); j++) &#123;</span><br><span class="line">            vector.remove(j);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vector.size(); j++) &#123;</span><br><span class="line">        	System.out.println(vector.get(j));</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3. 相对线程安全"></a>3. 相对线程安全</h5><p>相对线程安全是我们通常意义上的线程安全，其需要保证<font color='red'>对这个对象单独操作是线程安全的</font>（如上的<code>Vector</code>），通常的调用不需要做额外的保障措施，但对于一些特定顺序的连续调用，可能需要在调用端使用额外的同步手段保证调用的正确性。</p>
<p>Java语言中大部分线程安全都是相对线程安全，例如<code>Vector</code>、<code>Hashtable</code>、<code>Collections.synchronizedCollection()</code>方法包装的集合等。</p>
<h5 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4. 线程兼容"></a>4. 线程兼容</h5><p>线程兼容指的是对象本身并不是线程安全的，但是可以通过在调用端正确使用同步手段保证对象在并发环境中可以安全的使用，通常意义上的线程不安全，就是指的是这种情况。Java API中大部分类都是线程兼容的，例如<code>ArrayList</code>和<code>HashMap</code>等。</p>
<h5 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5. 线程对立"></a>5. 线程对立</h5><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程中并发使用的情况。Java语言天生具备多线程特性，线程对立的情况很少见，且通常有害。</p>
<p><code>Thread</code>类的<code>suspend()</code>和<code>resume()</code>方法，若两个线程分别同时持有一个对象，一个尝试去<code>suspend()</code>，另一个尝试去<code>resume()</code>，这种情况无论是否进行同步，都可能发生死锁。</p>
<p>常见的线程对立操作有<code>System.setIn()</code>、<code>Sytem.setOut()</code>和<code>System.runFinalizersOnExit()</code>等。</p>
<h4 id="2-线程安全的实现方法"><a href="#2-线程安全的实现方法" class="headerlink" title="2. 线程安全的实现方法"></a>2. 线程安全的实现方法</h4><p>了解Java中的线程安全后，我们如何实现线程安全呢？实现线程安全与代码编写有很大关系，但Java虚拟机提供的同步和锁机制也起到了非常重要作用。</p>
<h5 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1. 互斥同步"></a>1. 互斥同步</h5><p>互斥同步(Mutual Exclusion &amp; Synchronization)是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个(或者一些，信号量)线程使用，而互斥是实现同步的一种手段，临界区(Critical Section)、互斥量(Mutex)、信号量(Semaphore)是主要的互斥实现方式。</p>
<p>Java中，最基本的互斥手段是<code>synchronized</code>关键字，其经过编译后会在同步块前后分别形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令，两个字节码需要一个reference类型的参数指明锁定和解锁对象。Java程序中，若<code>synchronized</code>明确指定了对象参数，那就是这个对象的reference；若没有明确指定，那就根据<code>synchronized</code>修饰的是实例方法还是类方法，去取对应的对象实例或Class对象作为锁对象。</p>
<p>虚拟机规范要求，当<code>monitorenter</code>指令执行时，首先要尝试获取对象的锁。若对象锁没有被锁定或者当前线程已经拥有了锁，则把锁的计数+1；解锁时-1，计数为0时锁释放。当获取对象锁失败，当前线程阻塞等待，知道对象锁被另外一个线程释放。</p>
<ul>
<li><code>synchroinzed</code>同步块对同一条线程来说是可重入的，</li>
<li>同步块已经进入的线程执行完之前，会阻塞后面其他线程的进入。</li>
</ul>
<p>Java线程是映射到操作系统的原生线程之上的，所以阻塞或者唤醒一个线程，都需要操作系统帮忙完成，这就需要从用户态转为内核态，因此状态转换需要耗费很多的处理器时间，有时候状态转换需要耗费的处理器时间比用户代码执行的时间长，<code>synchroinzed</code>是Java语言中的一个重量级锁，非必要情况下尽量不要使用</p>
<p>除了<code>synchronized</code>之外，还可以使用<code>java.util.concurrent</code>包中的<a href='/blog/2019/05/16/concurrent/chapter5/5.3_reetrant_readwrite/' name='_blank'>重入锁(ReentrantLock)</a>实现同步。两者区别：重入锁表现为API层面的互斥锁，<code>synchronized</code>为原生语法层面的互斥锁。重入锁有一些高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。</p>
<p>现在<code>synchroinzed</code>与重入锁性能差距不大。</p>
<h5 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2. 非阻塞同步"></a>2. 非阻塞同步</h5><p>互斥同步最主要的问题是线程唤醒和阻塞带来的性能问题，从处理问题的方式来说，互斥同步是一种悲观的并发策略，即认为只要不做正确的同步措施(加锁)，那就肯定会出现问题，无论共享数据是否真的会出现阻塞竞争，都要加锁(概念模型中，实际上虚拟机会优化掉一大部分不必要的锁)、用户态内核态转换、维护锁计数器和检查是否有线程需要换线等操作。但随着硬件指令集的发展，有了另一个选择：基于冲突检测的乐观并发策略，就是先进行操作，若没有其他线程争用共享资源，那操作成功；若共享数据有征用，产生了冲突，就采取其他补偿措施（常见的如不断重试，直到成功为止），这种并发策略的许多实现都需要把线程挂起，因此这种操作称为非阻塞同步。</p>
<p>乐观并发策略需要硬件指令集发展，是因为需要操作和冲突检测这两个步骤具有原子性(使用互斥同步保证没有意义)，需要使用硬件完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，常用指令有：</p>
<ul>
<li>测试并设置(Test-and-Set)</li>
<li>获取并增加(Fetch-and-Increment)</li>
<li>交互(Swap)</li>
<li>比较并交换(Compare-and-Swap, CAS)</li>
<li>加载连接/条件存储(Load-Linked/Store-Conditional, LL/SC)</li>
</ul>
<p>上述指令中后两个现代处理器新增的，目的与功能类似。</p>
<p>CAS指令需要3个操作数，分别是内存位置V(Java中可以简单理解为变量的内存地址)、旧的预期值A、新值B。CAS执行时，当且仅当旧值A符合预期值时，处理器用新值B更新V的值，否则就不执行更新，且无论是否更新了V的值，都会返回V的旧值，上述过程是一个原子操作。</p>
<p>JDK5之后，Java程序中才可以使用CAS操作，由<code>sun.misc.Unsafe</code>类中的<code>compareAndSwapint()</code>和<code>compareAndSwapLong()</code>等几个方法包提供，虚拟机内部对这些方法做了特殊处理，即时编译的结果就是一条平台相关的CAS指令，没有方法调用的过程。<code>Unsafe</code>类不是提供给用户程序调用的类(<code>Unsafe.getUnsafe()</code>的代码中限制了只有启动类加载器加载的Class才能访问它)，因此如果不采用反射手段，只能通过其他的Java API间接使用它，例如J.U.C中的整数原子类。</p>
<p>尽管CAS很美，但是CAS操作无法涵盖互斥痛殴过不的所有使用场景，且CAS存在一个逻辑漏洞。即ABA问题，Java的J.U.C提供了带有标记的原子引用类<code>AtomicStampedReference</code>解决这个问题，其可以通过控制变量值的版本保证CAS的正确性。实际上大部分ABA问题都不会影响程序并发的正确性，解决ABA问题，改用传统的互斥同步比原子类更高效。</p>
<h5 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3. 无同步方案"></a>3. 无同步方案</h5><p>保证线程安全并不一定需要同步。同步保证的是共享数据争用时的正确性的手段，若一个方法不涉及共享数据，那其自然就不需要任何同步措施保证正确性。一般有两种代码天生不需要保证正确性：</p>
<ul>
<li><p>可重入代码，其可以在代码执行到任何时刻中断，转而去执行另一段代码，在控制权返回后原来的程序不会出现任何错误。可重入是线程安全的基本特性，即所有可重入代码都是线程安全的，但并不是所有线程安全的代码都是可重入的。重入代码有一些共同特性：</p>
<ul>
<li>不依赖存储在堆上的数据和公用系统资源</li>
<li>用到的状态量都由参数传入</li>
<li>不调用非可重入的方法</li>
<li>····</li>
</ul>
<p><font color='red'>判断代码是否可重入的方法</font>：一个方法，其返回值是可以预测的，只要输入相同的数据，都能返回相同的结果，就满足可重入的要求，也是线程安全的。</p>
</li>
<li><p>线程本地安全：把数据可见性限制在一个线程内，无须同步也能保证线程之间不出现数据争用问题。这种应用场景并不少见，大部分使用消费队列的架构模式（如生产者-消费者模式）都会将产品的消费过程尽量在一个线程中消费完。例如经典的Web交互模型中，“一个请求对应一个服务器线程”。</p>
</li>
</ul>
<p>Java中一个变量要被多个线程访问，可以使用<code>volatile</code>关键字声明；若一个变量被某个线程独享，则可以使用<code>java.lang.TreadLocal</code>实现线程本地存储功能。</p>
<h3 id="3-锁优化"><a href="#3-锁优化" class="headerlink" title="3. 锁优化"></a>3. 锁优化</h3><p>JDK5到JDK6的一个重要改进是高效并发，HotSpot虚拟机开发团队在这个版本上花费巨大精力去实现各种锁优化技术，如适应性自旋(Adaptive Spinning)、锁消除(Lock Elimination)、锁粗化(Lock Coarsening)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)等，都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<h4 id="1-自旋锁与自适应自旋"><a href="#1-自旋锁与自适应自旋" class="headerlink" title="1. 自旋锁与自适应自旋"></a>1. 自旋锁与自适应自旋</h4><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程需要转到内核态中完成，这写操作给系统带来了很大的压力。现实中许多应用，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程不值得。若物理机器有一个以上的处理器，能让两个或两个以上的线程同时执行，那么就可以让后面请求的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有所得线程是否很快会释放锁。为了让线程等待，需要让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁。</p>
<p>自旋不能代替阻塞，自旋等待虽然避免线程切换的开销，但会占用处理器的实际。所以若锁被占用的时间很短，自旋等待效果则很好，反之，自旋就会白白消耗处理器资源，带来性能上的浪费。自旋需要有一定的时间限制或次数，若超过限制仍未获得锁，就应当使用传统方式挂起线程。自旋次数默认是10次，可以用<code>-XX:PreBlockSpin</code>更改。</p>
<p>JDK6中引入了自适应自旋锁。自旋时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。若在同一个锁对象上，自旋等待刚刚成功获得过锁，且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋可能会再次成功，进而运行字段等待相对更长的时间。若某个锁，自旋很少成功过，那么后面获取该锁可能会省略掉自旋过程，避免浪费资源。自适应自旋，会随着程序运行和性能监控信息不断完善，虚拟机对程序锁的状况预测就会越来越准确。</p>
<h4 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2. 锁消除"></a>2. 锁消除</h4><p>锁消除是指虚拟机即时编译在运行时，对一些代码上的同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据是逃逸分析的数据支持，若判定在一段代码中，堆上所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上的数据对待，认为其是线程私有，同步加锁自然不需要进行。</p>
<p>变量是否逃逸，对于虚拟机来是说使用数据流分析确定的。正常情况下程序员应该清楚变量是否存在数据争用，但是实际上许多同步措施并不是程序员自己加入的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>是一个final类，对于字符串的连接是通过生成新的String对象进行的。Javac编译器会对String连接做自动自动优化。JDK5前会转化为<code>StringBuffer</code>对象的连接<code>append()</code>操作，JDK5及以后版本中使用<code>StringBuilder</code>对象的连接<code>append()</code>操作。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述<code>StringBuffer</code>中每个<code>append()</code>方法中都有一个同步块(<code>synchronized</code>)，锁的是sb对象。虚拟机会观察sb对象，会发现其作用域在<code>concatString()</code>方法内，永远不会逃逸到方法外，所以此处锁可以被消除。即时编译后，就会省略掉所有的同步而直接执行。</p>
<h4 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3. 锁粗化"></a>3. 锁粗化</h4><p>原则上总是推荐同步块的作用域范围尽量小——只在共享数据的实际作用域中进行同步，是为了使需要同步的操作数量尽可能变小，如存在锁竞争，那等待锁的线程也能尽快拿到。</p>
<p>实际应用中，若一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中，那即使没有锁竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p><a name='lightweightLocking'></a></p>
<h4 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4. 轻量级锁"></a>4. 轻量级锁</h4><p>轻量级锁是针对使用操作系统互斥量实现的传统锁(重量级锁)而言的。轻量级锁并不是用来代替重量级锁的，本意是在没有多线程竞争的前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>HotSpot虚拟机的对象头(Object Header)分为两部分信息：存储对象自身的运行时数据(哈希码、GC分代年龄等)，官方称为“Mark Word”，是实现轻量级锁和偏向锁的关键；另一个部分用于存储指向方法区对象类型数据的指针，若是数组对象还会额外存储数组的长度。</p>
<p><a href='/blog/2019/04/09/concurrent/chapter2/2.2_synchronized/'>Java对象头</a>信息是与对象自身定义无关的额外存储成本，考虑到空间效率，Mark Word被设计为非固定的数据结构以便在极小空间存储尽量多的信息，会依据对象的状态复用存储空间。例如：32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32bit空间中，25bit用于存储对象hash码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，其他状态下(轻量级锁定、重量级锁定、GC标记、可偏向)对象内容如下：</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th align="center">标志位</th>
<th align="left">状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码、对象分代年龄</td>
<td align="center"><code>01</code></td>
<td align="left">未锁定</td>
</tr>
<tr>
<td>指向锁记录的指针</td>
<td align="center"><code>00</code></td>
<td align="left">轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td align="center"><code>10</code></td>
<td align="left">膨胀(重量级锁定)</td>
</tr>
<tr>
<td>空，不需要记录信息</td>
<td align="center"><code>11</code></td>
<td align="left">GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td align="center"><code>01</code></td>
<td align="left">偏向锁</td>
</tr>
</tbody></table>
<p>在代码进行同步时，若此同步对象没有被锁定(锁标志位为01)，虚拟机将在当前线程栈帧中简历一个名为所记录(Lock Records)的空间，用于存储锁对象目前的Mark Word的拷贝(Displace Mark Word)，这时线程堆栈与对象头状态如下图所示：</p>
<p><img src="https://images.effiu.cn/blog/jvm/38.png" alt="轻量级锁CAS操作之前栈帧与对象的状态"></p>
<p>然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。若这个更新成功，那么线程拥有了对象的锁，且会对Mark Word的锁标志(Mark Word的最后两位)位转变为00，表示此对象处于轻量级锁的锁定状态，这时线程堆栈与对象头状态如下图：</p>
<p><img src="https://images.effiu.cn/blog/jvm/39.png" alt="轻量级锁CAS操作之后栈帧与对象的状态"></p>
<p>若更新失败，虚拟机将会检查对象的Mark Word是否指向当前线程的栈帧，若是则说明线程已经拥有这个对象的多，那么可以直接进入同步块执行，否则说明这个锁对象已经被其他线程抢占了。当两个一个线程征用一个锁时，轻量级锁就会膨胀为重量级锁，锁标志位为10，Mark Word中存储的就是指向重量级锁(互斥量)的指针，后面等待的锁的线程就会进入阻塞状态。</p>
<p>轻量级锁的解锁过程也是通过CAS操作进行的，若对象的Mark Word仍然指向线程的所记录，那就用CAS操作把对象当前Mark Word和线程中复制的Displace Mark Word替换回来。若成功，则同步过程完成，若替换失败，则说明有其他线程尝试过获取该锁，那就释放锁的同时唤醒被挂起的线程。</p>
<p>轻量级锁提升同步性能的依据是“对于绝大部分锁，整个同步周期内都是不存在竞争的”，若没有竞争，轻量级锁使用CAS操作避免使用互斥量的开销，若存在竞争，除了互斥量的开销，还额外发生了CAS操作，此时轻量级锁就会比重量级锁更慢。</p>
<h4 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h4><p>偏向锁也是JDK6引入的一项优化，目的是消除数据在无竞争情况下的同步原语，进一步提高运行性能。轻量级锁是在无竞争条件下使用CAS操作去消除同步使用的互斥量，偏向锁则是在无竞争情况下把整个同步过程消除掉，连CAS操作都不做了。</p>
<p>偏向锁就是锁会偏向于第一个获取它的线程，若接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要进行同步。</p>
<p>当锁对象第一次被线程获取时，虚拟机将把对象头的标志位设置为01，即偏向模式，同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word中，若CAS操作成功，持有偏向锁的线程以后每次进入锁相关的同步块时，虚拟机都不会进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁时，偏向模式就结束。根据锁对象目前是否处于被锁定状态，撤销偏向后恢复到未锁定(标志位为01)或轻量级锁定(标志位为00)的状态，后续同步操作就如上面的<a href='#lightweightLocking'>轻量级锁</a>那样执行。偏向锁、轻量级锁的状态转换及对象Mark Word关系如下：</p>
<p><img src="https://images.effiu.cn/blog/jvm/40.png" alt="轻量级锁CAS操作之后栈帧与对象的状态"></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型与线程</title>
    <url>/blog/2019/08/11/jvm/12_jmm_thread/</url>
    <content><![CDATA[<p>并发处理的广泛应用是使用<strong>Amdahl定律</strong>代替<strong>摩尔定律</strong>成为计算机发展源动力的根本原则。</p>
<blockquote>
<p>Amdahl定律通过系统中并行化与串行化的比重来描述多处理器系统能够获得的运算加速能力，摩尔定律用于描述处理器晶体管数量与运行效率之间的发展关系。两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程。</p>
</blockquote>
<p>多任务处理在现代计算机操作系统中是一项必备的功能。让计算机同时去做几件事情，不仅仅是因为计算机的运算能力强大，还有一个重要原因是计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间花费在磁盘I/O、网络通信或者数据库访问上。计算机大部分时间都处于等待其他资源的状态，所以我们为了充分利用计算机的运算能力，让计算机同时处理多个任务。</p>
<p>计算机同时处理多个任务，一个服务端同时对多个客户端提供服务，都是利用并发提供效率的场景。<font color='red'>衡量一个服务的好坏</font>，每秒事务处理数(Transactions Per Second，TPS)是最重要的指标之一，其代表一秒内服务端平均能相应的请求总数，TPS与程序的并发能力有非常密切的关系。当计算相同的任务时，程序线程并发协调得越有条不紊，效率就会越高。</p>
<p>如何写好并发应用程序是服务端程序开发的难点之一。处理好并发方面的问题需要很多编码经验支持。Java语言和虚拟机也提供了许多工具降低并发门槛。各种中间件服务器、各类框架都努力地处理尽可能多的线程并发细节，所以程序员不需要花费太多时间关注服务的并发、协调硬件资源，但是它们都不可能完成所有的并发处理的事情，了解并发的内幕是成为一个高级程序员不可缺少的技能。</p>
<p>下面说明虚拟机如何实现多线程、多线程之间由于共享和竞争数据而导致的一系列问题及解决方案。</p>
<a id="more"></a>

<h3 id="1-硬件的效率与一致性"><a href="#1-硬件的效率与一致性" class="headerlink" title="1. 硬件的效率与一致性"></a>1. 硬件的效率与一致性</h3><p>物理机遇到并发问题与虚拟机中的问题有不少相似之处。</p>
<p>为了更充分利用计算机处理器的效能，让计算机并发执行若干个运算任务。其中绝大多数任务不可能只靠处理器完成，处理器要与内存交互，如读取运算数据、存储运算结果等，这些I/O操作是很难消除的。计算机的存储设备比处理器的运算速度差几个数量级，所以现代计算机都加入了一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能能够快速进行，当运算结束后再从缓存同步到内存中，这样处理器就不需要等待缓慢的内存读写了。</p>
<p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但也为计算机系统带来更高的复杂度，其产生了新的问题：<strong>缓存一致性</strong>(Cache Coherence)。多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)，多个处理器的运算任务都涉及同一块内存区域时，可能会导致各自缓存数据不一致。为了解决这个问题，需要各个处理器访问缓存时遵循一些协议(MSI、MESI、MOSI、Synapse、Firefly、Dragon、Protocol等)，读写时根据协议进行操作，其可以理解为<font color='red'>在特定的操作协议写，对特定的内存或高速缓存进行读写访问的过程抽象</font>。处理器、高速缓存、主内存之间的交互关系如下：</p>
<p><img src="https://images.effiu.cn/blog/jvm/33.png" alt="处理器、高速缓存、主内存之间的交互关系"></p>
<p>除了增加高速缓存，为了使处理器内部的运算单元能尽量被充分利用，处理可能会对输入代进行乱序执行(Out-Of-Order Execution)优化，处理器将乱序执行的结果充足，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。Java虚拟机的即时编译器中也有指令重排(Instruction Reorder)优化。</p>
<h3 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2. Java内存模型"></a>2. Java内存模型</h3><p>Java虚拟机试图定义一种Java内存模型(Java Memory Model, JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，来实现在各种平台下都能达到一致的内存访问效果。</p>
<blockquote>
<p>C/C++等其他主流程序语言直接使用物理硬件和操作系统的内存模型，会由于不同平台上内存模型的差异，可能导致在一种平台上并发完全正常，但在另一种平台上并发访问却经常出错，因此某些场景就必须针对不同的平台编写程序。</p>
</blockquote>
<p>定义Java内存模型，必须足够严谨，保证Java并发内存访问操作不会产生歧义；也要足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有指令）来获得更好的执行速度。 </p>
<h4 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1. 主内存与工作内存"></a>1. 主内存与工作内存</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将<strong>变量</strong>存储到内存和从内存中取出变量这些底层细节。</p>
<blockquote>
<p>变量包括实例字段、静态字段和构成数组对象的元素，不包括局部变量与方法参数，因为这些是线程私有的，不会被共享。</p>
</blockquote>
<p>为了获得更好的执行性能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制编译器进行调整代码执行顺序。</p>
<p>Java内存模型规定了所有变量都存储在主存中，每个线程还有自己的工作内存。线程的工作内存中保存了被该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要通过主内存完成，线程、主内存、工作内存三者关系如下图：</p>
<blockquote>
<p>主内存与物理硬件的主内存名字一样，两者类似，但实际上仅是虚拟机内存的一部分。工作内存可与处理器高速缓存类比。</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/jvm/34.png" alt="线程、主内存、工作内存关系"></p>
<p>主内存、工作内存与Java内存区域中的Java堆、栈、方法区等不是同一层次的内存划分，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，工作内存对应于虚拟机栈中的部分区域。</p>
<h4 id="2-内存间交互操作"><a href="#2-内存间交互操作" class="headerlink" title="2. 内存间交互操作"></a>2. 内存间交互操作</h4><p>主内存与工作内存间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这些实现细节，Java内存模型中定义了8中操作完成，虚拟机实现时必须保证这8中操作是原子的、不可再分的(<code>load</code>、<code>store</code>、<code>read</code>、<code>write</code>在某些平台例外)</p>
<ul>
<li><code>lock</code>(锁定)，作用于主内存的变量，其把一个变量标识为一条线程独占的状态。</li>
<li><code>unlock</code>(解锁)，作用于主内存的变量，其把一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程锁定</li>
<li><code>read</code>(读取)，作用于主内存的变量，其把一个变量的值从主内存传输到线程的工作内存中，便于随后<code>load</code>动作使用</li>
<li><code>load</code>(载入)，作用于工作内存的变量，其把<code>read</code>操作从主内存中得到的变量放入工作内存的变量副本中</li>
<li><code>use</code>(使用)，作用于工作内存的变量，其把工作内存中的一个变量的值传递给执行引擎，当虚拟机遇到一个需要使用到变量的值的字节码时将会执行该操作。</li>
<li><code>assign</code>(赋值)，作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，当虚拟机遇到一个给变量赋值的字节码指令时执行该操作</li>
<li><code>store</code>(存储)，作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，便于随后<code>write</code>使用</li>
<li><code>write</code>(写入)，作用于主内存，把<code>store</code>操作从主内存中得到的变量的值放入主内存变量中</li>
</ul>
<p>把一个变量从主内存复制到工作内存中，需要顺序执行<code>read</code>和<code>load</code>操作，把一个变量的值从工作内存同步到主内存中，就需要顺序执行<code>store</code>和<code>write</code>操作。Java内存模型要求上述操作<strong>必须顺序执行，但未要求连续执行</strong>。Java内存模型还规定上述8种操作必须满足如下规则：</p>
<ul>
<li>允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>之一单独出现，但不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存</li>
<li>不允许线程无原因地(无<code>assign</code>操作)把数据从线程的工作内存同步回主内存</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(<code>load</code>或<code>assign</code>)的变量，即在<code>use</code>、<code>store</code>操作之前，必须先执行<code>assign</code>和<code>load</code>操作</li>
<li>一个变量在同一时刻只允许一个线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一个线程重复执行多次，多个<code>lock</code>后，只有执行相同次数的<code>unlock</code>后，变量才会被解除</li>
<li>一个变量被<code>lock</code>后，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>和<code>assign</code>操作初始化变量的值</li>
<li>一个变量事先没有被<code>lock</code>操作锁定，那就不允许执行<code>unlock</code>操作，也不允许<code>unlock</code>一个被其他线程锁定的变量</li>
<li>对一个变量执行<code>unlock</code>操作前，必须先把变量同步回主内存中(<code>store</code>和<code>write</code>操作)</li>
</ul>
<p>这8中内存访问操作以及上述规则限定，加上<code>volatile</code>的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。</p>
<h4 id="3-volatile型变量的特殊规则"><a href="#3-volatile型变量的特殊规则" class="headerlink" title="3. volatile型变量的特殊规则"></a>3. <code>volatile</code>型变量的特殊规则</h4><p><code>volatile</code>可以说是Java虚拟机提供的最轻量级的同步机制，<code>volatile</code>变量具备两种特性:</p>
<ul>
<li><code>volatile</code>变量的可见性</li>
<li><code>volatile</code>变量禁止指令重排</li>
</ul>
<h5 id="1-volatile的可见性"><a href="#1-volatile的可见性" class="headerlink" title="1. volatile的可见性"></a>1. <code>volatile</code>的可见性</h5><p>保证此变量对所有线程的可见性，即当一个线程修改了此变量的值，新值对于其他线程来说是立即可见的。<code>volatile</code>变量的运算在并发下是安全的，是因为<code>volatile</code>变量在各个线程的工作内存中不存在一致性问题，其实际是存在不一致的情况，但是每次使用<code>volatile</code>之前都要先刷新，所以执行引擎看不到不一致的情况，所以认为不存在不一致的问题。并不是用<code>volatile</code>关键字修饰的变量相关操作是原子的，所以<code>volatile</code>变量的运算在并发下一样是不安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程让步，当其他线程存在时</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果不是20000。因为<code>race++</code>非原子操作，使用<code>javap</code>反编译得到以下代码清单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void increase();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack&#x3D;2, locals&#x3D;0, args_size&#x3D;0</span><br><span class="line">        0: getstatic     #2                  &#x2F;&#x2F; Field race:I</span><br><span class="line">        3: iconst_1</span><br><span class="line">        4: iadd</span><br><span class="line">        5: putstatic     #2                  &#x2F;&#x2F; Field race:I</span><br><span class="line">        8: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 12: 0</span><br><span class="line">       line 13: 8</span><br></pre></td></tr></table></figure>

<p><code>getstatic</code>指令把<code>race</code>值压入栈顶时，<code>volatile</code>关键字保证了<code>race</code>的值是正确的，<code>iconst_1</code>、<code>iadd</code>这些指令时，其他线程可能已经把<code>race</code>的值加大了，此时栈顶的值已过期，<code>putstatic</code>指令执行后就可能把较小的<code>race</code>同步到主内存中。</p>
<p>实际上，编译出的字节码指令并不意味着是原子操作，一条字节码指令在解释执行时，需要运行多行代码才能实现其语义。一条字节码指令可能转化为若干本地机器码指令。<code>-XX:+PrintAssembly</code>参数输出反汇编命令。</p>
<p><code>volatile</code>只能保证可见性，在不符合以下两条规则时，仍然要使用<code>synchronized</code>和<code>java.util.concurrent</code>来保证原子性</p>
<ul>
<li>运算结果不依赖变量当前值，或者能够确保只有单一线程修改变量的值</li>
<li>变量不需要与其他状态变量共同参与不变约束</li>
</ul>
<h5 id="2-禁止指令重排序优化"><a href="#2-禁止指令重排序优化" class="headerlink" title="2. 禁止指令重排序优化"></a>2. 禁止指令重排序优化</h5><p>普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方能够获取正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序。以<a target='_blank' href='/blog/2019/05/22/concurrent/chapter3/3.8_delay_initialization/'>DCL(Double Check Lock)单例为例</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLocking</span> </span>&#123;                                   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String instance;                                 <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInstance</span><span class="params">()</span></span>&#123;                             <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;                                      <span class="comment">// 4: 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLocking.class)&#123;                // <span class="number">5</span>：加锁</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;                              <span class="comment">// 6: 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> String(<span class="string">&quot;initialization&quot;</span>);<span class="comment">// 7: 问题的根源出在这里</span></span><br><span class="line">                &#125;                                                   <span class="comment">// 8</span></span><br><span class="line">            &#125;                                                       <span class="comment">// 9</span></span><br><span class="line">        &#125;                                                           <span class="comment">// 10</span></span><br><span class="line">        <span class="keyword">return</span> instance;                                            <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>instance</code>变量赋值部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0x01a3del</span>d: movb $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi);</span><br><span class="line"><span class="number">0x01a3de24</span>: lock addl $ <span class="number">0x0</span>,(%esp);</span><br></pre></td></tr></table></figure>

<p>用<code>volatile</code>修饰的变量，在赋值时会多出第二行代码，其作用是:使得本<strong>CPU</strong>的<strong>Cache</strong>写入了内存该写入动作也会引起别的CPU或者别的内核无效化其<strong>Cache</strong>，相当于对<strong>Cache</strong>中的变量做了一次<code>store</code>和<code>write</code>操作。</p>
<p><font color='red'>指令重排序</font>指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各项应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。<code>lock</code>指令意味着所有之前的操作都已执行完成，且同步到内存中。</p>
<p><code>volatile</code>变量读操作的性能消耗与普通变量几乎没有区别，但写操作会慢一些，因为其需要在本地代码中插入许多内存屏障指令保证处理器不发生乱序执行。</p>
<p>Java内存模型中对<code>volatile</code>变量定义的特殊规则如：假设T是一个线程，V和W分别表示两个<code>volatile</code>变量，那么<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>和<code>write</code>操作时要满足如下规则：</p>
<ul>
<li>线程T对变量V的<code>use</code>动作，可以认为是和线程T对变量V的<code>load</code>、<code>read</code>动作相关联，<code>load</code>和<code>use</code>必须连续一起出现，即每次使用V前必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V的修改</li>
<li>线程T对变量V的<code>assign</code>动作可以认为是线程T对变量V的<code>store</code>、<code>write</code>相关联，<code>assyign</code>和<code>store</code>必须连续一起出现，即每次修改V后都必须立即同步回主内存中，用于保证其他线程可以 看到自己对变量V的修改。</li>
<li><code>volatile</code>修饰的变量不会被指令排序优化，保证代码执行顺序与程序顺序相同</li>
</ul>
<h4 id="4-对于long和double型变量的特殊规则"><a href="#4-对于long和double型变量的特殊规则" class="headerlink" title="4. 对于long和double型变量的特殊规则"></a>4. 对于<code>long</code>和<code>double</code>型变量的特殊规则</h4><p><a name='nonatimic'></a>Java内存要求<code>lock</code>、<code>unlock</code>、<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>、<code>write</code>这8种操作都具有原子性，但对于64位的数据类型(<code>double</code>、<code>long</code>)，在模型中特别定义了一条宽松的规定：运行虚拟机将没有被<code>volatile</code>修饰的64位数据的读写操作分为两次32位操作进行，即允许虚拟机实现选择可以不保证64位数据类型的<code>load</code>、<code>store</code>、<code>read</code>、<code>write</code>这4个操作的原子性，即<code>long</code>和<code>double</code>的非原子协定(Nonatomic Treatment of double and long Variables)。</p>
<p>若有多个线程共享未声明为<code>volatile</code>的<code>long</code>或则<code>double</code>变量，且同时对它们进行读取和修改，那么某些线程可能会读取到一个非原子值，也不是其他线程修改的值的代表了“半个变量”的数值。但目前商用Java虚拟机均是把这些操作实现为具有原子性的操作。</p>
<h4 id="5-原子性、可见性和有序性"><a href="#5-原子性、可见性和有序性" class="headerlink" title="5. 原子性、可见性和有序性"></a>5. 原子性、可见性和有序性</h4><p>Java内存模型围绕着并发过程中如何处理原子性、可见性和有序性这3个特性建立的。</p>
<ul>
<li><p><strong>原子性</strong>：由Java内存模型来直接保证的原子性变量操作包括<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>、<code>write</code>，大致可以认为基本数据类型的访问读写是具备原子性的，<a href='#nonatimic'>long和double的非原子协定</a>。</p>
<p>若需要更大范围的原子性，Java内存模型还提供了使用<code>lock</code>和<code>unlock</code>操作实现的<code>monitorenter</code>和<code>monitorexit</code>两个更高级别的字节码指令，对应于Java代码中的同步块——<code>synchronized</code>关键字。</p>
</li>
<li><p><strong>可见性</strong>：指当一个线程修改了共享变量的值，其他线程可以立即得知这个修改。Java内存模型是通过变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现可见性。<code>volatile</code>的特殊规则是新值能立即同步到主内存，每次试用期立即从主内存刷新值。</p>
<p><code>synchronized</code>和<code>final</code>也具有可见性:</p>
<ul>
<li><code>synchronized</code>的可见性：对一个变量执行操作前，必须先把此变量同步回主内存中(<code>store</code>、<code>write</code>)规定的。</li>
<li><code>final</code>的可见性，被<code>final</code>修饰的字段在构造器中一旦初始化完成，且构造器没有把this引用传递出去，那其他线程就能看到<code>final</code>字段的值。</li>
</ul>
</li>
<li><p><strong>有序性</strong>：在本线程观察，所有操作有序，在一个线程中观察另一个线程(Within-Thread As-If-Serial Semantics)，所有操作都是无序的(指令重排序，工作内存与主内存同步延迟)</p>
<ul>
<li><code>volatile</code>，禁止指令重排，所以有序</li>
<li><code>synchronized</code>，一个变量同一时刻只允许一条线程对其进行<code>lock</code>操作，所以有序</li>
</ul>
</li>
</ul>
<p>实际大部分并发控制都能使用<code>synchronized</code>完成，这也造成了其的滥用。</p>
<h4 id="6-先行发生原则"><a href="#6-先行发生原则" class="headerlink" title="6. 先行发生原则"></a>6. 先行发生原则</h4><p><a href='/blog/2019/04/30/concurrent/chapter3/3.7_happens-before/' target='_blank'>happens-before原则</a>，是判断数据是否存在竞争、线程是否安全的主要依据。下面是Java内存模型下的一些“天然”<code>happens-before</code>关系，其不需要任何同步器协助，可以在编码中直接使用：</p>
<ul>
<li>程序次序规则(Program Order Rule)，<strong>一个线程内</strong>，按照程序代码顺序，书写在前面的操作先于后面的操作发生，准确的说是，控制流顺序而不是书写顺序</li>
<li>管程锁定规则(Monitor Lock Rule)，一个<code>unlock</code>操作先发生于后面对同一个操作的<code>lock</code>操作，要求是同一个锁。</li>
<li><code>volatile</code>变量规则(Volatile Variable Rule)，对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作</li>
<li>线程启动规则(Thread Start Rule)，<code>Thread</code>对象的<code>start()</code>先行发生于此线程的每一个动作</li>
<li>线程终止规则(Thread Terminaltion Rule)，线程中所有操作都先行发生于对此线程的终止检测，<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值检测线程已经终止执行</li>
<li>线程中断规则(Thread Interruption Rule)，线程的<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。<code>Thread.interrupted()</code>方法检查线程是否有中断发生</li>
<li>对象终结规则(Finalizer Rule)，一个对象的初始化完成先行发生于它的<code>finalize()</code>方法的开始</li>
<li>传递性(Transitivity)：若操作A先行发生于操作B，操作B先发生于操作C，那么可以得出操作A先发生于操作C</li>
</ul>
<h3 id="3-Java-与线程"><a href="#3-Java-与线程" class="headerlink" title="3. Java 与线程"></a>3. Java 与线程</h3><p>并发不一定要依赖多线程(PHP中的多进程并发)，Java中并发就是多线程。</p>
<h4 id="1-线程的实现"><a href="#1-线程的实现" class="headerlink" title="1. 线程的实现"></a>1. 线程的实现</h4><p>线程是比进程更轻量级的调度执行单位，其可以把一个进程的资源分配和执行调度分开，各个线程可以共享进程资源(内存地址、文件I/O)，又可以独立调度(线程是CPU调度的基本单位)。实现线程主要由3种方式：</p>
<ul>
<li>使用内核线程实现</li>
<li>使用用户线程实现</li>
<li>使用用户线程加轻量级进程混合实现</li>
</ul>
<h5 id="1-内核线程实现"><a href="#1-内核线程实现" class="headerlink" title="1. 内核线程实现"></a>1. 内核线程实现</h5><p>内核线程(Kernel-Level Thread, KLT)是直接由操作系统内核(Kernel)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以看做是内核的一个分身，这样操作系统可以同时处理多个任务。</p>
<p>程序一般不会直接去使用内核线程，而是使用内核线程的一种高级接口——轻量级进程(Light Weight Process, LWP)，轻量级进程就是我们通常说的线程，每个轻量级进程是有一个内核线程支持，所以只有先支持内核线程，才能有轻量级进程。轻量级进程与内核线程是一对一关系：</p>
<p><img src="https://images.effiu.cn/blog/jvm/35.png" alt="轻量级进程与内核线程关系"></p>
<p>由于内核线程的支持，每个轻量级进程都能成为一个独立的调度单元，即使有一个轻量级进程先在系统调用中阻塞，也不会影响整个进程继续工作，但也有其局限性：</p>
<ul>
<li>由内核线程实现，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。系统调用代价较高，需要在用户态(User Model)和内核态(Kernel Model)中来回切换</li>
<li>每个轻量级进程都需要一个内核线程支持，所以轻量级进程要消耗一定的内核资源，因此一个轻量级进程的数量是有限的</li>
</ul>
<h5 id="2-用户线程实现"><a href="#2-用户线程实现" class="headerlink" title="2. 用户线程实现"></a>2. 用户线程实现</h5><p>广义上讲，只要非内核线程，就是用户线程。狭义的用户线程指完全建立在用户空间的线程库上，系统内核不能感知线程的存在。用户线程的建立、销毁和调度完全在用户态中完成，不需要内核的帮助。程序使用得当，这种线程不需要切换到内核态，快速且低耗，且可以支持规模更大的线程数量，部分高性能数据库中的多线程是由用户线程实现的。</p>
<p>用户线程优势在于不需要内核线程的支持，但劣势也是无内核线程的支持。线程的创建、切换和调度都是需要考虑的，且操作系统只负责把处理器资源分配到进程，那“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”等问题将会异常难处理。Java、Ruby等都放弃使用用户线程实现</p>
<h5 id="3-用户线程加轻量级进程混合实现"><a href="#3-用户线程加轻量级进程混合实现" class="headerlink" title="3. 用户线程加轻量级进程混合实现"></a>3. 用户线程加轻量级进程混合实现</h5><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户进程一起使用的实现方式。这种模式下既存在用户线程，也存在轻量级进程。</p>
<ul>
<li>用户线程建立在用户空间中，所以用户线程的创建、切换、析构等操作依然廉价，且可以支持大规模用户线程并发</li>
<li>操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，且用户线程的系统调度要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。</li>
</ul>
<p><img src="https://images.effiu.cn/blog/jvm/36.png" alt="用户线程与轻量级进程"></p>
<h5 id="4-Java线程的实现"><a href="#4-Java线程的实现" class="headerlink" title="4. Java线程的实现"></a>4. Java线程的实现</h5><p>操作系统支持的线程模型，决定了Java虚拟机的线程是怎么映射的。虚拟机规范中未限定Java线程需要使用的线程模型。线程模型只对线程并发规模和操作成本产生影响。</p>
<p>对于Sun JDK，是使用一对一的线程模型实现的。</p>
<h4 id="2-Java-线程调度"><a href="#2-Java-线程调度" class="headerlink" title="2. Java 线程调度"></a>2. Java 线程调度</h4><p>线程调度是指操作系统为线程分配处理器使用权的过程。</p>
<ul>
<li><p>协同式线程调度(Cooperative Threads-Scheduling)</p>
<p>线程的执行时间由线程本身控制，线程自己执行完后，要主动切换到另一个线程上。<strong>优点</strong>：实现简单，且线程自己控制线程切换，所以没有线程同步的问题。<strong>缺点</strong>：线程执行时间不可控，可能会一直阻塞。</p>
</li>
<li><p>抢占式线程调度(Preemptive Threads-Scheduling)</p>
<p>每个线程由系统分配执行时间，线程的切换不是由线程本身决定。<strong>优点</strong>：线程的执行时间系统可控，没有线程阻塞导致进程阻塞的问题。Java是抢占式线程调度。</p>
</li>
</ul>
<p>我们可以建议系统给某些线程分配多的执行时间——线程<strong>优先级</strong>。Java中有10个优先级(<code>Thread.MIN_PRIORITY</code>~<code>Thread.MAX_PRIORITY</code>)，两个线程处于<code>Ready</code>时，优先级越高越易被系统选择执行。</p>
<p>Java线程是通过映射到系统原生线程上实现的，所以线程调度最终取决于操作系统。操作系统也提供线程优先级概念，但并不一定可以与Java线程优先级一一对应，例如<strong>Windows</strong>中只有7种优先级。优先级还可以被系统自行改变。例如<strong>Windows</strong>中的优先级推进器。</p>
<h4 id="3-状态转换"><a href="#3-状态转换" class="headerlink" title="3. 状态转换"></a>3. 状态转换</h4><p>Java定义了5中线程状态，在任一时间点，一个线程有且只有一种状态：</p>
<ul>
<li>新建(New)，创建后尚未启动的线程</li>
<li>运行(Runnable)，包括操作系统线程状态中的Running和Ready，此状态的线程有可能正在执行，也有可能等待着CPU分配执行时间</li>
<li>无限期等待(Waiting)，这种状态的线程不会被分配CPU执行时间，其要等待被其他线程显式得唤醒，以下方法会让线程进入无限期等待状态：<ul>
<li>没有设置Timeout参数的<code>Object.wait()</code>方法</li>
<li>没有设置Timeout参数的<code>Thread.join()</code>方法</li>
<li><code>LockSupport.pack()</code>方法</li>
</ul>
</li>
<li>限期等待(Timed Waiting)， 处于这种状态的线程不会分配CPU执行时间，在一定时间后会被系统自动唤醒，以下方法会让线程进入限期等待状态：<ul>
<li><code>Thread.sleep()</code>方法</li>
<li>设置了Timeout参数的<code>Object.wait()</code>方法</li>
<li>设置了Timeout参数的<code>Thread.join()</code>方法</li>
<li><code>LockSupport.parkNanos()</code>方法</li>
<li><code>LockSupport.parkUntil</code>方法</li>
</ul>
</li>
<li>阻塞(Blocked)，线程被阻塞，阻塞状态与等待状态区别是：阻塞状态在等待着获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而等待状态是等待一段时间或者唤醒动作的发生。</li>
<li>结束(Terminated)，已终止线程的线程状态，线程已经结束执行。</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>编译期优化</title>
    <url>/blog/2019/08/08/jvm/10_compile_optimization/</url>
    <content><![CDATA[<p>Java语言的编译期是一段“不确定”的操作过程。</p>
<ul>
<li>前端编译器(编译器的前端)，把java文件转变成class文件的过程。例如：Sun的<code>Javac</code>、<code>Eclipse JDT</code>中的增量式编译器(ECJ)。</li>
<li>虚拟机的后端运行期编译器(JIT编译器，Just In Time Compiler)，把字节码转变为机器码的过程。例如：<strong>HotSpot VM</strong>的<code>C1</code>、<code>C2</code>编译器。</li>
<li>静态提前编译器(AOT编译器, Ahead Of Time Compiler)，直接把java文件编译成本地机器代码的过程。例如：<strong>GUN Compiler for the Java（GCJ)**、</strong>Excelsior JET**。</li>
</ul>
<p>上述过程中大家对Java认知最多的是第一类，其中“编译器”、“编译期”都仅限于第一类编译过程。第二类编译过程是<strong>运行期</strong>过程。</p>
<p><strong>Javac</strong>编译器<strong>几乎未对</strong>代码运行效率做任何优化。虚拟机设计团队把对性能的优化集中到了后端即时编译器中，这样非Java产生的Class文件(例如，JRuby、Groovy等语言的Class文件)也可以享受到编译器优化带来的好处。</p>
<p><strong>Javac</strong>做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。<font color='red'>许多Java语法特性都是靠编译器的“语法糖”来实现，而不是依赖虚拟机底层改进来支持</font>，Java中的即时编译器在运行期的优化过程对于程序运行更重要，前端编译器的优化过程对于程序编码来说关系更密切。</p>
<ul>
<li><input disabled="" type="checkbox"> 阅读Javac源码</li>
</ul>
<a id="more"></a>

<h3 id="1-Javac编译器"><a href="#1-Javac编译器" class="headerlink" title="1. Javac编译器"></a>1. Javac编译器</h3><p>Javac本身是一个由Java语言编写的程序，所以可以通过阅读Javac编译器了解其编译过程。</p>
<ul>
<li><input disabled="" type="checkbox"> 阅读Javac源码</li>
</ul>
<h4 id="1-Javac的源码与调试"><a href="#1-Javac的源码与调试" class="headerlink" title="1. Javac的源码与调试"></a>1. Javac的源码与调试</h4><p>Javac的源码存放在<code>JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac</code>中，除了JDK自身API，只引用链<code>JDK_SRC_HOME/langtools/src/chare/classes/com/sun/*</code>里的代码。</p>
<p>Sun Javac的代码中，编译过程大致包括以下3个过程：</p>
<ul>
<li>解析与填充符号表过程</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程</li>
</ul>
<p><img src="https://images.effiu.cn/blog/jvm/31.png" alt="Javac的编译过程"><a name='round'></a></p>
<p>Javac的编译动作入口是<code>com.sun.tools.javac.com.main.JavaCompiler</code>类。上述编译过程的3个过程集中在该类的<code>compile()</code>和<code>compile2()</code>方法中，主体代码如下图：<a name='javac'></a></p>
<p><img src="https://images.effiu.cn/blog/jvm/32.png" alt="Javac编译过程主体代码"></p>
<h4 id="2-解析与填充符号表"><a href="#2-解析与填充符号表" class="headerlink" title="2. 解析与填充符号表"></a>2. 解析与填充符号表</h4><p>解析步骤由<a href='#javac'>上图</a>的<code>parseFiles()</code>方法完成，解析步骤包括程序编译原理中的词法分析和语法分析两个过程。</p>
<h6 id="1-词法、语法分析"><a href="#1-词法、语法分析" class="headerlink" title="1. 词法、语法分析"></a>1. 词法、语法分析</h6><p><strong>词法分析</strong>是将源代码的字符流转变为标记(Token)集合，单个字符是程序编写过程的最小元素，而标记是编译过程的最小元素，关键字、变量名、字面量、运算符号都可以成为标记，例如：<code>int a = b + 2</code>，包含6个标记<code>int</code>、<code>a</code>、<code>=</code>、<code>b</code>、<code>+</code>、<code>2</code>，Javac的源码中，词法分析由<code>com.sun.tools.javac.parser.Scanner</code>类实现。</p>
<p><strong>语法分析</strong>是根据Token序列构造抽象语法树的过程，抽象语法树(Abstract Synatx Tree, AST)是一种用来描述程序代码语法结构的树形表示方式，语法树每个节点都代表着程序代码中的一个语法结构。例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p>
<p>Javac的源码中，语法分析过程由<code>com.sun.tools.javac.parser.Parser</code>类实现，这个节点产出的语法树由<code>com.sun.tools.javac.tree.JCTree</code>类表示，经过<font color='red'>语法解析后，编译器就不会再对源码文件进行操作了，后续操作步骤都建立在抽象语法树上</font>。</p>
<h6 id="2-填充符号表"><a href="#2-填充符号表" class="headerlink" title="2. 填充符号表"></a>2. 填充符号表</h6><p>语法分析和词法分析后，就是填充符号表的过程，即<a href='javac'>上图</a>中的<code>enterTrees()</code>方法。符号表(Symbol Table)是一组符号地址和符号信息构成的表格。符号表中所登记的信息在变异的不同阶段都要用到。语义分析中，符号表登记的内容将用于语义检查(一个名字的使用和原先的说明是否一致)和产生中间代码。在目标代码生成阶段，党对符号名进行地址分配时，符号表是地址分配的依据。</p>
<p>Javac的源码中，填充符号表的过程由<code>com.sun.tools.javac.comp.Enter</code>类实现，填充符号表的出口是一个待处理列表(To Do List)，包含每个编译单元的抽象语法树的定级节点，以及<code>package-info.java</code>(可能不存在)的定级节点。</p>
<h4 id="3-注解处理器"><a href="#3-注解处理器" class="headerlink" title="3. 注解处理器"></a>3. 注解处理器</h4><p>JDK5之后，Java语言提供了对注解(Annotation)的支持，其与普通Java代码一样，是在运行期间发挥作用的。</p>
<p>JDK6中实现了<strong>JSR-269</strong>规范(插入式注解处理API)，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，其可以认为是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。若这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，见<a href='#round'>上图</a>。</p>
<p>有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间（只要想象力丰富，可以实现许多原本在编码中完成的事情）。</p>
<p>在Javac源码中，插入式注解处理器的初始化过程是在<code>initPorcessAnnotation()</code>方法中完成的，其执行过程是在<code>processAnnotation()</code>方法中完成的，该方法判断是否还有新的注解处理器需要执行，若存在通过<code>com.sun.tools.javac.processing.JavaProcessEnvironment</code>类的<code>doProcessing()</code>方法生成一个新的<code>JavaCompiler</code>对象对编译的后续步骤进行处理。</p>
<h4 id="4-语义分析与字节码生成"><a href="#4-语义分析与字节码生成" class="headerlink" title="4. 语义分析与字节码生成"></a>4. 语义分析与字节码生成</h4><p>语法分析之后编译器获得了程序代码的抽象语法树，其可以表示一个结构正确的源程序的抽象，但无法保证其是符合逻辑的。语义分析的主要作用就是对结构上正确的源程序进行上下文有关性质的审查，例如类型审查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = a + c;</span><br><span class="line"><span class="keyword">int</span> d = b + c;</span><br><span class="line"><span class="keyword">char</span> d = d + c;</span><br></pre></td></tr></table></figure>

<p>上述代码中，3种赋值运算都可以构成正确的语法树，但只有第一个运算的写法在语义上是正确的，可以通过编译。</p>
<h6 id="1-标注检查"><a href="#1-标注检查" class="headerlink" title="1. 标注检查"></a>1. 标注检查</h6><p>语义分析分为标注检查和数据及控制流分析两个步骤。分别由<a href='#javac'><code>attribute()</code></a>和<a href='#javac'><code>flow()</code></a>方法完成。</p>
<p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与复制之间的数据类型是否能够匹配等等。标注检查的一个重要动作是<strong>常量折叠</strong>。例如：在如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>在语法树上仍然有“1”、“2”、“+”等标记(Token)，但是经过标注检查的常量折叠后，其会被折叠为字面量“3”，所以实际上<code>a = 1 + 2</code>并不比<code>a = 3</code>在运行期增加运算量。类内所有运算都会进行常量折叠。</p>
<p>标注检查步骤在<strong>Javac</strong>源码中的实现类是<code>com.sun.tools.javac.comp.Attr</code>类和<code>com.sun.tools.javac.comp.Check</code>类。</p>
<h6 id="2-数据及控制流分析"><a href="#2-数据及控制流分析" class="headerlink" title="2. 数据及控制流分析"></a>2. 数据及控制流分析</h6><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，其可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的差检查异常都被正确处理了等问题。编译期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有区别，部分校验只有在编译期或运行期才能进行。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个<code>foo()</code>方法中，第一个方法的参数和局部变量定义使用了<code>final</code>修饰符，而第二种方法则没有，在代码编写时期会受到final修饰符的影响，不能再改变arg和var变量的值，但是这两段代码编译出的Class文件没有任何区别的(反编译查看后无区别)。局部变量与字段(实例变量、类变量)是有区别的，它在常量池中没有<code>CONSTANT_Fieldref_inf</code>的符号引用，所有没有访问标志的信息，甚至连名字都不会保留下来(取决于编译时的选项)，所以编译后的Class文件不可能存在区别。<font color='red'>局部变量声明为<code>final</code>, 对运行期没有任何影响，变量的不变性仅仅由编译器在编译期间保障</font>。<strong>Javac</strong>源码中数据及控制流分析的入口是<a href='#javac'>上图</a>中的<code>flow()</code>方法，具体操作由<code>com.sun.tools.java.comp.Flow</code>类完成。</p>
<h6 id="3-语法糖"><a href="#3-语法糖" class="headerlink" title="3. 语法糖"></a>3. 语法糖</h6><p>语法糖(Syntactic Sugar)是指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。通常使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。<br>Java中最常用的语法糖主要是泛型、变长参数、自动装箱/拆箱等等，其会在编译阶段还原回简单的基础语法结构(虚拟机运行时不支持这些语法)，这成为解语法糖。</p>
<p>在<strong>Javac</strong>的源码中，解语法糖的过程由<code>desugar()</code>方法触发，在<code>com.sun.tools.javac.comp.TransTypes</code>类和<code>com.sun.tools.javac.comp.Lower</code>类中完成。</p>
<h6 id="4-字节码生成"><a href="#4-字节码生成" class="headerlink" title="4. 字节码生成"></a>4. 字节码生成</h6><p>字节码生成是<strong>Javac</strong>编译过程的最后一个阶段，在<strong>Javac</strong>源码中由<code>com.sun.tools.javac.jvm.Gen</code>类完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、符号表)转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p>
<p>例如：类的实例构造器<code>&lt;init&gt;()</code>方法和类构造器<code>&lt;clinit&gt;()</code>方法就是在该阶段添加到语法树中的(实例构造器并不一定是默认构造函数，若用户程序代码中没有提供任何构造函数，那编译器将会添加一个没有参数、访问性(<code>public</code>、<code>private</code>、<code>protected</code>)与当前类一致的默认构造函数，这个工作在填充符号表阶段已经完成)，这两个构造器的产生过程是一个代码收敛的过程，编译器会把语句块(<code>&#123;&#125;</code>、<code>static&#123;&#125;</code>)、变量初始化(实例变量和类变量)、调用父类的实例构造器(仅仅是实例构造器，类构造器<code>&lt;clinit&gt;()</code>中不需要调用父类<code>&lt;clinit&gt;()</code>方法，虚拟机会自动保证父类构造器的执行)等操作收敛到<code>&lt;init&gt;()</code>和<code>&lt;clinit&gt;()</code>方法之中，且会保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行，该动作由<code>Gen.normalizeDefs()</code>方法实现。</p>
<p>其他代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为<code>StringBuffer</code>或者<code>StringBuilder</code>的<code>append()</code>等操作。</p>
<p>完成了语法树的遍历和调整之后，就会把填充了所有需要信息的符号表交给<code>com.sun.tools.javac.jvm.ClassWriter</code>类，由这个类的<code>writeClass()</code>方法输出字节码，生成最终的Class文件，到此整个<strong>Javac</strong>的编译过程结束。</p>
<h3 id="2-Java语法糖的味道"><a href="#2-Java语法糖的味道" class="headerlink" title="2. Java语法糖的味道"></a>2. Java语法糖的味道</h3><p>几乎所有语言都有语言都或多或少提供过语法糖方便程序员开发，其虽然不会提供是指性的功能改进，但有许多优点：提高效率、提升语法的严谨性、减少编码出错的机会等等，但容易让程序员产生依赖，无法看清语法糖的糖衣，程序代码的真是面目。</p>
<h4 id="1-泛型与类型擦除"><a href="#1-泛型与类型擦除" class="headerlink" title="1. 泛型与类型擦除"></a>1. 泛型与类型擦除</h4><p>泛型是JDK5的一项新增特性，其本质是参数化类型(Parametersized Type)的应用，即<font color='red'>所操作的数据类型被指定为一个参数</font>。这种参数可以应用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p>
<p>泛型技术在C#和Java之中的使用方式有区别。C#里无论在程序源码中、编译后的IL中(Intermediate Language，中间语言，泛型是一个占位符)，或是运行期的CLR(Common Language Runtime)中，都是切实存在的。<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>就是两种类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为<strong>类型膨胀</strong>，基于这种方法实现的泛型称为<strong>真实泛型</strong>。</p>
<p>Java语言中泛型只在程序源码中存在，在变以后的字节码文件中就会被替换为原来的原生类型(Raw Type，裸类型)了，且在相应的地方插入了强制转型代码，因此对于运行期代码来说，<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>就是一种类型，所以Java泛型技术是Java语言的一颗语法糖，Java语言中的泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为<strong>伪泛型</strong>。</p>
<p>类型擦除实现泛型丧失了一些泛型思想应有的优雅。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码不能被编译，因为参数<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>编译之后都被擦除了，所以其特征签名一样。<font color='red'>泛型擦除成相同的类型是上述方法不能重载的部分原因</font>。</p>
<ul>
<li><input disabled="" type="checkbox"> jdk8编译失败</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        method(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码添加了不同的返回值，方法重载成功了。原因是：两个<code>method</code>方法加入不同的返回值后才能共存在一个Class文件中。<a target='_blank' href='/blog/2019/06/22/jvm/6_class_structure#methodSign'>Class文件结构</a>中的方法表的数据结构中，方法重载要求方法具有不同的特征签名，返回值和受检查异常列表包含在方法的特征签名中，所以返回值不参与重载选择，但是在Class文件格式中，只要描述符不是完全一致的两个方法就可以共存，所以两个方法具有相同的名称和特征签名，只要返回类型不同，就可以共存于一个Class文件中。</p>
<p>由于Java泛型的引入，不可避免地产生了新的需求，例如：在泛型类中如何获取传入的参数化类型等。因此JCP(Java Community Process)组织对虚拟机规范做出了相应修改，引入了<code>Signature</code>、<code>LocalVariableTypeTable</code>等新的属性用于解决伴随泛型而来的参数类型识别问题，<code>Signature</code>作用是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。</p>
<p>擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息。</p>
<h4 id="2-自动装箱、自动拆箱与遍历循环"><a href="#2-自动装箱、自动拆箱与遍历循环" class="headerlink" title="2. 自动装箱、自动拆箱与遍历循环"></a>2. 自动装箱、自动拆箱与遍历循环</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntacticSugar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyntacticSugar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List var0 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        <span class="keyword">for</span>(Iterator var2 = var0.iterator(); var2.hasNext(); var1 += var3) &#123;</span><br><span class="line">            var3 = (Integer)var2.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer var0 = <span class="number">1</span>;</span><br><span class="line">        Integer var1 = <span class="number">2</span>;</span><br><span class="line">        Integer var2 = <span class="number">3</span>;</span><br><span class="line">        Integer var3 = <span class="number">3</span>;</span><br><span class="line">        Integer var4 = <span class="number">321</span>;</span><br><span class="line">        Integer var5 = <span class="number">321</span>;</span><br><span class="line">        Long var6 = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(var2 == var3);				<span class="comment">// true，-128~127</span></span><br><span class="line">        System.out.println(var4 == var5);				<span class="comment">// false</span></span><br><span class="line">        System.out.println(var2 == var0 + var1);		 <span class="comment">// true，常量叠加，-128~127</span></span><br><span class="line">        System.out.println(var2.equals(var0 + var1));	  <span class="comment">// true</span></span><br><span class="line">        System.out.println(var6 == (<span class="keyword">long</span>)(var0 + var1));  <span class="comment">// true，类型强转</span></span><br><span class="line">        System.out.println(var6.equals(var0 + var1));     <span class="comment">// false 类型不一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5中语法糖。下述代码则是其编译后使用<strong>Java Decompiler</strong>打开后的(idea打开后看不到自动装箱/拆箱与变长参数语法糖)</p>
<ul>
<li>自动装箱、自动拆箱在编译后备转化为对应的包装和还原方法，<code>Integer.valueOf()</code>和<code>Integer.intValue()</code></li>
<li>遍历循环则把代码还原成立迭代器的实现，这也是遍历循环需要被遍历的类实现<code>Iterable</code>接口的原因</li>
<li>变长参数在调用是变成了一个数组类型的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntacticSugar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    List localList = Arrays.asList(<span class="keyword">new</span> Integer[] &#123; Integer.valueOf(<span class="number">1</span>), Integer.valueOf(<span class="number">2</span>), Integer.valueOf(<span class="number">3</span>), Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator localIterator = localList.iterator(); localIterator.hasNext();) &#123; <span class="keyword">int</span> j = ((Integer)localIterator.next()).intValue();</span><br><span class="line">      i += j;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Integer localInteger1 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    Integer localInteger2 = Integer.valueOf(<span class="number">2</span>);</span><br><span class="line">    Integer localInteger3 = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">    Integer localInteger4 = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">    Integer localInteger5 = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">    Integer localInteger6 = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">    Long localLong = Long.valueOf(<span class="number">3L</span>);</span><br><span class="line">    System.out.println(localInteger3 == localInteger4);</span><br><span class="line">    System.out.println(localInteger5 == localInteger6);</span><br><span class="line">    System.out.println(localInteger3.intValue() == localInteger1.intValue() + localInteger2.intValue());</span><br><span class="line">    System.out.println(localInteger3.equals(Integer.valueOf(localInteger1.intValue() + localInteger2.intValue())));</span><br><span class="line">    System.out.println(localLong.longValue() == localInteger1.intValue() + localInteger2.intValue());</span><br><span class="line">    System.out.println(localLong.equals(Integer.valueOf(localInteger1.intValue() + localInteger2.intValue())));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-条件编译"><a href="#3-条件编译" class="headerlink" title="3. 条件编译"></a>3. 条件编译</h4><p>许多程序设计语言都提供了条件编译的途径，如C、C++中使用预处理指示符(<code>#ifdef</code>)完成条件编译。而C、C++预处理器最初的任务是解决编译时的代码依赖关系(<code>#include</code>预处理命令等)，但在Java中没有预处理器，因为Javac编译器并不是一个个地编译Java文件，而是将所有编译单元的语法树定级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息，不需要使用预处理器。</p>
<p>Java中也可以使用条件编译，方法就是使用条件为常量的<code>if</code>语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;block 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码编译后Class文件的反编译结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能力的语句搭配，可能在控制流分析中提示错误，拒绝编译(<strong>Unreachable statement</strong>)。例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">false</span>) &#123;    </span><br><span class="line">    System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假编译器会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段(<code>com.sun.tools.javac.comp.Lower</code>类中)完成。由于这种条件编译的实现方式使用了<code>if</code>语句，所以其必须遵循最基本的Java语法，只能写在方法体内部，因此只能实现语句基本块级别的编译，没有办法实现根据条件调整整个java类的结构。</p>
<p>Java其他语法糖：内部类，枚举类、断言语句、对枚举和字符串的switch支持、try-with-resource等。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务及隔离性</title>
    <url>/blog/2019/08/07/mysql/10_transaction_isolation/</url>
    <content><![CDATA[<p>程序员的大部分工作是把现实世界的业务场景映射到数据库，我们要保证数据库操作符合现实世界中状态转换的规则。但是实际中，现实世界的一个变化，可能对应数据库的多条操作。例如，银行转账（A给B转账10元）：</p>
<ul>
<li>查询A账户金额</li>
<li>A账户余额减去10元</li>
<li>A账户修改后的余额写到磁盘</li>
<li>查询B账户余额</li>
<li>B账户余额增加10元</li>
<li>B账户余额写入到磁盘</li>
</ul>
<p>如上，现实中的一个不可分割的操作，对应了多个数据库操作，那么我们就需要保证这多个数据库操作不会执行一部分出现问题。</p>
<ul>
<li>数据库本身的错误</li>
<li>操作系统错误</li>
<li>直接断电</li>
<li>······</li>
</ul>
<a id="more"></a>

<h3 id="1-事务的概念"><a href="#1-事务的概念" class="headerlink" title="1. 事务的概念"></a>1. 事务的概念</h3><h4 id="1-数据库的特性"><a href="#1-数据库的特性" class="headerlink" title="1. 数据库的特性"></a>1. 数据库的特性</h4><ol>
<li>原子性(Atomicity)</li>
</ol>
<p>转账是一个不可分割的操作，要么没转，要么转账成功，没有中间的状态。数据库中这种要么全做，要么全不做的规则称为<strong>原子性</strong>。</p>
<ol start="2">
<li>隔离性(Isolation)</li>
</ol>
<p>现实中，银行的两次转账是互不影响的，例如当“A给B转账10元，但银行单笔限额5元时“，A向B转账过程中，会发生查询余额、存钱、转账等等数据库操作。现实与真实数据库中操作可能分别如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/30.png" alt="转账过程"></p>
<p><img src="https://images.effiu.cn/blog/mysql/31.png" alt="转账过程"></p>
<p>所以我们要保证数据库内其他状态转换不会影响到本次状态转换，这个规则称为<strong>隔离性</strong>。</p>
<ol start="3">
<li>一致性(Consistency)</li>
</ol>
<p>现实世界中存在的约束当然也要在数据库世界中有所体现，若数据库中的数据全部符合现实世界中的约束，则这些数据就是一致的，即<strong>一致性</strong>。保证数据的一致性需要现实数据库与业务代码一起保证：</p>
<ul>
<li><p>数据库本身可以为我们保证一部分一致性需求(数据库本身可以保证一部分现实世界的约束永远有效)。<code>MySQL</code>数据库可以为表建立主键、唯一索引、外键、声明某个列为<code>NOT NULL</code>拒绝<code>NULL</code>值插入等，还可以通过自定义触发器的方式定义一些约束条件保证数据库的一致性。</p>
</li>
<li><p>通过写业务代码，保证一致性。</p>
<p>现实生活中复杂的需求有很多，由于性能问题不能把所有的需求都交给数据库。例如，复杂的转账操作。<font color='red'>数据库中某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果</font>。所以原子性与隔离性都会对一致性产生影响。</p>
</li>
</ul>
<ol start="4">
<li>持久性(Durability)</li>
</ol>
<p>数据库中一个操作完成后，其结果将永久保留，称为<strong>持久性</strong>。</p>
<h4 id="2-事务的概念"><a href="#2-事务的概念" class="headerlink" title="2. 事务的概念"></a>2. 事务的概念</h4><p><strong>原子性</strong>(Atomicity)、<strong>隔离性</strong>(Isolation)、<strong>一致性</strong>(Consistency)和<strong>持久性</strong>(Durability)，即<strong>ACID</strong>。需要保证原子性、隔离性、一致性、持久性的一个或者多个数据库操作称之为一个<strong>事务</strong>(<code>transaction</code>)。事务是一个抽象的概念，具有以下几个状态：</p>
<ul>
<li><strong>活动的</strong>(active)，事务对应的数据库操作正在执行过程中，即该事务处于<strong>活动</strong>状态。</li>
<li><strong>部分提交</strong>(partially committed)，事务中最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘，此时事务处于<strong>部分提交</strong>的状态。</li>
<li><strong>失败的</strong>(failed)，事务处于<strong>活动中</strong>或者<strong>部分提交</strong>状态时，可能会遇到某些错误（数据库本身的错误，操作系统错误，直接断电等等）而无法继续执行，所以人为停止当前事务的执行，该事务处于<strong>失败的</strong>状态</li>
<li><strong>中止的</strong>(aborted)，当事务处于<strong>失败的</strong>状态，需要撤销事务对当前数据库造成的影响，即<strong>回滚</strong>。当<strong>回滚</strong>操作执行完毕后，数据库会恢复到执行事务之前的状态，该事务处在了<strong>中止的</strong>状态。</li>
<li><strong>提交的</strong>(committed)，处在部分提交的事务将修改过的数据同步到磁盘后，事务处于<strong>提交的</strong>状态。</li>
</ul>
<p><img src="https://images.effiu.cn/blog/jvm/30.png" alt="事务的过程"></p>
<p>事务处于提交的和中止的状态时，事务的生命周期已经结束了，即事务<code>commit</code>或者<code>rollback</code>后，事务结束。</p>
<h4 id="3-MySQL中事务的语法"><a href="#3-MySQL中事务的语法" class="headerlink" title="3. MySQL中事务的语法"></a>3. MySQL中事务的语法</h4><ul>
<li><p><code>BEGIN [WORK]</code>，代表开启一个事务</p>
</li>
<li><p><code>STARG TRANSACTION</code>，开启一个事务，写法：<code>START TRANSACTION READ ONLY</code></p>
<ul>
<li><code>READ ONLY</code>：标识当前事务是一个只读事务</li>
<li><code>READ WRITE</code>：标识当前事务是一个读写事务</li>
<li><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读</li>
</ul>
</li>
<li><p><code>COMMIT [WORK]</code>，提交一个事务</p>
</li>
<li><p><code>ROLLBACK [WORK]</code>，手动中止一个事务</p>
</li>
</ul>
<h4 id="4-支持事务的存储引擎"><a href="#4-支持事务的存储引擎" class="headerlink" title="4. 支持事务的存储引擎"></a>4. 支持事务的存储引擎</h4><p><code>MySQL</code>中并不是所有的存储引擎都支持事务的功能，目前只有<code>InnoDB</code>和<a href='blog/2019/06/10/mysql/1_first_mysql/'><code>NDB</code></a>存储引擎支持。</p>
<h4 id="5-自动提交"><a href="#5-自动提交" class="headerlink" title="5. 自动提交"></a>5. 自动提交</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;autocommit&#39;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><code>autocommit</code>，是一个系统变量，默认为<code>ON</code>，即一个SQL算一个独立的事务，称为<code>自动提交</code>。</p>
<p>当显式使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么本次事务再提交或者回滚前会关闭自动提交的功能。</p>
<h4 id="6-隐式提交"><a href="#6-隐式提交" class="headerlink" title="6. 隐式提交"></a>6. 隐式提交</h4><p>当使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，或者把系统变量<code>autocommit</code>设置为<code>OFF</code>后，事务不会自动提交，但是如果我们输入某些语句，事务会<strong>自动提交</strong>，即<strong>隐式提交</strong>：</p>
<ul>
<li>定义或修改数据库对象的数据定义语言(DDL)，使用<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等语句修改数据库、表、视图、存储过程等等，会隐式提交事务</li>
<li>隐式使用或修改<code>mysql</code>数据库中的表，<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句</li>
<li>事务控制或关于锁定的语句<ul>
<li>事务提交或者回滚前，使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启另一个事务时</li>
<li><code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句</li>
<li><code>LOAD DATA</code>语句批量向数据库中导入数据时</li>
</ul>
</li>
<li><code>MySQL</code>复制的一些语句，<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时</li>
<li>其他，<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、<code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式提交事务</li>
</ul>
<h4 id="7-保存点"><a href="#7-保存点" class="headerlink" title="7. 保存点"></a>7. 保存点</h4><p>在事务对应的数据库语句中标记几个点，即<strong>保存点</strong>，这样我们在使用<code>ROLLBACK</code>语句时可以指定会回滚到哪个点，而不是最初的原点。语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SAVEPOINT savepoint_name;</span><br><span class="line">ROLLBACK [WORK] TO savepoint_name;</span><br><span class="line">RELEASE SAVEPOINT savepoint_name;	##删除保存点</span><br></pre></td></tr></table></figure>

<h3 id="2-事务隔离级别"><a href="#2-事务隔离级别" class="headerlink" title="2. 事务隔离级别"></a>2. 事务隔离级别</h3><p><code>MySQL</code>是一个<strong>客户端/服务端</strong>架构的软件，对于服务器来说，可以有若干客户端与之连接，每个连接都是一个会话(<strong>Session</strong>)。每个客户端都可以在会话中发出请求，一个请求语句可以是某个事务的一部分，服务器也可能同时处理多个事务，事务之间需要符合<code>隔离性</code>，理论上某个事务对某个数据进行访问时，其他事务要求排队，当该事务提交后，其他事务才可以继续访问这个数据。<a name='isolation'></a>但是这样大大影响性能，所以要求既保持事务的<strong>隔离性</strong>，又让服务器在处理访问同一数据的多个事务时性能尽量高些，这就<font color='red'>要求我们舍弃部分隔离性而保证高性能</font>。</p>
<h4 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE hero (</span><br><span class="line">    number INT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    country varchar(100),</span><br><span class="line">    PRIMARY KEY (number)</span><br><span class="line">) Engine&#x3D;InnoDB CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO hero VALUES(1, &#39;刘备&#39;, &#39;蜀&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="2-事务并发执行的问题"><a href="#2-事务并发执行的问题" class="headerlink" title="2. 事务并发执行的问题"></a>2. 事务并发执行的问题</h4><ul>
<li>脏写(<strong>Dirty Write</strong>)，会话B修改了会话A未提交的修改过的数据，事务B回滚。</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/32.png" alt="脏写"></p>
<ul>
<li><p>脏读(<strong>Drity Read</strong>)，会话A读取到了会话B未提交的事务修改的数据，会话B回滚事务。</p>
<p><img src="https://images.effiu.cn/blog/mysql/33.png" alt="脏读"></p>
</li>
<li><p>不可重复读（<strong>Non-Repeatable Read</strong>）,事务A只能读到另一个已经提交的事务修改过的数据，且其他事务每对该数据进行一次修改并提交后，该事务都可以查询到最新值，则发生了<strong>不可重复读</strong>。</p>
<p><img src="https://images.effiu.cn/blog/mysql/34.png" alt="脏读"></p>
</li>
<li><p>幻读（<strong>Phantom</strong>），事务A先根据某些条件查询出一些记录，之后事务B又向表中插入了符合这些条件的记录，事务A继续以该条件查询时，能把事务B插入的记录也读出来，那么发生了<strong>幻读</strong>。即<font color='red'>在一个事务的两次查询中数据不一致</font>。</p>
</li>
</ul>
<blockquote>
<p>不可重复读的重点是修改：同样的条件，你读取过的数据，再次读取出来发现值不一样了<br>幻读的重点：在于新增或者删除： 同样的条件，第 1 次和第 2 次读出来的记录数不一样</p>
</blockquote>
<h4 id="3-SQL中的隔离级别"><a href="#3-SQL中的隔离级别" class="headerlink" title="3. SQL中的隔离级别"></a>3. SQL中的隔离级别</h4><p><code>MySQL</code>中事务并发执行引发的问题中，按照问题严重性分为：<strong>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</strong>，上文说的<a href='#isolation'>舍弃部分隔离性</a>换取部分性能：设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生，目前<strong>SQL标准</strong>中有4种隔离级别：</p>
<ul>
<li><code>READ UNCOMMITTED</code>：未提交读</li>
<li><code>READ COMMITTED</code>：已提交读</li>
<li><code>REPEATABLE READ</code>：可重复读</li>
<li><code>SERIALIZABLE</code>：可串行化</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read Committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<blockquote>
<p>以上4种隔离级别都不允许脏写发生。</p>
</blockquote>
<h4 id="4-MySQL种支持的隔离级别"><a href="#4-MySQL种支持的隔离级别" class="headerlink" title="4. MySQL种支持的隔离级别"></a>4. MySQL种支持的隔离级别</h4><p>不同的数据库对隔离级别的支持度不一样：</p>
<ul>
<li><code>Oracle</code>只支持<code>READ COMMITTED</code>和<code>SERIALIZABLE</code>隔离级别</li>
<li><code>MySQL</code>支持4种隔离级别，但与<strong>SQL</strong>标准有区别，<code>REPEATED READ</code>(默认)级别下，可以禁止幻读的发生</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure>

<p>以上SQL是设置事务的隔离级别，level可选值有4个：</p>
<ul>
<li><code>REPEATABLE READ</code></li>
<li><code>READ COMMITTED</code></li>
<li><code>READ UNCOMMITTED</code></li>
<li><code>SERIALIZABLE</code></li>
</ul>
<p>事务隔离级别的作用域：</p>
<ul>
<li><code>GLOBAL</code>，在全局范围内影响<ul>
<li>只对执行完该语句之后产生的会话起作用。</li>
<li>当前已经存在的会话无效。</li>
</ul>
</li>
<li><code>SESSION</code>，在会话范围影响<ul>
<li>对当前会话的所有后续事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li>
<li>在事务之间执行，则对后续事务有效</li>
</ul>
</li>
<li>不适用作用域关键字，<code>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code><ul>
<li>只对当前会话中的下一个即将开启的事务有效</li>
<li>下一个开启的事务执行完成后，后续事务恢复默认隔离级别</li>
<li>该语句不能再已经开启的事务中间执行</li>
</ul>
</li>
</ul>
<p>可以在启动<code>MySQL</code>服务器时设置隔离级别，启动参数：<code>--transaction-isolation=SERIALIABLE</code></p>
<h3 id="3-MVCC原理"><a href="#3-MVCC原理" class="headerlink" title="3. MVCC原理"></a>3. MVCC原理</h3><h4 id="1-版本链"><a href="#1-版本链" class="headerlink" title="1. 版本链"></a>1. 版本链</h4><p><code>MySQL</code>中<code>InnoDB</code>存储引擎中，其聚簇索引中包含<a href='/blog/2019/07/16/mysql/4_innodb_data_structure#hiddenColumn'>三个隐藏列</a></p>
<ul>
<li><code>DB_ROW_ID</code>：非必须，当数据库表中存在主键或者非<code>NULL</code>的<code>UNIQUE</code>键时，不会创建该列</li>
<li><code>DB_TRX_ID</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给<code>trx_id</code>隐藏列</li>
<li><code>DB_ROLL_PTR</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<strong>undo日志</strong>中，然后该列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from hero;</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">| number | name   | country |</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">|      1 | 刘备   | 蜀       |</span><br><span class="line">+--------+--------+---------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>假设插入该数据的事务id为80，那么插入后记录的示意图如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/35.png" alt="示意图"></p>
<blockquote>
<p><code>inert undo</code>只在事务回滚时起作用，当事务提交后，该类型的<code>undo</code>日志就没用了，其占用的<code>Undo Log Segment</code>也会被系统回收，即<code>undo</code>日志占用的<code>Undo</code>页面链要么被重用，要么被释放。虽然真正的<code>insert undo</code>日志占用的存储空间被释放，但是<code>DB_ROLL_PTR</code>的值并不会被清除，其占用7个字节，第一个比特位标记的是指向undo日志的类型，为<code>1</code>时，就表示指向的<code>undo</code>日志类型为<code>insert undo</code>(<code>insert</code>SQL语句是插入数据，数据是从无到有)。</p>
</blockquote>
<p>假设之后两个事务id分别为100，200的事务对这条记录进行<code>UPDATE</code>操作，那么流程如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/36.png" alt="示意图"></p>
<blockquote>
<p>两个事务不能同时更新同一条记录，否则就会发生脏写。<code>InnoDB</code>使用锁保证不会发生脏写，当第一个事务更新记录后，会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交，把锁释放后才可以继续更新。</p>
</blockquote>
<p>每次对记录进行改动，都会记录一条<code>undo</code>日志，每条<code>undo</code>日志也都有一个<code>roll_pointer</code>属性(<code>Insert</code>操作对应的<code>undo</code>日志没有该属性)，将这些<code>undo</code>日志都连起来，串成一个链表，如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/37.png" alt="示意图"></p>
<p>对该记录的每次更新，都会把旧值放到<code>undo</code>日志中，可以理解为一个旧版本，且所有版本会被<code>roll_pointer</code>属性连接成一个链表，称为<strong>版本链</strong>。版本链的头节点是当前记录最新的值。</p>
<h4 id="2-ReadView"><a href="#2-ReadView" class="headerlink" title="2. ReadView"></a>2. ReadView</h4><ul>
<li><code>Read UNCOMMITTED</code>隔离级别的事务，由于可以读取到未提交事务修改过的记录，所以直接读取版本链的最新记录。</li>
<li><code>SERIALIZABLE</code>隔离级别的事务，<code>InnoDB</code>使用加锁的方式访问记录</li>
<li><code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录，其核心问题是：<font color='red'>需要判断一下版本链中哪个版本是当前事务可见的</font>。</li>
</ul>
<p>针对上述要求有了<code>ReadView</code>概念：</p>
<ul>
<li><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务的<strong>事务id</strong>列表</li>
<li><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<strong>事务id</strong>，也就是<code>m_ids</code>中的最小值</li>
<li><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给下一个事务的id，其并不是<code>m_ids</code>中的最大值</li>
<li><code>creator_trx_id</code>：表示生成<code>ReadView</code>的事务id</li>
</ul>
<p>当我们访问某条记录时，只需要按照下面步骤判断版本是否可见：</p>
<ul>
<li>被访问版本的<code>trx_id</code>属性值与<code>ReadView</code>中的<code>creator_trx_id</code>相同，即当前事务访问它自己修改过的记录</li>
<li>若被访问版本的<code>trx_id</code>属性值小于<code>ReadView</code>中的<code>min_trx_id</code>，表示生成该版本的事务在当前事务生成的<code>ReadView</code>前已经提交，即可以被当前事务访问</li>
<li><code>trx_id</code>大于或等于<code>ReadView</code>中的<code>max_trx_id</code>值，表示生成该版本的事务在当前事务生成<code>ReadView</code>后开启，不可以被当前事务访问</li>
<li><code>trx_id</code>在<code>min_trx_id</code>和<code>max_trx_id</code>之间，那么就判断一下<code>trx_id</code>属性值是否在<code>m_ids</code>中，若在则说明创建<code>ReadView</code>时该版本的事务是活跃的，则该版本不可以被访问；若不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，则该版本可以被访问</li>
</ul>
<p>当某个版本对当前事务不可见时，就按照版本链找到上一个版本的数据，继续判断其可见性，直到确认版本可见或者版本链最后一个版本。<a name='readviewExample'></a></p>
<p><strong>READ COMMITTED</strong>和<strong>REPEATABLE READ</strong>隔离级别的最大区别时它们生成ReadView的时机不同。下面举例说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Transaction 100</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name &#x3D; &#39;关羽&#39; WHERE number &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name &#x3D; &#39;张飞&#39; WHERE number &#x3D; 1;</span><br><span class="line"></span><br><span class="line"># COMMIT 提交事务语句</span><br><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录，目的是开启事务</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事务执行过程中，只有在第一次真正修改记录时(<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句)，才会被分配一个单独的事务id，这个事务id是递增的。</p>
</blockquote>
<p>那么上述SQL执行后其版本链如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/38.png" alt="版本链"></p>
<h4 id="3-Read-COMMITTE—每次读取数据前都生成一个ReadView"><a href="#3-Read-COMMITTE—每次读取数据前都生成一个ReadView" class="headerlink" title="3. Read COMMITTE—每次读取数据前都生成一个ReadView"></a>3. Read COMMITTE—每次读取数据前都生成一个ReadView</h4><p><a href='#readviewExample'>以上述准备为基础</a>，此时开启一个READ COMMITTED隔离级别的事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM hero WHERE number &#x3D; 1; # 得到的列name的值为&#39;刘备&#39;</span><br></pre></td></tr></table></figure>

<p>那么该<code>SELECT</code>的执行过程如下：</p>
<ul>
<li>执行<code>SELECT</code>语句时先生成一个<strong>ReadView</strong>，其<code>m_ids</code>列表的内容就是[100, 200]，<code>min_trx_id</code>为100，<code>max_trx_id</code>为201(比<code>m_ids</code>中最大事务id的值大)，<code>creator_trx_id</code>为0。</li>
<li>然后从版本链中挑选可见的记录，如上图，最新版本的列<code>name</code>是张飞，但其<code>trx_id</code>值为100，在<code>m_ids</code>中，所以其不可见，根据<code>roll_poitner</code>跳转到下一版本。</li>
<li>上一版本的<code>name</code>是关羽，其<code>trx_id</code>为100，在<code>m_ids</code>中，不可见</li>
<li>上一版本列<code>name</code>是刘备，其<code>trx_id</code>为80，小于<strong>ReadView</strong>的<code>min_trx_id</code>，所以其可见，返回给客户端。</li>
</ul>
<p>当我们把<strong>事务id</strong>为100的事务提交后，再到<strong>事务id</strong>为200的事务中更新SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name &#x3D; &#39;赵云&#39; WHERE number &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name &#x3D; &#39;诸葛亮&#39; WHERE number &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/mysql/39.png" alt="版本链"></p>
<p>此时继续再<code>READ COMMITTED</code>隔离级别的事务中执行查询SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM hero WHERE number &#x3D; 1; # 得到的列name的值为&#39;刘备&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM hero WHERE number &#x3D; 1; # 得到的列name的值为&#39;张飞&#39;</span><br></pre></td></tr></table></figure>

<p>其执行过程如下：</p>
<ul>
<li>执行<strong>SELECT</strong>语句时单独生成一个<code>ReadView</code>，该<strong>ReadView</strong>的<code>m_ids</code>列表的内容就是[200]，事务id为100的事务已经提交，<code>min_trx_id</code>为200，<code>max_trx_id</code>为201，<code>creator_trx_id</code>为0</li>
<li>从版本链中挑选可见的记录，见上图，版本链中最新记录是诸葛亮，其<code>trx_id</code>值为200，再<code>m_ids</code>中，不可见，根据<code>roll_pointer</code>跳转到上一版本</li>
<li>上一版本中是赵云，<code>trx_id</code>为200，在<code>m_ids</code>中，不可见</li>
<li>上一版本是张飞，<code>trx_id</code>为100，小于<strong>ReadView</strong>中的<code>min_trx_id</code>的值200，可见，返回给客户端。</li>
</ul>
<p><font color='red'>使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView</font>。</p>
<h4 id="4-REPEATED-COMMITTED—在第一次读取数据时生成一个ReadView"><a href="#4-REPEATED-COMMITTED—在第一次读取数据时生成一个ReadView" class="headerlink" title="4. REPEATED COMMITTED—在第一次读取数据时生成一个ReadView"></a>4. REPEATED COMMITTED—在第一次读取数据时生成一个ReadView</h4><p>每次事务开始时，只会在第一次执行查询语句时生成一个<strong>ReadView</strong>，之后所有查询都不会重复生成。</p>
<p><a href='#readviewExample'>以上述准备为基础</a>，此时开启一个REPEATABLE READ隔离级别的事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM hero WHERE number &#x3D; 1; # 得到的列name的值为&#39;刘备&#39;</span><br></pre></td></tr></table></figure>

<p><code>SELECT</code>语句的执行过程如下：</p>
<ul>
<li>执行<code>SELECT</code>生成一个<strong>ReadView</strong>，其<strong>ReadView</strong>的<code>m_ids</code>列表的内容是[100, 200]，<code>min_trx_id</code>为100，<code>max_trx_id</code>为201，<code>creator_trx_id</code>为0</li>
<li>然后从版本链中挑选记录，<a href='#readviewExample'>见上图</a>，版本链中最新记录是张飞，该版本的<code>trx_id</code>为100，不可见，根据<code>roll_pointer</code>跳转到上一版本</li>
<li>上一版本中，是关于，其<code>trx_id</code>是100，继续跳转</li>
<li>是<code>刘备</code>，<code>trx_id</code>为80，小于<strong>ReadView</strong>中的<code>min_trx_id</code>，符合版本要求，返回给客户端</li>
</ul>
<p>当我们把事务id为100的事务提交后，在事务id为200的事务中执行如下SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name &#x3D; &#39;赵云&#39; WHERE number &#x3D; 1;</span><br><span class="line"></span><br><span class="line">UPDATE hero SET name &#x3D; &#39;诸葛亮&#39; WHERE number &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>那么版本链如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/40.png" alt="版本链"></p>
<p>继续到REPEATABLE READ隔离级别的事务中执行查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 100、200未提交</span><br><span class="line">SELECT * FROM hero WHERE number &#x3D; 1; # 得到的列name的值为&#39;刘备&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 100提交，Transaction 200未提交</span><br><span class="line">SELECT * FROM hero WHERE number &#x3D; 1; # 得到的列name的值仍为&#39;刘备&#39;</span><br></pre></td></tr></table></figure>

<p><code>SELECT2</code>语句的执行过程如下：</p>
<ul>
<li><strong>REPEATED READ</strong>隔离级别，不会重新生成<strong>ReadView</strong>，复用之前的<strong>ReadView</strong>。其<strong>ReadView</strong>的<code>m_ids</code>列表的内容是[100, 200]，<code>min_trx_id</code>为100，<code>max_trx_id</code>为201，<code>creator_trx_id</code>为0</li>
<li>然后从版本链中挑选记录，<a href='#readviewExample'>见上图</a>，版本链中最新记录是诸葛亮，<code>trx_id</code>为200，在<code>m_ids</code>中，不可见，根据<code>roll_pointer</code>跳转到上一版本</li>
<li>上一版本中，是赵云，<code>trx_id</code>在<code>m_ids</code>中不可见</li>
<li>张飞，版本的<code>trx_id</code>为100，不可见，</li>
<li>关羽，其<code>trx_id</code>是100，不可见，继续跳转</li>
<li>是<code>刘备</code>，<code>trx_id</code>为80，小于<strong>ReadView</strong>中的<code>min_trx_id</code>，符合版本要求，返回给客户端</li>
</ul>
<p>两次查询得到的结果一致，即<strong>可重复读</strong>。</p>
<h4 id="5-MVCC小结"><a href="#5-MVCC小结" class="headerlink" title="5. MVCC小结"></a>5. MVCC小结</h4><p>综上所述，<strong>MVCC</strong>(Muti-Version Concurrency Version，多版本并发控制)指的就是<strong>READ COMMITTED</strong>、<strong>REPEATED READ</strong>这两种隔离级别的事务在执行普通的<code>SELECT</code>操作时访问记录版本链的过程，这样可以使不同事务的读写、写读操作并发执行，从而提升系统性能。<font color='red'>READ COMMITTED和REPEATED READ这两个隔离级别区别就是：</font>生成ReadView的时机不同</p>
<ul>
<li>READ COMMITTED每次进行普通查询操作前都会生成一个ReadView</li>
<li>REPEATED READ只在第一次查询操作前生成一个ReadView</li>
</ul>
<p><code>insert undo</code>在事务提交后就可以被释放掉了，而<code>update undo</code>由于还需要支持<strong>MVCC</strong>，不能立即删除。为了支持<strong>MVCC</strong>，<code>delete mark</code>操作仅仅是在记录上打了一个删除标记，并没有真正删除。当系统确定ReadView的事务不会再访问某些<code>update undo</code>日志以及被打了<code>delete mask</code>的记录后，后台<strong>purge线程</strong>会把其真正删除掉。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载与执行子系统案例</title>
    <url>/blog/2019/08/06/jvm/9_classloader_case/</url>
    <content><![CDATA[<p>在Class文件格式与执行引擎这部分中，用户能直接影响的内容并不太多，Class文件以何种形式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户无法改变。用户能通过程序操作的，主要是字节码生成与类加载器这两部分。</p>
<p>下面是4个关于类加载与执行子系统的案例。</p>
<a id="more"></a>

<h5 id="1-Tomcat-正统的类加载器架构"><a href="#1-Tomcat-正统的类加载器架构" class="headerlink" title="1. Tomcat: 正统的类加载器架构"></a>1. Tomcat: 正统的类加载器架构</h5><p>主流的Java Web服务器，如<code>Tomcat</code>、<code>Jetty</code>、<code>WebLogic</code>、<code>WebSphere</code>等等都实现了自己定义的类加载器。</p>
<p><img src="https://images.effiu.cn/blog/jvm/28.png" alt="tomcat类加载"></p>
<p>如上图所示，一个健全的Web服务器需要解决以下几个问题：</p>
<ul>
<li>部署在同一个Web服务器上的两个Web应用所使用Java类库可以实现相互隔离（两个Web应用可能会依赖同一个三方类库的不同版本）。</li>
<li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享（不同Web应用可能会依赖同样的三方类库，类库不共享时，虚拟机的方法区会过度膨胀）。</li>
<li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响（服务器依赖的库与应用程序隔离开）。</li>
<li>支持JSP应用的Web服务器，大多数都要执行HotSwap功能。</li>
</ul>
<p>基于上述问题，部署Web应用时，单独的一个ClassPath就无法满足需求了，所以各种Web服务器都提供了多个ClassPath保证用户存放第三方类库，一般以<code>lib</code>和<code>classes</code>命名。在不同的路径中的类库，具备不同的访问范围和服务对象，一般每一个目录都会有一个相应的自定义累加载器去加载放置在里面的Java类库。</p>
<p>Tomcat目录结构中，有3组目录<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>可以存放Java类库，还包括Web应用自身的<code>/WEB-INF/*</code>，其含义如下：</p>
<ul>
<li><code>/common/*</code>，类库可被Tomcat和所有的Web应用程序共享</li>
<li><code>/server/*</code>，类库可被Tomcat使用，对所有Web应用程序不可见</li>
<li><code>/shared/*</code>，类库可以被所有的Web应用程序使用，对Tomcat不可见</li>
<li><code>/WEB-INF/*</code>，仅仅对Web应用程序自身可见，对Tomcat和其他Web应用程序不可见</li>
</ul>
<p>为了支持对上述目录的类库进行加载和隔离，Tomcat按照双亲委派模型定义了多个类加载器。</p>
<p><img src="https://images.effiu.cn/blog/jvm/29.png" alt="tomcat服务器类加载架构"></p>
<p>上图中，前三个类加载器时JDK默认的类加载器。<code>CommonClassLoader</code>、<code>CatalinaClassLoader</code>、<code>SharedClassLoader</code>和<code>WebappClassLoader</code>是Tomcat自己定义的类加载器，分别加载<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>和<code>/WebApp/WEB-INF/*</code>下的Java类库，其中<code>WebapClassLoader</code>可能会存在多个实例，一个Web应用对应一个<code>WebappClassLoader</code>实例，每一个JSP文件对应一个Jsp类加载器。</p>
<ul>
<li><code>CommonClassLoader</code>可以加载的类，都可以被<code>CatelinaClassLoader</code>和<code>SharedClassLoader</code>使用。</li>
<li><code>CatelinaClassLoader</code>和<code>SharedClassLoader</code>自己能加载的类则与对方相互隔离</li>
<li><code>WebappClassLoader</code>可以使用<code>SharedClassLoader</code>加载到的类，但是各个<code>WebappClassLoader</code>之间相互隔离</li>
<li><code>JspLoader</code>的加载范围仅仅是这个JSP文件所编译出来的那一个class，其出现的目的就是为了便于丢弃，当服务器检测到JSP文件被修改时，会替换掉目前的<code>JspLoader</code>的实例，并通过再建立一个新的Jsp类加载器实现JSP文件的HotSwap功能。</li>
</ul>
<p>目前Tomcat中需要指定<code>tomcat/conf/catalina.properties</code>中的<code>server.loader</code>和<code>shared.loader</code>才会真正建立<code>CatalinaClassLoader</code>和<code>SharedClassLoader</code>的实例。</p>
<h5 id="2-OSGi：灵活的类加载器架构"><a href="#2-OSGi：灵活的类加载器架构" class="headerlink" title="2. OSGi：灵活的类加载器架构"></a>2. OSGi：灵活的类加载器架构</h5><ul>
<li><input disabled="" type="checkbox"> 学习JavaEE规范，去看JBoss源码，学习类加载器，去看OSGi源码</li>
</ul>
<p>OSGi(Open Service GateWay Initiative)是OSGi联盟制定的一个基于Java语言的动态模块化规范，现已成为Java世界中模块化标准。OSGi中每个模块(Bundle)与普通的Java类库区别不大，都是以Jar封装，内部存储的是Java Package和Class。但是Bundle可以声明它所依赖的Java Package(通过Import-Package描述)，也可以声明它允许导出发布的Java Package(通过Export-Package描述)。<font color='red'>OSGi中，Bundle之间的依赖关系从传统的上层模块依赖底层模块转变为平级模块之间的依赖，类库的可见性得到精准控制</font>。Bundle中只有被Export过的Package才可以被访问，其他的Package和Class都会被隐藏起来。OSGi的另一个优点是：基于OSGi的程序很可能可以实现模块级的热插拔功能，当程序升级更新或者调试除错时，可以只停用、重新安装后启用程序的其中一部分。</p>
<ul>
<li>类库的可见性可以精准控制</li>
<li>模块级的热插拔功能</li>
</ul>
<p>OSGi的优点，归功于其灵活的类加载器架构。Bundle类加载器之间只有规则，没有固定的委派关系。</p>
<blockquote>
<p>某个Bundle声明了一个它依赖的Package，当有其他Bundle声明发布了这个Package，那么所有对这个Packge的类加载动作都会委派给发布它的Bundle，当不涉及某个具体的Package时，各个Bundle加载器是平级关系，只有具体使用某个Package和Class时，才会根据Package导入导出定义来构造Bundle间的委派和依赖。<font color='red'>当一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控制访问范围</font>。</p>
</blockquote>
<p>OSGi中类加载时查找规则如下：</p>
<ul>
<li>以<code>java.*</code>开头的类，委派给父类加载器加载</li>
<li>否则，委派列表(Bundle需要其他加载器加载的类)名单内的类，委派给父类加载器加载</li>
<li>否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载</li>
<li>否则，查找是否在自己的<strong>Fragment Bundle</strong>中，若是，则委派给<strong>Fragment Bundle</strong>的类加载器加载</li>
<li>否则，查找<strong>Dynamic Import</strong>列表的Bundle，委派给对应的Bundle类加载加载</li>
<li>否则，类查找失败</li>
</ul>
<p>OSGi里，加载器之间的关系不再是双亲委派模型的树形结构，而是一种更为复杂的、运行时才能确定的网状结构。</p>
<h5 id="3-字节码生成技术与动态代理的实现"><a href="#3-字节码生成技术与动态代理的实现" class="headerlink" title="3. 字节码生成技术与动态代理的实现"></a>3. 字节码生成技术与动态代理的实现</h5><p>  字节码生成技术有很多，例如<code>Javassist</code>、<code>CGLib</code>、<code>ASM</code>等等，JDK的<code>javac</code>是字节码生成技术的“老祖宗”，且是第一个由Java程序写成的程序，代码<code>langtools/src/share/classes/com/sun/tools/javac</code>目录中。其他使用字节码生成的技术如Web服务器中的JSP编译器，编译时植入的AOP框架等等。</p>
<p>动态，是针对使用Java代码实际编写了代理类的“静态”代理而言的，其优势不仅仅是省去了编写代理类，而是实现了可以在原始类和接口未知的时候，确定代理类的代理行为。以下以JDK动态代码说明字节码生成技术：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.object = object;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(object, objects);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中唯一黑匣子是<code>Proxy.newProxyInstance()</code>方法，其返回一个<code>IHello</code>接口，且代理了<code>new Hello</code>实例行为对象，其内部进行了验证、优化、缓存、同步、生成字节码、显示类加载等操作，其最后调用了<code>sun.misc.ProxyGenerator.generateProxyClass()</code>方法完成生成字节码的动作。main方法中加入<code>System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code>磁盘中会生成一个<code>$Proxy0.class</code>的代理类Class文件，反编译后代码（省略<code>hashCode</code>、<code>toString</code>、<code>equalsl</code>方法）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// super.h即父类中的InvocationHandler实例变量</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.effiu.essay.jvm.vm.DynamicProxyTest$IHello&quot;</span>).getMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内部很简单，为传入<code>IHello</code>接口的每个方法(包括<code>equals</code>、<code>hashCode</code>、<code>toString</code>方法)都生成了对应的实现，并且统一调用了<code>InvocationHandler</code>对象的<code>invoke()</code>方法。</p>
<h5 id="4-手动实现远程执行功能-page-289"><a href="#4-手动实现远程执行功能-page-289" class="headerlink" title="4. 手动实现远程执行功能(page 289)"></a>4. 手动实现远程执行功能(page 289)</h5><p>利用类加载及虚拟机执行子系统的知识去实现服务端执行临时代码的功能。</p>
<h6 id="1-目标"><a href="#1-目标" class="headerlink" title="1. 目标"></a>1. 目标</h6><p>要实现“在服务端执行临时代码”的目标有以下要求:</p>
<ul>
<li>不依赖JDK，在大部分JDK中都可以使用</li>
<li>不改变原有服务端程序的部署，不依赖三方类库</li>
<li>不侵入原有程序，不需要改变原有代码，也不会对原有程序的运行带来任何影响</li>
<li>“临时代码”支持Java语言</li>
<li>“临时代码”具备足够的自由度，不需要依赖特定的类或特定的接口(不可以依赖原有服务端没有的类库，可以依赖服务端使用的类库)</li>
<li>“临时代码”的执行结果能返回到客户端，执行结果也可以包括程序中输出的信息以及抛出的异常信息等。</li>
</ul>
<h6 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h6><p>要实现程序，有以下几个问题：</p>
<ul>
<li>如何编译提交的服务器的Java代码？<ul>
<li>使用三方依赖编译Java文件，会引入额外的依赖</li>
<li>直接在客户端编译完成，把字节码传到服务端</li>
</ul>
</li>
<li>如何执行编译之后的Java代码？<ul>
<li>通过类加载器加载这个类生成一个Class对象，然后通过反射调用一下某个方法。然后要考虑类的反复修改、提交、执行。提交的类要支持访问服务器的其他类库，临时代码还支持Java类在执行完后的回收和卸载</li>
</ul>
</li>
<li>如何收集Java代码的执行结果？<ul>
<li>把程序中的标准输出和错误输出打印的信息收集起来(<code>System.out/err</code>)，但是不能影响服务器端整个虚拟机进程全局共享的资源，所以不能直接用<code>System.setOut()</code>和<code>System.setErr()</code>重定向流到自定义的<code>PrintStream</code>对象上，所以我们要直接在执行的类中把<code>System.out</code>的符号引用替换为我们准备的<code>PrintStream</code>的符号引用</li>
</ul>
</li>
</ul>
<p>代码见：<a href=''>远程执行</a></p>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><p>Class文件格式、类加载及虚拟机执行引擎都是虚拟机中不可缺少的组成部分。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <url>/blog/2019/07/28/jvm/8_vm_bytecode_execution_engine/</url>
    <content><![CDATA[<p>分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码，以及执行代码时涉及的内存结构。</p>
<a id="more"></a>

<h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>执行引擎是Java虚拟机最核心的组成部分之一。虚拟机与物理机的区别：</p>
<ul>
<li>物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的。</li>
<li>虚拟机的执行引擎则是由自己实现的，因此可以自己自行制定指令集与执行引擎的结构体系，并且能够执行不被硬件直接支持的指令集格式</li>
</ul>
<p>Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，在不同的虚拟机实现里面，执行引擎在执行Java代码时会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。从外观看，所有执行引擎都是一直的：输入字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p>
<h5 id="2-运行时栈帧结构"><a href="#2-运行时栈帧结构" class="headerlink" title="2. 运行时栈帧结构"></a>2. 运行时栈帧结构</h5><p>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。<font color='red'>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息</font>。每个方法从调用开始至执行完成的过程，都是一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p>在编译程序代码时，栈帧中需要的空间大小已经确定且写入到<code>Code</code>属性中了，一个栈帧需要分配的内存，不会受到程序运行期变量数据的影响，仅仅取决于具体的虚拟机实现。</p>
<p>在一个线程中方法的调用链可能很长，很多方法可能同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，即当前栈帧(Current Stack Frame)，与其关联的方法称为当前方法(Current Method)。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，其结构模型如下：</p>
<p><img src="https://images.effiu.cn/blog/jvm/18.png" alt="栈帧模型"></p>
<blockquote>
<p>接下来详解栈帧中的局部变量表、操作数栈、动态连接、方法的返回地址等各个部分的作用和数据结构。</p>
</blockquote>
<h6 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h6><p>局部变量表(Local Variable Table)是一组变量值的存储空间，用于存放方法参数和犯法内部定义的局部变量。在Class类文件中方法的<code>Code</code>属性的<code>max_locals</code>数据项确定了方法所需要分配的局部变量表的最大容量。</p>
<p>局部变量表以变量槽(Variable Slot)为最小单位。虚拟机规定每个Slot都应该能存放<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>reference</code>、<code>returnAddress</code>类型的数据，但允许Slot随着处理器、操作系统的不同而发生变化。</p>
<p>上述8种数据类型中，因为一个Slot最少存储32的数据类型，前6种长度为32位，不需要解释。<code>reference</code>类型表示一个对象实例的引用，必须保证以下两点，否则无法实现Java语言规范中定义的语法约束。<code>returnAddress</code>很少使用。</p>
<ul>
<li>从此引用中直接或间接地查找到对象在Java堆中数据存放的起始地址索引</li>
<li>此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息</li>
</ul>
<p><a href="6_class_structure#max_locals">Slot</a>。针对64位长度的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。</p>
<p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表结束。针对64位数据类型的变量则会说明使用n和n+1两个Slot(引用中可以查找到对象所属数据类型)。</p>
<p>方法执行时，虚拟机是使用局部变量表完成参数值到参数变量表的传递过程的。例如，对于实例方法(非<code>static</code>方法)局部变量表中的第0个Slot用于传递方法所属对象实例的引用(<code>this</code>关键字)，从1开始的其他局部变量Slot是参数列表，然后在根据方法体内部定义的变量顺序和作用域分配其余Slot。</p>
<p>Slot是可以重用的。Slot是否可重用关键是垃圾回收，其关键是Slot是否还存有关于对象的引用(page 241)。</p>
<p>局部变量表没有准备阶段，不会对局部变量进行二次赋值，局部变量定义后但没有赋值是不能使用的。</p>
<h6 id="2-操作数栈"><a href="#2-操作数栈" class="headerlink" title="2. 操作数栈"></a>2. 操作数栈</h6><p>操作数栈(Operand Stack)也被称为操作栈，是一个后入先出(Last In First Out, LIFO)的栈，其最大深度也在编译时写入到了<code>Code</code>属性的<code>max_locals</code>中。</p>
<p>方法执行过程中会有各种字节码指令往操作数栈中写入和提取内容，即出栈/入栈操作。操作数栈中的元素的数据类型必须和字节码指令的序列严格匹配，在编译程序代码时编译器会保证这一点，类校验阶段的数据流分析阶段还会再次验证。</p>
<p>Java虚拟机的解析执行引擎称为“基于栈的执行引擎”，其中栈指“操作数栈”。</p>
<h6 id="3-动态连接"><a href="#3-动态连接" class="headerlink" title="3. 动态连接"></a>3. 动态连接</h6><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。Class文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数</p>
<ul>
<li>在类加载器阶段或者第一次使用时转化为直接引用，称为静态解析</li>
<li>每一次运行期间转化为直接引用，称为动态连接</li>
</ul>
<h6 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4. 方法返回地址"></a>4. 方法返回地址</h6><p>方法开始执行后，有两种方式退出方法：</p>
<ul>
<li>执行遇到任意方法返回的字节码指令(<code>return</code>关键字)，这时可能会有返回值传递给上层方法调用者。</li>
<li>方法执行过程中遇到异常，且该异常没有在方法内得到处理（本地方法异常表中没有匹配到异常处理器），此时不会产生任何返回值。</li>
</ul>
<p>无论哪种退出方式，都需要回到方法被调用的位置，程序才会继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。正常退出时，调用者的PC计数器的值可以作为返回地址。异常退出时，返回地址可以通过异常处理器表来确定，但是栈帧中不会保存这些信息，所以方法异常退出的过程，就是把当前栈帧出栈，可能执行的操作有：</p>
<ul>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>把返回值压入调用者栈帧的操作数栈中</li>
<li>调整PC计数器的值以指向方法调用这两后面的一条指令</li>
</ul>
<h6 id="5-附加信息"><a href="#5-附加信息" class="headerlink" title="5. 附加信息"></a>5. 附加信息</h6><p>虚拟机允许增加一些规范中没有的信息到栈帧中。</p>
<h5 id="3-方法调用"><a href="#3-方法调用" class="headerlink" title="3. 方法调用"></a>3. 方法调用</h5><p>方法发调用不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(调用的一个方法)，不涉及方法内部的具体运行过程。程序运行过程时，方法调用是最普遍、最频繁的操作，但是<strong>Class</strong>类文件的编译过程不包含传统编译中的连接步骤，<font color='red'>一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址(即，直接引用)</font>。这给Java带来了强大的动态扩展能力，但也使Java方法调用过程变得相对复杂，需要<font color='red'>在类加载期间，甚至到运行期间才能确定目标方法的直接引用</font>。</p>
<h6 id="1-解析"><a href="#1-解析" class="headerlink" title="1. 解析"></a>1. 解析</h6><p>所有方法调用中的目标在<strong>Class</strong>文件里面都是一个常量池的符号引用，在类加载解析阶段，会将其中一部分符号引用转化为直接引用，其前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，即调用目标方法在程序代码写好、编译器进行编译时就已经确认下来了，这类方法的调用称为<strong>解析</strong>。</p>
<p>“<font color='red'>编译期可知、运行期不变</font>”这类方法包括静态方法和私有方法。这两种方法特点是不可能通过继承或者别的方式重写为其他版本，因此他们适合在类加载阶段进行解析</p>
<ul>
<li>静态方法与类型关联</li>
<li>私有方法在外部不可被访问</li>
</ul>
<p>Java虚拟机提供了5条方法调用字节码指令<a name='bytecodeInstruction'></a>：</p>
<ul>
<li><code>invokestatic</code>:调用静态方法</li>
<li><code>invokespecial</code>: 调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法</li>
<li><code>invokevirtual</code>: 调用所有虚方法</li>
<li><code>invokeinterface</code>: 调用接口方法，会在运行时再确定一个实现此接口的对象</li>
<li><code>invokedynamic</code>: 运行时动态解析出调用点限定符所引用的方法，然后执行。</li>
</ul>
<p>前4条指令是固化在Java虚拟机内部对的，而<code>invokedynamic</code>指令的分派逻辑是由用户所设定的引导方法决定的</p>
<p>只要能被<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法都可以在解析阶段中确定唯一调用版本，包括静态方法、私有方法、实例构造器、父类方法4类，在加载阶段就会把符号引用解析为该方法的<strong>直接引用</strong>，这些方法称为<strong>非虚方法</strong>。</p>
<blockquote>
<p>举例如下:  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticResolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticResolution.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>javap -verbose StaticResolution.class</code>部分结果输出如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: invokestatic  #5                  // Method sayHello:()V</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上述<strong>非虚方法</strong>之外，还有被<code>final</code>修饰的方法，其是通过<code>invokevirtual</code>指令调用，但是<code>final</code>方法无法被覆盖，所以没有其他版本，也不需要对方法接收者进行多态选择(多态的选择肯定是唯一的)，所以<code>final</code>修饰的方法是非虚方法。</p>
<p><font color='red'>解析调用</font>一定是一个静态过程，在编译器就可以确定，在类装载阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期在去完成。</p>
<p><font color='red'>分派调用</font>可能是静态也可能是动态的，根据分派依据的宗量数可分为单分派和多分派，所以分派调用有如下四种:</p>
<ul>
<li>静态单分派</li>
<li>静态多分派</li>
<li>动态单分派</li>
<li>动态多分派</li>
</ul>
<h6 id="2-分派"><a href="#2-分派" class="headerlink" title="2. 分派"></a>2. 分派</h6><ol>
<li>静态分派</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello guys&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello guys&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello guys&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sd.sayHello(man);</span><br><span class="line">        sd.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello guys</span><br><span class="line">hello guys</span><br></pre></td></tr></table></figure>

<p>上述代码中，<font color='red'><code>Human</code>称为变量的静态来下(Static Type)，<code>Man</code>则称为变量的实际类型</font>，静态类型与实际类型在程序中都可以发生一些变化，且最终的静态类型是在编译期可知；实际类型变化的结果在运行期才可以确定，编译器在编译程序的时候并不确定一个对象的实际类型。</p>
<p>上述代码中，两次<code>sayHello()</code>方法调用，<strong style='color:red'>在方法接收者已经确定是对象<code>sr</code>的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型</strong>。虚拟机(编译器)在重载时是通过参数的静态类型而不是实际类型作为判定依据的，静态类型在编译期可知，因为在编译阶段，编译器会根据参数的静态类型决定使用哪个重在版本，并把方法的符号引用写到<code>main()</code>方法里两个<code>invokevirtual</code>指令的参数中。</p>
<p><font color='red'>所有依赖静态类型来定位方法执行版本的分配动作称为静态分派</font>，其典型是方法重载。静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。编译器虽然可以确定出方法重载的版本，但很多情况下这个重载版本并不是“唯一”的，而是只能确定一个“更加适合”的版本，其主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Character&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Serializable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码输出<code>hello char</code>，因为<code>a</code>是<code>char</code>类型的数据。</li>
<li>注释掉<code>sayHello(char)</code>，代码输出<code>hello int</code>，发生了一次自动类型转换，<code>a</code>不仅仅代表字符串，还可以代表数字<code>97</code></li>
<li>注释掉<code>sayHello(int)</code>，代码输出<code>hello long</code>，发生了两次自动类型转换，数字<code>97</code>继续转换为<code>97L</code></li>
<li>byte-&gt; short -&gt; char -&gt; int -&gt; long -&gt; float -&gt; double顺序转型进行匹配(类型转换是单向的，逆向会精度丢失)。</li>
<li>注释掉<code>sayHello(long)</code>，代码输出<code>hello Character</code>，发生了一次自动装箱</li>
<li>注释掉<code>sayHello(Character)</code>， 代码输出<code>hello Serialiable</code>，因为装箱类实现了<code>Serialble</code>接口，所以又发生了一次自动转型，当出现装箱类的多个接口时，此时会提示<strong>拒绝编译</strong>。</li>
<li>继续注释掉<code>sayHello(Serialbe)</code>，代码输出<code>hello Object</code>，自动装箱后转型为父类</li>
<li>注释掉<code>sayHello(Object)</code>，代码输出<code>hello arg ...</code>，可变长参数的重载优先级最低</li>
</ul>
<ol start="2">
<li>动态分派</li>
</ol>
<p>动态分配与重写(Overrite)有很密切的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其运行结果显而易见：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>

<p><font color='red'>虚拟机是如何判断调用方法的呢</font>？显然不是根据静态类型决定的，因为静态类型相同两个变量调用<code>sayHello()</code>后执行了不同的行为，其原因是两个变量的实际类型不同。<font color='red'>那么Java虚拟机是如何根据实际类型来分派执行版本的呢</font>？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class com/effiu/essay/jvm/vm/DynamicDispatcher$Man</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method com/effiu/essay/jvm/vm/DynamicDispatcher$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: new           #4                  // class com/effiu/essay/jvm/vm/DynamicDispatcher$Woman</span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        12: invokespecial #5                  // Method com/effiu/essay/jvm/vm/DynamicDispatcher$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        17: invokevirtual #6                  // Method com/effiu/essay/jvm/vm/DynamicDispatcher$Human.sayHello:()V</span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        21: invokevirtual #6                  // Method com/effiu/essay/jvm/vm/DynamicDispatcher$Human.sayHello:()V</span><br><span class="line">        24: new           #4                  // class com/effiu/essay/jvm/vm/DynamicDispatcher$Woman</span><br><span class="line">        <span class="number">27</span>: dup</span><br><span class="line">        28: invokespecial #5                  // Method com/effiu/essay/jvm/vm/DynamicDispatcher$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">31</span>: astore_1</span><br><span class="line">        <span class="number">32</span>: aload_1</span><br><span class="line">        33: invokevirtual #6                  // Method com/effiu/essay/jvm/vm/DynamicDispatcher$Human.sayHello:()V</span><br><span class="line">        <span class="number">36</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>上述字节码是<code>javap -verbose DynamicDispatcher.class</code>的输出结果。</p>
<p>0~15行是<code>Human man = new Man();</code>和<code>Human woman = new Woman();</code>的编译结果，是建立<code>man</code>和<code>woman</code>的内存空间，调用<code>Man</code>和<code>Woman</code>的实例构造器，其放在局部变量表的前两个Slot中。</p>
<p>16、20是把<code>man</code>和<code>woman</code>两个引用压到栈顶，是将要执行<code>sayHello()</code>方法的所有者，称为“接收者”。</p>
<p>17、21是方法调用指令，会发现其指令与参数是完全一样的(如下)，但是其最终执行的目标方法并不相同。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">aload_1</span><br><span class="line">invokevirtual #6                  // Method com/effiu/essay/jvm/vm/DynamicDispatcher$Human.sayHello:()V</span><br></pre></td></tr></table></figure>

<p>其原因是<code>invokevirtual</code>指令的多态查找过程<a herf='searchDynamic'></a>，如下：</p>
<ul>
<li>找到操作栈顶的第一个元素指向的对象是实际类型，记作C</li>
<li>如果在C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回这个方法的引用，查找过程结束；不通过返回<code>java.lang.IllegalAccessError</code>异常</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行上一步的搜索和验证过程</li>
<li>若始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常</li>
</ul>
<p><code>invokevirtual</code>指令指定的第一步就是确定接收者的实际类型，所以两次调用<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，以上过程就是<font color='red'>Java重写的本质</font>。在运行期根据实际类型确定方法执行版本的分派过程称为动态分配。</p>
<ol start="3">
<li>单分派和多分派</li>
</ol>
<p><font color='red'>方法的接收者与方法的参数统称为方法的宗量</font>。分派分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择；多分派是根据多于一个宗量对目标方法进行选择。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其代码运行结果显而易见，<font color='red'>编译阶段编译器的选择过程，即静态分派的过程</font>。选择目标方法的依据：</p>
<ul>
<li>静态类型是<code>Father</code>还是<code>Son</code></li>
<li>方法参数是<code>QQ</code>还是<code>_360</code></li>
</ul>
<p>上述代码的选择结果产生了两条<code>invokevirtual</code>指令，其指令参数分别为常量池中指向<code>Father.hardChoice(_360)</code>及<code>Father.hardChoice(QQ)</code>方法的符号引用，其是根据两个宗量选择，所以是多分派类型。</p>
<p><font color='red'>虚拟机运行阶段的选择，即动态分派的过程</font>。在执行对应的<code>invokevirtual</code>指令时（以<code>son.hardChoice(new QQ())</code>为例），由于编译器的静态分派已经制定了方法签名<code>hardChoice(QQ)</code>，所以虚拟机不在关心参数类型，因为参数的静态类型、实际类型都对方法的选择不构成任何影响，虚拟机运行阶段影响方法选择的是此方法的接受者的实际类型是<code>Father</code>还是<code>Son</code>，这个过程只有一个宗量作为选择依据，所以其为动态单分派。</p>
<ol start="4">
<li>虚拟机动态分派的过程</li>
</ol>
<p>动态分派是非常频繁的动作，且动态分派的<a href='#searchDynamic'>方法版本选择过程</a>需要运行时在类的方法元数据中搜索合适的目标方法, 因此在实际实现中基于性能的考虑，大部分实现都不会真正进行频繁的搜索。其常用“稳定优化”手段是：为类在方法区中简历一个虚方法表(<strong>Virtual Method Table, vtable</strong>)，在<code>invokeinterface</code>执行时也会用到接口方法表(<strong>Interface Method Table, itable</strong>)，使用虚方法表索引来代替元数据查找以提高性能。</p>
<p><img src="https://images.effiu.cn/blog/jvm/19.png" alt="方法表结构"></p>
<p>方法表中存放着各个方法的实际入口地址。若某个方法在子类中没有重写，则子类的虚方法表里的地址入口和父类相同方法 的地址入口是一致的，都指向了父类的实现入口。若子类重写了该方法，子类虚方法表中的地址会被替换为指向子类实现版本的入口地址。<code>Son</code>重写了<code>Father</code>的两个<code>hardChoic()</code>方法，所以<code>Son</code>的虚方法表没有指向<code>Father</code>的地址。</p>
<p>具有相同签名的方法，在父类、子类的虚方法表中都应该具有一样的索引序号，便于类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需要的入口地址。</p>
<p>方法表在类加载阶段进行初始化，当类的变量初始化完成后，虚拟机会把该类的方法表也初始化完成。</p>
<p>虚拟机在条件允许的情况下，还会使用更激进的“稳点优化”手段，例如内敛缓存(Inline Cache)、基于“类型继承关系分析”(Class Hierarchy Analysis, CHA)技术的守护内联。</p>
<h6 id="3-动态类型语言支持"><a href="#3-动态类型语言支持" class="headerlink" title="3. 动态类型语言支持"></a>3. 动态类型语言支持</h6><p>Java虚拟机字节码指令集的数量从Sun的第一款Java虚拟机到JDK7问世之前，没有发生任何变化。JDK7发布，字节码指令集新增了<code>invokedynamic</code>指令。其是JDK7实现“动态类型语言”(Dynamiclly Typed Language)支持而进行的改进之一，也是JDK8可以顺利实现Lambda表达式做技术准备。</p>
<ol>
<li>动态类型语言</li>
</ol>
<p><strong style='color:red'>动态类型语言的关键特征是它的类型检查主体过程是在运行期而不是编译器</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>][<span class="number">0</span>][-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述Java代码可以正常编译，但运行时报<code>NegativeArraySizeException</code>异常。运行期异常就是只要代码不运行到这一行就不会有问题。与运行期异常对应的是连接时异常，例如<code>NoClassDefFoundError</code>属于连接时异常，即使异常代码处于一条无法执行的分支路径上，类加载时(Java的连接过程不在编译阶段，而在类加载阶段)也会抛出异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [<span class="number">1</span>][<span class="number">0</span>][<span class="number">-1</span>];	<span class="comment">//GCC拒绝编译，报&quot;size of array is negative&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj.println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>假设这行代码是在Java语言中，变量<code>obj</code>的静态类型是<code>java.io.PrintStream</code>，那变量<code>obj</code>的实际类型就必须是<code>PrintStream</code>的子类才是合法的。否则即使<code>obj</code>确实存在<code>println(String)</code>方法，但与<code>PrintStream</code>无继承关系，代码依然报错——因为类型检查不合法。</p>
<p>Java和C的差别原因是Java语言在编译期已经将<code>println()</code>方法完整的符号引用生成出来(上述符号引用是<code>CONSTANT_InterfaceMethodref_info</code>常量)，作为方法调用指令的参数存储到Class文件中。如下：</p>
<p><code>invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V</code></p>
<p>符号引用包含了此方法定义在哪个具体类型中、方法名、参数顺序、参数类型和方法返回值等信息。通过该引用虚拟机可以直接翻译出这个方法的直接引用。而动态语言中(例如,ECMAScript)，变量<code>obj</code>本身是没有类型的，变量<code>obj</code>的值才具有类型，编译时最多只能确定方法名、参数、返回值等信息，不会去确定方法所在的具体类型。“变量无类型而变量值才有类型”是动态语言的重要特征。</p>
<p>静态类型语言在编译期确定类型，可以提供严谨的类型检查，便于发现与类型相关的问题，利于稳定性及3代码达到更大规模；动态语言在运行期确定类型，为开发者提供更大的灵活性。</p>
<ol start="2">
<li>JDK7与动态类型</li>
</ol>
<p>Java虚拟机层面对动态类型语言的支持有所欠缺，主要表现在方法调用方面。JDK7以前只有<a href='#bytecodeInstruction'>4条调用指令</a>，其第一个参数都是被调用方法的符号引用(<code>CONSTANT_Methodref_info</code>或者<code>CONSTANT_InterfaceMethodref_info</code>)。</p>
<ol start="3">
<li>java.lang.invoke包</li>
</ol>
<p>JDK7实现了<strong>JSR-292</strong>，新加入的<code>java.lang.invoke</code>包就是<strong>JSR-292</strong>的一部分，其主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，即<code>MethodHandle</code>。</p>
<p>Java语言不能把一个函数作为参数进行传递。当拥有<code>Method Hanle</code>后，Java也可以用于类似于函数指针或者委托的方法别名的工具了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType表示方法类型，包含了方法的返回值(第一个参数)，和具体参数(第二个参数)</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="comment">// lookup()作用是在制定类中查找符合给定的方法名称，方法类型，且符合调用权限的方法句柄</span></span><br><span class="line">        <span class="comment">// 此处调用的是虚方法，按照Java语言的规则，方法的第一个参数是隐式的，代表该方法的接收者，即this指向的对象，</span></span><br><span class="line">        <span class="comment">// 默认是放在参数列表中进行传递的，而现在提供了bindTo方法完成这件事情</span></span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup().findVirtual(reveiver.getClass(), <span class="string">&quot;println&quot;</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() %<span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line"></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">&quot;icyfenix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，演示了<code>MethodHandle</code>基本用途，无论Object是哪种类型，都可以正确地调用到<code>println</code>方法。方法<code>getPrintMH</code>模拟的是<code>invokevirtual</code>指令的执行过程，只不过其分配逻辑没有固化在Class文件的字节码上，而是通过一个具体方法实现的。其返回值<code>MethodHandle</code>可以视为最终调用方法的一个引用。</p>
<p><code>MethodHandle</code>与反射<code>reflect</code>的区别：</p>
<ul>
<li><code>Reflection</code>和<code>MethodHandle</code>机制都是模拟方法调用，但<code>Reflection</code>是模拟Java代码层面的调用，而<code>MethodHandle</code>是模拟字节码层次的方法调用。<code>MethodHandles.lookup()</code>的3个方法<code>findStatic()</code>、<code>findVirtual()</code>、<code>findSpecial()</code>是为了模拟<code>invokestatic</code>、<code>invokevirtual</code>、<code>invokeinterface</code>和<code>invokespecial</code>指令的执行权限校验行为，以上这些在<code>Reflection</code>中不需要关心。</li>
<li><code>Reflection</code>中的<code>java.lang.reflect.Method</code>对象远比<code>MethodHandle</code>机制中的<code>java.lang.invoke.MethodHandle</code>对象包含的信息多，其是Java的全面映像，包含方法签名、描述符以及方法属性表中各种书写的Java端表示方式，还包含执行权限等的运行期信息。而<code>MethodHandle</code>仅仅包含与执行该方法相关的信息。即<code>Reflection</code>是重量级，<code>MethodHandle</code>是轻量级。</li>
<li>由于<code>MethodHandle</code>是对字节码的方法指令调用的模拟，所以理论上虚拟机在这方面做的各种优化(如方法内联)，在<code>MethodHandle</code>上也应当可以采用类似思路去支持，<code>Reflection</code>则不可以。</li>
<li><code>Reflection</code>的设计是在Java的角度的，只为了Java语言服务；<code>MethodHandle</code>则设计成可服务于所有Java虚拟机之上的语言，也包括Java语言。</li>
</ul>
<ol start="4">
<li>invokedynamic指令</li>
</ol>
<ul>
<li><input disabled="" type="checkbox"> <strong style='color:red'>未理解</strong></li>
</ul>
<p><code>invokedynamic</code>指令与<code>MethodHandle</code>机制作用是一致的，都是为了解决原有的4条<code>invoke*</code>指令方法分配规则固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体的用户代码中，让用户有更高的自由度。只是一个采用上层Java代码实现；一个用字节码和Class中的其他属性、常量完成。</p>
<p>每一处含有<code>invokedynamic</code>指令的位置都称作“动态调用点”(Dynamic Call Site)，其第一个参数不再是代表方法符号引用的<code>CONSTANT_Methodref_info</code>常量，而是变为<code>CONSTANT_InvokeDynamic_info</code>常量，从这个新常量中可以得到3个信息：引导方法（Bootstrap Method, 存放在新增的BootstrapMethods属性中）、方法类型(MethodType)和名称。引导方法是固有参数，且返回值是<code>java.lang.invoke.CallSite</code>对象，代表真正要执行的目标方法调用。虚拟机可以根据<code>CONTANT_InvokeDynamic_info</code>常量中的信息找到并执行引导方法，得到一个<code>CallSite</code>对象，调用要执行的目标方法。具体见《深入理解Java虚拟机》p264。</p>
<ol start="5">
<li><p>掌控方法分派规则</p>
<p>具体见《深入理解Java虚拟机》p265。</p>
</li>
</ol>
<h5 id="4-基于栈的字节码解释执行引"><a href="#4-基于栈的字节码解释执行引" class="headerlink" title="4. 基于栈的字节码解释执行引"></a>4. 基于栈的字节码解释执行引</h5><p>很多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。</p>
<h6 id="1-解释执行"><a href="#1-解释执行" class="headerlink" title="1. 解释执行"></a>1. 解释执行</h6><p>只有确定了某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较准确。</p>
<p><img src="https://images.effiu.cn/blog/jvm/20.png" alt="编译过程"></p>
<p>绝大部分程序代码到物理机的目标代码或虚拟机能执行的指令集之前，都要经过上图的各个步骤。基于物理机、Java虚拟机、或者非Java的其他高级语言虚拟机的语言，大多都会遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树。</p>
<p>Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，在遍历语法树生成现象的字节码指令流的过程。上述部分动作是在java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p>
<h6 id="2-基于栈的指令集与基于寄存器的指令集"><a href="#2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="2. 基于栈的指令集与基于寄存器的指令集"></a>2. 基于栈的指令集与基于寄存器的指令集</h6><p>Java编译器输出的指令流，基本上是基于栈的指令集架构(Instruction Set Architecture, ISA)(部分字节码到指令会带有参数)，指令流中的指令大部分都是领地址指令，它们依赖操作数栈进行工作。另外一种指令集架构是基于寄存器的指令集。</p>
<p>基于栈与基于寄存器的指令集的不同之处(以计算”1+1”的结果为例)：</p>
<ul>
<li><p>基于栈的指令集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">iconst_1	<span class="comment">// 连续把两个常量1压入栈</span></span><br><span class="line">iadd		<span class="comment">// 把栈顶的两个值出栈、相加，然后把结果入栈</span></span><br><span class="line">istore_0	<span class="comment">// 把栈顶的值放到局部变量表的Slot中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于寄存器的指令集：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">add eax, 1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>基于栈的指令集特点是可移植的，而寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地收到硬件的约束。当使用栈架构的指令集，用户程序不会直接使用这些寄存器，就可以由虚拟机实现自行决定把一些访问最频繁的数据(程序计数器、栈顶缓存等)放到寄存器中以获取尽量好的性能。基于栈的指令集架构，代码相对更加紧凑（字节码中1个字节对应1条指令，多地址指令集中还需要存放参数）、编译器实现更加简单(不需要考虑空间分配问题，所需空间都在栈上操作)。</p>
<p>栈架构主要缺点是执行速度相对稍慢，出入栈本身会产生相当多的指令数量，且栈操作是在内存中，频繁的栈访问意味着频繁的内存访问，内存是执行速度的瓶颈。</p>
<h6 id="3-基于栈的解释器执行过程"><a href="#3-基于栈的解释器执行过程" class="headerlink" title="3. 基于栈的解释器执行过程"></a>3. 基于栈的解释器执行过程</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字节码指令如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int calc();</span><br><span class="line">  Code:</span><br><span class="line">	Stack&#x3D;2, Locals&#x3D;4, Args_size&#x3D;1</span><br><span class="line">    0:	bipush	100</span><br><span class="line">    2:  istore_1</span><br><span class="line">    3:	bipush	200</span><br><span class="line">    6:  istore_1</span><br><span class="line">    7:	bipush	300</span><br><span class="line">    10:  istore_1</span><br><span class="line">    11: iload_1</span><br><span class="line">    12: iload_2</span><br><span class="line">    13: iadd</span><br><span class="line">    14: iload_3</span><br><span class="line">    15: imul</span><br><span class="line">    16:	ireturn</span><br></pre></td></tr></table></figure>

<p>如上所述，需要深度为2的操作数栈和4个Slot局部变量空间，其执行过程如下：</p>
<p><img src="https://images.effiu.cn/blog/jvm/21.png"></p>
<p><img src="https://images.effiu.cn/blog/jvm/22.png"></p>
<p><img src="https://images.effiu.cn/blog/jvm/23.png"></p>
<p><img src="https://images.effiu.cn/blog/jvm/24.png"></p>
<p><img src="https://images.effiu.cn/blog/jvm/25.png"></p>
<p><img src="https://images.effiu.cn/blog/jvm/26.png"></p>
<p><img src="https://images.effiu.cn/blog/jvm/27.png"></p>
<p>上述执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述。</p>
<p>从中我们可以看出栈结构指令集的一般运作过程，整个运算过程的中间变量都以操作数站的出栈、入栈为信息交换途径。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>连接的原理</title>
    <url>/blog/2019/07/26/mysql/9_join_principle/</url>
    <content><![CDATA[<p>数据库中的一个重要概念是<code>Join</code>，即连接。那么连接的原理是什么？各个表中的记录是如何连接起来的？</p>
<a id="more"></a>

<h5 id="1-连接简介"><a href="#1-连接简介" class="headerlink" title="1. 连接简介"></a>1. 连接简介</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t1 (m1 int, n1 char(1));</span><br><span class="line">CREATE TABLE t2 (m2 int, n2 char(1));</span><br><span class="line">INSERT INTO t1 VALUES(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;);</span><br><span class="line">INSERT INTO t2 VALUES(2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;d&#39;);</span><br></pre></td></tr></table></figure>

<p>如上，创建两个表<code>t1</code>、<code>t2</code>，并插入数据。</p>
<h6 id="1-连接的本质"><a href="#1-连接的本质" class="headerlink" title="1. 连接的本质"></a>1. 连接的本质</h6><p><strong>连接</strong>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1, t2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    1 | a    |    2 | b    |</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    2 | b    |</span><br><span class="line">|    1 | a    |    3 | c    |</span><br><span class="line">|    2 | b    |    3 | c    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">|    1 | a    |    4 | d    |</span><br><span class="line">|    2 | b    |    4 | d    |</span><br><span class="line">|    3 | c    |    4 | d    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/mysql/24.png" alt="连接过程"></p>
<p>上述过程看起来就是把<code>t1</code>表和<code>t2</code>表的记录连接起来组成更大的记录，所以这个过程称为连接查询。查询的结果集中包含一个表的每一条记录与另一个表的每一天记录相互匹配的组合，即两个结果集的<code>笛卡尔积</code>。</p>
<h6 id="2-连接过程"><a href="#2-连接过程" class="headerlink" title="2. 连接过程"></a>2. 连接过程</h6><p><code>MySQL</code>查询中可以连接任意数量张表，但是若没有限制条件，多张表产生的笛卡尔积会非常巨大，所以在连接的时候需要过滤条件，过滤条件分为两种：</p>
<ul>
<li>涉及单表的条件，<code>t1.m1 &gt; 1</code>、<code>t2.m2 &lt; 4</code>等等</li>
<li>涉及两表的条件，<code>t1.m1 = t2.m2</code></li>
</ul>
<p>接下来以下面SQL为例，说明连接过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 &#x3D; t2.m2 AND t2.n2 &lt; &#39;d&#39;;</span><br></pre></td></tr></table></figure>

<p>SQL中包含3个过滤条件：</p>
<ul>
<li><code>t1.m1 &gt; 1</code></li>
<li><code>t1.m1 = t2.m2</code></li>
<li><code>t2.n2 &lt; &#39;d&#39;</code></li>
</ul>
<p>其连接过程如下：</p>
<ol>
<li><p>第一个查询的表，称为<strong>驱动表</strong>。驱动表的选择方式是：<font color='red'>选择代价最小的那种访问方法取执行单表查询语句</font>(从<code>const</code>、<code>ref</code>、<code>ref_or_null</code>、<code>range</code>、<code>index</code>、<code>all</code>)。假设<code>t1</code>作为驱动表，那么首先查找<code>t1.m1 &gt; 1</code>的记录，此时表中的数据少，且无索引，所以访问方法为<code>all</code>。查询过程如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/25.png" alt="查询过程"></p>
</li>
<li><p>针对驱动表得到的结果集，分别到<code>t2</code>表中查找匹配的记录(符合过滤条件的记录)，<code>t2</code>被称为<strong>被驱动表</strong>。第一步中从驱动表得到两条记录，所以需要查询两次<code>t2</code>表，此时<code>t1.m1 = t2.m2</code>会发挥作用：</p>
<ul>
<li>当<code>t1.m1 = 2</code>时，过滤条件，<code>t1.m1 = t2.m2</code>相当于<code>t2.m2 = 2</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 2</code>、<code>t2.n2 &lt; &#39;d&#39;</code>这两个过滤条件，然后<code>t2</code>执行单表查询。</li>
<li>当<code>t1.m1 = 3</code>时，过滤条件，<code>t1.m1 = t2.m2</code>相当于<code>t2.m2 = 3</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 3</code>、<code>t2.n2 &lt; &#39;d&#39;</code>这两个过滤条件，然后<code>t2</code>执行单表查询。</li>
</ul>
<p>执行过程如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/26.png" alt="执行过程"></p>
<p>综上，两表连接共需要查询1次<code>t1</code>表、两次<code>t2</code>表。</p>
</li>
</ol>
<h6 id="3-内连接和外连接"><a href="#3-内连接和外连接" class="headerlink" title="3. 内连接和外连接"></a>3. 内连接和外连接</h6><ul>
<li>内连接，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到结果集中。</li>
<li>外连接，驱动表中的记录即使在被驱动表中没有匹配的记录，也会加入到结果集中<ul>
<li>左外连接，选取左侧表为驱动表</li>
<li>右外连接，选取右侧表为驱动表</li>
</ul>
</li>
</ul>
<p><strong>连接</strong>的过滤条件分为两种：</p>
<ul>
<li><code>Where</code>子句的过滤条件，凡是不符合<code>Where</code>子句中的过滤条件的记录都不会被加入到最后的结果集</li>
<li><code>ON</code>子句的过滤条件，对于驱动表来说，无法在被驱动表中找到匹配记录时仍会把记录加入到结果集中，对应的被驱动表的各个字段用<code>NULL</code>值填充。<code>ON</code>子句是用于外连接驱动表中的记录在被驱动表找不到记录时是否把该记录加入到结果集中判断的。当把<code>ON</code>子句放到内连接中时，<code>MySQL</code>会把其与<code>Where</code>条件一样对待。</li>
</ul>
<p>一般把涉及单表的过滤条件放到<code>Where</code>子句中，涉及两个表的过滤条件放到<code>ON</code>子句中,<code>ON</code>子句中的条件也称为<strong>连接条件</strong>。</p>
<ul>
<li><p>左外连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>内连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure>

<p>在<code>MySQL</code>中，以下几个SQL是等价的：</p>
<ul>
<li><code>SELECT * FROM t1 JOIN t2;</code></li>
<li><code>SELECT * FROM t1 INNER JOIN t2;</code></li>
<li><code>SELECT * FROM t1 CROSS JOIN t2;</code></li>
<li><code>SELECT * FROM t1, t2;</code></li>
</ul>
</li>
</ul>
<p>连接的本质是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户，无论哪个表为驱动表，其产生的笛卡尔积是一样的。所以对于内连接来说，驱动表与被驱动表是可以互换的，不会影响结果集。对于外连接来说，驱动表中的记录即使在被驱动表中找不到符号<code>ON</code>子句连接条件的记录，也会被加入到结果几种，所以驱动表与被驱动表不能互换。</p>
<h5 id="2-连接的原理"><a href="#2-连接的原理" class="headerlink" title="2. 连接的原理"></a>2. 连接的原理</h5><h6 id="1-嵌套循环连接-Nested-Loop-Join"><a href="#1-嵌套循环连接-Nested-Loop-Join" class="headerlink" title="1. 嵌套循环连接(Nested-Loop Join)"></a>1. 嵌套循环连接(Nested-Loop Join)</h6><p>对于两个表连接来说，驱动表只会被访问一遍，但被驱动表却需要被访问多次（依赖于对驱动表执行单表查询后的结果集中的记录条数）。</p>
<ul>
<li>选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询</li>
<li>对驱动表的查询结果集的每一条记录，都分别到被驱动表中查找匹配记录</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/27.png" alt="连接查询过程"></p>
<h6 id="2-使用索引加快连接速度"><a href="#2-使用索引加快连接速度" class="headerlink" title="2. 使用索引加快连接速度"></a>2. 使用索引加快连接速度</h6><p><code>嵌套循环连接</code>的<code>步骤2</code>中可能需要访问多次被驱动表，如果访问驱动表是全表扫描，效率会很低，所以可以利用索引加快速度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 &#x3D; t2.m2 AND t2.n2 &lt; &#39;d&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/blog/mysql/28.png" alt="查询过程"></p>
<p>查询驱动表<code>t1</code>后，结果集中有两条记录，<strong>循环嵌套连接</strong>算法需要对被驱动表查询2次：</p>
<ul>
<li><p><code>t1.m1 = 2</code>，去查询一遍<code>t2</code>表，对<code>t2</code>表的查询语句相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t2 WHERE t2.m2 &#x3D; 2 AND t2.n2 &lt; &#39;d&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当<code>t1.m1 = 3</code>时，再去查询一遍<code>t2</code>表，此时对<code>t2</code>表的查询语句相当于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t2 WHERE t2.m2 &#x3D; 3 AND t2.n2 &lt; &#39;d&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当执行完驱动表的查询条件后，对被驱动表查询SQL的搜索条件已经确定，所以我们可以对<code>t2</code>表做优化</p>
<ul>
<li>在<code>m2</code>列上建立索引，对<code>m2</code>列的条件是等值查找，若<code>m2</code>列是普通二级索引，那么是<code>ref</code>的访问方法，当使用<code>ref</code>查询方法对<code>t2</code>表执行后，再回表判断<code>t2.n2 &lt; d</code>这个条件是否成立。若<code>m2</code>列是<code>t2</code>的主键列或者唯一索引列，那么是<code>const</code>的访问方法，<code>MySQL</code>中把再连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的执行方式称为：<code>eq_ref</code>。</li>
<li>再<code>n2</code>列上建立索引，涉及到的条件是<code>t2.n2 &lt; &#39;d&#39;</code>，可能用到<code>range</code>的访问方法，假设使用<code>range</code>的访问方法对<code>t2</code>表的查询的话，需要回表之后再判断在<code>m2</code>列上的条件是否成立。</li>
<li>当两列都存在索引的话，那么就需要查询优化器选择执行成本低的方式去执行。</li>
</ul>
<p>连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，这些列都是某个索引的一部分，此时即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>range</code>这些访问方法对被驱动表查询，也可以使用索引扫描，即<code>index</code>访问方法来查询被驱动表，所以真实工作中最好不要使用<code>*</code>作为查询列表。</p>
<h6 id="3-基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#3-基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="3. 基于块的嵌套循环连接（Block Nested-Loop Join）"></a>3. 基于块的嵌套循环连接（Block Nested-Loop Join）</h6><p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。当数据量太大时，内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。而采用<code>嵌套循环连接</code>算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个<code>I/O</code>代价就非常大了，所以我们得想办法：尽量减少访问被驱动表的次数。</p>
<p>当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可不可以在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。<code>join buffer</code>就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个<code>join buffer</code>中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的<code>I/O</code>代价。使用<code>join buffer</code>的过程如下图所示：</p>
<p><img src="https://images.effiu.cn/blog/mysql/28.png" alt="查询过程"></p>
<p>这种加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p>
<p>这个<code>join buffer</code>的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为<code>262144字节</code>（也就是<code>256KB</code>），最小可以设置为<code>128字节</code>。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大<code>join_buffer_size</code>的值来对连接查询进行优化。</p>
<p>另外需要注意的是，驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在<code>join buffer</code>中放置更多的记录。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>单表访问方法</title>
    <url>/blog/2019/07/26/mysql/8_single_table_access_method/</url>
    <content><![CDATA[<p><code>MySQL</code>单表查询。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine&#x3D;InnoDB CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<h5 id="1-访问方法-Access-Mehotd-概念"><a href="#1-访问方法-Access-Mehotd-概念" class="headerlink" title="1. 访问方法(Access Mehotd)概念"></a>1. 访问方法(Access Mehotd)概念</h5><p>查询的执行方式分为两种：</p>
<ul>
<li>使用全表扫描查询</li>
<li>使用索引进行查询<ul>
<li>针对主键或者唯一二级索引的等值查询</li>
<li>针对普通二级索引的等值查询</li>
<li>针对索引列的范围查询</li>
<li>直接扫描整个索引</li>
</ul>
</li>
</ul>
<p><code>MySQL</code>执行查询语句的方式称为<strong>访问方法</strong>或者<strong>访问类型</strong>。同一个查询语句可以使用多种访问方法执行，其结果是一样的，但是其执行时间可能会差距很大。</p>
<h6 id="1-const"><a href="#1-const" class="headerlink" title="1. const"></a>1. const</h6><p><code>MySQL</code>可以通过主键列定位一条记录，如下：<code>key2</code>列是唯一二级索引，只需要在<code>key2</code>列对应的<strong>B+树</strong>中定位一条二级索引记录，然后根据主键id回表确定完整的用户记录，其查询效率非常快。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &#x3D; 3841;</span><br></pre></td></tr></table></figure>

<p><code>MySQL</code>中把这种通过主键或者通过唯一二级索引列定位<strong>一条记录</strong>的访问方法称为<strong style='color:red'><code>const</code></strong>，即常数级别的，代价忽略不计的。只能在主键列或这唯一二级索引列和一个常数进行<strong>等值比较</strong>才有效，当主键或者唯一二级索引由多个列构成，则索引中每个列都需要与常数进行比较。其根本原因是<font color='red'>索引中全部列都进行等值比较才可以定位唯一一条记录</font>。</p>
<p>由于唯一二级索引，并没有限制<code>NULL</code>值数量，所以如果<code>Where</code>子句是<code>key2 IS NULL</code>，不能使用<code>const</code>访问方法。</p>
<h6 id="2-ref"><a href="#2-ref" class="headerlink" title="2. ref"></a>2. ref</h6><p>对普通二级索引列与常数等值比较，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用全表扫描</li>
<li>先使用二级索引找到对应记录的<code>id</code>值，然后再回表到聚簇索引中查找完整的用户记录，由于普通二级索引没有限制索引列值的唯一性，所以可能对应多条记录，<font color='red'>即二级索引的查询代价取决于等值匹配到的二级索引记录条数</font>。</li>
</ul>
<p><code>MySQL</code>选择使用全表扫描还是使用二级索引，是根据统计到的二级索引匹配到的记录条数。采用二级索引来执行查询的访问方法称为<strong style='color:red'><code>ref</code></strong>。其效率比<code>const</code>差了一点，因为其可能匹配到了多条记录。</p>
<ul>
<li><p>二级索引列为<code>NULL</code>的情况</p>
<p>普通二级索引和唯一二级索引，其索引列对包含<code>NULL</code>的数量并不限制，所以包含<code>IS NULL</code>的搜索条件，只能是<code>ref</code>，而不是<code>const</code>的访问方法</p>
</li>
<li><p>包含多个索引列的二级索引(联合索引)，只要左侧连续索引列是与常熟等值比较就可以采用<code>ref</code>的访问方法，但若索引列非等值比较就非<code>ref</code>访问方法。</p>
</li>
</ul>
<h6 id="3-ref-or-null"><a href="#3-ref-or-null" class="headerlink" title="3. ref_or_null"></a>3. ref_or_null</h6><p>当搜索条件中包含二级索引列等于某个常数以及<code>NULL</code>值，且<code>MySQL</code>使用的是二级索引的访问方法称为<code>ref_or_null</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_demo WHERE key1 &#x3D; &#39;abc&#39; OR key1 IS NULL;</span><br></pre></td></tr></table></figure>

<h6 id="4-range"><a href="#4-range" class="headerlink" title="4. range"></a>4. range</h6><p>利用索引进行范围匹配的方法称为<code>range</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;&#x3D; 38 AND key2 &lt;&#x3D; 79);</span><br></pre></td></tr></table></figure>

<p>上述SQL中，当<code>MySQL</code>选择<strong>二级索引+回表</strong>的方式执行时，搜索条件中需要匹配某个或者某些值。</p>
<h6 id="5-index"><a href="#5-index" class="headerlink" title="5. index"></a>5. index</h6><p>遍历二级索引记录的执行方法称为<code>index</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure>

<p>其<code>Where</code>子句中，<code>key_part2</code>列非<code>idx_key_part</code>联合索引的最左列，所以无法使用<code>ref</code>查询，但其有两个特点：</p>
<ul>
<li>查询列为<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>，联合索引中<code>idx_key_part</code>包含查询列表</li>
<li>搜索条件为<code>key_part2</code>，也在<code>idx_key_part</code>索引中</li>
</ul>
<p>所以，其可以直接遍历<code>idx_key_part</code>对应的<strong>B+树</strong>，比较<code>key_part2</code>列，然后把<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>放到结果集中。<strong>B+树</strong>中比聚簇索引记录小很多，也不需要回表，所以成本也不高。</p>
<h6 id="6-all"><a href="#6-all" class="headerlink" title="6. all"></a>6. all</h6><p>使用全表扫描执行查询的方式称之为：<code>all</code></p>
<h5 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h5><h6 id="1-range访问方法使用的范围区间"><a href="#1-range访问方法使用的范围区间" class="headerlink" title="1. range访问方法使用的范围区间"></a>1. <code>range</code>访问方法使用的范围区间</h6><p>对于<strong>B+树</strong>来说，使用索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来可以产生一个所谓的<strong>区间</strong>。</p>
<blockquote>
<p><code>LIKE</code>操作符只能前缀匹配或者完整字符串匹配。</p>
</blockquote>
<p>当我们使用<code>range</code>的访问方法时，重点是确定该查询可用的索引以及索引对应的范围区间。</p>
<ol>
<li><p>所有搜索条件都可以使用某个索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 AND key2 &gt; 200;</span><br></pre></td></tr></table></figure>

<p><code>AND</code>连接符取交集，<code>Where</code>子句其交集为<code>key2 &gt; 200</code>，范围区间为<code>(200, +∞)</code></p>
</li>
<li><p>有的搜索条件无法使用索引的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100 AND common_field &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure>

<p>当<code>MySQL</code>选择使用<strong>二级索引+回表</strong>的方式后，<code>Where</code>子句中<code>common_field=&#39;abc&#39;</code>无法使用索引，因为<code>key2&gt;100</code>，可以使用<code>idx_key2</code>的<code>range</code>访问方法，但是其<strong>B+树</strong>中不包含<code>common_field</code>列，所以只能是先<code>key2&gt;100</code>在<strong>B+树</strong>使用<code>range</code>中确认范围区间，在回表后使用<code>common_field = &#39;abc&#39;</code>过滤结果集，所以我们在使用索引确认范围区间时，需要把与索引无关的搜索条件替换为<code>true</code>。上述SQL在二级索引中确定范围区间时，可以替换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 &gt; 100;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂搜索条件下找出范围匹配的区间</p>
<p>查询条件特别复杂时，确定范围区间特别麻烦，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE </span><br><span class="line">        (key1 &gt; &#39;xyz&#39; AND key2 &#x3D; 748 ) OR</span><br><span class="line">        (key1 &lt; &#39;abc&#39; AND key1 &gt; &#39;lmn&#39;) OR</span><br><span class="line">        (key1 LIKE &#39;%suf&#39; AND key1 &gt; &#39;zzz&#39; AND (key2 &lt; 8000 OR common_field &#x3D; &#39;abc&#39;)) ;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>确定<code>Where</code>子句中搜索条件涉及到的索引列，<code>key1</code>、<code>key2</code></p>
</li>
<li><p>选择索引列，确定范围区间</p>
<ul>
<li><p>选择<code>key1</code>执行查询，把与索引无关的查询条件去掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(key1 &gt; &#39;xyz&#39; AND TRUE ) OR</span><br><span class="line">(key1 &lt; &#39;abc&#39; AND key1 &gt; &#39;lmn&#39;) OR</span><br><span class="line">(TRUE AND key1 &gt; &#39;zzz&#39; AND (TRUE OR TRUE))</span><br></pre></td></tr></table></figure>

<p>继续化简：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key1 &gt; &#39;xyz&#39; OR (key1 &lt; &#39;abc&#39; AND key1 &gt; &#39;lmn&#39;) OR (key1 &gt; &#39;zzz&#39;)</span><br></pre></td></tr></table></figure>

<p>去掉<code>TRUE</code>或则<code>FALSE</code>的条件，取并集，最终条件为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key1 &gt; &#39;zzz&#39;</span><br></pre></td></tr></table></figure>

<p>所以上边那个有一坨搜索条件的查询语句如果使用 <code>idx_key1</code> 索引执行查询的话，需要把满足<code>key1 &gt; xyz</code>的二级索引记录都取出来，然后拿着这些记录的id再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤。</p>
</li>
<li><p>选择<code>idx_key2</code>执行查询，把与该索引无关的条件用<code>TRUE</code>替换掉，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(TRUE AND key2 &#x3D; 748 ) OR</span><br><span class="line">(TRUE AND TRUE) OR</span><br><span class="line">(TRUE AND TRUE AND (key2 &lt; 8000 OR TRUE))</span><br></pre></td></tr></table></figure>

<p>简化后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUE</span><br></pre></td></tr></table></figure>

<p>其结果相当于扫描<code>idx_key2</code>二级索引的所有记录，然后回表</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h6 id="2-索引合并"><a href="#2-索引合并" class="headerlink" title="2. 索引合并"></a>2. 索引合并</h6><p><code>MySQL</code>一般情况下，执行一个查询最多会用到一个索引，但是特殊情况下会使用多个二级索引，这种需要多个索完成查询的执行方法为：<code>index merge</code></p>
<ol>
<li>Intersection合并</li>
</ol>
<p><code>Intersection</code>集交集，是指某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; AND key3 &#x3D; &#39;b&#39;;</span><br></pre></td></tr></table></figure>

<p>上述SQL有多个查询方案，<code>MySQL</code>的查询优化器会尽量选择最优方案</p>
<ul>
<li>只读取一个二级索引的成本：<ul>
<li>按照某个索引读取一个二级索引</li>
<li>根据二级索引得到的结果集进行回表操作，然后过滤其他搜索条件</li>
</ul>
</li>
<li>读取多个二级索引成本：<ul>
<li>按照不同的搜索条件分别读取不同的二级索引</li>
<li>将从多个二级索引得到的结果集取交集，然后进行回表操作</li>
</ul>
</li>
</ul>
<p>读取多个二级索引虽然多读取了一个索引，但是读取二级索引是<strong>顺序I/O</strong>，回表操作是<strong>随机IO</strong>，当读取第一个二级索引需要回表的数据太多，而读取多个二级索引取交集后结果集很少，读取一个二级索引回表比读取多个二级索引取交集后回表性能损耗更多时，就会使用到<code>Intersection</code>索引合并</p>
<p><code>Intersection</code>合并，是把从多个二级索引中查询出的主键值求交集，那么从二级索引中查询到的结果集本身已经是有序的，那么求交集就很简单：逐个取出两个结果集中最小的主键值，若相等则加入到交集结果中，否则丢弃小的主键值，继续从丢弃的主键值所在的结果集中取后一个主键值比较，直到某个结果集中全部取出。时间复杂度为<code>O(n)</code>。</p>
<p>以下情况会使用到<code>Intersection</code>索引合并：</p>
<ul>
<li><p>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中每个列都必须等值匹配，不能匹配部分列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; AND key_part1 &#x3D; &#39;a&#39; AND key_part2 &#x3D; &#39;b&#39; AND key_part3 &#x3D; &#39;c&#39;;</span><br></pre></td></tr></table></figure>

<p>下面SQL不能进行<code>Intersection</code>合并，因为存在结果集中的结果无序，无法直接进行比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#39;a&#39; AND key_part1 &#x3D; &#39;a&#39; AND key_part2 &#x3D; &#39;b&#39; AND key_part3 &#x3D; &#39;c&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; AND key_part1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键列可以是范围匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE id &gt; 100 AND key1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>

<p>对于<code>InnoDB</code>的二级索引记录时按照索引列（包括联合索引）进行排序的，当索引列值相同时，按照主键的值进行排序，所以上述SQL可以直接使用<code>key1</code>的二级索引进行范围匹配。</p>
</li>
</ul>
<p><font color='red'>即使满足<code>Intersection</code>合并的条件，也不一定会发生<code>Intersection</code>合并，具体需要由查询优化器判断</font>。</p>
<ol start="2">
<li><code>Union</code>合并</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; OR key3 &#x3D; &#39;b&#39;</span><br></pre></td></tr></table></figure>

<p><code>Intersection</code>是取交集，适用于搜索条件用<code>AND</code>连接的情况，<code>Union</code>是并集，适用于搜索条件用<code>OR</code>连接的情况。不同的<code>OR</code>关系的不同搜索条件使用不同的索引，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; OR key3 &#x3D; &#39;b&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现部分匹配的情况(<font color='red'>结果集必须主键有序</font>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; OR ( key_part1 &#x3D; &#39;a&#39; AND key_part2 &#x3D; &#39;b&#39; AND key_part3 &#x3D; &#39;c&#39;);</span><br></pre></td></tr></table></figure>

<p>如下：<a href='rangeMatch'></a>第一个因为对<code>key1</code>进行了范围匹配，第二个因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Union</code>索引合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#39;a&#39; OR (key_part1 &#x3D; &#39;a&#39; AND key_part2 &#x3D; &#39;b&#39; AND key_part3 &#x3D; &#39;c&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 &#x3D; &#39;a&#39; OR key_part1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键列可以是范围匹配</p>
</li>
<li><p>使用<code>Intersection</code>索引合并的搜索条件</p>
</li>
</ul>
<p>查询条件符合上述情况也不一定会采用<code>Union</code>索引合并，需要根据优化器判断。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过<code>Union</code>索引合并后进行访问的代价比全表扫描更小时才会使用<code>Union</code>索引合并。</p>
<ol start="3">
<li><p>Sort-Union合并</p>
<p><code>Union</code>中，当搜索条件为<a href='#rangeMerge'>范围匹配</a>时，因为结果集中的主键值无序，所以无法使用<code>Union</code>合并，但是若排序后<code>Union</code>合并成本比回表成本低，则可以先排序后合并<code>Sort-Union</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &lt; &#39;a&#39; OR key3 &gt; &#39;z&#39;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>先根据<code>key1 &lt; &#39;a&#39;</code>条件从<code>idx_key1</code>二级索引总获取记录，并按照记录的主键值进行排序</li>
</ul>
<ul>
<li>再根据<code>key3 &gt; &#39;z&#39;</code>条件从<code>idx_key3</code>二级索引总获取记录，并按照记录的主键值进行排序</li>
<li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和<code>Union</code>索引合并方式就一样了</li>
</ul>
<p>先按照二级索引记录的主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并。使用<font color='red'>前提是排序成本不高</font>。</p>
<ol start="4">
<li><p>索引合并注意事项</p>
<p>联合索引替代Intersection索引合并，索引合并执行是因为两个索引是单独存在的，若把索引组成联合索引则会减少索引合并的成本。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>B+ Tree的使用</title>
    <url>/blog/2019/07/23/mysql/7_b+_tree_use/</url>
    <content><![CDATA[<p><code>InnoDB</code>存储引擎的<strong>B+树</strong>索引：</p>
<ul>
<li>每个索引都是一个<strong>B+树</strong>，<strong>B+树</strong>分为多层。所有用户记录都存储在<strong>B+树</strong>的叶子节点，所有目录记录都存储在非叶子节点。</li>
<li><code>InnoDB</code>存储引擎会自动为主键建立<strong>聚簇索引</strong>，其叶子节点包含完整的用户记录。</li>
<li>可以为非主键列建立二级索引，二级索引的叶子节点包含的用户记录由<strong>索引列+主键列</strong>组成，所以通过二级索引查找用户记录，需要通过<strong>回表</strong>操作，即通过二级索引确定主键id后，在到聚簇索引中查找完整的用户记录。</li>
<li><strong>B+树</strong>中每层节点都是按照索引列大小排序组成的双向链表，每个页内的记录(用户记录或者目录记录)都是按照索引列值从小到大顺序形成的单链表。</li>
<li>通过索引查找记录是从<strong>B+树</strong>的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了<code>Page Directory</code>（页目录），所以在这些页面中的查找非常快。</li>
</ul>
<p>下面说明如何使用<strong>B+树</strong>。</p>
<a id="more"></a>

<h4 id="1-索引的代价"><a href="#1-索引的代价" class="headerlink" title="1. 索引的代价"></a>1. 索引的代价</h4><ul>
<li><p>空间代价，每建立一个索引，都要建立一个<strong>B+树</strong>，每棵<strong>B+树</strong>的每个节点都是数据页，每页默认占<code>16KB</code>大小。</p>
</li>
<li><p>时间代价，每次对表进行增、删、改时，都需要去修改各个<strong>B+树</strong>索引。例如，记录位移，页面分裂、页面回收等操作。</p>
<ul>
<li>页是按照索引值从小到大的双向链表</li>
<li>数据页内是按照索引值从小到大的单链表</li>
</ul>
</li>
</ul>
<h4 id="2-B-树索引使用的条件"><a href="#2-B-树索引使用的条件" class="headerlink" title="2. B+树索引使用的条件"></a>2. B+树索引使用的条件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    id INT NOT NULL auto_increment,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name, birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="1-全值匹配"><a href="#1-全值匹配" class="headerlink" title="1. 全值匹配"></a>1. 全值匹配</h5><p>搜索条件中的列与索引列一致，称为全值匹配。当索引列是联合索引时(<code>idx_name_birthday_phone_number</code>)：<a name='sort'></a></p>
<ul>
<li>先按照<code>name</code>列的值进行排序。</li>
<li>如果<code>name</code>列的值相同，则按照<code>birthday</code>列的值进行排序。</li>
<li>如果<code>birthday</code>列的值也相同，则按照<code>phone_number</code>的值进行排序。</li>
</ul>
<p><font color='red'><code>Where</code>子句内的搜索条件顺序对查询结果没有影响</font>，因为<code>MySQL</code>中有查询优化器。</p>
<h5 id="2-匹配左边的列"><a href="#2-匹配左边的列" class="headerlink" title="2. 匹配左边的列"></a>2. 匹配左边的列</h5><p>在搜索语句中也可以不包含全部联合索引中的列，只包含左侧的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &#x3D; &#39;Ashburn&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &#x3D; &#39;Ashburn&#39; AND birthday &#x3D; &#39;1990-09-27&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>B+树</strong>的记录的<a href='#sort'>排序规则</a>。当非匹配最左原则时，则无法使用索引。</p>
<h5 id="3-匹配列前缀"><a href="#3-匹配列前缀" class="headerlink" title="3. 匹配列前缀"></a>3. 匹配列前缀</h5><p>当字符串列为索引时，其是按照字符串比较规则排序的，如下：</p>
<ul>
<li>先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。</li>
<li>如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。</li>
<li>如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。</li>
</ul>
<p>所以有序的字符串特点如下：</p>
<ul>
<li>先按照字符串第一个字符排序</li>
<li>若第一个相同，则按照第二个字符串排序</li>
<li>以此类推。</li>
</ul>
<p>所以字符串的前n各字符是有序的，所以对于字符串类型索引来说，值匹配其前缀也可以快速定位记录。<a name='prefixMatching'></a>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#39;As%&#39;;</span><br></pre></td></tr></table></figure>

<p>以下SQL无法使用到索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#39;%As%&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name LIKE &#39;%As&#39;;</span><br></pre></td></tr></table></figure>

<h5 id="4-匹配范围值"><a href="#4-匹配范围值" class="headerlink" title="4. 匹配范围值"></a>4. 匹配范围值</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>B+树</strong>中的记录页与数据页是按照<code>name</code>排列的，所有上述插入过程如下:</p>
<ul>
<li>找到<code>name</code>值为<code>Asa</code>的记录</li>
<li>找到<code>name</code>值为<code>barlow</code>的记录</li>
<li>由于所有数据页是由双向链表组成，数据页内的记录是由单链表组成，所以可以得到符合条件的数据的主键集合</li>
<li>根据主键值到<strong>聚簇索引</strong>中<strong>回表</strong>找到完整记录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39; AND birthday &gt; &#39;1980-01-01&#39;;</span><br></pre></td></tr></table></figure>

<p>上述SQL中，只有<code>name</code>列才能用到<strong>B+树</strong>索引</p>
<ul>
<li>通过条件<code>name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39;</code>来对<code>name</code>进行范围查找，<code>name</code>列的索引会起作用</li>
<li>对<code>name</code>查找到的集合继续通过<code>birthday &gt; &#39;1980-01-01&#39;</code>条件过滤</li>
<li>回表</li>
</ul>
<p>下面的SQL，会在上述过程的基础上(回表操作后，继续过滤)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39; AND birthday &gt; &#39;1980-01-01&#39; AND country &gt; &#39;China&#39;</span><br></pre></td></tr></table></figure>

<h5 id="5-精确匹配某一列并范围匹配另外一列"><a href="#5-精确匹配某一列并范围匹配另外一列" class="headerlink" title="5. 精确匹配某一列并范围匹配另外一列"></a>5. 精确匹配某一列并范围匹配另外一列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &#x3D; &#39;Ashburn&#39; AND birthday &gt; &#39;1980-01-01&#39; AND birthday &lt; &#39;2000-12-31&#39; AND phone_number &gt; &#39;15100000000&#39;;</span><br></pre></td></tr></table></figure>

<p>上述SQL，因为左侧列是索引列，联合索引会起作用：</p>
<ul>
<li><code>name</code>是索引列，对起进行精确查找，使用<strong>B+树</strong></li>
<li>由于<code>name</code>是精确查找，所以结果集中<code>name</code>值是相同的，而，<strong>B+树</strong>中，当<code>name</code>相同时时按照<code>birthday</code>大小排序的，所以<code>birthday &gt; &#39;1980-01-01&#39; AND birthday &lt; &#39;2000-12-31&#39;</code>可以使用<strong>B+树</strong></li>
<li>由于<code>birthday</code>条件是范围查找，所以通过<code>birthday</code>确定的结果集值可能不同，所以<code>phone_number</code>无法使用<strong>B+树</strong>索引，只能遍历上一步查询的到的记录</li>
</ul>
<h5 id="6-用于排序"><a href="#6-用于排序" class="headerlink" title="6. 用于排序"></a>6. 用于排序</h5><p>当我们在查询语句中使用<code>Order By</code>子句按照某种规则排序时，一般是把记录加载到内存中，然后利用一些排序算法，例如快速排序、归并排序等等再内存中进行排序，当查询结果集太大以至于不能再内存中排序的话，还可能会暂时借助磁盘的空间存放中间结果，排序操作完成后再把排序后的结果集返回到客户端，<code>MySQL</code>中，把这种再内存或者磁盘上进行排序的方式称为<strong>文件排序</strong>（<code>fileSort</code>），效率比较低。</p>
<p>当<code>ORDER BY</code>子句里使用到了索引列，就会省去在内存或文件中排序的步骤，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>上述<code>Order By</code>子句是先按照<code>name</code>排序，若<code>name</code>相同，则按照<code>birthday</code>排序，若<code>birthday</code>相同，则按照<code>phone_number</code>排序，其与联合索引规则一致，所以会直接从索引中提取数据，然后进行回表操作。</p>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><p>要使用联合索引进行排序的话，<code>Order By</code>子句后的列的顺序必须按照索引列的顺序给出，否则不能使用<strong>B+树</strong>。匹配最左原则的<code>Order By</code>子句也可以使用<strong>B+树</strong>索引。下述SQL，相当于联合索引左侧列为常量(<code>name</code>值确定)，同样可以使用后面的列进行排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &#x3D; &#39;A&#39; ORDER BY birthday, phone_number LIMIT 10;</span><br></pre></td></tr></table></figure>

<h6 id="不能使用索引的几种情况"><a href="#不能使用索引的几种情况" class="headerlink" title="不能使用索引的几种情况"></a>不能使用索引的几种情况</h6><ol>
<li><p><code>ASC</code>、<code>DESC</code>混用</p>
<p>对于使用联合索引的场景，要求各个排序顺序是一致的，<code>ASC</code>或者<code>DESC</code>规则排序，不能一起使用。</p>
<ul>
<li><p>当排序列顺序一致时</p>
<ul>
<li><code>order by name ,birthday limit 10</code>，从索引左侧向右读取10行记录</li>
<li><code>order by name desc, birthday desc limit 10</code>，从索引右侧向左读取10行记录</li>
</ul>
</li>
<li><p>当排序顺序不一致时，<code>order by name, birthday desc limit 10</code></p>
<ul>
<li>先从索引左侧确定<code>name</code>最小列的值，然后找到<code>name</code>列等于该值的所有记录，然后从记录右侧开始向左找10条记录</li>
<li>若<code>name</code>列等于最小值的记录不足10条，则继续向右找<code>name</code>第二小的记录</li>
<li>重复上述过程，直到找到10条记录</li>
</ul>
<p>上述过程没有高效使用索引，不如直接使用文件排序</p>
</li>
</ul>
</li>
<li><p><code>Where</code>子句中出现非排序使用到的索引列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE country &#x3D; &#39;China&#39; ORDER BY name LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>上述SQL，搜索列(<code>Where</code>子句)<code>country</code>非<code>Order By</code>子句使用的列，所以没有用到索引，仅仅是把<code>country = &#39;China&#39;</code>的记录取出来再进行排序。</p>
</li>
<li><p>排序列包含非同一个索引的列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name, country LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>上述SQL中，使用联合索引<code>name</code>列确定的结果集中<code>country</code>是无序的</p>
</li>
<li><p>排序列使用的复杂的表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>上述SQL中，索引列的排序规则与<code>UPPER(name)</code>不一致</p>
</li>
</ol>
<h5 id="7-用于分组"><a href="#7-用于分组" class="headerlink" title="7. 用于分组"></a>7. 用于分组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number</span><br></pre></td></tr></table></figure>

<p>上述SQL相当于做了3次分组操作</p>
<ul>
<li>先把记录按照<code>name</code>值进行分组，所有<code>name</code>值相同的记录分为一组</li>
<li>将每个<code>name</code>值相同的分组里的记录，按照<code>birthday</code>值进行分组</li>
<li>再继续将<code>name</code>、<code>birthday</code>相同的记录按照<code>phone_number</code>分组</li>
</ul>
<p>其过程与<strong>B+树</strong>索引顺序一致，可以直接使用<strong>B+树</strong>索引进行分组。</p>
<ul>
<li>分组列顺序与索引顺序一致</li>
<li>可以使用索引列中左边的列进行分组</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> <code>Group By</code>子句中含有非索引列时，索引不起作用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number, country;</span><br></pre></td></tr></table></figure>

<p><code>Group By</code>子句中包含<code>country</code>，若要使用联合索引，需要先去二级联合索引中查询数据，然后根据结果集去聚簇索引中回表查找，然后分组，性能或者效率非常低。</p>
<h4 id="3-回表的代价"><a href="#3-回表的代价" class="headerlink" title="3. 回表的代价"></a>3. 回表的代价</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39;;</span><br></pre></td></tr></table></figure>

<p>上述SQL使用<code>idx_name_birthday_phone_number</code>索引，进行查询时分为以下两个步骤：</p>
<ul>
<li>使用联合索引中的<code>name</code>确定记录范围</li>
<li>由于联合索引对于的<strong>B+树</strong>用户记录中只包含部分字段，而查询列表是<code>*</code>，说明需要再根据联合索引<strong>B+树</strong>得到的主键id，到聚簇索引对应的<strong>B+树</strong>中<strong>回表</strong></li>
</ul>
<p>第一步中联合索引对应的<strong>B+树</strong>记录时连续分布几种在<strong>数据页</strong>中的，所以可以很快从记录数据的磁盘中读取出来，这种读取方式称为<code>顺序I/O</code>。然后第二步，由于第一步得到的结果集的主键id在聚簇索引中是非连续的（聚簇索引中时根据主键id排序的，与联合索引<strong>B+树</strong>排序方式不同），所以结果是分布在聚簇索引的不同页中，因而需要访问更多的数据页，这种读取方式称为<code>随机I/O</code>。<font color='red'>顺序I/O比随机I/O性能高很多</font>。</p>
<p>需要回表的记录越多，使用二级索引的性能越低或者代价越高，有时甚至不如全表扫描。例如<code>Asa</code>~<code>Barlow</code>之间的记录占全部记录90%以上，那么全表扫描性能更好。实际使用中，<code>InnoDB</code>的查询优化器会选择采用全表扫描还是二级索引+回表，查询优化器会事先对表中的记录做统计，然后利用统计数据根据查询条件计算需要回表的记录数，一般需要回表的记录越多，越倾向于使用全表扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info WHERE name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39; LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>上述SQL，会使用<strong>二级索引+回表</strong>，<code>LIMIT 10</code>说明回表id很少。</p>
<p>有排序或者分组需求的查询，也判断采用<strong>二级索引+回表</strong>，还是全表扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name, birthday, phone_number;</span><br></pre></td></tr></table></figure>

<h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>实际使用中，应该尽量避免<strong>回表</strong>带来的性能损耗，尽量保证查询列表里只包含索引列。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, birthday, phone_number FROM person_info WHERE name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39;</span><br></pre></td></tr></table></figure>

<p>上述SQL中，查询列表均是联合索引内的数据，此时不需要到聚簇索引中查找，这种只需要用到索引值的查询方式称为<strong>索引覆盖</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, birthday, phone_number  FROM person_info ORDER BY name, birthday, phone_number;</span><br></pre></td></tr></table></figure>

<p>上述SQL中，没有<code>LIMIT</code>子句，但是采用了<strong>覆盖索引</strong>，不需要<strong>回表</strong>操作，因为查询列表中没有索引列之外的列。</p>
<h4 id="4-如何选择索引"><a href="#4-如何选择索引" class="headerlink" title="4. 如何选择索引"></a>4. 如何选择索引</h4><ol>
<li><p>只为用于搜索、排序或分组的列创建索引</p>
</li>
<li><p>考虑列的基数，为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p>
<p><strong>列的基数</strong>指某一列中不重复数据的个数，其直接影响我们是否能有效利用索引。基数为<code>1</code>，即所有列中的值都一样，此时建立索引的重复值就会很多，使用索引的意义不大。</p>
</li>
<li><p>索引列的类型尽量小</p>
<p>类型大小指的是数据范围的大小，例如<code>TINYINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>占用的空间依次递增，表示的数据范围也是依次递增。当我们对某个整数列建立的索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，是因为：</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据了些越小，索引占用的存储空间越小，一个数据页内占用更多的记录，可以减少磁盘I/O带来的性能损耗，也意味着可以把更多的数据页缓存到内存中，加快读写效率</li>
</ul>
</li>
<li><p>索引字符串值的前缀</p>
<p>上文说到，<code>MySQL</code>中使用<a href='#prefixMatching'>匹配前缀</a>的方式也可以使用索引，那么当需要索引的列数据太长时，会有以下两个问题：</p>
<ul>
<li><strong>B+树</strong>索引中记录需要把该列完整的字符串存储起来，而且字符串越长，索引中占用的存储空间越大</li>
<li><strong>B+树</strong>索引中索引列越长，比较时占用更多的存储空间</li>
</ul>
<p>所以，<code>MySQL</code>支持对字符串前几个字符进行索引，这样虽然不能精确定位记录的位置，然后根据前缀记录相同的主键值回表查询完整的字符串值。这样<strong>B+树</strong>中存储的字符串前几个字符，既节约空间，有减少字符串的比较时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person_info(</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    phone_number CHAR(11) NOT NULL,</span><br><span class="line">    country varchar(100) NOT NULL,</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>name(10)</code>，<strong>B+树</strong>索引中只保留前10个字符的编码。</p>
<p>使用索引列前缀的方式无法支持使用索引排序，上述联合索引中<code>name</code>列是前缀索引，不支持对前缀相同，后续字符不同的记录进行排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM person_info ORDER BY name LIMIT 10;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让索引列在比较表达式中单独出现</p>
<p>下面SQL是有区别的（col列有索引）:</p>
<ul>
<li><code>Where col * 2 &lt; 4</code></li>
<li><code>Where col &lt; 4/2</code></li>
</ul>
<p>第一个<code>Where</code>子句中<code>col</code>列并不是单独列的形式出现的，存储引擎会依次遍历所有的记录，无法使用到索引</p>
<p>第二个<code>Where</code>子句中<code>col</code>是单独列的形式出现的，可以直接使用<strong>B+树</strong>索引</p>
</li>
<li><p>主键插入顺序</p>
<p><code>InnoDB</code>引擎中，表中的数据实际上是存储到聚簇索引的叶子节点中，数据页是按照主键值从小到大顺序进行排序的，插入数据的记录主键值大小也会影响插入效率。若主键值忽大忽小，那么我们插入数据时，可能会发生<strong>页分裂</strong>和记录位移，这就意味着性能损耗。所以建议：主键：<code>AUTO_INCREMENT</code>，让存储引擎自己为表生成主键。</p>
</li>
<li><p>冗余和重复索引</p>
<p>避免对一个列创建多个索引。</p>
</li>
</ol>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><ol>
<li><strong>B+树</strong>索引在空间和时间上都有代价</li>
<li><strong>B+树</strong>索引使用范围：<ul>
<li>全值匹配</li>
<li>匹配左边的列</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>用于排序</li>
<li>用于分组</li>
</ul>
</li>
<li><strong>B+树</strong>注意事项：<ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>为列的基数大的列创建索引</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串值的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才可以适用索引</li>
<li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li>
<li>定位并删除表中的重复和冗余索引</li>
<li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>git 命令</title>
    <url>/blog/2019/07/23/essay/git_cmd/</url>
    <content><![CDATA[<p>git常用命令</p>
<a id="more"></a>

<ul>
<li><p>同步远程分支(清理无效的远程追踪分支)：<code>git remote prune origin --dry-run</code></p>
</li>
<li><p>删除本地分支： <code>git branch -d branch_name</code> </p>
</li>
<li><p>创建远程分支：</p>
<ul>
<li><code>git checkout -b branch_name</code></li>
<li><code>git push origin branch_name:branch_name</code></li>
<li><code>git branch --set-upstream-to=origin/branch_name</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>B+ Tree Index</title>
    <url>/blog/2019/07/19/mysql/6_b+_tree_index/</url>
    <content><![CDATA[<p><code>InnoDB</code>索引页由7个部分组成，各个数据页组成了一个双向链表(<code>file header</code>中的<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>)，每个数据页中的记录按照主键值顺序组成了一个单向链表(记录头中的<code>next_record</code>)，每个数据页都会生成一个<strong>页目录</strong>(<code>Page Direcotory</code>)，通过主键查找时，在<strong>页目录</strong>中使用二分查找定位到对应的槽(<code>Slot</code>)，然后遍历槽对应的分组内的记录。具体见<a herf='/blog/2019/07/17/mysql/5_innodb_index_page_structure/'>InnoDB  Index 页结构</a></p>
<a id="more"></a>

<h5 id="1-非索引查找"><a href="#1-非索引查找" class="headerlink" title="1. 非索引查找"></a>1. 非索引查找</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT column_name FROM table WHERE column_name &#x3D; xxx;</span><br></pre></td></tr></table></figure>

<h6 id="1-在单页中查找"><a href="#1-在单页中查找" class="headerlink" title="1. 在单页中查找"></a>1. 在单页中查找</h6><ol>
<li><p>以主键为搜索条件：在页目录中使用二分查找确认对应的槽，遍历该槽对应的分组中的记录</p>
</li>
<li><p>以其他列为条件：从<strong>最小记录</strong>开始一次遍历单链表中的每条记录并比对。</p>
</li>
</ol>
<h6 id="2-在多页中查找"><a href="#2-在多页中查找" class="headerlink" title="2. 在多页中查找"></a>2. 在多页中查找</h6><ol>
<li>定位到记录所在的页</li>
<li>从所在页中查找对应的记录</li>
</ol>
<blockquote>
<p>没有索引情况下，只能从第一页沿着双向链表查找，然后在页内查找</p>
</blockquote>
<h5 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h5><h6 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">         c1 INT,</span><br><span class="line">         c2 INT,</span><br><span class="line">         c3 CHAR(1),</span><br><span class="line">         PRIMARY KEY(c1)</span><br><span class="line">     ) ROW_FORMAT &#x3D; Compact;</span><br></pre></td></tr></table></figure>

<p>记录头相关部分如下：</p>
<ul>
<li><code>record_type</code>：记录类型<ul>
<li>0，普通记录</li>
<li>1，B+树非叶子节点标记</li>
<li>2，最小记录</li>
<li>3，最大记录</li>
</ul>
</li>
<li><code>next_record</code>：下一记录真实数据的地址偏移量</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/15.png" alt="记录"></p>
<blockquote>
<p>把记录放到页里面</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/mysql/16.png" alt="记录"></p>
<h6 id="2-索引方案"><a href="#2-索引方案" class="headerlink" title="2. 索引方案"></a>2. 索引方案</h6><p>我们需要为快速定位记录所在的数据页建立一个别的目录，要求如下：</p>
<ul>
<li><p><font color='red'>下一数据页中用户记录的主键值必须大于上一页中用户记录的主键值</font></p>
<p>假设，每页最多可以存放3条记录，那么存储3条记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO index_demo VALUES(1, 4, &#39;u&#39;), (3, 9, &#39;d&#39;), (5, 3, &#39;y&#39;);</span><br><span class="line">Query OK, 3 rows affected (0.01 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>页内有3条记录，组成了单向链表，结果如下:</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/mysql/17.png" alt="记录"></p>
<p>继续插入SQL，<code>INSERT INTO index_demo VALUES(4, 4, &#39;a&#39;)</code>，会分配新页。其主键为4，小于5，为了保证上一页的主键必须小于下一页，插入主键为4的记录时需要伴随一次记录移动，把主键值为5的记录移动到新页，然后插入主键为4的记录。过程如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/18.png" alt="页分裂过程"></p>
<p>其本质是在对记录进行增删改操作中，必须通过一些记录移动操作始终保持<strong>下一数据页中用户记录的主键值必须大于上一页中用户记录的主键值</strong>成立，这个过程称为<strong>页分裂</strong>。</p>
<blockquote>
<p>页编号可能不是连续的，即页在存储空间并不连续</p>
</blockquote>
</li>
<li><p>给所有页建立一个目录项</p>
<p>页非连续，所以其在存储空间内并不连续，当我们想快速定位记录所在的页，需要为页做一个目录，包括两部分，见下图：</p>
<ul>
<li>页中用户记录最小的主键值，<code>Key</code>表示</li>
<li>页号，<code>page_no</code>表示</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/19.png" alt="页分裂过程"></p>
<p>以页10为例，对应目录项为1，包含页10内最小记录的<code>Key</code>，以及<code>page_no</code>10。其查找过程如下：</p>
<ol>
<li><p>先从目录项中根据二分法快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 <code>12 &lt; 20 &lt; 209</code>），它对应的页是<code>页9</code>。</p>
</li>
<li><p>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p>
</li>
</ol>
</li>
</ul>
<h6 id="3-InnoDB中的索引方案"><a href="#3-InnoDB中的索引方案" class="headerlink" title="3. InnoDB中的索引方案"></a>3. InnoDB中的索引方案</h6><p>上述的索引方案，比较简单，且当数据量过大时所有目录项不可能在连续的物理空间中存储，会产生几个问题</p>
<ul>
<li><p><code>InnoDB</code>是使用页作为管理存储空间的基本单位，但最多能保证<code>16KB</code>的连续存储空间。</p>
</li>
<li><p>若是连续的存储空间，那么频繁的增删改查，会导致索引页频繁的移动</p>
</li>
</ul>
<p>这些目录项内容与用户记录的索引页差不多，只不过<strong>目录项</strong>中两个列是<code>主键</code>和页号。目录页复用存储用户记录的数据页存储目录，为了与用户记录区分，其有不同的<code>record_type</code></p>
<ul>
<li><code>0</code>：普通的用户记录</li>
<li><code>1</code>：目录项记录</li>
<li><code>2</code>：最小记录</li>
<li><code>3</code>：最大记录</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/20.png" alt="目录页结构"></p>
<blockquote>
<p>上图可以发现，目录页与数据页的不同之处：</p>
</blockquote>
<ul>
<li>目录页<code>record_type</code>为1，普通数据页<code>record_type</code>为0</li>
<li>目录页只有主键值和页的编号两列</li>
<li>目录页中主键值最小的目录项的<code>min_rec_mask</code>为1</li>
</ul>
<p><code>Index</code>页的特点，目录页与数据页都一致。</p>
<p>以查找主键值为20的数据为例：</p>
<ul>
<li>先到存储目录的页，即<code>页30</code>中通过二分法在页目录(<code>Page Directory</code>)中定位<code>Slot</code>，然后根据页分组定位到具体的页</li>
<li>到存储具体记录的页中，根据二分查找快速定位到用户记录</li>
</ul>
<p>上图中还可以发现，当数据页过多时，一个目录页远不能起到索引的作用，所以会有多个目录页，目录页结构与规则与数据页一致</p>
<ul>
<li>下一个目录页中用户目录记录的最小主键值必须大于上一个页中记录的主键值。</li>
<li>目录页也会出现页分裂</li>
<li>当目录页过多时，为了快速定位数据页，会生成更高以及的目录</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/21.png" alt="目录页结构"></p>
<p><code>InnoDB</code>的索引方案便是<code>B+树</code>，实际记录都放在B+树最底层的叶子节点上，其余用来存放<strong>目录页</strong>的节点称为非叶子节点，<code>B+树</code>最上边的那个节点称为<strong>Root节点</strong>。</p>
<blockquote>
<p>B+树，可以分为多层。假设，存放用户数据的叶子节点可以存放100条用户记录，存放目录项的页内可以存放1000条目录，结论如下：</p>
</blockquote>
<ul>
<li><code>B+树</code>1层，只有1个存放用户数据的节点，则最多存放100条记录</li>
<li><code>B+树</code>2层，只有1个存放目录数据的节点，则最多存放100 * 10000条记录</li>
<li><code>B+``树</code>3层，则最多存放100 * 1000 * 1000条记录</li>
<li><code>B+树</code>4层，则最多存放100 * 1000 * 1000 * 1000条记录</li>
</ul>
<p>综上，正常<code>MySQL</code>的<strong>B+树</strong>在4层以内，那么一个查询SQL，就只需要经过4个页的查找，在页内，还可以通过<code>Page Directory</code>快速定位用户数据</p>
<h6 id="4-聚簇索引"><a href="#4-聚簇索引" class="headerlink" title="4. 聚簇索引"></a>4. 聚簇索引</h6><p><code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p>
<ul>
<li>使用主键值的大小进行页的记录和排序<ul>
<li>页内的记录是按照主键大小顺序排序的单向链表</li>
<li>存放用户记录的页也是根据用户记录的主键大小排序的双向链表</li>
<li>存放目录项记录的目录页可以有多层，同一层次的页也是根据目录中记录的主键大小排序的双向链表</li>
</ul>
</li>
<li><code>B+树</code>的叶子节点存储的是完整的用户记录</li>
</ul>
<p>具有以上两种特性的<code>B+</code>树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。</p>
<h6 id="5-二级索引"><a href="#5-二级索引" class="headerlink" title="5. 二级索引"></a>5. 二级索引</h6><p><code>MySQL</code>会根据主键创建<code>B+树</code>，这种索引只能在搜索条件是主键值时才能发挥作用。</p>
<p>一个表可以有多个索引。当我们以其他非主键列作为索引创建<code>B+树</code>后，其与主键列创建的<code>B+树</code>不同之处：</p>
<ul>
<li>使用索引列(非主键列)排序<ul>
<li>页内的记录是按照索引列排序的单向链表</li>
<li>各个存放用户记录的页也是根据页中索引列大小排序成的双向链表</li>
<li>各个存放目录的页分为不同的层次，在同一层次中的页也是根据索引列大小排序的</li>
</ul>
</li>
<li><code>B+</code>树的叶子节点存储的并不是完整的用户记录，而是<strong style='color:red'>索引列+主键列</strong>的值</li>
<li>目录项记录中不再是<strong>主键+页号</strong>的搭配，而是<strong>索引列+页号</strong>。</li>
</ul>
<p>当我们使用非主键列所谓索引时，需要先在该索引对应的<code>B+</code>树中，确定主键列的值，然后再去主键列对应的<code>B+树</code>确定用户记录，这种根据其他索引列确定主键值，在根据主键值去主键对应的<code>B+树</code>查找用户记录的过程称为<strong>回表</strong>。通过<strong>回表</strong>，虽然多了一次查询，但是节省了大量存储空间。非主键列建立的索引称为<strong>二级索引</strong>。</p>
<h6 id="6-联合索引"><a href="#6-联合索引" class="headerlink" title="6. 联合索引"></a>6. 联合索引</h6><p>也可以以多个列的大小作为排序规则，同时为多个列建立索引，例如以非主键列<code>A</code>和<code>B</code>列建立索引：</p>
<ul>
<li>先把各个记录和页按照<code>A</code>列进行排序</li>
<li>在记录<code>C2</code>列相同的情况下，采用<code>C3</code>列进行排序</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/21.png" alt="联合索引结构"></p>
<p>有以下几点区别</p>
<ul>
<li>每条目录项记录都由<code>A</code>、<code>B</code>和页号三部分组成，各记录先按照<code>A</code>列排序，再按照<code>B</code>列排序</li>
<li><code>B+树</code>叶子节点处记录由<code>A</code>、<code>B</code>和主键列构成</li>
</ul>
<h5 id="3-InnoDB的B-树索引的注意事项"><a href="#3-InnoDB的B-树索引的注意事项" class="headerlink" title="3. InnoDB的B+树索引的注意事项"></a>3. InnoDB的B+树索引的注意事项</h5><ol>
<li><p>跟节点不会移动，实际上<code>B+</code>树的形成过程是这样的：</p>
<ul>
<li>每当为表创建<code>B+</code>树索引时，都会为这个索引创建一个<code>Root节点</code>页，最开始<code>B+树</code>索引中即没有用户记录也没有目录项记录</li>
<li>向表中插入记录时，先把用户记录存储到<code>Root根节点</code>中</li>
<li>当<strong>Root节点</strong>中的可用空间用完时，继续插入记录，会将<strong>Root节点</strong>中的所有记录复制到一个新分配的页中，然后对该页进行<strong>页分裂</strong>操作，<strong>Root节点</strong>升级为存储目录记录的页</li>
</ul>
</li>
<li><p>页节点中目录项记录的唯一行</p>
<p><code>B+</code>树目录页节点内记录的内容是<strong>索引列的值+页号</strong>，对于二级索引来说由于索引列不唯一，可能会出现以下情况（以下数据，索引列的值均为1）：</p>
<p><img src="https://images.effiu.cn/blog/mysql/23.png"></p>
<p>此时，向表中插入索引列为1的数据时，会发现页目录内，两个目录的值均为1，无法判断叶子节点，为了防止以上问题，需要再目录页内记录除<strong>C2列+页号</strong>之外的主键值，主键值唯一，可以根据主键值确定叶子节点。</p>
</li>
<li><p>一个页面至少存储两条记录</p>
<p>为了防止<strong>B+树</strong>层级过多导致的查询成本(每页只存放1条记录)，<code>MySQL InnoDB</code>要求一个数据页至少存放两条记录</p>
</li>
</ol>
<h5 id="4-MyISAM中的索引方案"><a href="#4-MyISAM中的索引方案" class="headerlink" title="4. MyISAM中的索引方案"></a>4. MyISAM中的索引方案</h5><p><code>InnoDB</code>中索引即数据，也就是聚簇索引的那棵<code>B+</code>树的叶子节点中已经把所有完整的用户记录都包含了，而<code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p>
<ul>
<li>表中记录按照记录的插入顺序存储到一个文件中，称为<code>数据文件</code>。文件内不划分数据页，可以通过行号快速访问记录</li>
<li><code>MyISAM</code>存储引擎，需要记录头信息存储一些额外数据</li>
<li>插入数据时，没有按照主键大小排序，所以不能使用二分查找<ul>
<li><code>MyISAM</code>存储引擎的表会把索引信息另外存储到索引文件中，<code>MyISAN</code>会单独为表主键创建一个索引，该索引文件中的叶子节点存储的不是完整的用户记录，而是<strong>主键值+行号</strong>，需要先通过主键值确定行号，再通过行号确定记录</li>
<li>可以对其他列建立索引或者联合索引，与<code>InnoDB</code>类似，也成为二级索引，但没有回表过程。</li>
</ul>
</li>
<li><code>MyISAM</code>行格式有<ul>
<li>定长记录格式(Static)，可以快速计算出记录再数据文件中的地址偏移量</li>
<li>变长记录格式(Dynamic)，<code>MyISAN</code>会直接再索引叶子节点处存储该记录再数据文件中的地址偏移量</li>
<li>压缩记录格式(Compressed)</li>
</ul>
</li>
</ul>
<h5 id="5-MySQL-索引相关SQL"><a href="#5-MySQL-索引相关SQL" class="headerlink" title="5. MySQL 索引相关SQL"></a>5. MySQL 索引相关SQL</h5><ul>
<li><p>建表指定<code>Index</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表结构指定索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB INDEX 页结构</title>
    <url>/blog/2019/07/17/mysql/5_innodb_index_page_structure/</url>
    <content><![CDATA[<p><strong>页</strong>是<code>InnoDB</code>管理存储空间的基本单位，大小为<code>16KB</code>，<code>InnoDB</code>为了不同目的设计了多种类型的<strong>页</strong>：</p>
<ul>
<li>存放表中记录数据的页(索引，<code>INDEX</code>页)</li>
<li>存放表空间头部信息的页</li>
<li>存放<code>Insert Buffer</code>信息的页</li>
<li>存放<code>INODE</code>信息的页</li>
<li>存放<code>undo</code>日志信息的页</li>
<li>······</li>
</ul>
<p>下面说明<code>INDEX</code>页数据结构。</p>
<p>具体见<a href="/blog/2019/07/17/mysql/5_innodb_index_page_structure#pageType">下文</a></p>
<a id="more"></a>

<h5 id="1-数据页结构概述"><a href="#1-数据页结构概述" class="headerlink" title="1. 数据页结构概述"></a>1. 数据页结构概述</h5><p><img src="https://images.effiu.cn/blog/mysql/6.png" alt="数据页结构">&gt;</p>
<blockquote>
<p>上图中可以看出，一个<code>InnoDB</code>数据页存储空间大致被划分为7部分，具体描述：</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>File Header</code></td>
<td>文件头部</td>
<td>38字节</td>
<td>页的通用信息</td>
</tr>
<tr>
<td><code>Page Header</code></td>
<td>页面头部</td>
<td>56字节</td>
<td>数据页专有信息</td>
</tr>
<tr>
<td><code>Infimum + Supermum</code></td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td><code>User Records</code></td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td><code>Free Space</code></td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td><code>Page Directory</code></td>
<td>页面目录</td>
<td>不确定</td>
<td>页中某些记录的相对位置</td>
</tr>
<tr>
<td><code>File Trailer</code></td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<h5 id="2-记录在页中存储"><a href="#2-记录在页中存储" class="headerlink" title="2. 记录在页中存储"></a>2. 记录在页中存储</h5><p>真实的数据是存储到<code>User Records</code>中的，当我们插入一条记录时，就会从<code>Free Space</code>中申请一个记录大小的空间划分到<code>User Records</code>中。当<code>Free Space</code>被用完后，继续插入记录就会去申请新的页。如下图:</p>
<p><img src="https://images.effiu.cn/blog/mysql/7.png" alt="数据存储过程"></p>
<blockquote>
<p>为了更好管理在<code>User Records</code>中的记录，<code>InnoDB</code>做了好多。</p>
</blockquote>
<h6 id="1-记录头信息"><a href="#1-记录头信息" class="headerlink" title="1. 记录头信息"></a>1. 记录头信息</h6><blockquote>
<p>记录头信息如下:</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/mysql/4.png" alt="记录头信息"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1/2</td>
<td align="center">1</td>
<td>未被使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td align="center">1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>min_rec_mask</code></td>
<td align="center">1</td>
<td>B+树的每层非叶子节点中最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td align="center">4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td align="center">13</td>
<td>表示当前记录在记录堆中的位置信息</td>
</tr>
<tr>
<td><code>record_type</code></td>
<td align="center">3</td>
<td>记录的类型,0:普通记录;1:B+树非叶子节点记录;2:最小记录;3:最大记录</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td align="center">16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
<blockquote>
<p>建表，插入数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE page_demo(</span><br><span class="line">          c1 INT,</span><br><span class="line">          c2 INT,</span><br><span class="line">          c3 VARCHAR(10000),</span><br><span class="line">          PRIMARY KEY (c1)</span><br><span class="line">      ) CHARSET&#x3D;ascii ROW_FORMAT&#x3D;Compact;</span><br><span class="line">INSERT INTO page_demo VALUES(1, 100, &#39;aaaa&#39;), (2, 200, &#39;bbbb&#39;), (3, 300, &#39;cccc&#39;), (4, 400, &#39;dddd&#39;);</span><br></pre></td></tr></table></figure>

<p>其在<code>User Records</code>里如下：</p>
<p><img src="https://images.effiu.cn/blog/mysql/09.png" alt="数据排列"></p>
<blockquote>
<p>上述只展示了记录头信息和实际列数据信息。</p>
</blockquote>
<ul>
<li><p><code>delete_mask</code>：表示该记录是否被删除，占用1个二进制位，<code>0</code>代表未删除，<code>1</code>表示已删除</p>
<p>记录被删除后仍然在<code>页</code>中，是因为立即删除把其他记录重新排列需要性能消耗，所以只是打一个删除标记，且所有被删除的记录都会组成一个<strong>垃圾链表</strong>，这个链表中记录占用的空间是<strong>可重用空间</strong>。</p>
<blockquote>
<p>如果有新记录插入，可能会把被删除的记录占用的存储空间覆盖掉，但是如果有与带删除标识记录一样的数据，还会插入到原位置</p>
</blockquote>
</li>
<li><p><code>min_rec_mask</code>：B+树每层非叶子节点中最小记录都会添加改标记</p>
</li>
<li><p><code>n_owned</code></p>
</li>
<li><p><code>heap_no</code>：上图可知，当前记录在本页中的位置，从<code>2</code>开始，0和1已被<code>Infimum</code>、<code>Supermum</code>即最小记录和最大记录占用。</p>
<p><img src="https://images.effiu.cn/blog/mysql/11.png" alt="Infimumh和Supermum"></p>
<p>由于<code>Infimum</code>、<code>Supermum</code>是<code>MySQL</code>定义的记录，所以单独存储。</p>
</li>
<li><p><code>record_type</code>：表示当前记录的类型，共有4种类型</p>
<ul>
<li>0：普通记录</li>
<li>1：B+树非叶子节点记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
</li>
<li><p><code>next_record</code>：表示从当前记录真实数据的地方到<strong>下一条记录</strong>真实数据的<font color='red'>地址偏移量（向左读取就是记录头信息，向右读取就是真实数据，且NULL值列表，变长字段长度列表是逆序）</font>，实际是<strong>链表</strong>。下一条记录并不是指插入顺序的下一条记录，而是按照主键值由小到大顺序的下一条记录。规定<code>Infimum</code>（最小记录）的下一条记录就是本页中主键最小的记录，本页中主键最大的记录的下一条记录就是<code>Supermum</code>。见下图:</p>
<p><img src="https://images.effiu.cn/blog/mysql/12.png" alt="数据记录链表"></p>
<p>当我们删除记录时，链表页会变动：</p>
<ul>
<li>把该条记录的<code>delete_mask</code>置为1</li>
<li>该记录的<code>next_record</code>指向0</li>
<li>上一条记录的<code>next_record</code>指向下一条记录</li>
<li><code>n_owned</code>值减1</li>
</ul>
</li>
</ul>
<h5 id="2-Page-Directory-页目录"><a href="#2-Page-Directory-页目录" class="headerlink" title="2. Page Directory(页目录)"></a>2. Page Directory(页目录)</h5><p><code>InnoDB</code>为记录制作了一个目录：</p>
<ul>
<li><p>将页中所有正常的记录（包括最大、最小，不包括带删除标识的记录）划分为几组</p>
</li>
<li><p>每组的最后一条记录（组内最大的那条记录）的头信息中的<code>n_owned</code>属性表示改组拥有的记录数</p>
</li>
<li><p>将每组记录的最后一条记录的地址偏移量单独取出来按照顺序存储到靠近<strong>页</strong>尾部的地方，即<code>Page Directory</code>。页目录中这些地址偏移量称为<strong>Slot</strong>(称为槽)</p>
<p>假如，<code>page_demo</code>表中正常的记录有4条，那么<code>InnoDB</code>会把记录分成两组</p>
<ul>
<li>第一组只有最小记录(<code>Infimum</code>)，<strong>槽0</strong>记录最小地址偏移量，槽0的<code>n_owned</code>为1，说明该分组中只有1条记录</li>
<li>第二组4条真实数据 + 最大记录(<code>Supermum</code>)，<strong>槽1</strong>记录最大地址偏移量</li>
</ul>
<p><img src="https://images.effiu.cn/blog/mysql/14.png" alt="页分组"></p>
</li>
</ul>
<p>分组要求：</p>
<ul>
<li>最小记录所在分组只能由1条记录，即其本身</li>
<li>最大记录所在分组拥有的记录数在<code>1~8</code>之间</li>
<li>剩余分组记录数在<code>4~8</code>之间</li>
</ul>
<p>分组规则：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组</li>
<li>每插入一条记录，都会从<code>Page Directory</code>中找出主键值与记录主键差值最小的槽，把该槽对应记录<code>n_owned</code>+1直到等于8</li>
<li>当组中记录数等于8时，继续插入会将该组拆分为两组，一组4条，一组5条，同时新增一个槽记录并记录新增组中最大的那条记录偏移量以及更新原有槽<code>n_owned</code>以及槽内偏移量</li>
</ul>
<p>当我们从记录中查找数据时：</p>
<ul>
<li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录</li>
<li>通过记录的<code>next_record</code>遍历组内各个记录</li>
</ul>
<h5 id="3-Page-Header-页头部"><a href="#3-Page-Header-页头部" class="headerlink" title="3. Page Header(页头部)"></a>3. Page Header(页头部)</h5><p><strong>页</strong>的第二部分，固定<code>56</code>个字节，专门存储各种状态信息，具体如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">bit</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PAGE_N_DIR_SLOTS</code></td>
<td align="center">2</td>
<td>页目录中的槽数量</td>
</tr>
<tr>
<td><code>PAGE_HEAP_TOP</code></td>
<td align="center">2</td>
<td>未使用空间最小地址，<code>Free Space</code>起始地址</td>
</tr>
<tr>
<td><code>PAGE_N_HEAP</code></td>
<td align="center">2</td>
<td>本页中记录的数量(包括，最大、最小、带删除标识的记录)</td>
</tr>
<tr>
<td><code>PAGE_FREE</code></td>
<td align="center">2</td>
<td>第一个标记为删除的记录地址(删除链表的起始位置，<code>next_record</code>记录下一个带删除标识的记录)</td>
</tr>
<tr>
<td><code>PAGE_GARBAGE</code></td>
<td align="center">2</td>
<td>已删除记录占用字节数</td>
</tr>
<tr>
<td><code>PAGE_DIRECTION</code></td>
<td align="center">2</td>
<td>记录插入的方向</td>
</tr>
<tr>
<td><code>PAGE_N_DIRECTION</code></td>
<td align="center">2</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td><code>PAGE_N_RECS</code></td>
<td align="center">2</td>
<td>该页中记录的数量(不包括最大、最小、带删除标记的记录)</td>
</tr>
<tr>
<td><code>PAGE_MAX_TRX_ID</code></td>
<td align="center">8</td>
<td>当前页最大事务ID，仅在二级索引中定义</td>
</tr>
<tr>
<td><code>PAGE_LEVEL</code></td>
<td align="center">2</td>
<td>当前页在B+树种所处的层级</td>
</tr>
<tr>
<td><code>PAGE_INDEX_ID</code></td>
<td align="center">8</td>
<td>索引ID，当前页属于哪个索引</td>
</tr>
<tr>
<td><code>PAGE_BTR_SEG_LEAF</code></td>
<td align="center">10</td>
<td>B+树叶子端头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td><code>PAGE_BTR_SEG_TOP</code></td>
<td align="center">10</td>
<td>B+树叶非子端头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody></table>
<blockquote>
<p>部分解释如下：</p>
</blockquote>
<ul>
<li><code>PAGE_DIRECTION</code>，假如新插入的记录主键值比上一条大，则是向右插入，<code>PAGE_DIRECTION</code>用来记录插入方向。</li>
<li><code>PAGE_N_DIRECTION</code>，连续插入记录的方向是一致，则<code>PAGE_DIRECTION</code>为插入条数。方向改变则该值被清零</li>
</ul>
<h5 id="3-File-Header-文件头部"><a href="#3-File-Header-文件头部" class="headerlink" title="3. File Header(文件头部)"></a>3. File Header(文件头部)</h5><p><code>Page Header</code>是专门针对<code>Index</code>页记录的各种状态信息，<code>File Header</code>是针对各种类型的页。各种页都会以<code>File Header</code>为第一部分，描述了一些针对各种页的通用信息。如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">bit</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td>
<td align="center">4</td>
<td>页的校验和(checkSum值)</td>
</tr>
<tr>
<td><code>FIL_PAGE_OFFSET</code></td>
<td align="center">4</td>
<td>页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_PREV</code></td>
<td align="center">4</td>
<td>上一页页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_NEXT</code></td>
<td align="center">4</td>
<td>下一页页号</td>
</tr>
<tr>
<td><code>FIL_PAGE_LSN</code></td>
<td align="center">8</td>
<td>页面被最后修改时对应的日志序列位置</td>
</tr>
<tr>
<td><code>FIL_PAGE_TYPE</code></td>
<td align="center">2</td>
<td>页类型</td>
</tr>
<tr>
<td><code>FIL_PAGE_FILE_FLUSH_LSN</code></td>
<td align="center">8</td>
<td>仅仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值，(<code>LSN</code>，Log Sequence Number)</td>
</tr>
<tr>
<td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td>
<td align="center">4</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<ul>
<li><p><code>FIL_PAGE_SPACE_OR_CHKSUM</code>：通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。</p>
</li>
<li><p><code>FIL_PAGE_OFFSET</code>：页号</p>
</li>
<li><p><code>FIL_PAGE_TYPE</code>：当前页类型<a name="pageType"></a></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型名称</th>
<th align="center">十六进制</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>FIL_PAGE_TYPE_ALLOCATED</code></td>
<td align="center">0x0000</td>
<td align="center">最新分配，还没使用</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_UNDO_LOG</code></td>
<td align="center">0x0002</td>
<td align="center">Undo日志页</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_INODE</code></td>
<td align="center">0x0003</td>
<td align="center">段信息节点</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_IBUF_FREE_LIST</code></td>
<td align="center">0x0004</td>
<td align="center">Insert Buffer空闲列表</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_IBUF_BITMAP</code></td>
<td align="center">0x0005</td>
<td align="center">Insert Buffer位图</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_TYPE_SYS</code></td>
<td align="center">0x0006</td>
<td align="center">系统页</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_TYPE_TRX_SYS</code></td>
<td align="center">0x0007</td>
<td align="center">事务系统数据</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_TYPE_FSP_HDR</code></td>
<td align="center">0x0008</td>
<td align="center">表空间头部信息</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_TYPE_XDES</code></td>
<td align="center">0x0009</td>
<td align="center">扩展描述页</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_TYPE_BLOB</code></td>
<td align="center">0x000A</td>
<td align="center">BLOB页</td>
</tr>
<tr>
<td align="center"><code>FIL_PAGE_INDEX</code></td>
<td align="center">0x45BF</td>
<td align="center">索引页，也就是我们所说的数据页</td>
</tr>
</tbody></table>
<ul>
<li><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>，<code>InnoDB</code>中是以页为单位存储数据，当我们存储的数据占用的空间非常大时，<code>InnoDB</code>不可能有连续的存储空间，所以如果分散到多个不连续的空间时，就需要把页关联起来。<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就是上一页与下一页的页号，即是一个双向链表。并不是所有类型的页都有这两个属性。</li>
</ul>
<h5 id="4-File-Trailer"><a href="#4-File-Trailer" class="headerlink" title="4. File Trailer"></a>4. File Trailer</h5><p>用于检测一个页是否完整，由8个字节组成</p>
<ul>
<li>前4个字节代表页的校验和。当页的记录被修改了，同步到库之前就需要计算该页的校验和，因为<code>File Heaer</code>在页的前面，所以校验和会先被同步到磁盘，完全写完后也会被写到页的尾部，当完全同步成功时，则<code>File Header</code>和<code>File Trailer</code>内的校验和一致，否则代表同步过程出错。例如，写入到磁盘一半断电。</li>
<li>后4个字节代表页面被最后修改时对应的日志序列位置(<code>LSN</code>，Log Sequence Number)</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>Index</code>页。</li>
<li>一个数据页分为7个部分：<ul>
<li><code>File Header</code>，文件头部，38个字节，描述页的通用信息</li>
<li><code>Page Header</code>，页头部，56个字节，数据页专有信息</li>
<li><code>Infimum + Supermum</code>，最大记录和最小记录（虚拟记录或者位记录），26个字节</li>
<li><code>User Records</code>，真实数据，大小不固定，存储真实数据</li>
<li><code>Free Space</code>，空闲空间，大小不确定，页中尚未使用的部分</li>
<li><code>Page Directory</code>，页中某些记录的相对位置，即各个槽在页中的地址偏移量，大小不固定</li>
<li><code>File Trailer</code>，用于检验页是否完整的部分，占用固定的8个字节。</li>
</ul>
</li>
<li>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</li>
<li><code>InnoDB</code>会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul>
<li>通过二分法确定该记录所在的槽。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li>
</ul>
</li>
<li>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<code>双链表</code>。</li>
<li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB数据结构</title>
    <url>/blog/2019/07/16/mysql/4_innodb_data_structure/</url>
    <content><![CDATA[<blockquote>
<p><code>MySQL</code>是一个黑盒，我们一般只负责使用客户端发送请求并等待服务器返回结果。那么表中的数据到底存到了哪里？以什么格式存放的？<code>MySQL</code>是以什么方式访问这些数据的？</p>
</blockquote>
<blockquote>
<p><code>MySQL</code>服务器上对表中数据的读取和写入工作的是<strong>存储引擎</strong>，服务器支持不同的存储引擎，不同的存储引擎有不同的特性，<font color='red'>其数据在不同的存储引擎中存放的格式也不同</font>。具体见：<a href="https://www.effiu.cn/blog/2019/06/10/mysql/1_first_mysql/">认识MySQL</a>。以下以最常用的InnoDB存储引擎为例，说明存储引擎的记录结构。</p>
</blockquote>
<a id="more"></a>

<h5 id="1-InnoDB简介"><a href="#1-InnoDB简介" class="headerlink" title="1. InnoDB简介"></a>1. InnoDB简介</h5><p><strong>InnoDB</strong>是将数据存储到磁盘上的存储引擎。因为真正处理数据的过程是在内存中，所以当<code>MySQL</code>读取和写入数据时，需要把磁盘中的数据加载到内存中或者将内存中的数据写入到磁盘上。而读写磁盘速度很慢，所以InnoDB采取的方式是：<font color='red'>将数据划分为若干页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16KB</font>。</p>
<h5 id="2-InnoDB行格式"><a href="#2-InnoDB行格式" class="headerlink" title="2. InnoDB行格式"></a>2. InnoDB行格式</h5><p><code>MySQL</code>是以记录为单位向表中插入数据，所以这些记录在磁盘上存放方式称为<strong>行格式</strong>或者<strong>记录格式</strong>。<strong>InnoDB</strong>存储引擎有4中<strong>行格式</strong>：<code>Compact</code>、<code>Redunant</code>、<code>Dynamic</code>和<code>Compressed</code>。</p>
<h6 id="指定行格式的语法"><a href="#指定行格式的语法" class="headerlink" title="指定行格式的语法"></a>指定行格式的语法</h6><p>在创建表或者修改表语句中指定<strong>行格式</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table table_name (row_info) row_format&#x3D;compact;</span><br><span class="line">alter table table_name row_format&#x3D;compact;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以<code>learn</code>库的<code>record_format_demo</code>为例说明行格式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use learn;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE TABLE record_format_demo (c1 VARCHAR(10),c2 VARCHAR(10) NOT NULL,c3 CHAR(10), c4 VARCHAR(10)) CHARSET&#x3D;ascii ROW_FORMAT&#x3D;COMPACT;</span><br><span class="line">Query OK, 0 rows affected (0.18 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES(&#39;aaaa&#39;, &#39;bbb&#39;, &#39;cc&#39;, &#39;d&#39;), (&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);</span><br><span class="line">Query OK, 2 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from record_format_demo;</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">| c1   | c2  | c3   | c4   |</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">| aaaa | bbb | cc   | d    |</span><br><span class="line">| eeee | fff | NULL | NULL |</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="3-COMPACT行格式"><a href="#3-COMPACT行格式" class="headerlink" title="3. COMPACT行格式"></a>3. COMPACT行格式</h5><p><img src="https://images.effiu.cn/blog/mysql/1.png" alt="Compact行格式示意图"></p>
<p>一条完整的记录可以分为<strong>记录的额外信息</strong>和<strong>记录的真实数据</strong>两部分。</p>
<h6 id="1-记录的额外信息"><a href="#1-记录的额外信息" class="headerlink" title="1. 记录的额外信息"></a>1. 记录的额外信息</h6><p>这是服务器为了描述这条记录而添加的额外信息。分为3类：<strong>变长字段长度列表</strong>、<strong>NULL值列表</strong>和<strong>记录头信息</strong>。</p>
<ol>
<li><p>变长字段长度列表</p>
<p><code>MySQL</code>支持一些变长的数据类型，例如<code>VARCHAR(M)</code>、<code>VARBINARY(M)</code>、各种<code>TEXT</code>类型，各种<code>BLOG</code>类型。因为变长字段中存储的字节数据不固定，所以我们存储真实数据时需要把数据占用的字节数存起来。</p>
<ul>
<li>真正的数据内容</li>
<li>占用的字节数</li>
</ul>
<p>在<code>Compact</code>行格式中，把所有变长字段的真实数据占用的字节长度存放在记录的开头部位，形成了<strong>变长字段长度列表</strong>，各变长字段数据占用的字节数按照列的顺序<font color='red'>逆序存放</font>。</p>
<p>表<code>record_format_demo</code>表中<code>c1</code>、<code>c2</code>、<code>c4</code>都是<code>VARCHAR(10)</code>类型，且都是变长类型，所以这3列都需要存储到变长字段长度列表中。又因为是采用<code>ASCII</code>字符集，所以每个字符需要1各字节。所以其在变长字段长度列表中为<code>01 03 04</code>。</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">存储内容</th>
<th align="center">内容长度（十进制表示）</th>
<th align="center">内容长度（十六进制表示）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>c1</code></td>
<td align="center"><code>&#39;aaaa&#39;</code></td>
<td align="center"><code>4</code></td>
<td align="center"><code>0x04</code></td>
</tr>
<tr>
<td align="center"><code>c2</code></td>
<td align="center"><code>&#39;bbb&#39;</code></td>
<td align="center"><code>3</code></td>
<td align="center"><code>0x03</code></td>
</tr>
<tr>
<td align="center"><code>c4</code></td>
<td align="center"><code>&#39;d&#39;</code></td>
<td align="center"><code>1</code></td>
<td align="center"><code>0x01</code></td>
</tr>
</tbody></table>
<p>在变长字段长度列表中具体采用1个字节还是2个字节存储长度，根据真实数据占用的字节数判断。</p>
<p>假设一个字符最多使用字节数<code>W</code>，例如<code>utf8</code>是3个字节,<code>ascii</code>是1个字节,<code>gbk</code>是两个字节。对于<code>VARCHAR(M)</code>来说，最多可以存储<code>M</code>个字符，所以对多存储字节数是<code>W*M</code>。假设实际存储占用字节数是<code>L</code>。</p>
<ul>
<li><p>当<code>M*W &lt;= 255</code>时，使用1个字节表示真正的字符占用字节数</p>
</li>
<li><p>当<code>M*W &gt; 255 </code>时，有两种情况：</p>
<ul>
<li>若<code>L &lt;= 127</code>，则使用1个字节表示真正字符占用字节数</li>
<li>若<code>L &gt; 127</code>，则使用2个字节表示真正字符占用字节数</li>
</ul>
<blockquote>
<p>127是2^7，占7位，该字节的第一个二进制字节位用来表示某个字节是单独的字段长度还是半个字段长度。</p>
</blockquote>
</li>
</ul>
<p>综上所述，当<code>M*W &gt; 255</code>且<code>L &gt; 127</code>时，使用2个字节表示真正字符占用字节数，否则使用1个字节表示真正字符占用字节数。</p>
<blockquote>
<p>变长字段列表中只存储<strong>非NULL</strong>列内容占用长度，所以变长字段列表内容排列如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/mysql/2.png" alt="存储格式"></p>
</li>
</ol>
<p>​    <code>c3</code>列是<code>CHAR(10)</code>是定长列，对于定长字符列来说，该列不会被加入到变长字段列表中。</p>
<ol start="2">
<li><p>NULL值列表</p>
<p><code>MySQL</code>中列允许存储<code>NULL</code>值，但若把<code>NULL</code>值存储到记录的真实数据中会非常占用空间，所以<code>Compact</code>行格式把<code>NULL</code>值统一管理起来，存储到<code>NULL</code>值列表中。其过程如下:</p>
<ul>
<li>统计表中允许<code>NULL</code>值的列</li>
<li>若表中没有允许<code>NULL</code>值的列，则<code>NULL</code>值列表不存在，否则每个允许<code>NULL</code>值的列对应一个二进制位，二进制位按照列的顺序逆序排列，<code>1</code>表示该列位<code>NULL</code>,<code>0</code>表示列值不为<code>NULL</code>。</li>
<li><code>NULL</code>值列表必须用整数字节表示，不足整数字节则高位补<code>0</code>，例如，表中有9列允许<code>NULL</code>，则<code>NULL</code>值列表占两个字节，且高位补<code>0</code>。</li>
</ul>
<p>所以<code>record_format_demo</code>表内两条数据示意图如下:</p>
<p><img src="https://images.effiu.cn/blog/mysql/3.png" alt="数据示意图"></p>
</li>
<li><p>记录头信息</p>
<p>由固定的5个字节组成。5个字节即40个二进制位，不同位代表不同的意思，如下图：</p>
<p><img src="https://images.effiu.cn/blog/mysql/4.png" alt="记录头信息"></p>
<blockquote>
<p>以下是其详细描述，不需要了解</p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1/2</td>
<td align="center">1</td>
<td>未被使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td align="center">1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>min_rec_mask</code></td>
<td align="center">1</td>
<td>B+树的每层非叶子节点中最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td align="center">4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td align="center">13</td>
<td>表示当前记录在记录堆中的位置信息</td>
</tr>
<tr>
<td><code>record_type</code></td>
<td align="center">3</td>
<td>记录的类型,0:普通记录;1:B+树非叶子节点记录;2:最小记录;3:最大记录</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td align="center">16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
<h6 id="2-记录的真实数据"><a href="#2-记录的真实数据" class="headerlink" title="2. 记录的真实数据"></a>2. 记录的真实数据</h6><p><code>MySQL</code>会为每列添加一些隐藏列，具体如下：<a name='hiddenColumn'></a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th align="center">是否必须</th>
<th align="center">占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>DB_ROW_ID</code></td>
<td align="center">否</td>
<td align="center">6个字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td><code>DB_TRX_ID</code></td>
<td align="center">是</td>
<td align="center">6个字节</td>
<td>事务ID</td>
</tr>
<tr>
<td><code>DB_ROLL_PTR</code></td>
<td align="center">是</td>
<td align="center">7个字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>从上表中可以得出，<code>DB_TRX_ID</code>和<code>DB_ROLL_PTR</code>这两个隐藏列是必须的，而<code>DB_ROW_ID</code>是可选的。</p>
<p><strong style='color:red'><code>InnoDB</code>存储引擎对表主键的生成策略</strong>：优先使用用户自定义主键，若没有则选取一个<code>Unique</code>键作为主键，否则<code>InnoDB</code>会默认为表生成<code>DB_ROW_ID</code>隐藏列作为主键。</p>
<p><img src="https://images.effiu.cn/blog/mysql/5.png" alt="表数据结构"></p>
<blockquote>
<p>综上所述，表数据结构如上。第一条数据的C3列，<code>CHAR(10)</code>，所以占用10个字节空间。不足用空格填充。第二条数据的<code>c3</code>、<code>c4</code>列，在<code>NULL</code>值列表中。</p>
</blockquote>
<h5 id="4-Redundant行格式"><a href="#4-Redundant行格式" class="headerlink" title="4. Redundant行格式"></a>4. Redundant行格式</h5><p><code>Mysql 5.0</code>之前使用的一种行格式，非常古老。</p>
<h5 id="5-行溢出数据"><a href="#5-行溢出数据" class="headerlink" title="5. 行溢出数据"></a>5. 行溢出数据</h5><h6 id="1-列最多存储的数据"><a href="#1-列最多存储的数据" class="headerlink" title="1. 列最多存储的数据"></a>1. 列最多存储的数据</h6><p>对于<code>VARCHAR(M)</code>类型的列，最多存储65535(2^16)个字节，<code>M</code>表示最多存储的字符数量，当使用<code>ascii</code>字符集的话，一个字符代表一个字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="function">CREATE TABLE <span class="title">varchar_size_demo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    -&gt;     c VARCHAR(<span class="number">65535</span>)</span></span></span><br><span class="line"><span class="function">    -&gt; ) CHARSET</span>=ascii ROW_FORMAT=Compact;</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): Row size too large. The maximum row size <span class="keyword">for</span> the used table type, not counting BLOBs, is <span class="number">65535.</span> This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs</span><br></pre></td></tr></table></figure>

<p>上述SQL报错，说明65535超过<code>MySQL</code>最大存储空间限制了，除了<code>BLOG</code>和<code>TEXT</code>列之外，其他所有列占用的字节长度均不能超过65535个字节。报错中提示<code>This includes storage overhead</code>，是因为除了记录本身数据之外，还会存储一些其他数据</p>
<ul>
<li>真实数据</li>
<li>展示数据占用字节长度，长度最大为65535，所以数据长度占用2个字节</li>
<li><code>NULL</code>标识，如果该列有<code>NOT NULL</code>属性，则可以没有这部分存储空间，占用1个字节</li>
</ul>
<blockquote>
<p>当列用<code>NOT NULL</code>标识，则真实数据最大为<code>65533</code>，否则最大为<code>65532</code></p>
<p>当字符集非<code>ascii</code>时，可存储字符数<code>M</code>取决与一个字符最多需要的字节数<code>W</code></p>
</blockquote>
<h6 id="2-记录数据太大产生溢出"><a href="#2-记录数据太大产生溢出" class="headerlink" title="2. 记录数据太大产生溢出"></a>2. 记录数据太大产生溢出</h6><p><font color='red'>溢出的原因</font>： <code>MySQL</code>中磁盘和内存交互的基本单位是<strong>页</strong>，<code>MySQL</code>是以页为基本单位管理存储空间的，记录也是以存储到页中的，一页大小是<code>16KB</code>。即<code>16*1024</code>字节，而<code>VARCHAR(M)</code>最多存储<code>65532</code>个字节，这就产生了一页存储不了数据的情况。</p>
<p><font color='red'>解决方案</font>：在<code>Compact</code>和<code>Reduntant</code>行格式中，对于存储空间大的列，在<strong>记录真实数据处</strong>的地方，只会存储该列的部分数据，把剩余数据存储到其余几页中，然后在<strong>记录真实数据处</strong>用20个字节指向这些页的地址等信息，超出<strong>真实数据处</strong>的部分被称为<code>溢出页</code></p>
<blockquote>
<p>所有数据类型当数据很长时都会发生<strong>行溢出</strong>。</p>
</blockquote>
<h6 id="3-溢出的临界点"><a href="#3-溢出的临界点" class="headerlink" title="3. 溢出的临界点"></a>3. 溢出的临界点</h6><blockquote>
<p>当存储多少字节时就会发生<code>行溢出</code>呢？</p>
</blockquote>
<ul>
<li><code>MySQL</code>规定每页中最少存储两条记录</li>
<li>每页除了存放记录之外，还会存储一些额外信息，占用132个字节空间</li>
<li>每个记录的额外信息时27个字节<ul>
<li>2个字节用于存储真实数据的长度</li>
<li>1个字节用于存储列是否是NULL值</li>
<li>5个字节大小的头信息</li>
<li>6个字节的<code>row_id</code>列</li>
<li>6个字节的<code>transaction_id</code>列</li>
<li>7个字节的<code>roll_pointer</code>列</li>
</ul>
</li>
</ul>
<p><code>132 + (27 + n) * 2 &lt; 16*1024</code>，得出<code>n=8099</code>，得出当存储数据小于<code>8099</code>个字节时不会发生溢出。</p>
<h5 id="5-Dynamic和Compressed行格式"><a href="#5-Dynamic和Compressed行格式" class="headerlink" title="5. Dynamic和Compressed行格式"></a>5. Dynamic和Compressed行格式</h5><p><code>Dynamic</code>与<code>Compact</code>类似，但在<font color='red'>行溢出</font>时直接把所有字节存储到其他页面中，只在记录真实数据存储其他页面地址。</p>
<p><code>Compressed</code>行格式和<code>Dynamic</code>不同的一点是，<code>Compressed</code>行格式会采用压缩算法对页面进行压缩，以节省空间。</p>
<h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h5><ol>
<li><strong>页</strong>是<code>MySQL</code>数据库磁盘和内存交互的基本单位，也是<code>MySQL</code>管理存储空间的基本单位。</li>
<li><code>InnoDB</code>定义了4种行格式<ul>
<li><code>COMPACT</code></li>
<li><code>Reduntant</code></li>
<li><code>Dynamic</code></li>
<li><code>Compressed</code></li>
</ul>
</li>
<li>一页大小<code>16KB</code>，当记录种数据太多时，会发生<code>行溢出</code>现象。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机类加载</title>
    <url>/blog/2019/07/14/jvm/7_jvm_class_load/</url>
    <content><![CDATA[<p>虚拟机如何加载<strong>Class</strong>文件？<strong>Class</strong>文件中的信息进入到虚拟机后会发生什么变化？</p>
<p>虚拟机把描述类的数据从<strong>Class</strong>文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，就是虚拟机的加载机制。</p>
<p>在Java中类型的加载、连接和初始化过程都是在程序运行过程中完成的，这虽然会在类加载时增加性能开销但是，会为Java提供高度的灵活性，Java可以动态扩展的语言特性就是依赖运行期间动态加载和动态连接实现的。例如，面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义的累加载器，让一个本地的应用程序在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分（OSGi技术）。</p>
<a id="more"></a>

<h5 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1. 类加载时机"></a>1. 类加载时机</h5><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，声明周期如下：</p>
<p><img src="https://images.effiu.cn/blog/jvm/16.png" alt="类的声明周期"></p>
<p>加载、验证、准备、初始化、卸载的顺序是确定的，解析则在某些情况下可以在初始化阶段之后开始（为了支持Java语言的运行时绑定，即动态绑定或者晚期绑定）。</p>
<p>JVM规范中并没有强制约定类的加载时机。对于初始化阶段（加载、验证、准备阶段要保证在初始化之前完成），<font color='red'>有且只有5种场景</font>中的行为成为对一个类进行主动引用。规范如下：</p>
<ul>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>字节码指令时，若类未初始化，则要触发初始化操作。常见场景：<ul>
<li><code>new</code>关键字实例化对象</li>
<li>读取或者设置类的静态字段时（被<code>final</code>修饰、已在编译器把结果放入常量池的静态字段除外）</li>
<li>调用一个类的静态方法时</li>
</ul>
</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时，若没有进行初始化，则对类进行初始化</li>
<li>初始化一个类时，其父类没有进行初始化，需要先触发其父类初始化</li>
<li>虚拟机启动时，用户需要指定一个需要执行的主类（保护<code>main()</code>方法的类），虚拟机会先初始化这个主类</li>
<li>使用<strong>JDK7</strong>的动态语言支持时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// SuperClass init!</span></span><br><span class="line">    <span class="comment">// SubClass init</span></span><br><span class="line">	<span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// SuperClass init!</span></span><br><span class="line">	<span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NotInitialization</code>的<code>main()</code>方法引用父类静态字段，不会导致子类初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  -XX:+TraceClassLoading观察类加载过程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过数组定义引用类，不会触发次类的初始化。<code>-XX:+TraceClassLoading</code>查看类加载过程</p>
<p>发现<code>[Loaded com.effiu.essay.jvm.classloader.SuperClass</code>类的初始化，是由虚拟机自动生成的，直接继承与<code>java.lang.Object</code>的子类，创建动作由字节码指令<code>newarray</code>触发，是一个一维数组，数组的方法都实现在这个类里（这也是比C/C++安全的原因），当检测到发生数组越界时抛出<code>java.lang.ArrayIndexOutOfBoundsException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  -XX:+TraceClassLoading观察类加载过程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码没有初始化<code>ConstClass</code>类，因为<code>HELLOWORLD</code>是<code>final</code>的，其已经在编译节点通过常量传播优化，已经将”hello world”存储到了<code>NotInitialization</code>类的常量池中，后续<code>NotInitialization</code>对常量的引用实际被转化为<code>NotInitializationi</code>对自身常量池的引用。</p>
<p>接口的记载过程与类加载过程区别:</p>
<ul>
<li>接口中没有<code>static</code>代码块，但是编译器仍会为接口生成<code>&lt;clinit&gt;</code>类构造器，用于初始化接口中定义的成员变量</li>
<li>接口初始化时，并不要求父类接口全部完成初始化，只有在真正使用父类接口时（引用父类接口中的常量或者方法），才会初始化</li>
</ul>
<h5 id="2-类加载的过程"><a href="#2-类加载的过程" class="headerlink" title="2. 类加载的过程"></a>2. 类加载的过程</h5><p>类加载过程：加载、验证、准备、解析、初始化。</p>
<h6 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h6><p><a name='classLoader'>加载阶段虚拟机</a>需要完成以下3件事：</p>
<ol>
<li><p>通过一个类的全限定名获取定义此类的二进制字节流，这是一个相对开放的过程，例如：</p>
<ul>
<li>从ZIP包中读取，例如，JAR、WAR、EAR包</li>
<li>从网络中获取，例如，Applet</li>
<li>运行时计算生成，例如，动态代理技术，在<code>java.lang.reflect.Proxy</code>中使用<code>ProxyGenerator.generateProxyClass</code>为接口生成形式为<code>**Proxy</code>的代理类的二进制字节流</li>
<li>由其他文件生成，例如，JSP文件</li>
<li>从数据库中读取，在中间件服务器中可以选择把程序安装到数据库中完成程序代码在集群见的分发</li>
</ul>
<p>非数组类的加载阶段（获取类的二进制字节流的动作）可控性最强，即可以使用系统提供的累加载器完成，也可以由用户自定义类加载器完成，开发人员可以通过自定义自己的类加载器去控制字节流的获取方式（重写类加载器的<code>loadClass()</code>方法）</p>
<p>对于数组而言，数组本身不通过类加载器创建，而是由Java虚拟机直接创建的。数组的元素类型由加载器创建，数组类的创建过程规则如下：</p>
<ol>
<li>数组的组件类型是引用类型，递归采用<a href='#classLoader'>类加载过程</a>去加载这个组件类型，数组将在加载数组类型的类加载器的类名称空间上被标识（一个类必须与类加载器一起确定唯一性）</li>
<li>数组的组件类型不是引用类型，例如，int[]。Java虚拟机将会把数组标记为与引导类加载器关联</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类不是引用类型，那数组类的可见性默认为<code>public</code></li>
</ol>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>在类加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。</p>
</li>
<li><p>在内存中生成一个代表该类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据访问入口。对于<code>HotSpot</code>虚拟机而言，Class对象存储在方法区中。</p>
</li>
</ol>
<blockquote>
<p>加载过程与连接过程的部分内容是交叉进行的，加载阶段未完成，连接阶段可能已经开始。</p>
</blockquote>
<h6 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h6><p>验证时连接阶段的第一步，目的是为了确保<strong>Class</strong>文件的字节流中包含的信息符合Java虚拟机的要求，且不会危害虚拟机自身的安全。<strong>Class</strong>文件并不是一定由Java编译而来，其可以使用任何途径产生，甚至可以使用十六进制编译器直接编写产生Class文件。</p>
<p>验证阶段非常重要，直接决定了Java虚拟机是否能承受恶意攻击。验证阶段在虚拟机的类加载子系统中占了相当大的一部分。整体上看，验证阶段分为以下4个阶段的检查动作：</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<ol>
<li><p>文件格式验证。验证点包括但不限于：</p>
<ul>
<li>是否已魔数值<code>0xCAFEBABY</code>开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li><code>CONSTANT_Utf8_info</code>型的常量中是否有不符合<strong>UTF8</strong>编码的数据</li>
<li><strong>Class</strong>文件中各个部分以文件本身是否有被删除的或附加的其他信息</li>
<li>······</li>
</ul>
<p>该验证阶段的主要目的，是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。是基于二进制流验证的，只有通过了此验证，字节流才会进入内存的方法区进行存储。</p>
</li>
<li><p>元数据验证</p>
<p>对字节码描述的的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，主要是对类的元数据信息进行语义校验。包括但不限于：</p>
<ul>
<li>类是否存在父类（除<code>java.lang.Object</code>）</li>
<li>类的父类是否继承了不被允许继承的类（<code>final修饰的类</code>）</li>
<li>类非抽象类，是否实现了其父类或者接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾（重写父类<code>final</code>方法、不符合规则的重载）</li>
<li>······</li>
</ul>
</li>
<li><p>字节码验证</p>
<p>是整个验证过程中最复杂的一个阶段。目的是保证通过数据流和控制流分析，确定程序语义是合法、符号逻辑的。该阶段是对类的方法进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体重的类型转换是有效的，可以直接向上转型，但不能向下转型。</li>
</ul>
<p>类的方法体没有通过字节码验证，那类肯定有问题，若一个方法体通过了字节码验证也不一定是安全的。数据流验证具有高复杂性。为了避免过多消耗时间在字节码验证阶段，虚拟机给方法体的<code>Code</code>属性表中增加了一项名为<code>StackMapTable</code>的属性，其描述了方法体中所有的基本块开始时本地变量表和操作数栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检测<code>StackMapTable</code>属性中的记录是否合法，通过在字节码验证的类型推导转变为类型检查从而节省了时间。</p>
</li>
<li><p>符号引用验证</p>
<p>其发生在虚拟机将符号引用转化为直接引用的时候，一般在解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中各种符号引用）的信息进行匹配性校验，包括但不限于以下验证项：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性是否可以被当前类访问</li>
<li>······</li>
</ul>
<p>符号引用验证的目的是确保解析动作能正常执行，不能通过符号验证，则抛出<code>java.lang.IncompatibleClassChangeError</code>异常的子类，例如<code>java.lang.IllegalAccessError</code>、<code>java.lang.NoSuchMethodFieldError</code>、<code>java.lang.NoSuchMethodError</code>等。对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不一定必要（对程序运行没有影响）的阶段。对于自己写的代码，可以通过<code>-Xverify:none</code>参数关闭大部分的类验证措施，以缩短类加载的时间。</p>
</li>
</ol>
<h6 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h6><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<ul>
<li>对类变量进行内存分配的仅仅包括类变量(<code>static</code>修饰的变量)，不包括实例变量，实例变量将在对象实例化时随着对象一起分配在Java堆中</li>
<li>初始值是数据类型的零值，以下区别见<a href='6_class_structure#constantValue'>ConstantValue</a><ul>
<li><code>public static int value=123;</code>准备阶段的初始值是0，<code>value</code>赋值为<code>123</code>是在类的初始化阶段由类构造器<code>&lt;clinit&gt;</code>方法中。</li>
<li><code>public static final int value=123;</code>，这种在准备阶段变量<code>value</code>就会被初始化为<code>ConstantValue</code>属性所指定的值。</li>
</ul>
</li>
</ul>
<h6 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h6><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用与直接引用的区别:</p>
<ul>
<li><a href='/blog/2019/06/22/jvm/6_class_structure/#symbolicReference'>符号引用</a>：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义定位到目标即可。其与JVM无关，因为其定义在<strong>Class</strong>文件格式中</li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，其是和虚拟机相关的。</li>
</ul>
<p>虚拟机规范中没有规定解析发生的具体时间，只要求了在执行<code>anewarray</code>、<code>checkcast</code>、<code>getfield</code>、<code>getstatic</code>、<code>instanceof</code>、<code>invokedynamic</code>、<code>invokeinterface</code>、<code>invokespecial</code>、<code>invokestatic</code>、<code>invokevirtual</code>、<code>ldc</code>、<code>ldc_w</code>、<code>multianewarray</code>、<code>new</code>、<code>putfield</code>、<code>putstatic</code>这16个用于操作符号引用的字节码指令之前，需要先对其所使用的符号引用进行解析。虚拟机可以根据需要判断在类被加载器加载时对常量池中的符号引用解析，还是等到一个符号引用要被使用前解析。</p>
<p>高并发情况下会出现对同一个符号引用进行多次解析请求，除<code>invokedynamic</code>指令外，虚拟机会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量池标识为已解析状态）从而避免解析动作重复进行。 <code>invokedynamic</code>指令目的是用于动态语言支持，所以必须等到程序实际运行到这条指令时，解析动作才会进行。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，对应于常量池的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>、<code>CONSTANT_Interfaceref_info</code>、<code>CONSTANT_MethodType_info</code>、<code>CONSTANT_MethodHandle_info</code>、<code>CONSTANT_InvokeDynamic_info</code>7中常量类型。</p>
<ol>
<li><p>类或接口解析</p>
<blockquote>
<p>假设当前代码所处的类为D，要把从未解析过的符号引用S，解析为一个类或者接口C的直接引用，那么步骤如下：</p>
</blockquote>
<ol>
<li>若C不是数组，那么虚拟机会把代表S的全限定类名传递给D的类加载器去加载这个C，会在加载过程中进行元数据验证、字节码验证等，可能会触发其他类的加载动作（父类等）。</li>
<li>若C是数组，且数组元素类型为对象，那么S的描述符会是类似<code>[java/lang/Integer</code>的形式，将会按照第一步加载数组元素类型，然后由虚拟机生成一个代表次数组维度和元素的数组对象。</li>
<li>1和2未出现任何异常，那么C实际上已经是有效接口了，在解析完成前要进行符号引用验证，确认D是否具有对C的访问权限。</li>
</ol>
</li>
<li><p>字段解析</p>
<p>首先需要对<code>class_index</code>中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，即字段所属的类或者接口的符号引用。若类或者接口的符号引用解析出现异常则会导致字段解析失败</p>
<ol>
<li>C本身包含了简单名称和字段描述符都与模板匹配的字段，则返回字段的直接引用</li>
<li>否则，若C实现了接口，那么将会按照继承关系从下往上递归搜索接口直到包含简单名称和字段描述符都匹配的字段，返回字段的直接引用</li>
<li>否则，若C不是<code>java.lang.Object</code>，将会按照继承关系从下往上递归搜索直到父类中包含简单名称与字段描述符都与目标匹配的字段</li>
<li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常</li>
<li>查找成功，则对字段进行权限验证</li>
</ol>
</li>
<li><p>类方法解析</p>
<p>类方法解析第一步与<strong>字段解析</strong>一致。需要先解析<code>class_index</code>中索引方法所属的类或接口的符号引用</p>
<ol>
<li>类方法和接口方法符号引用的常量定义是分开的，当在类方法中发现<code>class_index</code>中索引的C是接口，则抛出异常<code>java.lang.IncompatbleClassChangeError</code></li>
<li>在类C中查找是否存在简单名称与描述符都与目标相匹配的方法</li>
<li>否则，C类的父类中递归查找</li>
<li>否则，在C实现的接口列表及父接口中递归查找是否存在相匹配的方法</li>
<li>否则抛出<code>java.lang.NoSuchMethodError</code></li>
</ol>
</li>
<li><p>接口方法解析</p>
<ol>
<li>解析出接口方法表<code>class_index</code>项中索引的方法所属的类或接口的符号引用</li>
<li>若在接口方法表中的索引C是类而非接口，抛出异常<code>java.lang.IncompatibleClassChangeError</code></li>
<li>否则，在接口C中查找符合的方法</li>
<li>否则，在C的父类中查找符合的方法</li>
<li>查找失败，抛出<code>java.langNoSuchMethodError</code></li>
<li>接口默认是<code>public static final</code>修饰，所以不需要进行权限认证。</li>
</ol>
</li>
</ol>
<ul>
<li><input disabled="" type="checkbox"> 其他3种符号引用？</li>
</ul>
<h6 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h6><p>类初始化是类加载过程的最后一步，在类的加载、连接阶段，只有在加载阶段用户应用程序可以通过自定义类加载器参与，其余动作完全由虚拟机主导和控制。在类初始化阶段才真正开始执行类中的Java程序代码(字节码)</p>
<p>准备阶段，变量由Java虚拟机初始化为系统要求的初始值。在初始化阶段则根据程序员通过程序制定的主观代码去初始化类变量和其他资源。初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<ul>
<li><input disabled="" type="checkbox"> <code>&lt;clinit&gt;()</code>方法如何生成？</li>
</ul>
<ul>
<li><p><code>&lt;clinit&gt;</code>方法是由编译器自动收集类中的所有类变量的赋值和静态语句块(<code>static&#123;&#125;</code>块)中的语句合并产生的。静态语句块只能访问到定义在静态语句块之前的变量。</p>
<blockquote>
<p><code>static</code>成员在<code>&lt;clinit&gt;</code>类构造器中初始化</p>
<p><code>static final</code>常量修饰的基本数据类型以及<code>java.lang.String</code>成员则使用<code>ConstantValue</code>初始化。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;					<span class="comment">// 可以在声明static变量前赋值</span></span><br><span class="line">        System.out.println(i);	 <span class="comment">// 不可以访问，编译器会提示&quot;非法向前引用&quot;</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法与类的构造器函数(<code>&lt;init&gt;</code>)不同，其不需要显式调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;</code>方法已经执行完毕。</p>
</li>
<li><p>父类<code>&lt;clinit&gt;()</code>方法优先执行，所以父类中定义的静态语句块优先于子类变量赋值操作执行</p>
</li>
<li><p><code>&lt;clinit&gt;</code>方法对于类或者接口非必需，若类中没有静态语句块且没有对变量的赋值操作，那么编译器可以不为类生成<code>&lt;clinit&gt;</code>方法</p>
</li>
<li><p>接口中不能使用静态语句块，但是存在变量的赋值操作，所以JVM会为接口生成<code>&lt;clinit&gt;</code>方法。但是接口中<code>&lt;clinit&gt;</code>方法不需要先执行父接口中的<code>&lt;clinit&gt;</code>，只有当父类接口中定义的变量使用时，父接口才会初始化。接口实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;</code>方法。</p>
</li>
<li><p>虚拟机会保证一个类的<code>&lt;clinit&gt;</code>方法在多线程环境中被正确的加锁、同步。若多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;</code>方法，其他线程都需要阻塞等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Illegal forward reference 编译器警告,非法向前引用</span></span><br><span class="line"><span class="comment">//        System.out.println(i);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">static</span> &#123;</span><br><span class="line">        	<span class="comment">//TODO 不加if，编译器提示“Initializer must be able to complete normally”</span></span><br><span class="line">        	<span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            	System.out.println(Thread.currentThread() + <span class="string">&quot;init DeadLoopClass&quot;</span>);</span><br><span class="line">            	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            	&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable scritp = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">            DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;run over&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(scritp);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(scritp);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]init DeadLoopClass</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，只有一个线程初始化<code>DeadLoopClass</code>，其他线程阻塞等待</p>
</blockquote>
</li>
</ul>
<h5 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3.类加载器"></a>3.类加载器</h5><p>虚拟机设计团队把类加载阶段中的“<font color='red'>通过一个类的全限定类名来获取描述此类的二进制字节流</font>”这个动作放到<strong>Java</strong>虚拟机外部去实现，便于应用程序自己决定如何获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>类加载器在类层次划分、OSGI、热部署、代码加密等领域应用很广泛。</p>
<h6 id="1-类与类加载器"><a href="#1-类与类加载器" class="headerlink" title="1. 类与类加载器"></a>1. 类与类加载器</h6><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在其Java虚拟机中的唯一性，每一个类加载器都有一个独立的类命名空间，即比较两个类是否相等，只有在这两个类都是由同一个类加载加载的前提下才有意义，否则即使来源于同一个<strong>Class</strong>文件，两个类也不相等（代表Class对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法、<code>instanceof</code>关键字做对象所属关系判定等情况）。</p>
<h6 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2. 双亲委派模型"></a>2. 双亲委派模型</h6><p>对于Java虚拟机来说只有<font color='red'>两种类加载器</font>：</p>
<ul>
<li>启动类加载器(<code>BootStrap ClassLoader</code>)：使用<code>C++</code>实现，是虚拟机自身的一部分</li>
<li>所有其他的类加载器：由<strong>Java</strong>语言实现，独立于虚拟机外部，全部继承自抽象类<code>java.lang.ClassLoader</code></li>
</ul>
<p>从Java开发者角度看，可以划分地更细致一些：</p>
<ul>
<li>启动类加载器(<code>Bootstrap ClassLoader</code>)：负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数指定的路径中的，且可以被虚拟机识别的(仅仅按照文件名识别)类库加载到虚拟机内存中，该加载器无法被Java程序直接引用，用户在编写自定义类加载器时，若需要把加载请求委派给引导类加载器直接使用<code>null</code>代替。</li>
<li>拓展类加载器(<code>Extension ClassLoader</code>)：这个加载器由<code>sun.mics.Launcher$ExtClassLoader</code>实现，负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的类库，开发者可以直接使用扩展类加载器</li>
<li>应用程序类加载器(<code>Application ClassLoader</code>)：由<code>sun.misc.Launcher$AppClassLoader</code>实现，这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值。负责加载用户类路径(ClassPath)上所指定的额类库，开发者可以直接使用该类加载器。若用户没有自定义类加载器，那么应用程序类加载器就是程序中默认的类加载器。</li>
</ul>
<p><img src="https://images.effiu.cn/blog/jvm/17.png" alt="双亲委派模型"></p>
<p>上图中类加载器之间的层次关系称为双亲委派模型(Parents Delegation Model)，其要求除了顶层启动类加载器之外，其余的类加载器都应该有自己的父类加载器。父子关系不会以继承关系实现，而是使用组合(Composition)关系复用父类加载器代码。</p>
<p><strong style='color:red'>双亲委派模型工作过程</strong>：如果一个类加载器收到了加载类的请求，它首先会把这个请求委派给父类加载器完成，所以所有的类加载请求都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成家在请求时，子类加载器才会尝试自己去加载。<strong style='color:red'>优点</strong>：Java类随着它的加载器一起具备了一种带有优先级的层次关系，防止应用程序变得混乱，其对于保证Java程序稳点运作很重要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 没有被加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用父类加载器加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 父类加载器为空，默认使用启动类加载器作为父加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 加载失败抛出异常</span></span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">// 使用自己的加载器加载类</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-破坏双亲委派模型"><a href="#3-破坏双亲委派模型" class="headerlink" title="3. 破坏双亲委派模型"></a>3. 破坏双亲委派模型</h6><p>双亲委派模型非强制性的约束模型，到目前为止出现过3次大规模的破坏情况：</p>
<ol>
<li><p>双亲委派模型出现之前——JDK1.2发布之前。针对已经存在的自定义的类加载器，JDK1.2添加了一个<code>protected</code>方法<code>findClass()</code>，对于已经存在的类加载来说，继承<code>java.lang.ClassLoader</code>的目的就是重写<code>loadClass()</code>方法。虚拟机在进行类加载时会调用<code>loadClassInternal()</code>，作用是调用自己的<code>loadClass()</code>。JKD1.2后不建议覆盖<code>loadClass()</code>，而是把自己的类加载逻辑写到<code>findClass()</code>中，在<code>loadClass()</code>中若父类加载失败则会调用自己的<code>findClass()</code>完成加载，这样就会保证符合双亲委派模型。</p>
</li>
<li><p>自身缺陷导致。双亲委派解决了各个类加载器的基础类的统一问题(越基础的类由越上层的加载器进行加载)，但是如果基础类调回用户的代码，例如<strong>JNDI(Java Naming And Directory Interface)**如何解决？</strong>JNDI<strong>由启动类加载器加载，但是其会对资源进行集中管理和查找，需要调用独立厂商实现并部署在应用程序的</strong>ClassPath**下的接口提供者(SPI, Service Provider Interface)的代码，但是启动类并不认识这类代码。</p>
<p><font color='red'>解决方案</font>：线程上下文类加载器(Thread Context ClassLoader)。该类加载器可以通过<code>java.lang.Tread</code>类的<code>setContextClassLoader()</code>方法设置，当创建线程时未设置，将会从父线程中继承一个，当全局范围内没有设置时，默认是应用程序类加载器。<strong>JNDI</strong>使用这个类加载器去加载所需要的SPI代码，即父类加载器请求子类加载器去完成类加载动作，这实际上已经打破了双亲委派模型。例如：JNID、JDBC等。</p>
</li>
<li><p>用户对程序动态性追求导致。动态性指“代码热替换(HotSwap)”、“模块热部署(Hot Deployment)”等。<strong>OSGi</strong>实现模块化热部署的关键是自定义的类加载器机制的实现。每一个程序模块(OSGi中称为Bundle)都有一个自己的类加载器，当你需要更换一个Bundle时，就把Bundle连同类加载器一同换掉。在<strong>OSGi</strong>中类加载器不是双亲委派模型中的树状结构，而是网状结构。收到类加载请求时，<strong>OSGi</strong>将按照如下顺序进行搜索：</p>
<ol>
<li>将以<code>java.*</code>开头的类委派给父类加载器加载</li>
<li>非<code>java.*</code>委派给父类加载器加载</li>
<li>否则，将<code>import</code>列表中的类委派给Export这个类的<strong>Bundle</strong>的类加载器加载</li>
<li>否则，查找当前<strong>Bundle</strong>的ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的<strong>Fragment Bundle</strong>中</li>
<li>否则，查找<strong>Dynamic Import</strong>列表的<strong>Bundle</strong>，委派给对应的<strong>Bundle</strong>类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
<p>以上，只有前两点符合双亲委派模型，其他类查找都是在平级的类加载器中进行</p>
</li>
</ol>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h5><p>介绍了类加载过程的“加载”、“验证”、“准备”、“解析”、“初始化”这5各阶段中虚拟机做的事情，还介绍了类加载器的工作原理及其对虚拟机的意义</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>字节码指令</title>
    <url>/blog/2019/06/23/jvm/6_bytecode_instruction/</url>
    <content><![CDATA[<p>Java虚拟机的指令是由一个字节长度的、代表着某种特定操作含义的数字(操作码)以及跟随其后的零至多个代表次操作所需的参数（操作数）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码。</p>
<p>字节码长度为1个字节，指令集的操作码总数不能超过256条，又由于<strong>Class</strong>文件格式放弃了编译后代码的操作数长度对齐，所以虚拟机处理超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，例如，一个16位的无符号证书使用两个无符号字节存储（byte1、byte2），即<code>(byte1 &lt;&lt; 8) | byte2</code>。这虽然会损失一些性能，但放弃了操作数对齐可以省略很多填充和间隔符号，一个字节代表操作码，也可以获得短小精干的编译代码。<font color='red'>小数据量、高传输效率</font>。</p>
<a id="more"></a>

<h6 id="1-字节码与数据类型"><a href="#1-字节码与数据类型" class="headerlink" title="1. 字节码与数据类型"></a>1. 字节码与数据类型</h6><p>在Java虚拟机指令集中，大多数指令都包含了其操作所对应的数据类型信息。例如，<code>iload</code>和<code>fload</code>，其在虚拟机内部可能由同一段代码实现，但是<strong>Class</strong>文件中它们拥有各自的操作码。</p>
<p>大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表示为哪种数据类型服务</p>
<ul>
<li><code>i</code>代表<code>int</code>类型数据操作</li>
<li><code>l</code>代表<code>long</code></li>
<li><code>f</code>代表<code>float</code></li>
<li><code>s</code>代表<code>short</code></li>
<li><code>b</code>代表<code>boolean</code></li>
<li><code>c</code>代表<code>char</code></li>
<li><code>d</code>代表<code>double</code></li>
<li><code>a</code>代表<code>reference</code></li>
</ul>
<p>还有一些没有明确指明操作类型的对象，例如<code>arraylength</code>。还有与数据类型无关的指令<code>goto</code>等。</p>
<p>Java虚拟机操作码长度只有一个字节，总数有限，因此<strong>JVM</strong>虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，即指令集将会故意被设计成非完全独立（并非每种数据类型和每一种操作都需要有对应的指令），有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p>
<blockquote>
<p>编译器会在编译期或运行期将<code>byte</code>和<code>short</code>类型的数据带符号扩展为相应的<code>int</code>类型数据，将<code>boolean</code>和<code>char</code>类型数据零位扩展为相应的int类型数据。处理<code>char</code>、<code>byte</code>、<code>boolean</code>、<code>short</code>数组时也会转换为对应的<code>int</code>类型的字节码指令处理。以上四种类型实际上使用相应的<code>int</code>类型作为运算类型。</p>
</blockquote>
<h6 id="2-加载和存储指令"><a href="#2-加载和存储指令" class="headerlink" title="2. 加载和存储指令"></a>2. 加载和存储指令</h6><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。包括以下内容：</p>
<ul>
<li>将一个局部变量加载到操作栈：<code>iload</code>、<code>iload_&lt;n&gt;</code>、<code>lload</code>、<code>lload_&lt;n&gt;</code>、<code>fload</code>、<code>fload_&lt;n&gt;</code>、<code>dload</code>、<code>dload_&lt;n&gt;</code>、<code>aload</code>、<code>aload_&lt;n&gt;</code></li>
<li>讲一个数值从操作栈存储到局部变量表:<code>istore</code>、<code>istore_&lt;n&gt;</code>、<code>lstore</code>、<code>lstore_&lt;n&gt;</code>、<code>fstore</code>、<code>fstore_&lt;n&gt;</code>、<code>dstore</code>、<code>dstore_&lt;n&gt;</code>、<code>astore</code>、<code>astore_&lt;n&gt;</code>。</li>
<li>讲一个常量加载到操作数栈:<code>bipush</code>、<code>sipush</code>、<code>ldc</code>、<code>ldc_w</code>、<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;i&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code>。</li>
<li>扩充局部变量表的访问索引指令:<code>wide</code>。</li>
</ul>
<p>除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数占传输数据。</p>
<p>以尖括号结尾(例如，<code>iload_&lt;n&gt;</code>)代表了一组指令，(例如，<code>iload_1</code>、<code>iload_2</code>、<code>iload_3</code>、<code>iload_4</code>)，其均是某个带有操作数的通用指令。例如，<code>iload_0</code>等于与操作数为0的<code>iload</code>指令完全一致。</p>
<h6 id="3-运算指令"><a href="#3-运算指令" class="headerlink" title="3. 运算指令"></a>3. 运算指令</h6><p>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。分为两种：</p>
<ul>
<li>对整型数据进行运算的指令</li>
<li>对浮点型数据进行运算的指令</li>
</ul>
<blockquote>
<p>对<code>byte</code>、<code>short</code>、<code>char</code>、<code>boolean</code>类型的算术指令，均使用操作<code>int</code>类型的指令代替。</p>
</blockquote>
<p>整数与浮点数算术指令在溢出和被零除时有各自不同的行为表现。所有算术指令如下：</p>
<ul>
<li>加法指令： <code>iadd</code>、<code>ladd</code>、<code>fadd</code>、<code>dadd</code>。</li>
<li>减法指令：<code>isub</code>、<code>lsub</code>、<code>fsub</code>、<code>dsub</code>。</li>
<li>乘法指令：<code>imul</code>、<code>lmul</code>、<code>fmul</code>、<code>dmul</code>。</li>
<li>除法指令：<code>idiv</code>、<code>ldiv</code>、<code>fdiv</code>、<code>ddiv</code>。</li>
<li>求余指令：<code>irem</code>、<code>lrem</code>、<code>frem</code>、<code>drem</code>。</li>
<li>取反指令：<code>ineg</code>、<code>lneg</code>、<code>fneg</code>、<code>dneg</code></li>
<li>位移指令：<code>ishl</code>、<code>ishr</code>、<code>iushr</code>、<code>lshl</code>、<code>lshr</code>、<code>lushr</code>。</li>
<li>按位或指令：<code>ior</code>、<code>lor</code>。</li>
<li>按位与指令：<code>iand</code>、<code>land</code></li>
<li>按位异或指令：<code>ixor</code>、<code>lxor</code></li>
<li>局部变量自增指令：<code>iinc</code></li>
<li>比较指令：<code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code>。</li>
</ul>
<p>Java虚拟机指令直接支持了在《Java语法规范》中描述的各种对数据及浮点数操作的语义。</p>
<blockquote>
<p>数据运算可能导致溢出，但Java虚拟机中没有明确定义过整型数据溢出的具体运算，仅仅规定了在处理整型数据时，除法指令以及求余指令中出现除数为0时会导致虚拟机抛出<code>ArithmeticException</code>异常，其他任何运算场景都不会抛出异常。</p>
</blockquote>
<blockquote>
<p>处理浮点数时，必须严格遵守<strong>IEEE 754</strong>规范中所规定的的行为和限制，即非正规浮点数值和逐级下溢的运算规则。</p>
<ul>
<li>进行浮点运算时，运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，当有两种可表示的形式与该值一致，优先选择最低有效位为0的，即向最接近数舍入模式。</li>
<li>浮点数转换为整数时，采用向零舍入模式，舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢掉。将会选择一个最接近但不大于原值的数字作为最精确的舍入结果。</li>
<li>处理浮点数运算时，不会抛出任何运行时异常，当一个操作数产生溢出时，将会使用有符号的无穷大表示（<strong>NaN</strong>）。使用带<strong>NaN</strong>值作为操作数的运算，结果都会返回<strong>NaN</strong>。</li>
</ul>
</blockquote>
<h6 id="4-类型转换指令"><a href="#4-类型转换指令" class="headerlink" title="4. 类型转换指令"></a>4. 类型转换指令</h6><p>类型转换指令可以将两种不同的数值类型进行相互转换，一般用于实现用户代码中显示类型转换操作，或者处理数据类型相关指令无法与数据类型一一对应的问题。</p>
<p>Java虚拟机直接支持（无需显式的转换指令）小范围类型向大范围类型的安全转换：</p>
<ul>
<li><code>int</code>类型到<code>long</code>、<code>float</code>、<code>double</code>类型</li>
<li><code>long</code>类型到<code>float</code>、<code>double</code>类型</li>
<li><code>float</code>类型到<code>double</code>类型</li>
</ul>
<p>虚拟机处理窄化类型转换时，必须显式使用转换指令完成。包括：<code>i2b</code>、<code>i2c</code>、<code>i2s</code>、<code>l2i</code>、<code>f2i</code>、<code>f2l</code>、<code>d2i</code>、<code>d2l</code>、<code>d2f</code>。可能会导致转换结果错误或者精度丢失的情况。</p>
<ul>
<li><code>int</code>、<code>long</code>窄化转为时，仅仅是简单的丢弃高位字节的内容。</li>
<li>浮点值窄化转为为证书类型时，遵循以下规则：<ul>
<li>浮点值是<strong>NaN</strong>，转换结果是<code>int</code>或<code>long</code>的0。</li>
<li>非<strong>NaN</strong>采用向零舍入模式取整。若取整后的值V，是在目标类型（<code>int</code>和<code>long</code>）表示范围之内，转换结果为V</li>
<li>否则，根据V的符号，转换为所能表示的最大或最小正数。</li>
</ul>
</li>
<li><code>double</code>转换为<code>float</code>时<ul>
<li>向最接近数舍入模式舍入得到一个可以使用<code>float</code>类型表示的数字。</li>
<li>若转换结果绝对值太小（无限接近0），则使用<code>float</code>类型的正负0表示</li>
<li>转换结果太大无法使用<code>float</code>表示，则使用<code>float</code>类型的正负无穷大表示</li>
<li><strong>NaN</strong>转换后为<code>float</code>类型的<strong>NaN</strong></li>
</ul>
</li>
</ul>
<p>尽管类型窄化转换会导致一系列问题，例如：上限溢出、下限溢出和精度丢失等情况，但是JVM永远不会抛出运行时异常。</p>
<h6 id="5-对象创建与访问指令"><a href="#5-对象创建与访问指令" class="headerlink" title="5. 对象创建与访问指令"></a>5. 对象创建与访问指令</h6><p>Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。</p>
<ul>
<li>创建类实例：<code>new</code></li>
<li>创建数组指令：<code>newarray</code>、<code>anewarray</code>、<code>multianewarray</code>。</li>
<li>访问类<ul>
<li><code>static</code>成员：<code>getstatic</code>、<code>putstatic</code></li>
<li>非<code>static</code>成员：<code>getfield</code>、<code>putfield</code></li>
</ul>
</li>
<li>数组元素加载到操作数栈的指令：<code>baload</code>、<code>caload</code>、<code>saload</code>、<code>iaload</code>、<code>laload</code>、<code>faload</code>、<code>daload</code>、<code>aaload</code>。</li>
<li>将一个操作数栈的值存储到数组元素中：<code>bastore</code>、<code>castore</code>、<code>sastore</code>、<code>iastore</code>、<code>lastore</code>、<code>fastore</code>、<code>dastore</code>、<code>aastore</code></li>
<li>取数组长度指令：<code>arraylength</code></li>
<li>检查类实例类型指令：<code>instanceof</code>、<code>checkcast</code></li>
</ul>
<h6 id="6-操作数栈管理指令"><a href="#6-操作数栈管理指令" class="headerlink" title="6. 操作数栈管理指令"></a>6. 操作数栈管理指令</h6><ul>
<li>将操作数栈的栈顶一个或两个元素出栈： <code>pop</code>、<code>pop2</code></li>
<li>复制栈顶一个或两个数值并将复制值或双份复制值重新压入栈顶：<code>dup</code>、<code>dup2</code>、<code>dup_x1</code>、<code>dup_x2</code>、<code>dup2_x1</code>、<code>dup2_x2</code></li>
<li>将栈顶两个数值互换：<code>swap</code></li>
</ul>
<h6 id="7-控制转移指令"><a href="#7-控制转移指令" class="headerlink" title="7. 控制转移指令"></a>7. 控制转移指令</h6><p>控制转移指令可以让<strong>JVM</strong>有条件或无条件地从指定位置指令而不是控制转移指令的下一条指令继续执行程序。</p>
<ul>
<li>条件分支：<code>ifeq</code>、<code>iflt</code>、<code>ifle</code>、<code>ifgt</code>、<code>ifge</code>、<code>ifnull</code>、<code>ifnonnull</code>、<code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmpgt</code>、<code>if_icmple</code>、<code>if_acmpeq</code>、<code>if_acmpne</code>。</li>
<li>复合条件分支：<code>tableswithc</code>、<code>lookupswitch</code></li>
<li>无条件分支：<code>goto</code>、<code>goto_w</code>、<code>jsr</code>、<code>jsr_w</code>、<code>ret</code></li>
</ul>
<blockquote>
<p>对于<code>boolean</code>类型、<code>byte</code>类型、<code>char</code>类型、<code>short</code>类型的条件分支比较，都使用<code>int</code>类型的比较指令完成。</p>
<p>对于<code>long</code>、<code>float</code>、<code>double</code>类型，则先使用对应的（<code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code>）运算指令，返回一个整型值到操作数栈中，随后执行<code>int</code>类型的条件分支完成整个分支跳转。</p>
</blockquote>
<p>各种类型的比较最后都是<code>int</code>类型比较操作，所以<code>int</code>比较很重要。</p>
<h6 id="8-方法调用和返回指令"><a href="#8-方法调用和返回指令" class="headerlink" title="8. 方法调用和返回指令"></a>8. 方法调用和返回指令</h6><ul>
<li><code>invokevirtual</code>用于调用对象的实例方法，根据对象的实际类型分派（虚方法分派）</li>
<li><code>invokeinterface</code>指令用于调用接口方法，在运行时搜索一个实现了这个接口方法的对象，寻找适合的方法调用</li>
<li><code>invokespecial</code>用于调用需要特殊处理的实例方法（初始化，私有或者父类方法）。</li>
<li><code>invokestatic</code>用于调用类（<code>static</code>）方法</li>
<li><code>invokedynamic</code>用于运行时动态解析出调用的限定符所引用的方法，并执行。</li>
</ul>
<p>方法调用指令与数据类型无关，但是返回指令是根据类型区分的，<code>ireturn</code>、<code>lreturn</code>、<code>freturn</code>、<code>dreturn</code>、<code>areturn</code>、还有一条<code>return</code>供<code>void</code>方法、构造方法、类或接口的类初始化方法使用</p>
<h6 id="9-异常处理指令"><a href="#9-异常处理指令" class="headerlink" title="9. 异常处理指令"></a>9. 异常处理指令</h6><p>显式抛出异常的操作，都由<code>athrow</code>指令完成。Java虚拟机规范还规定了许多运行时异常在虚拟机检查到异常状况时自动抛出。</p>
<p><strong>JVM</strong>中处理异常不是由字节码实现的，而是采用异常表完成。</p>
<h6 id="10-同步指令"><a href="#10-同步指令" class="headerlink" title="10. 同步指令"></a>10. 同步指令</h6><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列(<code>synchronized</code>代码块)的同步，都是使用管理线程(<strong>Monitor</strong>)支持的。</p>
<p>方法级同步，隐式完成不需要使用字节码控制，其实现在方法调用和返回操作中。当方法<code>access_flags</code>中的<code>ACC_SYNCHRONIZED</code>位为1时，说明已被声明为同步方法。方法调用时，执行线程就要求先成功持有管理线程，然后才能执行方法，当方法完成时释放管理线程；在持有管理线程期间，其他线程无法获取同一个管城；方法执行期间抛出异常且方法内部没有处理异常，那么同步方法持有的管理线程将在异常抛出同步方法时自动释放。</p>
<p>同步指令集序列，<strong>JVM</strong>中的指令集有<code>monitorenter</code>和<code>monitorexit</code>两条指令支持<code>synchronized</code>关键字语义，会在方法正常return出以及出现异常处添加<code>monitorexit</code>指令，保证正常释放锁。</p>
<hr>
<p><strong>Class</strong>文件是虚拟机执行引擎的数据入口，也是Java技术体系的基础构成之一。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Class类文件结构</title>
    <url>/blog/2019/06/22/jvm/6_class_structure/</url>
    <content><![CDATA[<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。随着虚拟机的发展，越来越多的语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p>
<a id="more"></a>

<h5 id="1-平台无关的基石"><a href="#1-平台无关的基石" class="headerlink" title="1. 平台无关的基石"></a>1. 平台无关的基石</h5><p>Sun公司以及其他虚拟机提供商发布了许多可以允许在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种与平台无关的字节码，实现了“一次编写，到处运行”。各种平台的虚拟机与所有平台都统一使用了一种程序存储格式—<strong style='color:red'>字节码</strong>(<strong>ByteCode</strong>)，这是平台无关的基石。</p>
<blockquote>
<p>虚拟机还有另外一种中立特性—<strong>语言无关性</strong>。Java虚拟机设计之初，就考虑到了其他语言在Java虚拟机上运行的可能性，其在发布文档时也刻意把Java规范分成了Java语言规范《The Java Language Specification》以及Java虚拟机规范《Java Virtual Machine Specification》。</p>
</blockquote>
<blockquote>
<p>现在已经有大批在Java虚拟机上运行的语言，<strong>Clojure</strong>、<strong>Groovy</strong>、<strong>JRuby</strong>、<strong>Jython</strong>、<strong>Sacla</strong>等。<font color='red'>实现语言无关性的基础仍然是虚拟机和字节码存储格式</font>。虚拟机只与<strong>Class文件</strong>这种特定的二进制文件所关联，<strong>Class文件</strong>包含了Java虚拟机指令集和符号表以及若干辅助信息。基于安全考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，任何一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效Class文件。Java虚拟机是一个通用的、与机器无关的执行平台。</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/jvm/14.jpg" alt="JVM的语言无关性"></p>
<p>Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此自己码所能提供的语义描述能力肯定比Java语言本身更加强大，所以一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持。</p>
<h5 id="2-Class-类文件的结构"><a href="#2-Class-类文件的结构" class="headerlink" title="2. Class 类文件的结构"></a>2. Class 类文件的结构</h5><blockquote>
<p>解析<strong>Class文件</strong>的数据结构。</p>
<p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但类或及接口并不一定定义在文件里（例如，可以通过类加载器直接生成）。</p>
</blockquote>
<p><strong>Class</strong>文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符， 所以Class文件中存储的内容几乎全部是程序运行的必要数据。</p>
<p>Java虚拟机规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据。其只有两种数据类型：无符号数和表。</p>
<ul>
<li>无符号数，属于基本数据类型，以<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>分别代表1、2、4、8个字节的无符号数。可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表，是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u4</td>
<td align="center">magic</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">minor_version</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">major_version</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">cp_info</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count-1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">this_class</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">super_class</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">fields_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">field_info</td>
<td align="center">fields</td>
<td align="center">fields_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">methods_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">method_info</td>
<td align="center">methods</td>
<td align="center">methods_count</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<p>无论无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合</p>
<h6 id="1-魔数与Class文件的版本"><a href="#1-魔数与Class文件的版本" class="headerlink" title="1. 魔数与Class文件的版本"></a>1. 魔数与Class文件的版本</h6><p>每个Class文件的头4个字节称为<strong>魔数</strong>(Magic Number)，唯一的作用是确定这个文件是否为一个能被Java虚拟机接受的Class文件。Class文件的魔数值为：“0xCAFEBABE”（咖啡宝贝）。</p>
<blockquote>
<p>很多文件存储标准都是使用魔数进行身份识别，例如图片格式。使用魔数而不是扩展名进行识别主要基于安全考虑，因为文件扩展名可以随意改动。文件格式制定者可以自由选择魔数值。</p>
</blockquote>
<p>魔数后的4个字节便是Class文件的版本号：次版本号（Minor Version）和主版本号（Major Version）。高版本JKD能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<blockquote>
<p>以TestClass.java为例说明Class文件结构。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是Java代码，编译后的class文件，使用Binary Viewer打开后如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/jvm/15.jpg" alt="Class文件结构"></p>
<p>其前八位分别是魔数值“CAFEBABY”，以及此版本号和主版本号0x34即十进制的52。</p>
<h6 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h6><p>常量池可以理解为Class文件中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。</p>
<p>由Class文件结构可知，<font color='red'>常量池有两部分：constant_pool_count和constant_pool</font>。这是因为常量池数量不固定，所以在常量池入口需要放置一项<strong>u2</strong>类型的数据，代表常量池容量计数值。这个容量计数器是从1开始的，0表示某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”，上图的第9-10位,即0x00 ~ 0x1A表示十进制的27，表示常量池中有26个常量。</p>
<p><font color='red'>常量池主要存放两个类常量：字面量（Literal）和<a name='symbolicReference'>符号引用（Symbolic References）</a></font>。</p>
<ul>
<li>字面量，包括文本字符串、声明为final的常量值等</li>
<li>符号引用，属于编译原理方面的概念<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>Java代码进行<code>javac</code>编译时，并没有“连接”这一步骤，而是在虚拟机加载Class文件时进行动态连接。即，Class文件中不会保存各个方法、字段的最终内存布局信息，所以这些字段、方法的符号引用不经过运行期转换无法得到真正内存入口地址，也无法被虚拟机使用。在虚拟机运行时，需要从常量池中获得对应的符号引用，在类创建时或运行时解析、翻译到具体的内存地址中。</p>
<p>常量池中每一项常量都是一个表，JDK1.7以后有14中表结构。每个常量的第一位都是<code>u1</code>类型的标志位，代表当前常量属于哪种类型。如下</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="center">标志</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONSTANT_Utf8_info</td>
<td align="center">1</td>
<td align="left">UTF-8编码的字符串</td>
</tr>
<tr>
<td align="left">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="left">整型字面量</td>
</tr>
<tr>
<td align="left">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="left">浮点型字面量</td>
</tr>
<tr>
<td align="left">CONSTANT_Long_info</td>
<td align="center">5</td>
<td align="left">长整型字面量</td>
</tr>
<tr>
<td align="left">CONSTANT_Double_info</td>
<td align="center">6</td>
<td align="left">双精度浮点型字面量</td>
</tr>
<tr>
<td align="left">CONSTANT_Class_info</td>
<td align="center">7</td>
<td align="left">类或者接口的符号引用</td>
</tr>
<tr>
<td align="left">CONSTANT_String_info</td>
<td align="center">8</td>
<td align="left">字符串类型字面量</td>
</tr>
<tr>
<td align="left">CONSTANT_Fieledref_info</td>
<td align="center">9</td>
<td align="left">字段的符号引用</td>
</tr>
<tr>
<td align="left">CONSTANT_Methodref_info</td>
<td align="center">10</td>
<td align="left">类中方法的符号引用</td>
</tr>
<tr>
<td align="left">CONSTANT_InterfaceMethodref_info</td>
<td align="center">11</td>
<td align="left">接口中方法的符号引用</td>
</tr>
<tr>
<td align="left">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="left">字段或方法的部分符号引用</td>
</tr>
<tr>
<td align="left">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="left">表示方法句柄</td>
</tr>
<tr>
<td align="left">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="left">标识方法类型</td>
</tr>
<tr>
<td align="left">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="left">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<p>使用<code>javap -verboase TestClass</code>输出TestClass.class的字节码内容，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /E:/idea_workspace/essay-project/src/main/java/com/effiu/essay/jvm/TestClass.class</span><br><span class="line">  Last modified <span class="number">2019</span>-<span class="number">6</span>-<span class="number">16</span>; size <span class="number">465</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">631e6305</span>b9b12e9de76e26c134765044</span><br><span class="line">  Compiled from <span class="string">&quot;TestClass.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">effiu</span>.<span class="title">essay</span>.<span class="title">jvm</span>.<span class="title">TestClass</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #4.#22         // com/effiu/essay/jvm/TestClass.n:I</span><br><span class="line">   #3 = String             #23            // default</span><br><span class="line">   #4 = Class              #24            // com/effiu/essay/jvm/TestClass</span><br><span class="line">   #5 = Class              #25            // java/lang/Object</span><br><span class="line">   #6 = Utf8               m</span><br><span class="line">   #7 = Utf8               I</span><br><span class="line">   #8 = Utf8               n</span><br><span class="line">   #9 = Utf8               j</span><br><span class="line">  #10 = Utf8               ConstantValue</span><br><span class="line">  #11 = Integer            0</span><br><span class="line">  #12 = Utf8               &lt;init&gt;</span><br><span class="line">  #13 = Utf8               ()V</span><br><span class="line">  #14 = Utf8               Code</span><br><span class="line">  #15 = Utf8               LineNumberTable</span><br><span class="line">  #16 = Utf8               get</span><br><span class="line">  #17 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  #19 = Utf8               SourceFile</span><br><span class="line">  #20 = Utf8               TestClass.java</span><br><span class="line">  #21 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #22 = NameAndType        #8:#7          // n:I</span><br><span class="line">  #23 = Utf8               default</span><br><span class="line">  #24 = Utf8               com/effiu/essay/jvm/TestClass</span><br><span class="line">  #25 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.effiu.essay.jvm.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field n:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #3                  // String default</span><br><span class="line">         <span class="number">2</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">get</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;TestClass.java&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>继续分析TestClass.java</p>
</blockquote>
<ol>
<li><p><code>0x0A</code>表示十进制的10，即<code>tag=10</code>表示<code>CONSTANT_Methodref_info</code>类型。其表结构如下，共占5位</p>
<p>后续两个值为<code>0x00~0x05</code>以及<code>0x00~0x15</code>即5和21，即第5和第21项常量。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tag</td>
<td align="center">u1</td>
<td>值为10</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td>指向声明方法的类描述符CONSTANT_Class的索引项</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">u2</td>
<td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td>
</tr>
</tbody></table>
<ol start="2">
<li><p><code>0x09</code>表示十进制的9，即<code>tag=9</code>表示<code>CONSTANT_Fieledref_info</code>类型。其与<code>CONSTANT_Methodref_info</code>相似。后续两个值为<code>0x04</code>和<code>0x16</code>，即4和22。</p>
</li>
<li><p><code>0x08</code>表示<code>CONSTANT_String_info</code>，其表结构如下，共占3位。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tag</td>
<td align="center"><code>u1</code></td>
<td>值为8</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center"><code>u2</code></td>
<td>指向字符串字面量的索引</td>
</tr>
</tbody></table>
</li>
</ol>
<p>   <code>0x17</code>即十进制的23</p>
<ol start="4">
<li><p><code>0x07</code>表示<code>CONSTANT_Class_info</code>，表结构如下，共占3位</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tag</td>
<td align="center"><code>u1</code></td>
<td>值为7</td>
</tr>
<tr>
<td align="center">index</td>
<td align="center"><code>u2</code></td>
<td>指向全限定类名常量项的索引</td>
</tr>
</tbody></table>
</li>
</ol>
<p>   <code>0x18</code>即24，查看第24项常量，即：<code>com/effiu/essay/jvm/TestClass</code></p>
<ol start="5">
<li><p><code>0x07</code>,<code>0x19</code>即十进制的25，即：<code>java/lang/Object</code></p>
</li>
<li><p><code>0x01</code>表示<code>CONSTANT_Utf8_info</code>，表结构如下（共占4位）：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tag</td>
<td align="center"><code>u1</code></td>
<td align="center">值为1</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center"><code>u2</code></td>
<td align="center">UTF-8编码的字符串占用的字节数</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center"><code>u1</code>(长度为length)</td>
<td align="center">长度为length的UTF-8编码的字符串</td>
</tr>
</tbody></table>
</li>
</ol>
<p>   Class文件中方法、字段等需要引用<code>CONSTANT_Utf8_info</code>型常量，所以其最大长度<code>2^16=65535</code>就是方法、字段名的最大长度。</p>
<blockquote>
<p>其他常量省略</p>
</blockquote>
<p>字节码文本中可以发现，一些常量代码中没有出现，例如，<code>I</code>、<code>V</code>、<code>&lt;init&gt;</code>、<code>LineNumberTable</code>等。这些会被字段表(field_info)、方法表(method_info)、属性表(attribute_info)引用到，用来描述一些不方便使用固定字节进行表达的内容，例如，方法的返回值、参数列表，参数类型等。</p>
<blockquote>
</blockquote>
<p>常量池中14种常量项如下：<a href="https://files.effiu.cn/14_constant_pool.html" target='_blank'>14种常量项</a></p>
<iframe src='https://files.effiu.cn/14_constant_pool.html' style='width:100%;height:1000px'></iframe>
i###### 3. 访问标志

<p>常量池之后是<code>u2</code>的访问标识符(<code>access_flags</code>)，用于识别一些类或者接口层次的访问信息。例如，这个Class是类还是接口；是否用<code>public</code>修饰；是否用<code>abstract</code>修饰；是否用<code>final</code>修饰等等。共有16个占位符，目前已使用8个。</p>
<table>
<thead>
<tr>
<th align="center">标志名称</th>
<th align="center">标志值</th>
<th>16进制</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td>0000,0000,0000,0001</td>
<td>是否为<code>public</code>类型</td>
</tr>
<tr>
<td align="center">ACC_FINAL</td>
<td align="center">0x0010</td>
<td>0000 0000 0001 0000</td>
<td>是否用<code>final</code>修饰类（不包括接口）</td>
</tr>
<tr>
<td align="center">ACC_SUPER</td>
<td align="center">0x0020</td>
<td>0000 0000 0010 0000</td>
<td>是否允许使用<a href='#invokespecial'>invokespecial</a>字节码指令的新语义</td>
</tr>
<tr>
<td align="center">ACC_INTERFACE</td>
<td align="center">0x0200</td>
<td>0000 0010 0000 0000</td>
<td>标识是否是接口</td>
</tr>
<tr>
<td align="center">ACC_ABSTRACT</td>
<td align="center">0x0400</td>
<td>0000 0100 0000 0000</td>
<td>是否用<code>abstract修饰</code>，对于接口或者抽象类，此值为真，其他为假</td>
</tr>
<tr>
<td align="center">ACC_SYNTHETIC</td>
<td align="center">0x1000</td>
<td>0001 0000 0000 0000</td>
<td>标识这个类并非由用户代码产生</td>
</tr>
<tr>
<td align="center">ACC_ANNOTATION</td>
<td align="center">0x2000</td>
<td>0010 0000 0000 0000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td align="center">ACC_ENUM</td>
<td align="center">0x4000</td>
<td>0100 0000 0000 0000</td>
<td>标识这个一个枚举</td>
</tr>
</tbody></table>
<p>由上表可得<code>0000 0000 0011 0001</code>即<code>0x0031</code>表示<code>public final class</code>；<code>0000 0100 0010 0001</code>即<code>0x0021</code>表示<code>public abstract class</code>，所以<code>TestClass</code>的<code>access_flag</code>为<code>0x0021</code>。</p>
<h6 id="4-类索引、父类索引和接口索引集合"><a href="#4-类索引、父类索引和接口索引集合" class="headerlink" title="4. 类索引、父类索引和接口索引集合"></a>4. 类索引、父类索引和接口索引集合</h6><p>类所以与父类索引都是<code>u2</code>数据。接口因为允许实现多个接口或者多继承，所以是一组<code>u2</code>的集合。</p>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类全限定名，默认继承<code>java.lang.Object</code></li>
<li>接口索引集合用来描述类实现了哪些接口或者接口继承了哪些接口，按照<code>implements</code>或者<code>extends</code>顺序排列在接口索引集合中</li>
</ul>
<p>类索引、父类素引指向一个<code>CONSTANT_Class_info</code>类型的类描述符常量，通过<code>CONSTANT_Class_info</code>类型常量中的索引值可以确定<code>CONSTANT_Utf8_info</code>类型常量中的全限定名字符串。例如，字节码<code>0x0004</code>表示第四个常量，即<code>#4 = Class  #24  // com/effiu/essay/jvm/TestClass</code></p>
<p>接口索引集合，入口第一项为<code>u2</code>类型的接口计数器，表示索引表的容量。</p>
<h6 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5. 字段表集合"></a>5. 字段表集合</h6><p>字段表(<code>field_info</code>)用于描述接口或者类中声明的变量。<code>field_count</code>表示类中常量个数，<code>0x0003</code>有3个常量。字段(<code>field</code>)包括类级变量以及实例变量，不包括方法内部声明的局部变量。<font color='red'>描述变量的信息</font>：<strong>字段作用域(<code>public</code>、<code>private</code>、<code>protected</code>)、实例变量还是类变量(<code>static</code>)、是否可被序列化(<code>transient</code>)、可变性(<code>final</code>)、并发可见性(<code>volatile</code>)、字段数据类型(基本类型、数组、对象)、字段名称</strong>。</p>
<ul>
<li>修饰符用布尔值表示</li>
<li>字段名则引用常量池中的常量表示。</li>
</ul>
<p>字段表结构如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>u2</code></td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td align="center">name_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td align="center">descriptor_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td align="center">attribute_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>attribute_info</code></td>
<td align="center">attribute_info</td>
<td align="center">attribute_count</td>
</tr>
</tbody></table>
<ol>
<li><p><code>access_flags</code></p>
<p>字段修饰符中，与类的<code>access_flags</code>类似。字段访问标志如下：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th align="center">标志值</th>
<th align="center">16进制值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">0000 0000 0000 0001</td>
<td>是否<code>public</code></td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">0000 0000 0000 0010</td>
<td>是否<code>private</code></td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td align="center">0x0004</td>
<td align="center">0000 0000 0000 0100</td>
<td>是否<code>protected</code></td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">0000 0000 0000 1000</td>
<td>是否<code>static</code></td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">0000 0000 0001 0000</td>
<td>是否<code>final</code></td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td align="center">0x0040</td>
<td align="center">0000 0000 0100 0000</td>
<td>是否<code>volatile</code></td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td align="center">0x0080</td>
<td align="center">0000 0000 1000 0000</td>
<td>是否<code>transient</code></td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td align="center">0x1000</td>
<td align="center">0001 0000 0000 0000</td>
<td>是否由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td align="center">0x4000</td>
<td align="center">0100 0000 0000 0000</td>
<td>是否<code>enum</code></td>
</tr>
</tbody></table>
</li>
</ol>
<p>   以上字段访问标志结合<strong>Java</strong>本身语言使用。</p>
<ol start="2">
<li><p><code>name_index</code>和<code>descriptor_index</code></p>
<p>对常量池的引用，分别代表字段的简单名称以及字段和方法的描述符</p>
<ul>
<li><p>全限定名：com/effiu/essay/jvm/TestClass; “；”表示全限定类名结束</p>
</li>
<li><p>简单名称：没有类型和参数修饰的方法或者字段名称，例如: 字段<code>m</code>，和方法<code>get()</code>的简称为<code>m</code>和<code>get</code></p>
</li>
<li><p>描述符：作用是描述字段的数据类型、方法的参数列表、返回值。数据类型描述规则如下：</p>
</li>
</ul>
</li>
</ol>
<pre><code> | 标识字符 | 含义   | 标识字符 | 含义                        |
 | :------: | ------ | :------: | --------------------------- |
 |    B     | byte   |    J     | long                        |
 |    C     | char   |    S     | short                       |
 |    D     | double |    Z     | boolean                     |
 |    F     | float  |    V     | void                        |
 |    I     | int    |    L     | 对象类型，Ljava/lang/Object |





 数组类型，每一维度前置一个`[`，例如:`String[][]`描述符为`[[java/lang/String`。

 参数列表，返回值。按照先参数列表后返回值的顺序，参数列表严格按照参数顺序放在`()`之内。例如，`String get(String s)`描述符为`(S)Ljava/lang/String`。</code></pre>
<p>例如：</p>
<ul>
<li><code>00 02 00 06 00 07 00 00</code>分别表示<code>private </code>、<code>m</code>、<code>I</code>、0个<code>attribute</code>即<code>private int m;</code>。</li>
<li><code>00 02 00 08 00 07 00 00</code>分别表示<code>private</code>、<code>n</code>、<code>I</code>、0个<code>attribute</code>即<code>private int n;</code>。</li>
<li><code>00 1A 00 09 00 07 00 01</code>分别表示<code>private static final</code>、<code>j</code>、<code>I</code>、1个<code>attribute</code>。<code>attribute_info</code>属性表后续说明。</li>
<li>代码<code>private int n = 10;</code>与<code>private static final int j = 0;</code>区别见:<a href='#constantValue'>ConstantValue部分</a></li>
</ul>
<p>字段表集合中不会列出超类中继承而来的字段，但有可能出现代码中不存在的字段。例如，内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。Java中字段无法重载，两个字段名不能一致，但是字节码中只要两个字段的描述符不一致就是合法的。</p>
<h6 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6. 方法表集合"></a>6. 方法表集合</h6><p><font color='red'>方法表与字段表基本一致</font>。区别如下：</p>
<ul>
<li><p><code>access_flag</code>中没有<code>volatile</code>和<code>transient</code>，但是多了<code>synchronized</code>、<code>native</code>、<code>strictfp</code>和<code>abstract</code>关键字。</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th align="center">标志值</th>
<th align="center">16进制值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td align="center">0x0001</td>
<td align="center">0000 0000 0000 0001</td>
<td>是否<code>public</code></td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td align="center">0x0002</td>
<td align="center">0000 0000 0000 0010</td>
<td>是否<code>private</code></td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td align="center">0x0004</td>
<td align="center">0000 0000 0000 0100</td>
<td>是否<code>protected</code></td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td align="center">0x0008</td>
<td align="center">0000 0000 0000 1000</td>
<td>是否<code>static</code></td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td align="center">0x0010</td>
<td align="center">0000 0000 0001 0000</td>
<td>是否<code>final</code></td>
</tr>
<tr>
<td>ACC_SYNCHRONIZED</td>
<td align="center">0x0020</td>
<td align="center">0000 0000 0010 0000</td>
<td>是否<code>synchronized</code></td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td align="center">0x0040</td>
<td align="center">0000 0000 0100 0000</td>
<td>是否是由编译器产生的桥接方法</td>
</tr>
<tr>
<td>ACC_VARAGS</td>
<td align="center">0x0080</td>
<td align="center">0000 0000 1000 0000</td>
<td>是否接受不定参数</td>
</tr>
<tr>
<td>ACC_NATIVE</td>
<td align="center">0x0100</td>
<td align="center">0000 0001 0000 0000</td>
<td>是否<code>native</code></td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td align="center">0x0400</td>
<td align="center">0000 0100 0000 0000</td>
<td>是否<code>abstract</code></td>
</tr>
<tr>
<td>ACC_STRICTFP</td>
<td align="center">0x0800</td>
<td align="center">0000 1000 0000 0000</td>
<td>是否为<code>strictfp</code></td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td align="center">0x1000</td>
<td align="center">0001 0000 0000 0000</td>
<td>是否由编译器自动产生的</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li>方法中的代码。经过编译器编译成字节码指令后，存放在方法属性表集合中名为<code>Code</code>的属性里。</li>
</ul>
<p>父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息，但同样可能会出现自动添加的方法，例如：类构造器<code>&lt;clinit&gt;</code>方法和实例构造器<code>&lt;init&gt;</code>方法。<a name='methodSign'></a></p>
<p>Java中要重载一个方法，除了与原方法有相同的简单名称外，还要有与原方法不同的特性签名(<font color='red'>字节码特征签名还包括方法返回值以及受检查异常表</font>)，所以如果返回值不同，在字节码中就是可以共存的。</p>
<p>举例：</p>
<ul>
<li><code>00 03</code>即<code>methods_count</code>即有3个方法：构造方法+2个方法。</li>
<li><code>00 01 00 0C 00 0D 00 01</code>分别表示<code>public</code>、<code>&lt;init&gt;</code> 、<code>()V</code>即<code>void</code>、1个<code>attribute</code>即构造方法。<code>attribute</code>见<a href='#constantValue'>ConstantValue部分</a>。<code>00 0E</code>表示<code>attribute</code>的<a href='#code'>Code部分</a></li>
<li><code>00 01 00 10 00 11 00 01</code>分别表示<code>public</code>、<code>get</code>、<code>()Ljava/lang/String;</code>、1个<code>attribute</code>即<code>public String get()</code>方法。</li>
<li><code>00 01 00 10 00 12 00 01</code>分别表<code>public</code>、<code>get</code>、<code>(Ljava/lang/String;)Ljava/lang/String;</code>、1个<code>attribute</code></li>
</ul>
<h6 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7. 属性表集合"></a>7. 属性表集合</h6><p>属性表(<code>attribute_info</code>)，在<code>Class</code>文件、字段表、方法表中都可以携带自己的属性表集合。属性表集合不再要求各个属性表的顺序，只要求不与已有属性名重复，任何实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机会忽略掉它不认识的属性。最新的《Java虚拟机规范 (Java SE 7)》中预定义属性如下：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Code</code></td>
<td>方法表</td>
<td>Java代码变异成的字节码指令</td>
</tr>
<tr>
<td align="center"><code>ConstantValue</code></td>
<td>字段表</td>
<td><code>final</code>和<code>static</code>关键字定义的常量值</td>
</tr>
<tr>
<td align="center"><code>Deprecated</code></td>
<td>类、方法表、字段表</td>
<td>被声明为<code>deprecated</code>的方法和字段</td>
</tr>
<tr>
<td align="center"><code>Exceptions</code></td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td align="center"><code>EnclosingMethod</code></td>
<td>类文件</td>
<td>类为局部类或者匿名类时，用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td align="center"><code>InnerClass</code></td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td align="center"><code>LineNumberTable</code></td>
<td>Code属性</td>
<td>Java源码行号与自己码指定的对应关系</td>
</tr>
<tr>
<td align="center"><code>LocalVariableTable</code></td>
<td>Code属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td align="center"><code>StackMapTable</code></td>
<td>Code属性</td>
<td>供类型检查验证器检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配</td>
</tr>
<tr>
<td align="center"><code>Sinature</code></td>
<td>类、方法、字段表</td>
<td>用于支持泛型情况下的方法签名，Java中任何类、接口、方法、成员变量等使用了泛型，则<code>Sinature</code>属性会记录泛型签名信息，避免泛型擦除后导致签名混乱</td>
</tr>
<tr>
<td align="center"><code>SourceFile</code></td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td align="center"><code>SourceDebugExtension</code></td>
<td>类文件</td>
<td>存储额外的调试信息。为非Java语言编写，却需要编译成字节码并运行在Java虚拟机中的程序调试提供。因为无法通过Java堆栈定位JSP文件的行号。例如JSP文件</td>
</tr>
<tr>
<td align="center"><code>Synthetic</code></td>
<td>类、方法表、字段表</td>
<td>标识方法或者字段为编译器自动生成</td>
</tr>
<tr>
<td align="center"><code>LocalVariableTypeTable</code></td>
<td>类</td>
<td>使用特征签名代替描述符，为了引入泛型语法后能描述泛型参数化类型添加</td>
</tr>
<tr>
<td align="center"><code>RuntimeVisibleAnnotations</code></td>
<td>类、方法表、字段表</td>
<td>为动态注解提供支持，用于指明哪些注解式运行时（运行时进行反射调用）可见</td>
</tr>
<tr>
<td align="center"><code>RuntimeInvisibleAnnotations</code></td>
<td>类、方法表、字段表</td>
<td>与<code>RuntimeVisibleAnnotations</code>作用相反，指明运行时不可见注解</td>
</tr>
<tr>
<td align="center"><code>RuntimeVisibleParameterAnnotations</code></td>
<td>方法表</td>
<td>与<code>RuntimeVisibleAnnotations</code>类似，作用对象为方法参数</td>
</tr>
<tr>
<td align="center"><code>RuntimeInvisibleParameterAnnotations</code></td>
<td>方法表</td>
<td>与<code>RuntimeInvisibleAnnotations</code>类似，作用对象为方法参数</td>
</tr>
<tr>
<td align="center"><code>AnnotationDefault</code></td>
<td>方法表</td>
<td>用于记录类元素的默认值</td>
</tr>
<tr>
<td align="center"><code>BootstrapMethods</code></td>
<td>类文件</td>
<td>用于保存<code>invokedynamic</code>指令引用的引导方法限定符</td>
</tr>
</tbody></table>
<p>每个属性都需要从常量池中引用一个<code>CONSTANT_Utf8_info</code>类型的常量表示。属性值的结果是自定义的，通过一个<code>u4</code>的长度说明属性值所占用的位数。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>u2</code></td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td align="center"><code>u4</code></td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td align="center"><code>u1</code></td>
<td>info</td>
<td>attribute_length</td>
</tr>
</tbody></table>
<ol>
<li><p><a name='code'>Code属性</a></p>
<p><strong>Java</strong>程序方法体中的代码经过编译后哦，最终为字节码指令存储在<code>Code</code>属性内。<code>Code</code>结构如下：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>名称</th>
<th>数量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>u2</code></td>
<td>attribute_name_index</td>
<td>1</td>
<td>指向常量池的索引，固定为Code</td>
</tr>
<tr>
<td align="left"><code>u4</code></td>
<td>attribute_length</td>
<td>1</td>
<td>属性值的长度</td>
</tr>
<tr>
<td align="left"><code>u2</code></td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值，虚拟机运行时根据该值分配栈帧中操作栈深度</td>
</tr>
<tr>
<td align="left"><code>u2</code></td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存储空间，单位是<code>Slot</code>，<a href='#max_locals'>Slot相关</a></td>
</tr>
<tr>
<td align="left"><code>u4</code></td>
<td>code_length</td>
<td>1</td>
<td>方法不允许超过65535(2^16-1)条字节码指令。</td>
</tr>
<tr>
<td align="left"><code>u1</code></td>
<td>code</td>
<td>code_length</td>
<td>存储字节码指令的一系列字节流，<a href='#code1'>Code</a></td>
</tr>
<tr>
<td align="left"><code>u2</code></td>
<td>exception_table_length</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td align="left"><code>exception_info</code></td>
<td>exception_table</td>
<td>exception_table_length</td>
<td></td>
</tr>
<tr>
<td align="left"><code>u2</code></td>
<td>attributes_count</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td align="left"><code>attribute_info</code></td>
<td>attributes</td>
<td>attribute_count</td>
<td>属性</td>
</tr>
</tbody></table>
<p>构造方法:<code>00 0E 00 00 00 27 00 02 00 01 00 00 00 0B 2A B7 00 01 2A 10 0A B5 00 02 B1 00 00 00 01 00 0F 00 00 00 0A 00 02 00 00 00 07 00 04 00 0B</code>解释为:</p>
<ul>
<li><p><code>00 0E</code>表示属性表为<code>Code</code></p>
</li>
<li><p><code>00 00 00 27</code>表示整个属性表长度为<code>39</code>不包含(<code>attribute_name_index</code>和<code>attribute_length</code>)</p>
</li>
<li><p><code>00 02</code>表示<code>max_stack</code>为2</p>
</li>
<li><p><code>00 01</code>表示<code>max_locals</code>空间为1</p>
</li>
<li><p><code>00 00 00 0B</code>表示<code>code_length</code>为11</p>
</li>
<li><p><code>2A B7 00 01 2A 10 0A B5 00 02 B1</code>即Code`。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         7: putfield      #2                  // Field n:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><code>10 0A B5 00 02</code>中，<code>10 0A</code>表示<code>bipush 10</code>即当单字节常量10推送至栈顶；<code>B5 00 02</code>表示<code>putfield</code>第2个常量。即第5~9个指令即为<code>private int n</code>赋值。</p>
<p><code>B1</code>从当前方法返回<code>void</code></p>
</li>
<li><p><code>00 01</code>，1个<code>attribute</code>。</p>
</li>
<li><p><code>00 0F 00 00 00 0A</code>，常量池中序号为15的常量，即<a href='#lineNumberTable'><code>LineNumberTable</code></a>长度为10。</p>
</li>
<li><p><code>00 02 00 00 00 07 00 04 00 0B</code>表示<code>line_number_info</code>数量以及对应关系，<a href='#lineNumberTable1'>见下文</a></p>
</li>
</ul>
</li>
<li><p>Exception属性</p>
<p>作用是列举出方法中可能抛出的受检查异常，即方法<code>throws</code>关键字后面列举的异常。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>u2</code></td>
<td>attribute_index_name</td>
<td>1</td>
<td>指向常量池索引</td>
</tr>
<tr>
<td><code>u4</code></td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度`</td>
</tr>
<tr>
<td><code>u2</code></td>
<td>number_of_exceptions</td>
<td>1</td>
<td>方法可能抛出的异常数</td>
</tr>
<tr>
<td><code>u2</code></td>
<td>number_index_table</td>
<td>number_of_exceptions</td>
<td>是一个指向常量池中常量的索引</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p><span name='lineNumberTable'>LineNumberTable属性</span></p>
<p>用于描述Java源码行号与字节码行为(字节码偏移量)之间的对应关系。不是运行时必需属性，<code>-g:none</code>或者<code>-g:lines</code>取消或者要求生成这项信息。不生成<code>LineNumberTable</code>属性的主要影响是，抛出异常时，堆栈中不会显示出错的行号，调试程序时无法按照源码设置断点。<code>LineNumberTable</code>结构见下表</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>u2</code></td>
<td>attribute_index_name</td>
<td>1</td>
<td>指向常量池中的常量，固定为<code>LineNumberTable</code></td>
</tr>
<tr>
<td><code>u4</code></td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td><code>u2</code></td>
<td>line_number_table_length</td>
<td>1</td>
<td>源码行号与字节码对应个数</td>
</tr>
<tr>
<td><code>line_number_info</code></td>
<td>line_number_info</td>
<td>line_number_table_length</td>
<td>源码行号与字节码对应关系</td>
</tr>
</tbody></table>
</li>
</ol>
<p>   <code>line_number_info</code>包含<code>start_pc</code>和<code>line_number</code>两个<code>u2</code>数据项，前者是字节码行号，后者是Java源码行号</p>
<p>   <a name='lineNumberTable1'><code>00 02 00 00 00 07 00 04 00 0B</code></a>表示为2个<code>line_number_info</code>。即<code>line 7: 0</code>和<code>line 11: 4</code>。</p>
<ol start="4">
<li><p>LocalVariableTable属性</p>
<p>用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。非必需属性，<code>-g:none</code>或者<code>-g:vars</code>选项取消或者要求生成这项信息。没有该属性时，其他人引用个这个方法时，所有的参数名称将丢失，IDE会使用<code>arg0</code>，<code>arg1</code>占位符代替原有参数名，且在调试期间无法根据参数名称从上下文中获得参数值。属性表结构如下:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td><code>u2</code></td>
<td>attribute_index_name</td>
<td>1</td>
</tr>
<tr>
<td><code>u4</code></td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td><code>u2</code></td>
<td>local_variable_table_length</td>
<td>1</td>
</tr>
<tr>
<td><code>local_variable_info</code></td>
<td>local_variable_table</td>
<td>local_variable_table_length</td>
</tr>
</tbody></table>
</li>
</ol>
<p>   <code>local_variable_info</code>代表一个栈帧与源码中的局部变量的关联，表结构如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th>名称</th>
<th align="center">数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>u2</code></td>
<td>start_pc</td>
<td align="center">1</td>
<td>局部变量声明周期开始的字节码的偏移量</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td>length</td>
<td align="center">1</td>
<td>局部变量声明周期作用范围长度</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td>name_index</td>
<td align="center">1</td>
<td>指向常量池中常量的索引</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td>descriptor_index</td>
<td align="center">1</td>
<td>指向常量池中常量的索引</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td>index</td>
<td align="center">1</td>
<td>局部变量在栈帧局部变量表的<code>Slot</code>的位置，64位则是index和index + 1</td>
</tr>
</tbody></table>
<ol start="5">
<li><p>SourceFile属性</p>
<p>记录生成这个<code>Class</code>文件的源码文件名称。可选。<code>-g:none</code>和<code>-g:source</code>关闭或者要求生成这项信息。若没有则当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th>名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>u2</code></td>
<td>attribute_index_name</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>u4</code></td>
<td>attribute_length</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td>sourcefile_index</td>
<td align="center">1</td>
</tr>
</tbody></table>
</li>
</ol>
<p>   <code>00 13 00 00 00 02 00 14</code>中<code>00 13</code>表示常量池中的<code>SourceFile</code>，<code>00 00 00 02</code>长度为2，<code>00 14</code>表示常量池中的<code>TestClass.java</code>。</p>
<ol start="6">
<li><p><a name='constantValue'>ConstantValue属性</a></p>
<p><code>ConstantValue</code>属性的作用的通知虚拟机自动为静态变量赋值，只有被<code>static</code>关键字修饰的变量(类变量)才可以使用<code>ConstantValue</code>。例如，<code>TestClass</code>中的<code>private int n = 10;</code>和<code>private static final int j = 0;</code>虚拟机针对两种成员变量处理方式和时刻不同。</p>
<ul>
<li><p>非<code>static</code>类型变量的赋值是在实例构造器<code>&lt;init&gt;</code>方法中进行的。</p>
</li>
<li><p>类变量，有两种方式：</p>
<ul>
<li>在类构造器<code>&lt;clinit&gt;</code>方法中，</li>
<li>使用<code>ConstantValue</code>属性</li>
</ul>
<p>Sun Javac编译器，同时使用<code>static final</code>修饰变量(<strong>常量</strong>)时，且这个变量的数据类型是基本类型或者<code>java.lang.String</code>，就生成<code>ConstantValue</code>属性进行初始化；没有<code>final</code>或者非基本数据类型或者<code>java.lang.String</code>修饰，则将会选择在<code>&lt;clinit&gt;</code>方法中初始化</p>
</li>
</ul>
<p><code>ConstantValue</code>的属性值只是一个常量池的索引号，而<code>Class</code>文件格式的常量类型中只有基本属性和字符串相对于的字面量</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>u2</code></td>
<td>attribute_name_index</td>
<td>属性名引用(哪种属性)在常量池中的索引，例如<code>Code</code>、<code>ConstantValue</code>等等</td>
</tr>
<tr>
<td align="center"><code>u4</code></td>
<td>attribute_lenght</td>
<td>ConstantValue内容的长度</td>
</tr>
<tr>
<td align="center"><code>u2</code></td>
<td>constantvalue_index</td>
<td>代表常量池中一个字面量常量的引用</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li>二进制中的<code>00 0A</code>代表常量池中的第10个常量<code>ConstantValue</code>，即<code>attribute</code>中的<code>ConstantValue</code>，<code>00 00 00 02</code>表示属性长度为2。<code>00 0B</code>表示常量池中第11个常量<code>0</code>，即<code>TestClass</code>中第三个成员方法代码为<code>private static final int j = 0;</code></li>
</ul>
<p>①：<a name='invokespecial'><code>invokespecial</code></a>指令的语义在JDK 1.0.2发生过改变，为了区别这条指令使用哪种语义，JDK 1.0.2之后编译后的类这个标志都为真。</p>
<p>②：<a name='max_locals'><code>Slot</code>：</a>对于<code>byte</code>、<code>char</code>、<code>float</code>、<code>int</code> 、<code>short</code>、<code>boolean</code>和<code>returnAddress</code>等不超过32位的数据类型，每个局部变量占用1个<code>Slot</code>，而<code>double</code>和<code>long</code>占用64个字节，所以用两个<code>Slot</code>存放。方法参数（包括实例方法中的隐藏参数<code>this</code>）、显式异常处理器的参数(Exception Handler Parameter，即<code>try-catch</code>语句中<code>catch</code>块所定义的异常)、方法体中定义的局部变量都需要使用局部变量表存放。<code>Slot</code>可以重用，因为部分局部变量会在超出局部变量范围后<code>Slot</code>被其他局部变量使用。</p>
<p>③：<a name='code1'><code>Code</code></a>：Code是Class文件中最重要的一个属性，Java程序中的信息分为：</p>
<ul>
<li>代码(Code)，方法体中的<strong>Java</strong>代码</li>
<li>元数据(Metadata)，类、字段、方法定义等信息。</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java web</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集</title>
    <url>/blog/2019/06/13/mysql/3_character_set/</url>
    <content><![CDATA[<p>计算机只能存储二进制数据，所以建立了字符与二进制数据的映射关系，即<strong>字符集</strong>。将一个字符映射成二级制数据的过程叫做<strong>编码</strong>，二进制映射到一个字符的过程叫做<strong>解码</strong>。</p>
<p>当我们确定字符集后，还需要确定比较规则。例如，汉字有几万个，对于某个字符集会有多种比较字符大小的规则。</p>
<a id="more"></a>

<p>计算机只能存储二进制数据，所以建立了字符与二进制数据的映射关系，即<strong>字符集</strong>。当我们确定字符集后，还需要确定比较规则。</p>
<h6 id="1-常见的字符集"><a href="#1-常见的字符集" class="headerlink" title="1. 常见的字符集"></a>1. 常见的字符集</h6><p>字符集有很多种，它们表示的字符范围和用到的编码规则不一样。</p>
<ul>
<li><p><code>ASCII</code>字符集，共收录128个字符集，包括空格、标点、数字、大小写字母等，共128个字符，用1个字节进行编码</p>
</li>
<li><p><code>ISO 8859-1</code>字符集，共收录256(2^8)个字符集，是在<code>ASCII</code>的基础上又扩充了128个西欧常用字符，也可以使用1个字节编码，别名<code>latin1</code>。</p>
</li>
<li><p><code>GB2312</code>，收录了汉字、拉丁字母、希腊字符、日文平假名及片假名字母、尔语西里尔字母。汉字6763个，其他文字符号682个。同时兼容<code>ASCII</code>字符集。</p>
<ul>
<li>如果字符在<code>ASCII</code>中，则采用1字节编码</li>
<li>否则采用2字节编码</li>
</ul>
<p>这种表示一个字符需要字节码数不同的编码方式，称为<code>边长编码方式</code>。例如，<code>爱u</code>，<code>爱</code>是汉字，用2个字节表示，编码后十六进制为<code>0xCED2</code>，<code>u</code>在<code>ASCII</code>码中，用1个字节编码<code>0x75</code>，所以拼接后为<code>0xCED275</code>。</p>
</li>
</ul>
<ul>
<li><code>GBK</code>，在收录范围上对<code>GB2312</code>做了扩充，向下兼容<code>GB2312</code>。</li>
<li><code>utf8</code>，收录了地球上所有的字符，还在不断扩充，兼容<code>ASCII</code>字符集，采用变长编码方式，一个字符需要1~4个字节。</li>
</ul>
<p>同一个字符，在不同字符集中有不同的编码方式。</p>
<h6 id="2-MySQL中支持的字符集和排序规则"><a href="#2-MySQL中支持的字符集和排序规则" class="headerlink" title="2. MySQL中支持的字符集和排序规则"></a>2. MySQL中支持的字符集和排序规则</h6><p>正常的<code>utf8</code>字符集表示一个字符需要1<del>4个字节，但是常用字符1</del>3个字节就可以表示，在MySQL中字符集表示一个字符所用最大字节长度会影响系统的存储和性能</p>
<ul>
<li><code>utf8mb3</code>(<code>utf8</code>)，阉割过的<code>utf8</code>字符集，只使用1~3个字节表示</li>
<li><code>utf8mb4</code>，正常的<code>utf8</code>字符集，使用1~4个字节表示</li>
</ul>
<h6 id="3-字符集的查看"><a href="#3-字符集的查看" class="headerlink" title="3. 字符集的查看"></a>3. 字符集的查看</h6><p><code>show charset;</code>或者<code>show character set;</code>查看MySQL中的字符集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show character set;</span><br><span class="line">+----------+-----------------------------+---------------------+--------+</span><br><span class="line">| Charset  | Description                 | Default collation   | Maxlen |</span><br><span class="line">+----------+-----------------------------+---------------------+--------+</span><br><span class="line">···</span><br><span class="line">| latin1   | cp1252 West European        | latin1_swedish_ci   |      1 |</span><br><span class="line">| latin2   | ISO 8859-2 Central European | latin2_general_ci   |      1 |</span><br><span class="line">···</span><br><span class="line">| ascii    | US ASCII                    | ascii_general_ci    |      1 |</span><br><span class="line">···</span><br><span class="line">| gb2312   | GB2312 Simplified Chinese   | gb2312_chinese_ci   |      2 |</span><br><span class="line">···</span><br><span class="line">| gbk      | GBK Simplified Chinese      | gbk_chinese_ci      |      2 |</span><br><span class="line">···</span><br><span class="line">| utf8     | UTF-8 Unicode               | utf8_general_ci     |      3 |</span><br><span class="line">···</span><br><span class="line">| utf8mb4  | UTF-8 Unicode               | utf8mb4_general_ci  |      4 |</span><br><span class="line">···</span><br><span class="line">| utf16    | UTF-16 Unicode              | utf16_general_ci    |      4 |</span><br><span class="line">···</span><br><span class="line">| utf32    | UTF-32 Unicode              | utf32_general_ci    |      4 |</span><br><span class="line">···</span><br><span class="line">+----------+-----------------------------+---------------------+--------+</span><br><span class="line">40 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>该版本MySQL共支持41中字符集（只展示部分常用字符集），<code>Default collation</code>表示这种字符集默认的比较规则。<code>Maxlen</code>表示表示一个字符最多需要几个字节。    </p>
<h6 id="4-比较规则"><a href="#4-比较规则" class="headerlink" title="4. 比较规则"></a>4. 比较规则</h6><p><code>show collation [like 匹配模式];</code>，查看比较规则。一个字符集对应多种比较规则，以下是只展示<code>utf8</code>比较规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show collation like &#39;utf8\_%&#39;;</span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">| Collation                | Charset | Id  | Default | Compiled | Sortlen |</span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">| utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 |</span><br><span class="line">| utf8_bin                 | utf8    |  83 |         | Yes      |       1 |</span><br><span class="line">| utf8_unicode_ci          | utf8    | 192 |         | Yes      |       8 |</span><br><span class="line">| utf8_icelandic_ci        | utf8    | 193 |         | Yes      |       8 |</span><br><span class="line">| utf8_latvian_ci          | utf8    | 194 |         | Yes      |       8 |</span><br><span class="line">| utf8_romanian_ci         | utf8    | 195 |         | Yes      |       8 |</span><br><span class="line">| utf8_slovenian_ci        | utf8    | 196 |         | Yes      |       8 |</span><br><span class="line">| utf8_polish_ci           | utf8    | 197 |         | Yes      |       8 |</span><br><span class="line">| utf8_estonian_ci         | utf8    | 198 |         | Yes      |       8 |</span><br><span class="line">| utf8_spanish_ci          | utf8    | 199 |         | Yes      |       8 |</span><br><span class="line">| utf8_swedish_ci          | utf8    | 200 |         | Yes      |       8 |</span><br><span class="line">| utf8_turkish_ci          | utf8    | 201 |         | Yes      |       8 |</span><br><span class="line">| utf8_czech_ci            | utf8    | 202 |         | Yes      |       8 |</span><br><span class="line">| utf8_danish_ci           | utf8    | 203 |         | Yes      |       8 |</span><br><span class="line">| utf8_lithuanian_ci       | utf8    | 204 |         | Yes      |       8 |</span><br><span class="line">| utf8_slovak_ci           | utf8    | 205 |         | Yes      |       8 |</span><br><span class="line">| utf8_spanish2_ci         | utf8    | 206 |         | Yes      |       8 |</span><br><span class="line">| utf8_roman_ci            | utf8    | 207 |         | Yes      |       8 |</span><br><span class="line">| utf8_persian_ci          | utf8    | 208 |         | Yes      |       8 |</span><br><span class="line">| utf8_esperanto_ci        | utf8    | 209 |         | Yes      |       8 |</span><br><span class="line">| utf8_hungarian_ci        | utf8    | 210 |         | Yes      |       8 |</span><br><span class="line">| utf8_sinhala_ci          | utf8    | 211 |         | Yes      |       8 |</span><br><span class="line">| utf8_german2_ci          | utf8    | 212 |         | Yes      |       8 |</span><br><span class="line">| utf8_croatian_ci         | utf8    | 213 |         | Yes      |       8 |</span><br><span class="line">| utf8_unicode_520_ci      | utf8    | 214 |         | Yes      |       8 |</span><br><span class="line">| utf8_vietnamese_ci       | utf8    | 215 |         | Yes      |       8 |</span><br><span class="line">| utf8_general_mysql500_ci | utf8    | 223 |         | Yes      |       1 |</span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">27 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>每种字符集对应多种比较规则，每种字符集都有默认的比较规则，<code>Default</code>列值为<code>YES</code>的就是该字符集的默认比较规则</p>
<p>具体命名规律如下：</p>
<ul>
<li><p>比较规则名称以字符集名称开头</p>
</li>
<li><p>后面是比较规则主要作用于哪种语言，例如，<code>utf8_polish_ci</code>是波兰语规则比较，<code>utf8_spanish_ci</code>是西班牙语比较规则，<code>utf8_general_ci</code>是通用的比较规则</p>
</li>
<li><p>名称后缀意味着该比较规则是否区分语言中的重音、大小写等</p>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">英文释义</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>_ai</code></td>
<td align="center"><code>accent insensitive</code></td>
<td align="center">不区分重音</td>
</tr>
<tr>
<td align="center"><code>_as</code></td>
<td align="center"><code>accent sensitive</code></td>
<td align="center">区分重音</td>
</tr>
<tr>
<td align="center"><code>_ci</code></td>
<td align="center"><code>case insensitive</code></td>
<td align="center">不区分大小写</td>
</tr>
<tr>
<td align="center"><code>_cs</code></td>
<td align="center"><code>case sensitive</code></td>
<td align="center">区分大小写</td>
</tr>
<tr>
<td align="center"><code>_bin</code></td>
<td align="center"><code>binary</code></td>
<td align="center">以二进制方式比较</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="5-字符集和比较规则的应用"><a href="#5-字符集和比较规则的应用" class="headerlink" title="5. 字符集和比较规则的应用"></a>5. 字符集和比较规则的应用</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;character%&#39;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | &#x2F;usr&#x2F;share&#x2F;mysql&#x2F;charsets&#x2F; |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#39;collation%&#39;;</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">| Variable_name        | Value           |</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">| collation_connection | utf8_general_ci |</span><br><span class="line">| collation_database   | utf8_general_ci |</span><br><span class="line">| collation_server     | utf8_general_ci |</span><br><span class="line">+----------------------+-----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><code>MysQL</code>有4个级别的字符集和比较规则，如下：</p>
<ul>
<li>服务器级别，</li>
<li>数据库级别</li>
<li>表级别</li>
<li>列级别</li>
</ul>
<ol>
<li><p>服务器级别</p>
<p><code>MySQL</code>提供了两个系统变量来表示服务器字符集和比较规则</p>
<ul>
<li><code>character_set_server</code>，服务器级别的字符集</li>
<li><code>collation_server</code>，服务器级别的比较规则</li>
</ul>
<p>我们可以通过命令行或者配置文件修改服务器级别的字符集与比较规则，也可以在服务器启动后使用<code>set</code>语句修改字符集和比较规则</p>
</li>
<li><p>数据库级别</p>
<p><code>MySQL</code>提供了两个系统变量来表示数据库字符集和比较规则</p>
<ul>
<li><code>character_set_database</code>，服务器级别的字符集</li>
<li><code>collation_database</code>，服务器级别的比较规则</li>
</ul>
<p>这两个变量<font color='red'>只读</font>，不能通过修改这个变量的值改变当前数据库的字符集和比较规则，在创建和修改数据库的时候可以指定该数据库的字符集和比较规则。</p>
<p><code>alter database db_name character set utf8;</code></p>
<p>数据库创建时可以不指定字符集和比较规则，这样将使用服务器级别的字符集和比较规则作为数据库字符集和比较规则。</p>
</li>
<li><p>表级别</p>
<p>可以在创建和修改表时指定表的字符集和比较规则，若建表时不指定字符集和比较规则，则使用数据库的字符集和比较规则。</p>
</li>
<li><p>列级别</p>
<p>同一表中不同的列有不同的字符集和比较规则。在创建表和修改列定义时可以指定列的字符集和比较规则。修改列时，没有指定字符集和比较规则使用该表的字符集和比较规则。</p>
</li>
</ol>
<h6 id="7-仅修改字符集或者比较规则"><a href="#7-仅修改字符集或者比较规则" class="headerlink" title="7. 仅修改字符集或者比较规则"></a>7. 仅修改字符集或者比较规则</h6><p>字符集和比较规则是互相有联系的，如果我们修改列字符集，比较规则会跟着变化，只修改了比较规则，字符集也会变化</p>
<ul>
<li>只修改字符集，则比较规则变为对应字符集默认的比较规则</li>
<li>只修改比较规则，则字符集变为对应比较规则的字符集</li>
</ul>
<h6 id="8-MySQL中字符集的转换"><a href="#8-MySQL中字符集的转换" class="headerlink" title="8. MySQL中字符集的转换"></a>8. MySQL中字符集的转换</h6><p>客户端发送到服务器的请求本质上是一个字符串，服务器向客户端返回的本质也是字符串。字符串是使用某种字符集编码的二进制数据，从发送到返回结果过程中伴随着多次字符集的转换，这个过程中会用到以下3个系统变量：</p>
<table>
<thead>
<tr>
<th align="center">系统变量</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>character_set_client</code></td>
<td align="center">服务器解码请求使用</td>
</tr>
<tr>
<td align="center"><code>character_set_connection</code></td>
<td align="center">服务器处理请求时使用</td>
</tr>
<tr>
<td align="center"><code>character_set_results</code></td>
<td align="center">服务器向客户端返回数据时使用</td>
</tr>
</tbody></table>
<ul>
<li>客户端使用操作系统的字符集编码(<code>character_set_client</code>)请求字符串，向服务器发送的是经过编码的字符串。</li>
<li>服务器将发送过来的字符串使用<code>character_set_client</code>进行解码，再使用<code>character_set_connection</code>进行编码。</li>
<li>如果<code>character_set_connection</code>的字符集与具体操作列编码一致，则直接进行相应操作，否则需要将请求种的字符串从<code>character_set_connection</code>代表的字符集转换为具体操作列使用的字符集之后再进行操作。</li>
<li>将从某个列获取到的字符串从该列使用的字符集转换为<code>character_set_results</code>代表的字符集后发送到客户端。</li>
</ul>
<h6 id="9-比较规则的应用"><a href="#9-比较规则的应用" class="headerlink" title="9. 比较规则的应用"></a>9. 比较规则的应用</h6><p><strong>比较规则</strong>的作用通常提现比较字符串大小以及对某个字符串列进行排序种，所以也成为<strong>排序规则</strong>。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>启动选项和配置文件</title>
    <url>/blog/2019/06/11/mysql/2_startup_options_config_files/</url>
    <content><![CDATA[<p><strong>MySQL</strong>服务器程序和客户端程序有很多设置项。例如，<strong>MySQL</strong>服务器程序的客户端连接数量、客户端和服务器的通讯方式、表的默认存储引擎、查询缓存大小等等；<strong>MySQL</strong>客户端的<code>mysql -h host -P port -p password</code>等。这些设置项一般都有默认值，例如服务器最大客户端连接数151，表默认存储引擎是<strong>InnoDB</strong>。我们可以在程序启动的时候去修改默认值（启动选项，startup options）。在<strong>MySQL</strong>的<code>bin</code>目录下的可执行文件，例如<code>mysqld</code>、<code>mysql_safe</code>、<code>mysql</code>、<code>mysqladmin</code>，启动的时候都可以指定启动参数</p>
<ul>
<li>在命令行中指定</li>
<li>在配置文件中指定</li>
</ul>
<a id="more"></a>

<h6 id="1-在命令行中设置启动参数"><a href="#1-在命令行中设置启动参数" class="headerlink" title="1. 在命令行中设置启动参数"></a>1. 在命令行中设置启动参数</h6><p>启动服务器端的时候使用<code>skip-networking</code>命令，<code>mysqld --skip-networking</code>禁止客户端进程通过TCP/IP的方式与服务器通信。启动命令<code>mysqld --default-storage-engine=InnoDB</code>把存储引擎设置为<strong>InnoDB</strong>。</p>
<p>在命令行中设置启动参数的格式：每个设置项前加<code>--</code>前缀，设置项之间用空格隔开，需要设置值的启动项用<code>=</code>且不能带空白字符，例如，<code>mysqld --skip-networking --default-storage-engine=InnoDB</code>。</p>
<p>设置项还有长形式和短形式，<strong>MySQL</strong>对于常用设置项提供了短形式，常见如下</p>
<table>
<thead>
<tr>
<th align="center">长形式</th>
<th align="center">短形式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>--host</code></td>
<td align="center"><code>-h</code></td>
<td align="center">主机名</td>
</tr>
<tr>
<td align="center"><code>--user</code></td>
<td align="center"><code>-u</code></td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center"><code>--password</code></td>
<td align="center"><code>-p</code></td>
<td align="center">密码</td>
</tr>
<tr>
<td align="center"><code>--port</code></td>
<td align="center"><code>-P</code></td>
<td align="center">端口号</td>
</tr>
<tr>
<td align="center"><code>--version</code></td>
<td align="center"><code>-V</code></td>
<td align="center">MySQL版本信息</td>
</tr>
</tbody></table>
<h6 id="2-配置文件中设置启动参数"><a href="#2-配置文件中设置启动参数" class="headerlink" title="2. 配置文件中设置启动参数"></a>2. 配置文件中设置启动参数</h6><p>命令行中设置参数只对当次连接生效，所以如果想要设置对于所有连接通用的启动参数，需要在配置文件中设置，这样可以长期保存到硬盘中，每次启动服务器都可以从文件中加载启动选项。</p>
<ol>
<li><p>配置文件的路径</p>
<p><strong>MySQL</strong>程序启动时会寻找多个路径下的配置，既有固定的，又存在可以在名两行中设置的，以下以类Unix为例，</p>
<table>
<thead>
<tr>
<th align="center">路径名</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>/etc/my.cnf</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>/etc/mysql/my.cnf</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>SYSCONFDIR/my.cnf</code></td>
<td align="center">CMAKE构建时指定的目录，默认是位于安装目录下的<code>etc</code>目录</td>
</tr>
<tr>
<td align="center"><code>$MYSQL_HOME/my.cnf</code></td>
<td align="center">仅限服务器的选项</td>
</tr>
<tr>
<td align="center"><code>default-extra-file</code></td>
<td align="center">命令行指定的额外配置文件路径</td>
</tr>
<tr>
<td align="center"><code>~/.my.cnf</code></td>
<td align="center">用户特定选项</td>
</tr>
<tr>
<td align="center"><code>~/mylogin.cnf</code></td>
<td align="center">用户特定的登陆选项</td>
</tr>
</tbody></table>
<ul>
<li><strong>MySQL_HOME</strong>是环境变量，该目录下只能设置启动服务器相关配置</li>
<li><code>~</code>开头的路径是用户相关的，类Unix系统都有用户的概念，每个用户都可以有一个目录<code>~</code>表示用户目录下。</li>
</ul>
<p>另外，<strong>MySQL</strong>服务器启动时，会调用其他启动服务。例如启动<code>mysqld_safe</code>启动会间接调用<code>mysqld</code>，所以传递给<code>mysqld_safe</code>的启动选项，可能<code>mysqld_safe</code>并不处理，而是由<code>mysqld</code>处理。</p>
</li>
<li><p>配置文件的内容</p>
<p>配置文件中启动选项分为若干个组，每个组都有一个组名<code>[]</code>括起来。每个组下有若干个启动选项。不同的组是给不同的命令使用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port&#x3D;3306</span><br><span class="line"># 服务端使用的字符集默认为UTF8</span><br><span class="line">character-set-server&#x3D;utf8mb4</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line"># 允许的最大连接数</span><br><span class="line">max_connections&#x3D;200</span><br><span class="line">[mysqld_safe]</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqladmin]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">启动命令</th>
<th align="center">类别</th>
<th>能读取的组</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>mysqld</code></td>
<td align="center">启动服务器</td>
<td><code>[mysqld]</code>、<code>[server]</code></td>
</tr>
<tr>
<td align="center"><code>mysqld_safe</code></td>
<td align="center">启动服务器</td>
<td><code>[mysqld]</code>、<code>[server]</code>、<code>[mysql_safe]</code></td>
</tr>
<tr>
<td align="center"><code>mysql.server</code></td>
<td align="center">启动服务器</td>
<td><code>[mysqld]</code>、<code>[server]</code>、<code>[mysql.server]</code></td>
</tr>
<tr>
<td align="center"><code>mysql</code></td>
<td align="center">启动客户端</td>
<td><code>[mysql]</code>、<code>[client]</code></td>
</tr>
<tr>
<td align="center"><code>mysqladmin</code></td>
<td align="center">启动客户端</td>
<td><code>[mysqladmin]</code>、<code>[client]</code></td>
</tr>
<tr>
<td align="center"><code>mysqldump</code></td>
<td align="center">启动客户端</td>
<td><code>[mysqldump]</code>、<code>[client]</code></td>
</tr>
</tbody></table>
</li>
<li><p>配置文件的优先级</p>
<p>MySQL将在某些固定的路径搜索配置文件，也可以在<code>defaults-extra-file</code>启动选项来指定额外的配置文件路径。<strong>MySQL</strong>将按照上文顺序依次读取各个配置文件，文件不存在则忽略，如果设置了相同的启动选项，以最后一个配置文件中的设置项为准。</p>
<p>在同一个配置文件中，多个组中存在同样的配置，则以后出现的为准。</p>
<p><code>defaults-file</code>会指定读取的配置文件（MySQL不会在默认路径下搜索配置文件），<code>defaults-extra-file</code>和<code>defaults-file</code>的区别，使用<code>defaults-extra-file</code>可以指定额外的配置文件搜索路径（也就是说那些固定的配置文件路径也会被搜索）。</p>
</li>
<li><p>命令行和配置文件中启动的区别</p>
<p><strong>MySQL</strong>命令行中绝大部分启动项都可以在配置文件中使用，部分命令是专为命令行设计的，例如：<code>defaults-extra-file</code>、<code>defaults-file</code>这种指定配置文件相关的命令，放在配置文件中没有意义。若一个启动项即出现在命令行中，又出现在配置文件中，则以命令行中的启动项为准。</p>
</li>
</ol>
<h6 id="3-系统变量"><a href="#3-系统变量" class="headerlink" title="3. 系统变量"></a>3. 系统变量</h6><p><strong>MySQL</strong>服务器中有许多影响程序行为的变量，即<strong>MySQL</strong>系统变量。例如：<code>max_connections</code>、<code>defaults_storage_engine</code>等，每个系统变量都有一个默认值，我们可以使用命令行或者配置文件修改默认值，也可以在程序运行过程中修改，无需停止并重启服务。</p>
<p><code>show variables like &#39;%variable_name%&#39;;</code>可以查看系统变量。</p>
<p>大部分启动项可以通过命令行或者配置文件进行设置，但是对于由多个单词组成的启动项来说，可以使用<code>-</code>或者<code>_</code>，系统变量则必须由<code>_</code>连接起来。</p>
<p><strong>MySQL</strong>的系统变量有作用范围的概念，如下：</p>
<ul>
<li><code>GLOBAL</code>，全局变量，影响服务器的整体操作</li>
<li><code>SESSION</code>，会话变量，影响客户端连接的操作</li>
</ul>
<p>服务器启动时，会将系统变量初始化为默认值（可以通过命令行或者配置文件修改默认值），然后服务器会为每个连接的客户端维护一组会话变量，客户端连接时使用相应的全局变量的值初始化会话变量。即通过命令行或者配置文件设置的系统变量作用域是<code>GLOBAL</code>，客户端连接时维护的会话变量是<code>SESSION</code>的。</p>
<p><code>SET [GLOBAL | SESSION] variable_name=value</code></p>
<p><code>SET @@(GLOBAL | SESSION).variable_name=value</code></p>
<p><code>SET variable_name=value</code>，默认是SESSION级别</p>
<p>并不是所有的系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>作用范围，例如：<code>max_connections</code>只具有<code>GLOBAL</code>作用范围，<code>insert_id</code>只具有<code>SESSION</code>作用范围。还有部分系统变量是只读的。</p>
<h6 id="4-系统变量与启动选项的区别"><a href="#4-系统变量与启动选项的区别" class="headerlink" title="4. 系统变量与启动选项的区别"></a>4. 系统变量与启动选项的区别</h6><p><strong>启动选项</strong>是程序启动时传递的一些参数，<strong>系统变量</strong>是影响程序运行行为的变量。</p>
<ul>
<li>大部分系统变量都可以作为启动项传入</li>
<li>有些系统变量是在程序运行过程中生成的，不能作为启动项设置，例如：<code>character_set_client</code></li>
<li>有些启动项不是系统变量，例如：<code>defaults-file</code></li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机性能监控与故障处理工具</title>
    <url>/blog/2019/06/10/jvm/4_vm_monitor/</url>
    <content><![CDATA[<h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h6><p><strong>从实践角度了解虚拟机内存管理的世界</strong>。当我们给系统定位问题的时候，知识、经验是管件基础，数据是依据，工具是运用知识处理数据的手段。数据包括：运行日志、异常对战、GC日志、线程快照（threaddump/javacore文件）、堆转储快照（heapdump/hprof）等</p>
<h6 id="2-JDK的命令行工具"><a href="#2-JDK的命令行工具" class="headerlink" title="2. JDK的命令行工具"></a>2. JDK的命令行工具</h6><p>主要介绍用于监视虚拟机和故障处理的工具。JDK的工具在<code>bin</code>目录下。</p>
<p><img src="https://images.effiu.cn/blog/jvm/13.jpg" alt="JDK工具目录"></p>
<p>这些工具很小，其是针对<code>lib/tool.jar</code>类库的封装。当应用程序部署到生成环境后，无论是直接接触物理服务器还是远程<strong>Telnet</strong>到服务器上可能都会受到限制，借助<code>tools.jar</code>类库里的接口，我们可以直接在应用程序中实现强大的监控分析功能。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jps</td>
<td>JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</td>
</tr>
<tr>
<td align="center">jstat</td>
<td>JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面运行数据</td>
</tr>
<tr>
<td align="center">jinfo</td>
<td>Configuration Info for Java，显示虚拟机配置信息</td>
</tr>
<tr>
<td align="center">jmap</td>
<td>Memory Map for Java，生成虚拟机内存转储快照(heapdump文件)</td>
</tr>
<tr>
<td align="center">jhat</td>
<td>JVM Heap Dump Browser，用于分析heapdump文件，会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td>
</tr>
<tr>
<td align="center">jstack</td>
<td>Stack Trace for Java，显示虚拟机线程快照</td>
</tr>
</tbody></table>
<ol>
<li><p>jps：虚拟机进程状况工具</p>
<p>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class, main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(Local Virtual Machine Identifier, LVMID)。其他命令都需要jps命令的配合确定进程ID，对于本地虚拟机进程来说，LVMID与操作系统的进程ID(Process Identifier, PID)一致。<code>jps [options] [hostid]</code>，执行举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vdevops jvm]# jps -l</span><br><span class="line">14017 sun.tools.jps.Jps</span><br><span class="line">31365 org.apache.catalina.startup.Bootstrap</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中欧冠注册的主机名。</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-q</td>
<td>指数从<strong>LVMID</strong>，省略类的名称</td>
</tr>
<tr>
<td align="center">-m</td>
<td>输出虚拟机启动时传递给<code>mian()</code>函数的参数</td>
</tr>
<tr>
<td align="center">-l</td>
<td>输出主类的全名，若进程是Jar包，则输出Jar路径</td>
</tr>
<tr>
<td align="center">-v</td>
<td>输出虚拟机进程启动的JVM参数</td>
</tr>
</tbody></table>
</li>
<li><p>jstat：虚拟机统计信息监视工具</p>
<p><code>jstat</code>（JVM Statistics Monitor Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类状态、内存、垃圾收集、JIT编译等运行数据，其是运行期定位性能问题的首选工具。</p>
<p>命令格式：<code>jstat [option vmid] [interval [s|ms] [count]]</code>，若是本地虚拟机进程，VMID与LVMID一致，若是远程虚拟机进程，那VMID的格式是：<code>[protocol:][//][lvmind][@hostname[:port]/servername]</code>。<code>interval</code>和<code>count</code>分别表示查询间隔和次数，默认只查询一次。<code>option</code>代表用户想要查询的信息，主要分为3类：类装载、垃圾收集、运行期编译状态</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-class</td>
<td>监视器类状态、卸载数量、总空间以及类装载消耗的时间</td>
</tr>
<tr>
<td align="center">-gc</td>
<td>监视Java堆状态，已用空间、GC时间等合计信息</td>
</tr>
<tr>
<td align="center">-gccapacity</td>
<td>基本与<code>-gc</code>相同，但主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcutil</td>
<td>监视内容与<code>-gc</code>相同，主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td align="center">-gcnew</td>
<td>监视新生代GC状况</td>
</tr>
<tr>
<td align="center">-gcnewcapacity</td>
<td>监视内容与<code>-gcnew</code>相同，主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-gcold</td>
<td>监视老年代GC状况</td>
</tr>
<tr>
<td align="center">-gcoldcapacity</td>
<td>监视内容与<code>-gcold</code>相同，主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td align="center">-compiler</td>
<td>输出JIT编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td align="center">-printcompilation</td>
<td>输出已被JIT编译器编译的方法</td>
</tr>
</tbody></table>
</li>
<li><p>jinfo：Java配置信息工具</p>
<p>jinfo(Configuration Info for Java)的作用是实时查看和调整虚拟机各项参数。使用<code>jps -v</code>可以查看虚拟机启动时显示指定的参数，<code>jinfo -flag</code>和<code>jinfo -flags</code>可以查看参数的系统默认值；<code>-XX:+PrintFlagsFinal</code>也可以查看参数的默认值；<code>jinfo -sysprops</code>可以把虚拟机进程的<code>System.getProperties()</code>内容打印出来。</p>
<p><code>jinfo [option] pid</code></p>
</li>
<li><p>jmap：Java内存映像工具</p>
<ul>
<li><code>jmap [option] vmid</code>，jmap(Memory Map for Java)命令用于生成堆转储快照。</li>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>，虚拟机会在OOM异常出现之后自动生成dump文件</li>
<li><code>-XX:+HeapDumpOnCtrlBreak</code>，[Ctrl]+[Break]键会让虚拟机生成dump文件</li>
<li><code>kill -3</code>发送进程退出信号，也可以拿到dump文件</li>
</ul>
<p>jmap，不仅仅可以拿到dump文件，还可以查询finalize执行队列、Java堆的详细信息，如空间使用率、当前使用的垃圾收集器等</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-dump</td>
<td>生成Java堆转储快照。格式: -dump:[live, ]format=b file=<filename>，live参数表示是否指dump出存活的对象</td>
</tr>
<tr>
<td align="center">-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize()方法的对象</td>
</tr>
<tr>
<td align="center">-heap</td>
<td>显示Java堆详细信息，例如，GC、参数配置、分代状态等</td>
</tr>
<tr>
<td align="center">-histo</td>
<td>显示堆中对象统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td align="center">-F</td>
<td>当虚拟机进程对<code>-dump</code>选项没有响应时，可以使用<code>-F</code>强制生成dump快照</td>
</tr>
</tbody></table>
</li>
<li><p>jhat：虚拟机堆转储快照分析工具</p>
<p>jhat(JVM Heap Analysis Tool)命令与jmap搭配使用分析jamp生成的堆转储快照。jhat内置了一个微型HTTP/HTML服务器，生成dump文件分析结果后可以在浏览器中查看。不建议使用。</p>
<ul>
<li>一般不会再部署应用程序的服务器上直接分析jmap文件，因为分析工作是一个耗时且消耗硬件资源的过程</li>
<li>jhat分析功能相对来说比较简陋</li>
</ul>
</li>
<li><p>jstack：Java堆栈跟踪工具</p>
<p>jstack(Stack Trace For Java)，用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待等等。出现长时间停顿时，通过<code>jstack</code>查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台的运行情况</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈快照</td>
</tr>
<tr>
<td align="center">-l</td>
<td>除堆栈外，关于锁的附加信息</td>
</tr>
<tr>
<td align="center">-m</td>
<td>调用到本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody></table>
</li>
<li><p>HSDIS：JIT生成代码反汇编</p>
<p>HSDIS是Sun官方推荐的<strong>HotSpot</strong>虚拟机JIT编译代码的反汇编插件，包含在<strong>HotSpot</strong>虚拟机源码中，作用是让HotSpot的<code>-XX:+PrintAssembly</code>指令调用它来把动态生成的本地代码还原为汇编代码输出，同时还会有大量有价值的注释，我们可以通过输出的本地代码分析问题。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>认识MqSQL</title>
    <url>/blog/2019/06/10/mysql/1_first_mysql/</url>
    <content><![CDATA[<h6 id="1-启动MySQL服务"><a href="#1-启动MySQL服务" class="headerlink" title="1. 启动MySQL服务"></a>1. 启动MySQL服务</h6><ul>
<li><p><strong>mysqld</strong></p>
<p>这个可执行文件就代表着<code>MySql</code>服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。</p>
</li>
<li><p><strong>mysqld_safe</strong></p>
<p><code>mysqld_safe</code>是一个启动脚本，会间接调用<code>mysqld</code>，而且还启动了一个监控进程，这个监控进程会在服务器进程挂掉得时候重启进程。<code>mysqld_safe</code>会将服务器程序得出错信息和其他诊断信息重定向到某个文件中，产生出错日志，方便排查问题。</p>
</li>
<li><p><strong>mysql.server</strong></p>
<p><code>mysql.server</code>也是一个启动脚本，会间接调用<code>mysqld_safe</code>，调用命令<code>mysql.server start</code>。其实际文件是<code>../support-files/mysql.server</code></p>
</li>
<li><p><strong>mysqld_multi</strong></p>
<p>一台计算机上运行多个MySQL进程时，<code>mysqld_multi</code>可执行文件可以对每个实例进行启动或停止进行监控。</p>
</li>
</ul>
<h6 id="2-启动MySQL客户端程序"><a href="#2-启动MySQL客户端程序" class="headerlink" title="2. 启动MySQL客户端程序"></a>2. 启动MySQL客户端程序</h6><ol>
<li>连接MySQL服务：<code>mysql -h host -u username -p</code></li>
<li>断开连接：<code>quit</code>、<code>exit</code>、<code>\q</code></li>
</ol>
<h6 id="3-客户端与服务器连接过程"><a href="#3-客户端与服务器连接过程" class="headerlink" title="3. 客户端与服务器连接过程"></a>3. 客户端与服务器连接过程</h6><p>MySQL支持下边三种客户端进程和服务器进程得通信方式</p>
<ol>
<li><p><strong>TCP/IP</strong></p>
<p>数据库进程与客户端进程在不同的服务器中，它们之间通过网络通讯。<strong>MySQL</strong>采用<strong>TCP</strong>作为服务器和客户端之间的网络通信协议。在网络中的其他进程就可以通过<code>IP地址 + 端口号</code>的方式来与这个进程连接。<strong>MySQL</strong>服务器默认监听3306端口。<code>mysqld -P3307</code>，指定启动端口号</p>
</li>
</ol>
<blockquote>
<p><code>TCP/IP</code>网络体系结构是现在通用的一种网络体系结构，其中的<code>TCP</code>和<code>IP</code>是体系结构中两个非常重要的网络协议。</p>
</blockquote>
<ol start="2">
<li><p><strong>命名管道和共享内存</strong></p>
<p><code>Windows</code>用户，客户端进程和服务器进程之间可以考虑使用<strong>命名管道</strong>和<strong>共享内存</strong>进行通信。</p>
<ul>
<li><strong>命名管道</strong>，服务器启动参数加<code>--enable-named-pipe</code>，客户端命令中加<code>--pipe</code>或者<code>--protocol=pipe</code></li>
<li><strong>共享内存</strong>，服务器启动参数加<code>--share-memory</code>，也可以在客户端命令中加<code>--protocol=memory</code>显式指定使用共享内存通信。但要求客户端与服务端进程在同一台<code>Windows</code>主机中</li>
</ul>
</li>
<li><p><strong>Unix套接字文件</strong></p>
<p>服务端进程与客户端进程都在同一台类<strong>Unix</strong>服务器上，则可以使用<strong>Unix</strong>域套接字文件来进行进程间通信。启动客户端程序的时候指定主机为<code>localhost</code>或者指定<code>--protocol=socket</code>启动参数就会使用<strong>Unix</strong>域套接字文件进行通信。<strong>MySQL</strong>默认监听<strong>Unix</strong>套接字文件路径<code>/tmp/mysql.sock</code>，客户端也默认使用这个文件。也可以指定<code>socket</code>套接字参数<code>--socket=/tmp/a.txt</code>。</p>
</li>
</ol>
<h6 id="4-服务器处理客户端请求"><a href="#4-服务器处理客户端请求" class="headerlink" title="4. 服务器处理客户端请求"></a>4. 服务器处理客户端请求</h6><p><img src="https://images.effiu.cn/blog/mysql/1224549-20190322161637421-1625662895.png" alt="请求过程"></p>
<ol>
<li><p>连接管理</p>
<p>客户端与服务端连接时，服务端会创建或者分配一个线程专门处理。断开连接后，服务器并不会立即销毁这个线程，而是将该线程缓存起来。在另一个客户端申请连接后，将该线程继续分配给其他客户端，从而节省开销。<code>Mysql</code>会为每个客户端分配一个线程，但是线程分配太多会影响性能，所以也需要限制可以同时连接到服务器的客户端数量。相关命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%max_connections%&#39;; &#x2F;&#x2F; 查看最低连接数</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| extra_max_connections | 1     |</span><br><span class="line">| max_connections       | 10000 |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">2 rows in set</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Threads%&#39;;	&#x2F;&#x2F; 查看相关线程数</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Threads_cached          | 247   |		&#x2F;&#x2F; 缓存连接数</span><br><span class="line">| Threads_connected       | 204   |		&#x2F;&#x2F; 打开的连接数</span><br><span class="line">| Threads_created         | 451   |</span><br><span class="line">| Threads_running         | 1     |		&#x2F;&#x2F; 激活的连接数，一般低于connected数值</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">8 rows in set</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show full processlist;   &#x2F;&#x2F; 查看所有连接线程的连接信息</span><br><span class="line">show processlist;		 &#x2F;&#x2F; 显示前100条连接信息</span><br><span class="line">+---------+-------------+---------------------+------------------------+---------+-------+-------+-----------------------+-----------+---------------+</span><br><span class="line">| Id      | User        | Host                | db                     | Command | Time  | State | Info                  | Rows_sent | Rows_examined |</span><br><span class="line">+---------+-------------+---------------------+------------------------+---------+-------+-------+-----------------------+-----------+---------------+</span><br></pre></td></tr></table></figure>

<p>客户端连接时，需要携带<code>host</code>、<code>username</code>、<code>port</code>、<code>password</code>等信息，客户端会进行认证，认证失败服务器会拒绝连接。</p>
</li>
<li><p>解析与优化</p>
<p><code>MySQL</code>连接正常后，还要经过其他处理。</p>
<ol>
<li><p>查询缓存</p>
<p><code>MySQL</code>会把服务器处理的查询请求和结果缓存起来，下次请求若命中缓存则会直接返回结果。这个缓存是在不同客户端之间共享的。不过当查询请求有任何变动（空格、注释、大小写等）都会导致不会命中缓存，另外查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表(<code>mysql</code>、<code>information_schema</code>、<code> performance_schema</code>)都会导致缓存请求不会被缓存，例如<code>NOW</code>函数。</p>
<p><code>MySQL</code>的缓存系统会监视涉及到的每张表，只要该表的结构或者数据被修改（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>DROP TABLE</code>、<code>ALTER TABLE</code>等语句）都会导致相关缓存失效并删除。</p>
<p>虽然查询缓存会提高性能，但维护缓存也会造成开销（去缓存中查询、更新缓存、占用内存空间）等，不推荐使用缓存</p>
</li>
<li><p>语法解析</p>
<p>缓存命中失败，就会进入查询阶段。<code>MySQL</code>会对客户端发送过来的文本进行解析，判断语法是否正确，从文本中将要查询的表、字段、查询条件解析出来。其本质是一个编译过程，涉及词法解析、语法分析、语义分析等阶段。</p>
</li>
<li><p>查询优化</p>
<p>当服务端经过语法解析后，获得了查询的条件、表、列等需要的信息。<code>MySQL</code>优化程序会对语句进行优化，例如：外连接转换为内连接、表达式简化、子查询转化为连接等。优化结果会生成一个执行计划，会表明应该使用哪些索引查询、表的连接顺序是什么等，可以使用<code>EXPLAIN</code>语句查看语句的执行计划</p>
</li>
<li><p>存储引擎</p>
<p><code>MySQL</code>服务器把数据的存储和提取操作都封装到了<strong>存储引擎</strong>模块里，表是一行一行的记录组成的，但是这是逻辑上的概念，实际在物理存储介质上，读取数据、写入数据都是<strong>存储引擎</strong>负责的。<code>MySQL</code>提供了多种存储引擎，不同的存储引擎有不同的结构，存取算法也有区别。</p>
</li>
</ol>
<blockquote>
<p>为了方便管理把，连接管理、缓存查询、语法解析、查询优化不涉及真实数据存储的功能划分为<code>MySQL server</code>的功能，真实存储数据的为<strong>存储引擎</strong>。</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/mysql/1224549-20190322161700846-234684790.png" alt="请求过程"></p>
</li>
</ol>
<h6 id="5-常用存储引擎"><a href="#5-常用存储引擎" class="headerlink" title="5. 常用存储引擎"></a>5. 常用存储引擎</h6><table>
<thead>
<tr>
<th align="center">存储引擎</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ARCHIVE</td>
<td align="center">用于数据存档，存储之后不能修改</td>
</tr>
<tr>
<td align="center">BLACKHOLE</td>
<td align="center">黑洞引擎，解决Mysql集群，同步<code>binlog</code>时给master造成太大负担问题，<a href="https://www.cnblogs.com/wt645631686/p/8086682.html">主从架构中的作用</a></td>
</tr>
<tr>
<td align="center">CSV</td>
<td align="center">在存储数据时，以逗号分隔各个数据项，<a href="https://www.jianshu.com/p/7ec7429a78d2">CSV</a></td>
</tr>
<tr>
<td align="center">FEDERADED</td>
<td align="center">用来访问远程表</td>
</tr>
<tr>
<td align="center">InnoDB</td>
<td align="center">具备外键，支持索引，支持事务</td>
</tr>
<tr>
<td align="center">MEMORY</td>
<td align="center">置于内存的表</td>
</tr>
<tr>
<td align="center">MERGE</td>
<td align="center">用来管理多个MyISAM表构成的表集合</td>
</tr>
<tr>
<td align="center">MyISAM</td>
<td align="center">主要的非事务处理存储引擎，查询快、占用空间小、处理速度快，但不支持事务</td>
</tr>
<tr>
<td align="center">NDB</td>
<td align="center">MySQL集群专用存储引擎</td>
</tr>
</tbody></table>
<p>存储引擎对于某些功能的支持情况如下：</p>
<table>
<thead>
<tr>
<th align="center">Feature</th>
<th align="center">MyISAM</th>
<th align="center">Memory</th>
<th align="center">InnoDB</th>
<th align="center">Archive</th>
<th align="center">NDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B-tree indexes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">Backup/point-in-time recovery</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Cluster database support</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Clustered indexes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">Compressed data</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">Data caches</td>
<td align="center">no</td>
<td align="center">N/A</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Encrypted data</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Foreign key support</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Full-text search indexes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">Geospatial data type support</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Geospatial indexing support</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">Hash indexes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Index caches</td>
<td align="center">yes</td>
<td align="center">N/A</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Locking granularity</td>
<td align="center">Table</td>
<td align="center">Table</td>
<td align="center">Row</td>
<td align="center">Row</td>
<td align="center">Row</td>
</tr>
<tr>
<td align="center">MVCC</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">Query cache support</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Replication support</td>
<td align="center">yes</td>
<td align="center">Limited</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Storage limits</td>
<td align="center">256TB</td>
<td align="center">RAM</td>
<td align="center">64TB</td>
<td align="center">None</td>
<td align="center">384EB</td>
</tr>
<tr>
<td align="center">T-tree indexes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Transactions</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Update statistics for data dictionary</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
<h6 id="6-相关操作"><a href="#6-相关操作" class="headerlink" title="6. 相关操作"></a>6. 相关操作</h6><ol>
<li>查看当前支持的引擎</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br></pre></td></tr></table></figure>

<p><code>Support</code>表示该引擎是否可用，<code>Default</code>代表默认引擎，<code>Comment</code>是对存储引擎的一个描述，<code>Transactions</code>列代表该存储引擎是否支持事务处理。<code>XA</code>列代表着该存储引擎是否支持分布式事务。<code>Savepoints</code>代表着该存储引擎是否支持部分事务回滚。</p>
<ol start="2">
<li><p>设置表的存储引擎</p>
<p>存储引擎是对表中的数据进行提取和写入的，我们可以为不同表设置不同的存储引擎。相关SQL如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 建表SQL，指定存储引擎</span><br><span class="line">CREATE TABLE table_name(</span><br><span class="line">    建表语句;</span><br><span class="line">) ENGINE &#x3D; INNODB;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 修改表的存储引擎</span><br><span class="line">ALTER TABLE table_name ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看建表语句，会展示当前表引擎</span><br><span class="line">SHOW CREATE TABLE table_name\G;</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <url>/blog/2019/06/10/jvm/3_gc_memory_allocation/</url>
    <content><![CDATA[<p>Java与C++之间主要区别：内存动态分配和垃圾收集技术</p>
<h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h6><p>当需要排查各种内存溢出、内存泄露问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，就需要我们对内存分配与内存回收实施必要的监控与调节。</p>
<p>Java内存运行区域中程序计数器、虚拟机栈、本地方法栈会随着线程而存在和销毁；栈中的栈帧随着方法的进入和退出而执行出栈和入栈操作，每个栈帧中分配多少内存是在类结构中确定的（JIT编译器会进行一些优化），所以这些区域不需要过多考虑回收，它们会随着线程结束或者方法结束被回收。</p>
<p>Java堆和方法区是所有线程共享的，一个接口的多个实现类需要的内存不确定，一个方法的多个分支中需要的内存也不确定，只有在程序运行期才知道创建哪些对象，其内存分配和回收是动态的，所以需要垃圾收集器回收这部分区域。</p>
<h6 id="2-判断对象是否需要回收"><a href="#2-判断对象是否需要回收" class="headerlink" title="2. 判断对象是否需要回收"></a>2. 判断对象是否需要回收</h6><ol>
<li><p>引用计数器法</p>
<p>给对象添加一个引用计数器，每当有地方引用对象时，计数器加1；引用失效时，计数器减1，任何时候计数器为0的对象都是可回收的。<font color='red'>优点</font>：实现简单，判断效率高。<font color='red'>缺点</font>：<strong>无法解决对象之间相互循环引用的问题</strong>，所以JVM中没有使用引用计数器法。</p>
</li>
<li><p>可达性分析算法</p>
<p>通过一系列<strong>GC Roots</strong>对象作为起始点，从这些节点开始向下搜索，搜索走过的路径为<strong>引用链</strong>，当一个对象到<strong>GC Roots</strong>没有任何引用链相连时(GC Roots到这些对象不可达)，则说明此对象不可用。</p>
<p><img src="https://images.effiu.cn/blog/jvm/03.jpg" alt="可达性分析算法"></p>
<p>Java中可以作为<strong>GC Roots</strong>的对象包括以下几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态常量属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中<strong>JNI</strong>(Java Native Interface)引用的对象</li>
</ul>
</li>
<li><p>对象引用</p>
<p>引用计数器法与可达性分析算法，都是根据引用判断对象是否存活。存在这么一类对象：当内存空间足够时，则可以保留在内存中，当内存空间在进行垃圾回收后，内存仍不够使用，则可以抛弃这些对象。Java引用分为：强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，其引用强度依次减弱。</p>
<ul>
<li>强引用，在代码中普遍存在，<code>Object o = new Object();</code>这类引用都是强引用，只要强引用存在，垃圾收集器永远不会回收引用的对象</li>
<li>软引用，是指一些有用但非必需对象，这些对象在系统将要发生<strong>OOM</strong>时，会把这些对象列进回收范围之中进行二次回收，若回收后仍没有足够的内存，则抛出<strong>OOM</strong></li>
<li>弱引用，描述非必需对象，被弱引用关联的对象只能生存到下一次<strong>GC</strong>发生之前。发生GC时，必然会回收弱引用关联的对象</li>
<li>虚引用，唯一目的是：在这个对象被收集器回收时收到一个系统通知</li>
</ul>
</li>
<li><p>对象的生存与死亡</p>
<p>即使可达性分析算法中不可达的对象，也可以继续存活下去，这种对象处于第一次标记阶段，要被回收至少要经历两次标记过程。当经过可达性分析后，发现没有与<strong>GC Roots</strong>相连的引用链，对象将被第一次标记并且进行一次筛选，判断是否有必须执行<code>finalize()</code>方法，若对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将认为对象没有必要执行<code>finalize()</code>方法。</p>
<p>当对象被判定为有必要执行<code>finalize()</code>方法，这个对象将被放入到一个叫做<strong>F-Queue</strong>队列中，并在稍后由一个虚拟机自动建立的、低优先级的<strong>Finalizer</strong>线程去执行对象的<code>finalize()</code>方法，但是这个线程并不会等待其执行结束，这是为了防止<code>finalize()</code>方法执行缓慢，或者发生死循环，可能导致队列中其他对象永久处于等待状态，甚至导致整个GC回收缓慢。若对象在<code>finalize()</code>方法中与<strong>GC Roots</strong>关联(例如，把<code>this</code>关键字赋值给某个类变量或者对象的成员变量)，那么第二次标记时将会被移出”即将回收”的集合，若对象没有与<strong>GC Roots</strong>关联将会被回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态常量属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, i am still alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed&quot;</span>);</span><br><span class="line">        <span class="comment">// 在第一次执行finalize后，与GC Roots关联成功</span></span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 第二次gc()，因为已经调用过finalize方法，所以JVM不会再次执行finalize方法</span></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际开发中尽量不要使用<code>finalize()</code>方法，若要回收资源建议使用<code>try-with-resource</code>。</p>
</li>
<li><p>回收方法区</p>
<p>Java虚拟机规范中可以不要求虚拟机实现方法区的垃圾收集，且方法区中的垃圾收集一般性价比低。方法区的垃圾收集主要分为两部分：废弃常量和无用的类。</p>
<ul>
<li><p>废弃常量回收，与Java堆中的对象回收类似，当没有任何引用关联常量时，在垃圾回收时回收 该常量。常量池中其他类(接口)、方法、字段的符号引用与此类似（<code>static</code>修饰符修饰）。</p>
</li>
<li><p>无用的类，类需要满足以下3个条件才会被标记为“无用的类”，满足以下3个条件后，可以被回收，但是不一定要回收</p>
<ul>
<li>该类所有实例都被回收，Java堆中不存在该类的实例</li>
<li>该类的<strong>ClassLoader</strong>已被回收</li>
<li>该类的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-Xnoclassgc		<span class="comment">//控制垃圾回收方法区中无用的类</span></span><br><span class="line">-verbose:class/-XX:+TraceClassLoading/-XX:TraceClassUnLoading	//查看类加载和卸载信息</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>大量使用反射、动态代理、CGLib等<strong>ByteCode</strong>框架、动态生成<strong>JSP</strong>以及OSGi这类频繁自定义<strong>ClassLoader</strong>的场景都需要虚拟机具备类卸载的功能，保证方法区不会溢出</p>
</li>
</ol>
<h6 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h6><ol>
<li><p>标记—清除算法，分为标记、清除两个阶段。</p>
<ul>
<li>标记，标记处所以需要回收的对象</li>
<li>清除，标记完成后统一回收被标记的对象</li>
</ul>
<p><font color='red'>不足之处</font>：效率低，标记和清除效率很低；空间利用率低，标记清除之后会产生大量不连续的空间碎片，可能会导致以后需要分配大对象时，无法找到足够的连续内存不得不提前出发<strong>GC</strong></p>
</li>
<li><p>复制算法</p>
<p>解决了效率问题，将可用内存空间分为大小相等的两部分，每次只使用其中一块，当被使用的内存满后，将活着的对象复制到另外一部分去，再把之前的空间一次性全部清空。</p>
<ul>
<li>优点：每次回收都是对整个内存区域的回收，回收效率高，内存分配时也不存在内存碎片，只需要移动堆顶指针，按顺序分配对象。</li>
<li>缺点：将内存分割为两部分，实际内存利用率低</li>
</ul>
<p>商业虚拟机采用这种算法回收新生代。其Eden、From Survivor、To Survivor比例为8:1:1。</p>
<p><strong style='color:red'>内存分配过程</strong>:</p>
<ul>
<li>对象优先分配在 Eden 区，如果 Eden 区无法分配，那么尝试把活着的对象放到<strong>From Survivor</strong>中去（Minor GC）</li>
</ul>
<ul>
<li>如果<strong>From Survivor</strong>可以放入，那么放入之后清除Eden区。</li>
<li>如果<strong>From Survivor</strong>不可以放入，那么尝试把 Eden 和<strong>From Survivor</strong>的存活对象放到 <strong>To Survivor</strong>中。<ul>
<li>如果 <strong>To Survivor</strong>可以放入，那么放入 <strong>To Survivor</strong>之后清除 Eden 和<strong>From Survivor</strong>，之后再把<strong>To Survivor</strong>中的对象复制到<strong>From Survivor</strong>中，保持<strong>To Survivor</strong>一直为空。</li>
<li>如果 <strong>To Survivor</strong> 不可以放入，那么直接把它们放入到老年代中，并清除 Eden 和 <strong>From Survivor</strong>，这个过程也称为<strong>分配担保</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>标记—整理算法</p>
<p>复制算法在对象存活率高的内存区域中会进行较多的复制操作，效率降低，且会浪费内存空间。标记—整理算法：</p>
<ul>
<li>标记，标记过程与标记—清除的标记过程一样。</li>
<li>整理，让所有存活对象向一端移动，然后直接清除掉边界以外的内存。</li>
</ul>
</li>
<li><p>分代收集算法</p>
<p>根据对象存活周期将内存区域划分为几块：新生代(Eden、From Survivor、To Survivor)和老年代。根据各自特点采用不同垃圾收集算法。</p>
<ul>
<li>新生代，每次垃圾收集都会有大批对象被回收，所以采用复制算法，只需要付出少量的内存空间</li>
<li>老年代，对象存活、没有额外的空间进行分配担保，标记整理或者标记清除算法。</li>
</ul>
</li>
</ol>
<h6 id="4-HotSpot算法实现"><a href="#4-HotSpot算法实现" class="headerlink" title="4. HotSpot算法实现"></a>4. HotSpot算法实现</h6><p>实际JVM实现垃圾收集相关算法时，需要对算法有严格的考虑，才能保证虚拟机高效运行。</p>
<ol>
<li><p>枚举根节点</p>
<p>可达性分析中从<strong>GC Roots</strong>节点寻找引用链，可作为<strong>GC Roots</strong>节点主要是全局性的引用(常量或类静态属性)与执行上下文(栈帧中的本地变量)，实际应用中很多方法区达到数百兆，若要逐个检查这里的引用，会消耗很多资源。</p>
<p>可达性分析，还会造成GC停顿，因为分析工作必须在一个能确保一致性的快照中进行(分析期间整个执行系统停顿，不能出现分析过程中对象引用关系不断变化的情况，否则可达性分析的准确性无法保证)。</p>
<p>目前主流的Java虚拟机都是准确式GC(虚拟机可以判断内存中对象的类型)，当系统停顿后，虚拟机不需要一个不漏地检查所有执行上下文和全局的引用位置，虚拟机可以知道哪些地方存放着对象引用。在<strong>HotSpot</strong>实现中，是使用一组<strong>OopMap</strong>的数据结构类达到这个目的，类加载完成后，<strong>HotSpot</strong>就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用，这样GC过程中可以直接得知执行上下文和全局变量位置。</p>
</li>
<li><p>安全点(SafePoint)</p>
<p>通过OopMap，<strong>HotSpot</strong>可以快速准确地完成GC Roots枚举，但是可能会导致引用关系变化，或者说<strong>OopMap</strong>内容变化指令非常多，若每一条指令都生成OopMap，将会浪费大量额外空间，GC成本变高。</p>
<p><strong>HotSpot</strong>没有为每一条指令生成<strong>OopMap</strong>，而是在特定位置生成了<strong>OopMap</strong>，这些位置即安全点（SafePoint）。程序执行时并非在所有地方都停顿下来执行GC，而是只有在安全点才能暂停。安全点的选择是以程序“是否具有让程序长时间执行下去的特征”为标准进行选定的。“长时间执行”最明显特征是指令复用，例如方法调用、循环跳转、异常跳转等，所以这些具有这些功能的指令才会产生<strong>SafePoint</strong>。</p>
<p>因为GC时需要程序暂停，但是只能在安全点暂停，所以GC发生时需要保证所有线程（不包括执行JNI调用的线程）都在安全点上，有两种方案：</p>
<ul>
<li>抢先式中断(Preemptive Suspension)：不需要线程执行代码主动配合，在发生GC时，首先把所有线程全部中断，若发现存在不在安全点的线程，则恢复线程，直到停顿在安全点。现在几乎没有虚拟机采用抢占式中断。</li>
<li>主动式中断(Voluntary Suspension)：当GC需要中断线程时，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标识为真时就自己中断挂起，轮询标志的地方和安全点是重合的，另外加上创建对象需要分配内存的地方</li>
</ul>
</li>
<li><p>安全区域</p>
<p><strong>Safe Point</strong>可以解决如何进入GC的问题，但是仅仅保证了程序执行时，在不太长时间内进入<strong>GC</strong>的<strong>Safe Point</strong>，若存在没有分配时间片的线程(Sleep或者Blocked状态)，线程无法响应<strong>JVM</strong>的中断请求，此事需要安全区域(<strong>Safe Region</strong>)解决问题。</p>
<p>安全区域指一段代码中，引用关系不会发生变化。这个区域中任意地方开始GC都是安全的。线程执行到<strong>Safe Region</strong>中的代码时，首先标识自己已经进入安全区(Safe Region)。当<strong>JVM</strong>发生GC时，就不需要考虑标识为安全区(<strong>Safe Region</strong>)的线程了。线程离开<strong>Safe Region</strong>时，首先检查系统是否完成了根节点枚举（或者整个<strong>GC</strong>过程），若完成线程继续执行，否则必须等待收到可以安全离开的信号为止。</p>
</li>
</ol>
<h6 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h6><p>收集算法是内存回收的方法论，垃圾收集器就是内存回收的实现。Java虚拟机规范对垃圾收集器应该如何实现并没有任何规定，所以不同的厂商、不同的虚拟机所提供的收集器有很大差别，以下是<strong>HosSpot</strong>虚拟机的垃圾收集器。</p>
<p><img src="https://images.effiu.cn/blog/jvm/06.jpg" alt="HotSpot垃圾收集器"></p>
<p>上图的7中不同垃圾收集器作用于不同分代。收集器之间有直线，说明可以配合使用。</p>
<ol>
<li><p><strong>Serial</strong>收集器</p>
<p><strong>Serial</strong>收集器是最基本、发展历史最悠久的收集器，其是一个单线程的收集器，进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束，其他线程的工作由垃圾收集器暂停，所以这对用户不可见，这也对很多应用不友好。</p>
<p><img src="https://images.effiu.cn/blog/jvm/07.jpg" alt="Serial/Serial Old"></p>
<p><strong>HotSpot</strong>虚拟机开发团队一直努力消除或者减少工作线程因为内存回收导致的停顿。从<strong>Serial</strong>到<strong>Parallel</strong>，再到<strong>Concurrent Mark Sweep</strong>(CMS)乃至<strong>Garbage First</strong>(G1)收集器。</p>
<p><strong>Serial</strong>垃圾收集器是虚拟机在Client模式下默认的新生代垃圾收集器。</p>
<ul>
<li><font color='red'>优点</font>：简单高效，对象单个CPU的环境，没有多线程交互的开销</li>
</ul>
</li>
<li><p><strong>ParNew</strong>收集器</p>
<p><strong>ParNew</strong>是Serial收集器的多线程版本，除了多线程进行垃圾收集外，其余行为包括<strong>Serial</strong>收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与<strong>Serial</strong>一致。</p>
<p><img src="https://images.effiu.cn/blog/jvm/08.jpg" alt="ParNew/Serial Old"></p>
<p><strong>ParNew</strong>是很多运行在Server模式下的虚拟机中的首先新生代收集器，因为除了<strong>Serial</strong>之外，<strong>ParNew</strong>是唯一可以与<strong>CMS</strong>配合使用的垃圾收集器。当使用<code>-XX:+ConcMarkSweepGC</code>参数后，<strong>ParNew</strong>是默认垃圾收集器，<code>-XX:+UseParNewGC</code>指定新生代垃圾收集器。在单线程环境下，<strong>ParNew</strong>不如<strong>Serial</strong>效果好，<strong>ParNew</strong>默认开启的线程数与CPU数量相同，<code>-XX:+ParallelGCThreads</code>限制垃圾收集器的线程数。</p>
<ul>
<li>并行(Parallel)，指多条垃圾收集线程并行工作，此时用户线程处于停顿状态。</li>
<li>并发(Concurrent)，用户与垃圾收集线程同时执行(可能会交替执行，也可能不在一个CPU上)</li>
</ul>
</li>
<li><p><strong>Parallel Scavenge</strong></p>
<p><strong>Parallel Scavenge</strong>是新生代垃圾收集器，同样是使用复制算法的并行多线程垃圾收集器，其与<strong>ParNew</strong><font color='red'>不同之处</font>：<strong>Parallel Scavenge</strong>目标是达到一个可控制的吞吐量(Throughtput)，即CPU用于运行用户代码的时间与CPU总消耗时间的比值，即<font color='red'>吞吐量=运行用户代码时间/运行用户代码时间+垃圾收集时间</font>。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的相应速度能提升用户体验，高吞吐量可以高效率地利用CPU，适合在后头运算而不需要太多交互的任务。</p>
<p><strong>Parallel Scavenge</strong>提供了两个参数用于控制吞吐量。</p>
<ul>
<li><code>-XX:+MaxGCPauseMillis</code>，最大垃圾收集停顿时间，大于0ms，垃圾收集器会尽量在规定时间内完成收集，<font color='red'>GC停顿时间缩短是以缩小吞吐量和新生代空间来换取时间的</font>。</li>
<li><code>-XX:+GCTimeRatio</code>，设置吞吐量大小，0~100之间，垃圾收集时间占总时间的比率，例如：<code>-XX:+GcTimeRatio=19</code>，则运行最大GC时间是总时间的5%（1/1+19）。</li>
<li><code>-XX:+UseAdaptiveSizePoilcy</code>，开关参数，打开后，不需要指定新生代大小(<code>-Xmn</code>)、Eden与Survivor的比例(<code>-XX:+SurvivorRatio</code>)、晋升老年代对象大小(<code>-XX:+PretenureSizeThreshold</code>)等细节参数，虚拟机会根据当前系统运行情况收集性能监控，动态调整以提供合适的停顿时间或者最大吞吐量，GC自适应调节策略。</li>
</ul>
<p>使用<code>-XX:+UseAdaptiveSizePolicy</code>自适应调节策略，加<code>-XX:+MaxGCPauseMillis</code>或<code>-XX:+GCTimeRatio</code>给虚拟机设定一个目标。</p>
</li>
<li><p><strong>Serial Old</strong>收集器</p>
<p><strong>Serial Old</strong>是<strong>Serial</strong>的老年代版本，单线程收集器，使用<font color='red'>标记-整理算法</font>，主要意义在于给Client模式下虚拟机回收老年代使用。</p>
<ul>
<li><strong>JDK5</strong>之前的版本中与<code>Parllel Sacvenge</code>搭配使用</li>
<li>作为CMS收集器的后备预选，在并发收集发生<strong>Concurrent Mode Failure</strong>时使用。</li>
</ul>
<p><img src="https://images.effiu.cn/blog/jvm/09.jpg" alt="Serial /Serial Old"></p>
</li>
<li><p><strong>Parallel Old</strong>收集器</p>
<p><strong>Parallel Old</strong>是<strong>Parallel Scavenge</strong>收集器的老年代版本，使用多线程和“标记-整理算法”。其主要是与<strong>Parallel Scavenge</strong>配合使用。“吞吐量”优先收集器的组合，在一些注重吞吐量以及CPU资源敏感的场合，都可以优先考虑<strong>Parallel Scavenge</strong>和<strong>Parallel Old</strong>。</p>
<p><img src="https://images.effiu.cn/blog/jvm/10.jpg" alt="Parallel Scavenge和Parallel Old"></p>
</li>
<li><p><strong>CMS</strong>收集器</p>
<p>CMS是一种一获取最短回收停顿时间为目标的收集器。基于<font color='red'>标记-清除算法</font>实现，分为4步。</p>
<ul>
<li>初始标记(CMS initial mark)，只是标记一个<strong>GC Roots</strong>能直接关联的对象，速度快，需要停顿</li>
<li>并发标记(CMS concurrent mark)，并发标记是<strong>GC Roots Tracing</strong>的过程</li>
<li>重新标记(CMS remark)，为了修正并发标记阶段因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，比初始标记停顿时间稍长，远比并发标记时间短</li>
<li>并发清除(CMS concurrent sweep)</li>
</ul>
<p>在整个过程中，最耗时的并发标记与并发清除都可以与工作线程一起工作，所以其是与工作线程并发执行的</p>
<p><img src="https://images.effiu.cn/blog/jvm/11.jpg" alt="Concurrent Mark Sweep"></p>
<ul>
<li><p><font color='red'>CMS优点</font>：并发收集、低停顿</p>
</li>
<li><p>缺点：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感，会因占用CPU资源导致程序变慢，吞吐量会降低。默认启动的线程数是(CPU数量+3)/4，会随着CPU数量增大占比下降，所以当CPU低于4个时，CMS对程序影响很大</li>
<li>CMS收集器无法处理浮动垃圾，可能会出现失败导致另一次Full GC产生。所谓浮动垃圾即，CMS无法处理并发清除阶段产生的垃圾，只能留在下一次GC时清除，而且垃圾收集阶段程序会运行，所以需要预留足够的内存空间供程序运行使用，<code>-XX:+CMSInitiatingOccupancyFraction</code>提高触发GC的百分比，以降低内存回收次数。<strong>Concurent Mode Failure</strong>失败会导致虚拟机启动后备预案，临时启用<code>Serial Old</code>收集器重新进行老年代的垃圾收集，所以<code>-XX:+CMSInitiatingOccupancyFraction</code>太高也会导致<strong>Concurent Mode Failure</strong>失败，降低性能。</li>
</ul>
<blockquote>
<p>  浮动垃圾是在并发标记过程中与程序是并行的，这个过程中程序可能会产生新的垃圾(浮动垃圾)，重新标记过程只是修改并发标记过程中的不可达对象，没有办法处理浮动垃圾。</p>
</blockquote>
<ul>
<li>CMS是基于标记-清除算法实现的，会产生大量的内存碎片。<code>-XX:+UseCMSComopacetAtFullConllection</code>开关参数，当CMS顶不住要进行Full GC时开始内存碎片整理合并过程，但是会导致停顿时间变长。<code>-XX:+CMSFullGCsBeforeCompaction</code>表示设置执行多少次不压缩的Full GC后，进行一次带压缩的Full GC，默认每次都带压缩。</li>
</ul>
</li>
<li><p><strong>Concurent Mode Failure</strong>原因主要有两个：</p>
<ul>
<li>在年老代被用完之前不能完成对无引用对象的回收</li>
<li>是当新空间分配请求在年老代的剩余空间中得到满足。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong style='color:red'>G1收集器</strong></p>
<p><strong>G1</strong>是一款面向服务端应用的垃圾收集器，与CMS相比优点如下：</p>
<ul>
<li>并行与并发，G1能充分利用多CPU、多核环境的硬件优势，使用多个CPU缩短停顿时间。</li>
<li>分代收集，采用不同的方式去处理新生代、老年代的垃圾对象。</li>
<li>空间整合，整体上看是<font color='red'>标记-整理算法</font>，局部看是复制算法，在GC运行后不会导致内存碎片产生，不会因为无法分配大对象无法找到连续内存空间而提前出发一次GC</li>
<li>可预测的停顿，可以建立可预测停顿模型，可以在开发者指定时间内完成GC。</li>
</ul>
<p><strong>G1</strong>收集器，Java堆的内存与其他收集器不同，其将整个堆内存划分为多个大小相等的<strong>Region</strong>，所以新生代和老年代不再是物理隔离的，是<strong>Region</strong>的集合。</p>
<p><strong>G1</strong>可以预测停顿时间，是因为可以有计划地避免在整个堆中进行垃圾回收。G1跟踪各个<strong>Region</strong>里面垃圾堆积的价值大小（回收获得的空间大小以及所需要的时间），在后台维护一个优先列表，每次根据允许的时间，优先回收价值最大的<strong>Region</strong>，同时也保证了G1在有限时间内获取尽可能高的收集效率。</p>
<p><strong>G1</strong>划分<strong>Region</strong>后，<strong>Region</strong>仍不是孤立的，因为对象分配到<strong>Region</strong>后，其可以被其他<strong>Region</strong>内的对象引用。<strong>G1</strong>中<strong>Region</strong>之间的对象引用以及其他收集器中新生代和老年代之间的对象引用，虚拟机使用<strong>Remembered Set</strong>避免全堆扫描。在<strong>G1</strong>中每个<strong>Region</strong>都有一个Remembered Set。当虚拟机发现需要对Reference类型的数据写操作时，会触发一个<strong>Write Barrier</strong>暂时中断写操作，检查<strong>Reference</strong>引用的对象是否处于不同Region中，若是则通过<strong>CardTable</strong>把相关信息记录到被引用对象所属的<strong>Regioin</strong>的<strong>Remebered Set</strong>中，内存回收时在<strong>GC Roots</strong>中加入<strong>Remembered Set</strong>即可保证不对全堆扫描也不会遗漏。</p>
<p>不包括<strong>Remembered Set</strong>操作，G1收集器分为以下几个步骤：</p>
<ul>
<li>初始标记(Initial Marking)，标记GC Roots能直接关联到的对象，并写修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能正确在可用的Region中创建对象。需要停顿线程，时间很短</li>
<li>并发标记(Concurrent Marking)，从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，可以与程序并发运行</li>
<li>最终标记(Final Marking)，是为了修正并发标记期间因为用户程序继续运行导致标记产生变动的记录，变动记录在<strong>Remebered Set Logs</strong>里面，最终标记会把<strong>Remebered Set Logs</strong>的数据合并到<strong>Remebered Set</strong>中，需要停顿，但是可以并行执行</li>
<li>筛选回收(Live Data Counting And Evacuation)，对各个Region的回收价值和成本进行排序，根据用户期望指定回收计划，可以并发执行</li>
</ul>
<p><img src="https://images.effiu.cn/blog/jvm/12.jpg" alt="G1"></p>
</li>
<li><p>理解GC日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">33.125：[GC [DefNew：3324K-&gt;152K(3712K),0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs]</span><br><span class="line">100.667：[Full GC [Tenured：0K-&gt;210K(10240K), 0.0149142 secs]4603K-&gt;210K(19456K), [Perm：2999K-&gt;2999K(21248K)], 0.0150007 secs][Times：user=0.01 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure>

<ol>
<li><code>33.125</code>和<code>100.667</code>表示GC发生的时间，从Java虚拟机启动开始计数。</li>
<li><code>[GC</code>和<code>[Full GC</code>是指垃圾收集的停顿类型，Full说明是带有停顿的过程。<code>System.gc()</code>触发的收集，显示为<code>[Full GC(System)</code>。</li>
<li><code>[DefNew</code>、<code>[Trnured</code>、<code>[Perm</code>表示GC发生的区域</li>
<li><code>3324K-&gt;152K(3712K)</code>，是指GC前该区域内存已使用量 -&gt; GC后该区域内控使用量(该区域内存总量)。方括号之外的<code>3324K-&gt;152K(11904K)</code>表示GC前该Java堆已使用量 -&gt; GC后该堆使用量(Java堆总容量)</li>
<li><code>0.0031680 secs</code>该区域GC占用的时间，单位是秒。</li>
</ol>
</li>
<li><p>垃圾收集器参数总结</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UseSerialGC</td>
<td>Client下的默认值，使用Serial+Serial Old收集器组合回收内存</td>
</tr>
<tr>
<td align="center">UseParNewGC</td>
<td>使用ParNew+Serial Old收集器组合回收内存</td>
</tr>
<tr>
<td align="center">UseConcMarkSweepGC</td>
<td>使用ParNew+CMS+Serial Old收集器组合进行内存回收</td>
</tr>
<tr>
<td align="center">UseParallelGC</td>
<td>Server模式下默认值，Parallel Scavenge+Serial Old回收内存</td>
</tr>
<tr>
<td align="center">UseParallelOldGC</td>
<td>使用Parallel Scavenge + Parallel Old回收内存</td>
</tr>
<tr>
<td align="center">Survivor Ratio</td>
<td>Eden与Survivor区域的容量比值，默认为8</td>
</tr>
<tr>
<td align="center">PretenureSizeThreshold</td>
<td>直接晋升老年代对象大小</td>
</tr>
<tr>
<td align="center">MaxTenureThreshold</td>
<td>晋升老年代对象的年龄，对象在经过Minor GC后年龄加1</td>
</tr>
<tr>
<td align="center">UseAdativeSizePolicy</td>
<td>Parallel Scavenge收集器中，动态调整各个区域大小以及进入老年代的年龄</td>
</tr>
<tr>
<td align="center">HandlePromitionFailure</td>
<td>是否允许分配担保失败，即老年代剩余空间不足以应付新生代整个Eden和Survivor都存活的极端对象</td>
</tr>
<tr>
<td align="center">ParallelGCThreads</td>
<td>并行GC时启动回收内存线程数</td>
</tr>
<tr>
<td align="center">GCTimeRatio</td>
<td>Parallel Scavenge 收集器中GC时间占总时间的比率，默认99</td>
</tr>
<tr>
<td align="center">MaxGCPauseMillis</td>
<td>Parallel Scavenge 收集器设置GC的最大停顿时间</td>
</tr>
<tr>
<td align="center">CMSInitiatingOccupancyFraction</td>
<td>CMS中触发GC的百分比。</td>
</tr>
<tr>
<td align="center">UseCMSCompactAtFullCollection</td>
<td>设置CMS收集器完成回收后，是否开启一次内存碎片整理</td>
</tr>
<tr>
<td align="center">CMSFullGCBeforeCompaction</td>
<td>设置CMS进行若干次后，开启一次内存碎片整理</td>
</tr>
</tbody></table>
<h6 id="6-内存分配与回收策略"><a href="#6-内存分配与回收策略" class="headerlink" title="6.  内存分配与回收策略"></a>6.  内存分配与回收策略</h6><p>内存自动管理技术可以归结为自动化地解决了两个问题：</p>
<ul>
<li>对象分配内存，各种GC收集器算法及实现，枚举根节点、安全点、安全区域等<strong>HotSpot</strong>算法等等</li>
<li>回收对象内存，堆上分配内存，主要分配在Eden上，如果启动了本地线程缓冲，将按线程优先在TLAB上分配。分配规则不是百分百确定，而是当前使用的垃圾收集器组合以及虚拟机参数设置的，以下是主要的内存分配规则<ul>
<li>对象优先在<strong>Eden</strong>分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代</li>
<li>动态对象年龄判定</li>
<li>空间分配担保</li>
</ul>
</li>
<li>以下举例均以Parallel Scavenge + Parallel Old垃圾收集器组合为例</li>
</ul>
<ol>
<li><p>对象优先在<strong>Eden</strong>分配</p>
<p>对象优先在<strong>Eden</strong>分配，当<strong>Eden</strong>区域没有足够空间时，虚拟机将发起一次<strong>Minor GC</strong>。<code>-XX:+PringGCDetails</code>，用于打印在GC发生垃圾收集行为时打印内存回收日志，在进程退出时输出当前内存区域分配情况，实际应用中使用日志工具进行分析。</p>
<ul>
<li>新生代GC(Minor GC)，指发生在新生代的垃圾收集工作，因为Java对象大多生存时间短，所以Minor GC非常频繁，回收速度很快。</li>
<li>老年代GC(Major GC/Full GC)，发生在老年代的GC，<strong>Full GC</strong>经常会伴有<strong>Minor GC</strong>，但并不绝对，且<font color='red'>Full GC速度比Minor GC慢10倍以上</font>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数： -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="comment">// 发生了一次GC</span></span><br><span class="line">        <span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: <span class="number">6906</span>K-&gt;<span class="number">973</span>K(<span class="number">9216</span>K)] <span class="number">6906</span>K-&gt;<span class="number">5077</span>K(<span class="number">19456</span>K), <span class="number">0.0063378</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">9216</span>K, used <span class="number">7439</span>K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space <span class="number">8192</span>K, <span class="number">78</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc508d0</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space <span class="number">1024</span>K, <span class="number">95</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffef3620</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">10240</span>K, used <span class="number">4104</span>K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space <span class="number">10240</span>K, <span class="number">40</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff002020</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3484</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 383<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<p><code>byte[] allocation4 = new byte[4 * _1MB];</code>会触发一次<strong>Minor GC</strong>，因为超过了Eden分配空间，<strong>Minor GC</strong>后<code>6906K-&gt;973K(9216K)</code>，说明GC后3个对象分配到了老生代(对象超过Survivor空间大小，所以会通过内存分配担保提前转移到老年代去)。</p>
</li>
<li><p>大对象直接进入老年代</p>
<p>大对象指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组，实际开发中应该尽量避免使用大对象，容易导致还有不少内存空间而触发垃圾收集以获取足够连续内存空间。<code>-XX:PretenureSizeThreshold</code>参数，用于设置超过指定大小后直接分配到老年代分配，这是为了避免在Eden区与Survivor之间发生大量内存复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  大对象直接进入老年代，但是只对Serial和ParNew有效，Parallel Scavenge无效</span></span><br><span class="line"><span class="comment">     * VM参数： -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     *  -XX:+PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>长期存活对象进入老年代</p>
<p>分代回收对象管理内存，那么内存回收哦时必须知道哪些对象应该放在新生代，哪些在老年代。虚拟机给每个对象定义了一个对象年龄(Age)计数器。Eden -&gt; Surivivor对象年龄设置为1，且每经过一次<strong>Minor GC</strong>，年龄加1,当达到一定次数后将会晋升到老年代。<code>-XX:MaxTenuringThreshold</code>设置年龄阈值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象优先在Eden分配</span></span><br><span class="line"><span class="comment">     * VM参数： -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     * -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="comment">// 会发生一次Minor GC，-XX:MaxTenuringThreshold=1，第二次GC直接进入老年代</span></span><br><span class="line">        <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 发生了一次GC</span></span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象年龄判定</p>
<p>为了更好适应不同程序的内存状况，虚拟机并不是永远要求对象年龄必须达到阈值(MaxTenuringThreshold)才会晋升到老年代。当Survivor空间中相同年龄所有对象大小的和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接晋升到老年代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象优先在Eden分配</span></span><br><span class="line"><span class="comment">     * VM参数： -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     * -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// allocation1 + allocation2大于Survivor空间一半</span></span><br><span class="line">        <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">null</span>;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空间分配担保</p>
<p>发生<strong>Minor GC</strong>之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立则<strong>Minor GC</strong>是安全的，不成立则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置的值是否允许担保失败。若允许则会继续判断老年代最大可哟连续空间是否大于历次晋升到老年代对象的平均大小，若大于则尝试进行一次<strong>Minor GC</strong>（可能会有风险），若小于或者<code>-XX:HandlePromotionFailure</code>设置为不允许冒险，则改为进行一次<strong>Full GC</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JVMTest5 &#123;</span><br><span class="line"></span><br><span class="line">    private static final int _1MB &#x3D; 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对象优先在Eden分配</span><br><span class="line">     * VM参数： -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio&#x3D;8 -XX:-HandlePromotionALot</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] allocation1 &#x3D; new byte[2 * _1MB];</span><br><span class="line">        &#x2F;&#x2F; allocation1 + allocation2大于Survivor空间一半</span><br><span class="line">        byte[] allocation2 &#x3D; new byte[2 * _1MB];</span><br><span class="line">        byte[] allocation3 &#x3D; new byte[2 * _1MB];</span><br><span class="line">        allocation1 &#x3D; null;</span><br><span class="line">        byte[] allocation4 &#x3D; new byte[2 * _1MB];</span><br><span class="line">        byte[] allocation5 &#x3D; new byte[2 * _1MB];</span><br><span class="line">        byte[] allocation6 &#x3D; new byte[2 * _1MB];</span><br><span class="line">        allocation4 &#x3D; null;</span><br><span class="line">        allocation5 &#x3D; null;</span><br><span class="line">        allocation6 &#x3D; null;</span><br><span class="line">        byte[] allocation7 &#x3D; new byte[4 * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h6><p>介绍了垃圾收集器特点以及运作原理，验证了Java虚拟机分配内存以及回收的主要规则。内存回收与垃圾收集器很多时候是影响系统性能、并发能力的主要因素之一。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域与内存溢出</title>
    <url>/blog/2019/06/07/jvm/2_memory/</url>
    <content><![CDATA[<blockquote>
<p>对于Java程序员来说，自动内存管理机制使得不用关系对象的创建与销毁，也不容易出现内存溢出和内存泄露的问题，但是一旦出现内存溢出和内存泄露，如果不了解虚拟机运行机制，将会对排查问题造成很大的困扰</p>
</blockquote>
<h6 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h6><p><strong>Java</strong>虚拟机在执行Java程序过程中会把内存区域分为若干不同的数据区域。</p>
<ol>
<li><p>程序计数器</p>
<p>程序计数器(Program Counter Register)是一块较小的内存空间，用于记录当前线程执行的字节码的行号。在虚拟机概念模型中，字节码解释器工作时是通过改变计数器的值来新选择将要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。</p>
<p>由于Java虚拟机的多线程是通过线程切换并分配时间片的方式实现的，那么任何一个确定的时刻，<strong style='color:red'>一个处理器或者内核都只会执行一个线程中的一条指令，为了切换线程后能恢复到正确的执行位置，每个线程都需要一个计数器，所以是线程私有的</strong>。</p>
</li>
<li><p><strong>Java</strong>虚拟机栈</p>
<p><strong>Java</strong>虚拟机栈是线程私有。描述的是<strong>Java</strong>方法执行的<strong style='color:red'>内存模型</strong>：每个方法在执行时都会创建一个栈帧，用于存储<strong>局部变量</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口信息</strong>等，一个方法的调用过程就对应着一个栈帧在虚拟机栈的入栈到出栈过程。</p>
<p>局部变量存放了编译期可知的各种基本数据类型、对象引用（Reference类型，不是对象本身，可能是指向对象的引用指针，可能是一个代表对象的句柄或其他与对象相关的位置）和<strong>returnAddress</strong>类型（指向一条字节码指令地址）</p>
<p>针对虚拟机栈有两种异常情况：</p>
<ul>
<li>线程请求的栈深度大于虚拟机锁允许的深度，<code>StackOverflowError</code></li>
<li>Java虚拟机允许动态扩展，当扩展时无法申请到足够的内存，<code>OutOfMemoryError</code></li>
</ul>
</li>
<li><p>本地方法栈</p>
<p>与虚拟机栈类似，用于虚拟机使用的<strong>Native</strong>方法。也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code></p>
</li>
<li><p><strong>Java</strong>堆</p>
<p><strong>Java</strong>堆是虚拟机所管理内存中最大的一块，是被所有线程共享的区域。用于存放对象实例（所有对象实例以及数组都要在堆上分配）。随着<strong>JIT</strong>编译器的发展与逃逸分析技术的成熟，栈上分配、标量替换将会导致其他情况发生。</p>
<p><strong>Java</strong>堆是垃圾收集器管理的主要区域。算法是分代收集算法。Java堆中分为<strong>新生代和老生代</strong>，<strong>新生代分为Eden空间、From Survivor空间、To Survivor空间</strong>。<strong>Java</strong>堆中还可能会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer），是为了更好地回收内存，更快地分配内存。</p>
</li>
<li><p>方法区</p>
<p>方法区是各个线程共享的内存区域。用于存储被<strong>虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。Java虚拟机对方法区的限制比较宽松，甚至可以不实现垃圾收集，<strong style='color:red'>这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载</strong>。</p>
</li>
<li><p>运行时常量池</p>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分，所以也受方法区内存限制，会抛出<code>OutOfMemoryError</code>。Class文件中除了包括类的版本、字段、方法接口等描述信息，还包含常量池，<strong style='color:red'>用于记录编译器生成的各种字面量和符号引用</strong>。运行期也允许将新的常量方法常量池中。</p>
</li>
<li><p>直接内存</p>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java规范中定义的内存区域，但是这部分内存也会被频繁地使用。</p>
<p>NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，其可以使用<strong>Native</strong>函数直接分配堆外内存，通过一个存储在<strong>Java</strong>堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作，显著地提高了性能，避免了在Java堆和Native堆中频繁地复制。</p>
<p>直接内存不受Java堆大小限制，受限于本机总内存大小以及处理器寻址空间限制。</p>
</li>
</ol>
<h6 id="2-对象探秘"><a href="#2-对象探秘" class="headerlink" title="2. 对象探秘"></a>2. 对象探秘</h6><p>HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
<ol>
<li><p>对象的创建（仅仅包含Java普通对象，不包括数组和Class对象等）</p>
<ul>
<li>虚拟机遇到<code>new</code>指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，且检查这个符号引用代表的类是否已被加载、解析和初始化过，若没有则必须执行类加载过程。</li>
<li>当类加载检查通过后，虚拟机将直接在Java堆中为对象分配内存，且对象需要的内存大小在类加载完成后便可以完全确定，这个分配空间的任务即把一块大小确定的内存从Java堆中划分出来。<ul>
<li><strong>指针碰撞</strong>，当Java堆中内存是绝对规整的，那么所有用过的内存放在一边，未被使用的在另一边，中间放着一个指针作为分界点的指示器，那么分配内存仅仅是移动指针，例如，<strong>Serial</strong>、<strong>ParNew</strong>等带有<strong>compact</strong>过程的收集器</li>
<li><strong>空闲列表</strong>，当内存不规整时，就需要虚拟机维护一个列表，记录内存块是否可用，分配对象时从可用列表中找到一块足够大的空间，并更新列表的记录，例如<strong>CMS</strong>使用标记清除算法的虚拟机</li>
</ul>
</li>
<li>并发情况下，在虚拟机中创建对象是非常频繁的，可能会出现对象A分配内存，指针没来得及修改，就会被其他对象访问，解决这种问题的方案:<ul>
<li>对分配内存空间的动作进行同步处理—虚拟机采用<font color='red'>CAS加失败重试</font>保证更新操作的原子性</li>
<li>把分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先  分配一小块内存，即本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)。<code>-XX:+/-UseTLAB</code>设定</li>
</ul>
</li>
<li>内存分配完成后，虚拟机会将内存空间都初始化为零值（不包括对象头），如果使用<strong>TLAB</strong>，这一工作过程可以提前至TLAB分配时进行，其保证了对象的实例字段在Java代码中未真正初始化就可被使用（虚拟机初始化完成）</li>
<li>虚拟机对对象头进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，另外会根据虚拟机当前运行状态不同(是否持有偏向锁等)对象头会有不同的设置方式</li>
<li>此时虚拟机已经完成初始化，但对象的创建刚刚开始—<init>方法未执行，所有的字段未真正初始化（虚拟机初始化完成，字段仍是零），<init>会执行对象的初始化过程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//确保常量池中存放的是已解释的类</span></span><br><span class="line"><span class="keyword">if</span>（！constants-＞tag_at（index）.is_unresolved_klass（））&#123;</span><br><span class="line">	<span class="comment">//断言确保是klassOop和instanceKlassOop（这部分下一节介绍）</span></span><br><span class="line">	oop entry=（klassOop）*constants-＞obj_at_addr（index）；</span><br><span class="line">	assert（entry-＞is_klass（），<span class="string">&quot;Should be resolved klass&quot;</span>）；</span><br><span class="line">	klassOop k_entry=（klassOop）entry；</span><br><span class="line">	assert（k_entry-＞klass_part（）-＞oop_is_instance（），<span class="string">&quot;Should be instanceKlass&quot;</span>）；</span><br><span class="line">	instanceKlass * ik=（instanceKlass*）k_entry-＞klass_part（）；</span><br><span class="line">	<span class="comment">//确保对象所属类型已经经过初始化阶段</span></span><br><span class="line">	<span class="keyword">if</span>（ik-＞is_initialized（）＆＆ik-＞can_be_fastpath_allocated（））&#123;</span><br><span class="line">    	<span class="comment">//取对象长度</span></span><br><span class="line">		<span class="keyword">size_t</span> obj_size=ik-＞size_helper（）；</span><br><span class="line">		oop result=<span class="literal">NULL</span>；</span><br><span class="line">		<span class="comment">//记录是否需要将对象所有字段置零值</span></span><br><span class="line">		<span class="keyword">bool</span> need_zero=！ZeroTLAB；</span><br><span class="line">		<span class="comment">//是否在TLAB中分配对象</span></span><br><span class="line">        <span class="keyword">if</span>（UseTLAB）&#123;</span><br><span class="line">        	result=（oop）THREAD-＞tlab（）.allocate（obj_size）；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>（result==<span class="literal">NULL</span>）&#123;</span><br><span class="line">            need_zero=<span class="literal">true</span>；</span><br><span class="line">            <span class="comment">//直接在eden中分配对象</span></span><br><span class="line">            retry：</span><br><span class="line">			HeapWord * compare_to=*Universe：heap（）-＞top_addr（）；</span><br><span class="line">			HeapWord * new_top=compare_to+obj_size；</span><br><span class="line">			<span class="comment">/*cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，如果并发失败，转到retry中重试，直至成功分配为止*/</span></span><br><span class="line">			<span class="keyword">if</span>（new_top＜=*Universe：heap（）-＞end_addr（））&#123;</span><br><span class="line">				<span class="keyword">if</span>（Atomic：cmpxchg_ptr（new_top,Universe：heap（）-＞top_addr（），compare_to）！=compare_to）&#123;</span><br><span class="line">					<span class="keyword">goto</span> retry；</span><br><span class="line">				&#125;</span><br><span class="line">                result=（oop）compare_to；</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>（result！=<span class="literal">NULL</span>）&#123;</span><br><span class="line">			<span class="comment">//如果需要，则为对象初始化零值</span></span><br><span class="line">			<span class="keyword">if</span>（need_zero）&#123;</span><br><span class="line">				HeapWord * to_zero=（HeapWord*）result+<span class="keyword">sizeof</span>（oopDesc）/oopSize；</span><br><span class="line">				obj_size-=<span class="keyword">sizeof</span>（oopDesc）/oopSize；</span><br><span class="line">				<span class="keyword">if</span>（obj_size＞<span class="number">0</span>）&#123;</span><br><span class="line">					<span class="built_in">memset</span>（to_zero，<span class="number">0</span>，obj_size * HeapWordSize）；</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//根据是否启用偏向锁来设置对象头信息</span></span><br><span class="line">			<span class="keyword">if</span>（UseBiasedLocking）&#123;</span><br><span class="line">				result-＞set_mark（ik-＞prototype_header（））；</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				result-＞set_mark（markOopDesc：prototype（））；</span><br><span class="line">			&#125;</span><br><span class="line">            result-＞set_klass_gap（<span class="number">0</span>）；</span><br><span class="line">			result-＞set_klass（k_entry）；</span><br><span class="line">			<span class="comment">//将对象引用入栈，继续执行下一条指令</span></span><br><span class="line">			SET_STACK_OBJECT（result，<span class="number">0</span>）；</span><br><span class="line">			UPDATE_PC_AND_TOS_AND_CONTINUE（<span class="number">3</span>，<span class="number">1</span>）；</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的内存布局</p>
<p><strong>HotSpot</strong>虚拟机中，对象在内存中分为3块区域：<strong style='color:red'>对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)</strong>。</p>
<ol>
<li><p>对象头，对象头包括两部分信息</p>
<ul>
<li>对象自身的运行时数据，例如，哈希码，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，即<strong>Mark Word</strong>，是与对象自身定义无关的额外存储成本，为了节省空间效率，<strong>Mark Word</strong>被设计成非固定的数据结构以便在极小的空间内存内存储尽量多的信息。具体见<a href="https://effiu.github.io/blog/2019/04/09/concurrent/chapter2/2.2_synchronized/">synchronized</a></li>
<li>对象头的另外一部分是类型指针，即对象指向类元数据的指针。</li>
<li>对象是数据，还会存储数组的长度，因为虚拟机可以通过普通Java对象元数据信息确定Java对象的大小，但是数组的元数据中无法确认大小</li>
</ul>
</li>
<li><p>实例数据</p>
<p>对象真正的有效信息，包括代码中定义的各种类型的字段内容（父类和子类都需要记录）。存储顺序会受Java虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码的定义顺序影响。分配策略为<code>longs/doubles</code>、<code>ints</code>、<code>shorts/chars</code>、<code>bytes/booleans</code>、<code>oops</code>(Ordinary Object Pointer)，相同宽度的数据总被分配到一起且父类中定义的变量会在子类之前。若<strong>CompatcFields</strong>参数值为<strong>true</strong>，子类中较窄的变量也会被插入到父类变量的空隙中</p>
</li>
<li><p>对其填充</p>
<p>不一定存在，没有特殊意义，起占位符的作用。由于<strong>HotSpot VM</strong>自动内存管理系统要求对象起始地址必须是8字节的整数倍，而对象头大小是8的整数倍，所以实例数据部分字段没有对齐时，需要通过对齐填充补全。</p>
</li>
</ol>
</li>
<li><p>对象的访问定位</p>
<p>Java程序需要通过栈上的<strong>reference</strong>数据操作堆上的具体对象，<strong>reference</strong>类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义引用如何定位、访问对重的具体位置，对象的访问方式取决于虚拟机的实现。目前主要有句柄池和直接指针两种方式</p>
<ul>
<li><p><strong>句柄池</strong>，Java堆中会划分出一块内存作为句柄池，<strong>reference</strong>引用中存储的就是对象的柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。<strong style='color:red'>优点</strong>：对象被移动后只会改变句柄中的实例数据指针，不需要改变<strong>reference</strong>引用</p>
<p><img src="https://images.effiu.cn/blog/jvm/04.png" alt="句柄池访问对象"></p>
</li>
<li><p><strong>直接指针</strong>，速度更快，节省了指针定位的时间开销（Java中对象访问很频繁）。HotSpot VM是使用直接指针访问对象的。</p>
<p><img src="https://images.effiu.cn/blog/jvm/05.png" alt="直接指针访问对象"></p>
</li>
</ul>
</li>
</ol>
<h6 id="3-OutOfMemoryError异常"><a href="#3-OutOfMemoryError异常" class="headerlink" title="3. OutOfMemoryError异常"></a>3. OutOfMemoryError异常</h6><p>JVM中，除了程序计数器外，虚拟机内存的其他几个运行区域都有发生<code>OutOfMemoryError</code>。</p>
<ol>
<li><p>Java堆溢出</p>
<p>Java堆用于存储对象实例，只要不断创建对象，且保证对象可达就可以避免<strong>GC</strong>回收，以此当对象占用内存空间达到容量限制后就会产生<strong>OOM</strong>。</p>
<p><code>-XX:+HeapDumpOnOutOfMemoryError</code>可以让虚拟机在出现内存异常时<strong>Dump</strong>出当前内存堆转储快照便于分析。<code> -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=path</code>，path即dump路径。</p>
<p>解决堆内存异常，一般是通过内存映像分析工具对<strong>Dump</strong>出来的堆转储快照进行分析，确认内存中的对象是否必要，确认是内存溢出(<strong>OOM</strong>)还是内存泄露(Memory Leak)。</p>
<ul>
<li>若是内存泄露可以进一步使用工具查看泄露对象到<strong>GC Roots</strong>的引用链，确认泄露对象的类型信息以及<strong>GC Roots</strong>引用链的信息，便于定位出现问题的代码。</li>
<li>若确认对象不存在泄露，则需要检查虚拟机堆参数(-Xmx、-Xms)是否可以调大，确认是否存在某些对象生命周期是否过长，尝试减少程序运行期的内存消耗。</li>
</ul>
</li>
<li><p>虚拟机栈和本地方法栈溢出</p>
<p>在HotSpot虚拟机中没有区分虚拟机栈和本地方法栈。<code>-Xoss</code>(设置本地方法栈大小)实际是无效的，栈容量只由<code>-Xss</code>参数设置。</p>
<p>当栈空间不足时，可能会是由于<strong>内存太小</strong>或者是<strong>已使用栈空间太大</strong>，大部分情况是抛出<code>StackOverflowError</code>。一般来说多线程情况下，单个线程分配的栈空间越大，可以建立的线程数量越少，建立线程时越容易把剩下的内存消耗，所以如果是建立过多线程会导致内存溢出。这种情况若不能减少线程数就只能减少最大堆和最大栈容量换取更多的线程。</p>
</li>
<li><p>方法区和运行时常量池溢出</p>
<p>运行时常量池是方法区的一部分。</p>
<p>方法区用于存放<strong>Class</strong>的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等等，所以一般运行时产生大量的类会导致方法去溢出。例如Spring中，对类进行代理时，代理的类越多，就越需要越大的方法区保证动态生成的<strong>Class</strong>可以载入内存。</p>
<p>方法区溢出也是比较常见的内存溢出异常，方法区的回收比较苛刻。以下场景需要注意方法区内存溢出：</p>
<ul>
<li>Spring、Mybatis等对字节码的代理增强</li>
<li>大量<strong>JSP</strong>或者动态产生JSP文件的应用</li>
<li>基于<strong>OSGI</strong>的应用</li>
</ul>
</li>
<li><p>本机直接内存溢出</p>
<p><code>DirectMemory</code>容量可以通过<code>-XX:MaxDirectMemorySize</code>指定，默认与Java堆最大值(-Xmx)一样。<code>DirectMemory</code>导致的内存溢出，在Heap Dump文件中不会看到明显异常，所以当出现内存溢出时，Dump文件很小，且有使用NIO则有可能是直接内存溢出</p>
</li>
</ol>
<blockquote>
<p>总结：Java垃圾收集机制，但是内存溢出仍是常见现象。</p>
</blockquote>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>走进Java</title>
    <url>/blog/2019/06/02/jvm/1_into_java/</url>
    <content><![CDATA[<p>Java的技术体系主要由Java程序运行的虚拟机、提供各开发领域接口支持的Java API、Java编程语言及许多三方Java框架(Spring、Struts)组成。</p>
<p>Java优点: 在虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。Java虚拟机在各种物理机上建立了统一的运行平台，实现了在一台虚拟机上编译的程序能在任何虚拟机上运行。但是，某些领域针对程序的性能、稳定性和可扩展性方面都有极高的要求，此时就需要对虚拟机运行原理有一定的了解。</p>
<h5 id="1-要点"><a href="#1-要点" class="headerlink" title="1. 要点"></a>1. 要点</h5><ul>
<li>走进Java</li>
<li>自动内存管理机制，有Java虚拟机管理内存，所以一旦出现内存泄露和溢出方面的问题，如果不了解内存管理机制，将会很难排查工作</li>
<li>虚拟机执行子系统，虚拟机执行程序过程</li>
<li>程序编译与代码优化，源码编译成字节码和从字节码编译成本地机器码两个过程</li>
<li>高效并发</li>
</ul>
<h6 id="2-走进Java"><a href="#2-走进Java" class="headerlink" title="2. 走进Java"></a>2. 走进Java</h6><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h6><blockquote>
<p>Java是由一系列计算机软件和规范形成的技术体系，这个技术体系提供了完善的软件开发和跨平台部署的支持环境，不仅仅是门语言。</p>
</blockquote>
<p>其优势如下:</p>
<ul>
<li>摆脱了平台的束缚，实现了”一次编写，到处运行”的理想</li>
<li>提供了一个相对安全的内存管理和访问机制，避免绝大部分的内存泄露和指针越界问题</li>
<li>实现了代码节点检测和运行时编译及优化，使得Java应用能够随着运行时间的增加获得更高的性能</li>
<li>有一套完善的应用程序接口以及商业机构和开源社区的第三方类库</li>
</ul>
<h6 id="2-Java技术体系"><a href="#2-Java技术体系" class="headerlink" title="2. Java技术体系"></a>2. Java技术体系</h6><p>Sun官方定义的Java技术他体系包括以下几个部分：</p>
<ul>
<li>Java程序设计语言</li>
<li>各种硬件平台上的Java虚拟机</li>
<li>Class文件格式</li>
<li>Java API类库</li>
<li>商业机构和开源社区的第三方Java类库</li>
</ul>
<blockquote>
<p>Java程序设计语言、Java虚拟机、Java API类库这三部分统称为<strong>JDK(Java Development Kit)**，Java API中的Java SE API子集和Java虚拟机这两部分统称为</strong>JRE(Java Runtime Environment)**。</p>
</blockquote>
<p><img src="https://images.effiu.cn/blog/jvm/01.jpg" alt="Java技术体系"></p>
<blockquote>
<p>按照技术服务的领域划分，可以分为4个平台：</p>
</blockquote>
<ul>
<li>Java Card，支持Java小程序(Applets)运行在小内存设备上的平台</li>
<li>Java ME(Micro Edition)，Java程序运行在移动终端(手机、PAD)上，对Java  API有所精简，加入了针对移动终端的支持</li>
<li>Java SE(Standard Edition)，支持面向桌面级应用（例如，Windows下的应用程序）的Java平台</li>
<li>Java EE(Enterprise Edition)，支持使用多层架构 的企业应用的Java平台，并对其做了大量的扩充（<code>javax.*</code>的包名，部分<code>javax.*</code>也加入了Java API）提供了相关的部署支持</li>
</ul>
<h6 id="3-Java发展史"><a href="#3-Java发展史" class="headerlink" title="3. Java发展史"></a>3. Java发展史</h6><p><img src="https://images.effiu.cn/blog/jvm/02.jpg" alt="Java发展时间线"></p>
<ul>
<li>1997年2月19日，Sun发布了JDK1.1，相关技术：JAR文件格式、JDBC、JavaBeans、RMI、Java语法(内部类、反射)等</li>
<li>1998年12月4日，Sun发布了JDK1.2，Java虚拟机内置了JIT(Just In Time)编译器，<strong>Classic Vm</strong>、<strong>HotSpot VM</strong> 和 <strong>Exact VM</strong>等。</li>
<li>2000年5月8日，Sun发布了JDK1.3，新增了Java类库(Timer、数学运算等)等</li>
<li>2002年2月13日，Sun发布了JDK1.4，新增了技术特性：正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器等</li>
<li>2004年9月30日，JDK1.5发布，在语法易用性上有很大的改进：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环等；在虚拟机和API：改进了Java的内存模型，提供了<code>java.util.concurrent</code>并发包等</li>
<li>2006年12月11日，JDK1.6发布，改进：提供动态语言支持、提供编译API和微型HTTP服务器API等；对Java虚拟机内部改动：锁与同步、垃圾收集、类加载等方面</li>
<li>2009年2月19日，JDK1.7发布，提供了新的G1收集器、加强对非Java语言的调用支持</li>
</ul>
<h6 id="4-Java虚拟机发展史"><a href="#4-Java虚拟机发展史" class="headerlink" title="4. Java虚拟机发展史"></a>4. Java虚拟机发展史</h6><blockquote>
<p>部分内容如下：</p>
</blockquote>
<ol>
<li><strong>HotSpot VM</strong>特点：</li>
</ol>
<ul>
<li>准确式内存管理，即虚拟机知道内存中某个位置的数据具体是什么类型</li>
<li>热点代码探测技术，可以通过执行计数器找出最具有编译价值的代码，然后通知<strong>JIT</strong>编译器以方法为单位进行编译。</li>
</ul>
<ol start="2">
<li><strong>BEA JRockit/IBM J9 VM</strong></li>
</ol>
<blockquote>
<p><strong>JRockit的垃圾回收器和MissionControl服务套件</strong>等部分优于其他Java虚拟机</p>
</blockquote>
<h5 id="5-Java技术的未来"><a href="#5-Java技术的未来" class="headerlink" title="5. Java技术的未来"></a>5. Java技术的未来</h5><ol>
<li><p>模块化，模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。</p>
</li>
<li><p>混合语言</p>
<p>单一的Java开发已经无法满足当前软件的复杂需求了，越来越多的基于Java虚拟机的语言开发被应用到软件项目中，多语言混合编程正成为主流，每种语言都可以针对自己擅长的方面更好地解决问题。例如，并行处理用<strong>Clojure</strong>语言、展示层用<strong>JRuby/Rails</strong>，中间层用<strong>Java</strong>。接口对各层开发透明，各种语言之间交互不存在任何困难</p>
</li>
<li><p>多核并行</p>
<p>CPU硬件的发展已经从高频率转变为多核心，越来越关注并行编程的领域。<strong>Fork/Join</strong>模式是处理并行编程的一个经典方法，能够轻松利用多核CPU提供的计算资源来协助完成计算任务。</p>
</li>
<li><p>进一步丰富语法</p>
</li>
<li><p>64位虚拟机</p>
</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实践</title>
    <url>/blog/2019/06/01/concurrent/11_concurrent_practice/</url>
    <content><![CDATA[<h5 id="1-生产者和消费者模式"><a href="#1-生产者和消费者模式" class="headerlink" title="1. 生产者和消费者模式"></a>1. 生产者和消费者模式</h5><blockquote>
<p>并发编程中， 生产者和消费者模式可以解决绝大部分并发问题。 生产者和消费者模式是通过一个容器解决生产者和消费者的耦合问题，彼此之间不通信，而是通过阻塞队列进行通信。</p>
</blockquote>
<blockquote>
<p>多核时代，多线程并发处理速度比单线程更快，所以使用多个线程生产数据，多个线程消费数据，甚至消费者消费数据后，又作为生产者把数据放到新的队列里。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/78.jpg" alt="多生产者消费者模式"></p>
<blockquote>
<p>Java的线程池就是一种生产者和消费者模式的实现方式。生产者把任务给线程池，线程池处理任务，而且线程池会在将要运行任务数大于线程池基本线程数时把任务放到阻塞队列中。</p>
</blockquote>
<h5 id="2-线上问题定位"><a href="#2-线上问题定位" class="headerlink" title="2. 线上问题定位"></a>2. 线上问题定位</h5><blockquote>
<p>查看日志、系统状态、dump线程信息等</p>
<p>top查看进程运行状态，<code>COMMAND</code>是进程启动命令，<code>%MEM</code>CPU利用率。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top - 16:25:20 up 657 days, 21:39,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  69 total,   1 running,  68 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  1016396 total,    69612 free,   761020 used,   185764 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.    87244 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND </span><br><span class="line">30769 root       0 -20  128624   8684   5084 S  0.7  0.9  89:08.25 AliYunDun             </span><br><span class="line">28276 root      20   0  157568   2128   1528 R  0.3  0.2   0:00.09 top                   </span><br><span class="line">28706 root      20   0 2322768 196616   3172 S  0.3 19.3  24:50.92 java                   </span><br><span class="line">    1 root      20   0   43212   2424   1256 S  0.0  0.2   4:50.29 systemd</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>top -Hp pid</code>查看某个进程的线程信息，一般有3种情况</p>
</blockquote>
<ul>
<li>某个线程CPU利用率一直100%，说明该线程有可能死循环，记录<strong>PID</strong>，也有可能是GC导致的，可以使用<code>jstat</code>查看GC情况</li>
<li>某个线程一直在TOP 10位置，说明该线程性能有问题</li>
<li>CPU利用率高的线程在不断变化，说明不是一个线程导致的CPU偏高</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number">28706</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> java                   </span><br><span class="line"><span class="number">28707</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">76</span> java                  </span><br><span class="line"><span class="number">28708</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">47.56</span> java                   </span><br><span class="line"><span class="number">28709</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">01</span> java                   </span><br><span class="line"><span class="number">28710</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">01</span> java                   </span><br><span class="line"><span class="number">28711</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> java                   </span><br><span class="line"><span class="number">28712</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">20.75</span> java                   </span><br><span class="line"><span class="number">28713</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">09.80</span> java                   </span><br><span class="line"><span class="number">28714</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2322768</span> <span class="number">196616</span>   <span class="number">3172</span> S  <span class="number">0.0</span> <span class="number">19.3</span>   <span class="number">0</span>:<span class="number">00</span>.<span class="number">00</span> java</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>jstat -gc 28706 5000</code>，查看java进程的JVM统计信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line"><span class="number">2688.0</span> <span class="number">2688.0</span>  <span class="number">0.0</span>    <span class="number">70.2</span>  <span class="number">21760.0</span>  <span class="number">16491.0</span>   <span class="number">54156.0</span>    <span class="number">38140.2</span>   <span class="number">41600.0</span> <span class="number">40620.6</span> <span class="number">4736.0</span> <span class="number">4485.4</span>    <span class="number">787</span>    <span class="number">2.267</span>   <span class="number">5</span>      <span class="number">0.307</span>    <span class="number">2.574</span></span><br><span class="line"><span class="number">2688.0</span> <span class="number">2688.0</span>  <span class="number">0.0</span>    <span class="number">70.2</span>  <span class="number">21760.0</span>  <span class="number">16491.0</span>   <span class="number">54156.0</span>    <span class="number">38140.2</span>   <span class="number">41600.0</span> <span class="number">40620.6</span> <span class="number">4736.0</span> <span class="number">4485.4</span>    <span class="number">787</span>    <span class="number">2.267</span>   <span class="number">5</span>      <span class="number">0.307</span>    <span class="number">2.574</span></span><br><span class="line"><span class="number">2688.0</span> <span class="number">2688.0</span>  <span class="number">0.0</span>    <span class="number">70.2</span>  <span class="number">21760.0</span>  <span class="number">16493.1</span>   <span class="number">54156.0</span>    <span class="number">38140.2</span>   <span class="number">41600.0</span> <span class="number">40620.6</span> <span class="number">4736.0</span> <span class="number">4485.4</span>    <span class="number">787</span>    <span class="number">2.267</span>   <span class="number">5</span>      <span class="number">0.307</span>    <span class="number">2.574</span></span><br><span class="line"><span class="number">2688.0</span> <span class="number">2688.0</span>  <span class="number">0.0</span>    <span class="number">70.2</span>  <span class="number">21760.0</span>  <span class="number">16493.1</span>   <span class="number">54156.0</span>    <span class="number">38140.2</span>   <span class="number">41600.0</span> <span class="number">40620.6</span> <span class="number">4736.0</span> <span class="number">4485.4</span>    <span class="number">787</span>    <span class="number">2.267</span>   <span class="number">5</span>      <span class="number">0.307</span>    <span class="number">2.574</span></span><br><span class="line"><span class="number">2688.0</span> <span class="number">2688.0</span>  <span class="number">0.0</span>    <span class="number">70.2</span>  <span class="number">21760.0</span>  <span class="number">16493.1</span>   <span class="number">54156.0</span>    <span class="number">38140.2</span>   <span class="number">41600.0</span> <span class="number">40620.6</span> <span class="number">4736.0</span> <span class="number">4485.4</span>    <span class="number">787</span>    <span class="number">2.267</span>   <span class="number">5</span>      <span class="number">0.307</span>    <span class="number">2.574</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>C只当前大小，U指当前使用大小，S是<code>Survivor</code>，E是<code>Edon</code>，O是老年代，M是方法区，CCS压缩类空间，GC是垃圾回收，T是time</p>
</blockquote>
<blockquote>
<p>其他命令：</p>
</blockquote>
<ul>
<li><code>jstat -class pid</code>，类加载统计</li>
<li><code>jstat -compiler pid</code>，编译统计</li>
<li><code>jstat -gccapacity pid</code>，堆内存统计</li>
<li><code>jstat -gcnew pid</code>，新生代垃圾回收统计</li>
<li>等待</li>
</ul>
<blockquote>
<p><code>jinfo</code>，查看JVM信息，部分信息如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:CICompilerCount=<span class="number">2</span> -XX:InitialHeapSize=<span class="number">16777216</span> -XX:MaxHeapSize=<span class="number">262144000</span> -XX:MaxNewSize=<span class="number">87359488</span> -XX:=<span class="number">196608</span> -XX:NewSize=<span class="number">5570560</span> -XX:OldSize=<span class="number">11206656</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br></pre></td></tr></table></figure>

<ul>
<li><code>InitialHeapSize</code>，初始化堆大小</li>
<li><code>MaxHeapSize</code>，最大堆空间</li>
<li><code>MaxNewSize</code>，最大新生代大小</li>
<li><code>OldSize</code>，老年代大小</li>
</ul>
<blockquote>
<p><code>jstack pid</code>，查看指定进程的线程信息</p>
</blockquote>
<h5 id="3-性能测试"><a href="#3-性能测试" class="headerlink" title="3. 性能测试"></a>3. 性能测试</h5><ul>
<li><p><code>netstat -nat | grep port -c</code>，查看连接指定端口的服务器个数，例如: <code>netstat -nat | grep 3306 -c</code>查看数据库连接数</p>
</li>
<li><p><code>cat /proc/net/dev</code>，查看网络流量</p>
</li>
<li><p><code>cat /proc/loadavg </code>，查看系统平均负载</p>
</li>
<li><p><code>cat /proc/meminfo </code>，查看系统内存情况</p>
</li>
<li><p><code>cat /proc/stat</code>，查看CPU利用率</p>
</li>
</ul>
<h5 id="4-异步任务池"><a href="#4-异步任务池" class="headerlink" title="4. 异步任务池"></a>4. 异步任务池</h5><p><img src="https://images.effiu.cn/gitbook/concurrent/79.jpg" alt="异步任务池"></p>
<blockquote>
<p>任务池的主要处理流程是，每台机器会启动一个任务池，每个任务池里有多个线程池，当<br>某台机器将一个任务交给任务池后，任务池会先将这个任务保存到数据库中，然后某台机器上<br>的任务池会从数据库中获取待执行的任务，再执行这个任务。 </p>
</blockquote>
<blockquote>
<p>每个任务有几种状态，分别是<strong style='color:red'>创建（NEW）、执行中（EXECUTING）、RETRY（重试）、挂起<br>（SUSPEND）、中止（TEMINER）和执行完成（FINISH）</strong>。</p>
</blockquote>
<ul>
<li>创建：提交给任务池之后的状态。</li>
<li>执行中：任务池从数据库中拿到任务执行时的状态。</li>
<li>重试：当执行任务时出现错误，程序显式地告诉任务池这个任务需要重试，并设置下一次<br>执行时间。</li>
<li>挂起：当一个任务的执行依赖于其他任务完成时，可以将这个任务挂起，当收到消息后，<br>再开始执行。</li>
<li>中止：任务执行失败，让任务池停止执行这个任务，并设置错误消息告诉调用端。</li>
<li>执行完成：任务执行结束。 </li>
</ul>
<blockquote>
<p>设计注意事项：</p>
</blockquote>
<ul>
<li>任务池的任务隔离，根据任务优先级隔离任务</li>
<li>任务池的重试策略，根绝任务类型设置不同的重试策略</li>
<li>任务池的使用，不能在执行机器上保存数据，防止多个机器执行出现问题，建议保存到其他集群中</li>
<li>任务池的异步属性，任务名称、下次执行时间、已执行次数、任务类型、任务优先级和执行报错信息等</li>
</ul>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Executor框架</title>
    <url>/blog/2019/05/30/concurrent/10_executor/</url>
    <content><![CDATA[<blockquote>
<p>使用多线程异步执行任务，会因为Java线程的创建与销毁消耗大量的计算资源。</p>
<p>Java线程即是工作单元，又是执行机制。<code>Runnable</code>和<code>Callable</code>是工作单元，<code>Executor</code>是执行机制。</p>
</blockquote>
<h5 id="1-Executor"><a href="#1-Executor" class="headerlink" title="1. Executor"></a>1. <code>Executor</code></h5><h6 id="1-Executor的两级调度模型"><a href="#1-Executor的两级调度模型" class="headerlink" title="1. Executor的两级调度模型"></a>1. <code>Executor</code>的两级调度模型</h6><blockquote>
<p>在<code>HotSpot VM</code>线程模型中，Java线程(<code>java.lang.Thread</code>)被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；该Java线程终止是，这个操作系统也会被回收，操作系统会调度所有线程并将它们分配给可用的CPU。</p>
<p>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器(<code>Executor</code>框架)将这些任务映射为固定数量的线程；底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<p>如下图：应用程序通过<code>Executor</code>框架控制上层的调度；而下层的调度由操作系统内核控制，其不受应用程序控制。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/62.jpg" alt="两级调度模型"></p>
<h6 id="2-Executor框架的结构与成员"><a href="#2-Executor框架的结构与成员" class="headerlink" title="2. Executor框架的结构与成员"></a>2. <code>Executor</code>框架的结构与成员</h6><ol>
<li><code>Executor</code>框架的结构</li>
</ol>
<blockquote>
<p><code>Executor</code>框架主要由3大部分组成：</p>
</blockquote>
<ul>
<li>任务，被执行任务需要实现接口:<code>Runnable</code>或者<code>Callable</code></li>
<li>任务的执行，任务执行机制的核心接口<code>Executor</code>，继承自<code>Executor</code>的<code>ExecutorService</code>,其有两个关键实现类。<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code></li>
<li>异步计算的结果，<code>Future</code>接口及其实现<code>FutureTask</code></li>
</ul>
<blockquote>
<p><code>Executor</code>框架的主要接口与类如下图:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/63.jpg" alt="类与接口"></p>
<ul>
<li><code>Executor</code>: 是<code>Executor</code>的基础，将任务的提交与任务的执行分离</li>
<li><code>ThreadPoolExecutor</code>，线程池的核心实现，用来执行被提交的任务</li>
<li><code>ScheduledThreadPoolExecutor</code>，是一个实现类，可以在给定延迟后执行或者定时执行，比<code>Timer</code>更强大、灵活</li>
<li><code>Future</code>，接口及其实现<code>FutureTask</code>，用于异步计算的结果</li>
<li><code>Runnable</code>和<code>Callable</code>接口，代表任务，可以被<code>ThreadPoolExecutor</code>或者<code>ScheduledThreadPoolExecutor</code>执行</li>
</ul>
<blockquote>
<p><code>Executor</code>使用示意图</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/64.jpg" alt="使用示意图"></p>
<blockquote>
<p>主线程创建实现<code>Runnable</code>或者<code>Callable</code>接口的任务对象。然后把对象交给<code>ExecutorService</code>(<code>submit()</code>、<code>execute()</code>)。若需要返回结果，则需要使用<code>ExecutorService.submit(Callable task)</code>，然后<code>task.get()</code>获取异步返回结果，<code>task.cancel(boolean mayInterruptIfRuning)</code>用来取消任务的执行。</p>
</blockquote>
<ol start="2">
<li><code>Executor</code>框架的成员</li>
</ol>
<blockquote>
<p>框架的成员<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>Future</code>接口、<code>Runnable</code>接口、<code>Callable</code>接口<code>Executors</code></p>
</blockquote>
<ol>
<li><code>ThreadPoolExecutor</code></li>
</ol>
<blockquote>
<p>可以使用工厂类创建3种类型的线程池</p>
</blockquote>
<ul>
<li><code>SingleThreadExecutor</code>: 适用于需要保证顺序地执行各个任务，在任意时间点不会有多个线程获得的场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>FixedThreadPool</code>: 适用于为了满足资源管理的需求而限制当前线程数量的应用场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CachedThreadPool</code>: 是大小无界的线程池，适用于执行很多短期异步任务的小程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>ScheduledThreadPoolExecutor</code>，通常使用工厂类<code>Executors</code>创建</li>
</ol>
<ul>
<li><code>ScheduledThreadPoolExecutor</code>，包含若干线程，适用于需要多个后台线程执行周期任务，同时为了满足组员管理的需求而限制后台线程数量的应用场景</li>
<li><code>SingleScheduledThreadPoolExecutor</code>，包含一个线程线程，适用于需要执行单个后台线程执行周期任务，同时也会顺序的执行各个任务。</li>
</ul>
<ol start="3">
<li><code>Futurn</code>接口</li>
<li><code>Runnable</code>接口和<code>Callable</code>接口</li>
</ol>
<blockquote>
<p>都是用来提交任务的接口。<code>Callable</code>接口会返回执行结果。</p>
<p>以下方法会把<code>Runnable</code>包装成一个<code>Callable</code>接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-ThreadPoolExecutor详解"><a href="#2-ThreadPoolExecutor详解" class="headerlink" title="2. ThreadPoolExecutor详解"></a>2. <code>ThreadPoolExecutor</code>详解</h5><blockquote>
<p><code>ThreadPoolExecutor</code>是<code>Executor</code>框架的核心类。主要由以下投个组件构成。</p>
</blockquote>
<ul>
<li><code>corePool</code>: 核心线程池的大小</li>
<li><code>maximumPool</code>: 最大线程池的大小</li>
<li><code>BlockingQueue</code>: 用来暂时保存任务的工作队列</li>
<li><code>RejectedExecutionHandler</code>: 当<code>ThreadPoolExecutor</code>已经关闭或<code>ThreadPoolExecutor</code>已经饱和<br>时（达到了最大线程池大小且工作队列已满），<code>execute()</code>方法将要调用的<code>Handler</code></li>
</ul>
<blockquote>
<p> 通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor。</p>
</blockquote>
<ul>
<li><code>FixedThreadPool</code></li>
<li><code>SingleThreadExecutor</code></li>
<li><code>CachedThreadPool</code></li>
</ul>
<h6 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1. FixedThreadPool"></a>1. <code>FixedThreadPool</code></h6><blockquote>
<p>可重用固定线程数的线程池。<code>keepAliveTime</code>是多余的空闲线程等待新任务的时间，超时线程将被终止。执行示意图如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/gitbook/concurrent/65.jpg"></p>
<ul>
<li>线程数小于<code>corePoolSize</code>时会创建新线程执行任务</li>
<li>达到<code>corePoolSize</code>时，将任务放到<code>LinkedBlockingQueue</code>队列中去</li>
<li>循环从队列中获取任务</li>
<li><code>LinkedBlockingQueue</code>是无界队列(<code>Integer.MAX_VALUE</code>)。会产生以下影响：<ul>
<li>线程数达到<code>corePoolSize</code>后，新任务将在无界队列中等待</li>
<li><code>maximumPoolCore</code>是一个无效参数</li>
<li><code>keepAliveTime</code>是一个无效参数，因为并不会销毁<code>corePoolSize</code></li>
<li>不执行<code>shutdown()</code>或者<code>shutdownNow()</code>将不会拒绝任何任务</li>
</ul>
</li>
</ul>
<h6 id="2-SingleThreadExecutor"><a href="#2-SingleThreadExecutor" class="headerlink" title="2. SingleThreadExecutor"></a>2. <code>SingleThreadExecutor</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        	(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                	<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                	<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与<code>FixedThreadPool</code>相比，特殊之处是<code>corePool</code>和<code>maximumPool</code>均被设置为1，运行示意图如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/66.jpg"></p>
<ul>
<li>线程数小于<code>corePoolSize</code>时会创建1个线程执行任务</li>
<li>达到<code>corePoolSize</code>时，将任务放到<code>LinkedBlockingQueue</code>队列中去</li>
<li>执行完任务后，会在一个无限循环中反复从<code>LinkedBlockingQueue</code>中获取任务</li>
</ul>
<h6 id="3-CachedThreadPool"><a href="#3-CachedThreadPool" class="headerlink" title="3. CachedThreadPool"></a>3. <code>CachedThreadPool</code></h6><blockquote>
<p>是一个会根据需要创建线程的线程池</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>corePoolSize</code>设置为0，<code>maximumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>，<code>keepAliveTime</code>设置为60s</p>
<p>队列为<code>SynchronousQueue</code>。当线程提交任务速度大于处理任务速度时会不断创建新线程执行任务。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/67.jpg"></p>
<ul>
<li><code>SynchronousQueue.offer</code>，将任务放到阻塞队列中，若有空闲线程在执行<code>SynchronousQueue.poll</code>则配对成功</li>
<li><code>maximumPool</code>为空或者没有空闲 线程时，<code>CachedThreadPool</code>会创建一个新线程执行任务</li>
<li>新线程执行完任务后，会执行<code>SynchronousQueue.poll</code>获取新任务，否则等待60s，超时则销毁线程</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/68.jpg"></p>
<h5 id="3-ScheduledThreadPoolExecutor"><a href="#3-ScheduledThreadPoolExecutor" class="headerlink" title="3. ScheduledThreadPoolExecutor"></a>3. <code>ScheduledThreadPoolExecutor</code></h5><blockquote>
<p>主要用来给延迟或定时任务使用，与<code>Timer</code>类似，单比<code>Timer</code>强大、灵活，可以指定多个后台线程。</p>
</blockquote>
<h6 id="1-运行机制"><a href="#1-运行机制" class="headerlink" title="1. 运行机制"></a>1. 运行机制</h6><blockquote>
<p>以下是执行示意图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/69.jpg"></p>
<blockquote>
<p>为了实现周期性任务，对<code>ThreadPoolExecutor</code>做了修改</p>
</blockquote>
<ul>
<li>使用<code>DelayQueue</code>延迟任务队列，其是无界队列</li>
<li>获取任务方式改变</li>
<li>执行周期任务后，增加了额外的处理</li>
</ul>
<blockquote>
<p><code>ScheduledThreadPoolExecutor</code>执行过程</p>
</blockquote>
<ul>
<li>调用<code>ScheduledThreadPoolExecutor#scheduleAtFixedRate()</code>或者<code>ScheduledThreadPoolExecutor#scheduleWithFixedDelay()</code>时会向<code>DelayQueue</code>中添加一个实现了<code>RunnableScheduledFuture</code>接口的<code>ScheduledFutureTask</code></li>
<li>线程池中的线程从<code>DelayQueue</code>中获取<code>ScheduledFutureTask</code>执行</li>
</ul>
<h6 id="2-ScheduledThreadPoolExecutor实现"><a href="#2-ScheduledThreadPoolExecutor实现" class="headerlink" title="2. ScheduledThreadPoolExecutor实现"></a>2. <code>ScheduledThreadPoolExecutor</code>实现</h6><blockquote>
<p><code>ScheduledFutureTask</code>包含3个成员</p>
</blockquote>
<ul>
<li><code>long</code>型成员变量<code>time</code></li>
<li><code>long</code>型<code>sequenceNumber</code>，表示任务被添加到<code>ScheduledThreadPoolExecutor</code>队列中的序号</li>
<li><code>long</code>型<code>period</code>，任务的执行间隔周期</li>
</ul>
<blockquote>
<p><code>DelayQueue</code>，内部封装了<code>PriorityQueue</code>会对队列中的<code>ScheduledFutureTask</code>进行排序，基于<code>time</code>和<code>sequenceNumber</code>。<strong>JDK8有变化</strong>。以下是执行任务的过程：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/70.jpg"></p>
<ul>
<li>线程1从<code>DelayQueue</code>中获取已到周期的<code>ScheduledFutureTask</code></li>
<li>线程1执行这个任务</li>
<li>线程1修改这个任务的<code>time</code>为下次被执行的时间</li>
<li>线程1把修改后的任务放回<code>DelayQueue</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列持有的锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 可中断地获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环获取任务</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 查看队列中的第一个任务</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 说明队列为空，等待</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不为空，判断当前任务的执行延迟时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 已过执行时间，执行并将第一个任务放到最后</span></span><br><span class="line">                    <span class="comment">// 唯一出口</span></span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">            	<span class="comment">// leader不为null，说明已经有其他线程获等待获取队列头元素</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">					<span class="comment">// 当前线程设置为leader</span></span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待到执行时间</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 通知等待队列中的线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://images.effiu.cn/gitbook/concurrent/71.jpg"></p>
<h5 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3. FutureTask"></a>3. <code>FutureTask</code></h5><h6 id="1-FutureTask简介"><a href="#1-FutureTask简介" class="headerlink" title="1. FutureTask简介"></a>1. <code>FutureTask</code>简介</h6><blockquote>
<p><code>Future</code>接口和<code>FutureTask</code>类，代表异步计算的结果。<code>FutureTask</code>还实现了<code>Runnable</code>接口，说明<code>FutureTask</code>可以交给<code>Executor</code>执行，也可以直接执行<code>FutureTask.run()</code>。<code>FutureTask</code>有3种状态：</p>
</blockquote>
<ul>
<li>未启动，<code>FutureTask.run()</code>方法没有被执行之前处于未启动状态。</li>
<li>已启动，<code>FutureTask.run()</code>调用后</li>
<li>已完成，<code>FutureTask.run()</code>执行结束后(正常结束或者被取消)后，处于已完结状态</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/73.jpg"></p>
<ul>
<li><code>FutureTask</code>处于未启动或已启动状态时，<code>FutureTask.get()</code>将会阻塞线程</li>
<li><code>FutureTask.cancel(boolean)</code>  <ul>
<li>未启动时，将直接取消任务。</li>
<li>已启动时，<code>FutureTask.cancel(true)</code>将会尝试立即中断执行此任务的线程；<code>FutureTask.cancel(false)</code>将不会对正在执行任务的线程产生影响</li>
<li>已完成时，返回<code>false</code></li>
</ul>
</li>
</ul>
<h6 id="2-FutureTask使用"><a href="#2-FutureTask使用" class="headerlink" title="2. FutureTask使用"></a>2. <code>FutureTask</code>使用</h6><blockquote>
<p><code>FutureTask</code>可以交给<code>Executor</code>执行，也可以通过<code>ExecutorService.submit(···)</code>返回一个<code>FutureTask</code>。</p>
<p><strong style='color:red'>当一个线程需要等待另一个线程把某个任务执行完后才能继续执行时，可以使用<code>FutureTask</code></strong></p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/74.jpg"></p>
<p><img src="https://images.effiu.cn/gitbook/concurrent/75.jpg"></p>
<h6 id="3-FutrueTask的实现"><a href="#3-FutrueTask的实现" class="headerlink" title="3. FutrueTask的实现"></a>3. <code>FutrueTask</code>的实现</h6><blockquote>
<p>基于<strong>AQS</strong>，其内部维护了一个私有的继承自<strong>AQS</strong>的子类<code>Sync</code>。</p>
</blockquote>
<ul>
<li><code>FutureTask.get</code>类似于<code>acquire</code>操作</li>
<li><code>FutureTask.run</code>和<code>FutureTask.cancel</code>类似于<code>release</code>操作</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/76.jpg"></p>
<blockquote>
<p><code>FutureTask</code>的所有操作都委托给了继承自<strong>AQS</strong>的私有内部类。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/blog/2019/05/28/concurrent/9_threadpool/</url>
    <content><![CDATA[<blockquote>
<p><strong style='color:red'>Java中的线程池是运用场景最多的并发框架</strong>，几乎所有需要异步或并发执行任务的程序都可以使用线程池。合理使用线程池会有以下3个好处:</p>
</blockquote>
<ul>
<li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的孙昊</li>
<li>提高相应速度，任务不需要创建线程就可以立即执行</li>
<li>提高线程可管理性，线程是稀缺资源，无限制创建不仅会消耗系统资源，还会降低系统稳定性，使用线程池进行统一分配、调优和监控。</li>
</ul>
<h6 id="1-线程池的实现原理"><a href="#1-线程池的实现原理" class="headerlink" title="1. 线程池的实现原理"></a>1. 线程池的实现原理</h6><blockquote>
<p>从下图可得出以下结论：</p>
</blockquote>
<ul>
<li>线程池判断核心线程池里的线程是否都在执行任务</li>
<li>线程池判断工作队列是否已满</li>
<li>线程池判断线程池的线程是否都处于工作状态</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/59.jpg" alt="处理流程"></p>
<blockquote>
<p>线程池<code>ThreadPoolExecutor</code>执行分为以下4种情况：</p>
</blockquote>
<ul>
<li>若当前运行线程少于<code>corePoolSize</code>，则创建新线程执行任务(需要获取全局锁)</li>
<li>若运行线程等于或多余<code>corePoolSize</code>，则将任务加入<code>BlockQueue</code></li>
<li>若<code>BlockQueue</code>队列已满，则创建新的线程处理任务(需要获取全局锁)</li>
<li>若新创建线程会使当前运行线程超出<code>maximumPoolSize</code>，任务将被拒绝，调用<code>RejectExecutionHandler.rejectedExecution()</code>方法</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/60.jpg" alt="处理流程"></p>
<blockquote>
<p>上述步骤，所有创建线程操作需要全局锁(是一个瓶颈)。步骤2不需要全局锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ThreadPoolExecutor</code>中线程执行示意图如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/61.jpg" alt="线程执行示意图"></p>
<blockquote>
<p>线程池中线程执行任务分两种情况：</p>
</blockquote>
<ul>
<li><code>execute()</code>方法中创建一个线程时，会让这个线程执行当前任务</li>
<li>线程执行完任务后，会反复从<code>BlockingQueue</code>中获取任务执行</li>
</ul>
<h6 id="2-线程池的使用"><a href="#2-线程池的使用" class="headerlink" title="2. 线程池的使用"></a>2. 线程池的使用</h6><blockquote>
<p><code>new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; runnableTaskQueue, RejectedExecutionHandler handler)</code>，需要以下几个参数:</p>
</blockquote>
<ul>
<li><code>corePoolSize</code>: 线程池基本大小，提交任务后，线程池会创建线程执行任务，即使其他控线基本线程能够执行新任务时也会创建线程，直到任务数大于线程池基本大小时就不再创建。<code>prestartAllCoreThreads()</code>会提前创建并启动所有基本线程</li>
<li><code>BlockingQueue&lt;Runnable&gt;</code>: 任务队列。用于保存等待执行任务的阻塞队列，可选队列类型如下：<ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，FIFO原则</li>
<li><code>LinkedBlockingQueue</code>: 基于链表结构的有几节阻塞队列，FIFO原则，吞吐量高于<code>ArrayBlockingQueue</code>。<code>Executors.newFixedThreadPool()</code>使用了此队列。</li>
<li><code>SynchronousQueue</code>: 不存储元素的阻塞队列。吞吐量高于<code>LinkedBlockingQueue</code>，<code>Executors.newCacheedThreadPoool()</code>使用了此队列。</li>
<li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列</li>
</ul>
</li>
<li><code>maximumPoolSize</code>: 线程池最大数量。线程池允许的最大线程数。只有当队列已满，且已线程数小于最大线程数，线程池才会创建新的线程执行任务。注意：无界队列，队列不会满</li>
<li><code>ThreadFactory</code>: 用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li>
<li><code>RejectedExecutionHandler</code>：饱和策略。当队列和线程池已满说明线程池处于饱和状态，此时必须采取一种策略处理提交的任务。有以下4种策略：<ul>
<li><code>AbortPolicy</code>: 抛出异常，默认策略</li>
<li><code>CallerRunsPolicy</code>: 只用调用者所在线程来运行任务</li>
<li><code>DiscardOldestPolicy</code>: 丢弃队列中最近的一个任务并执行当前任务</li>
<li><code>DiscardPolicy</code>: 不处理，直接丢弃</li>
<li>还可以自定义<code>RejectedExecutionhandler</code>接口</li>
</ul>
</li>
</ul>
<h6 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3. 提交任务"></a>3. 提交任务</h6><blockquote>
<p>有两种提交任务的方法，<code>execute()</code>和<code>submit()</code></p>
</blockquote>
<ul>
<li><code>execute()</code>: 是用于提交不需要返回值的任务。</li>
<li><code>submit()</code>: 用于提交需要返回值的任务。会返回一个<code>future</code>类型的对象，可以使用此对象判断任务是否执行成功，可以使用<code>future.get()</code>获取返回值，会一直阻塞到任务执行完成，<code>get(long timeout, TimeUnit unit)</code>方法会阻塞到指定超时时间。</li>
</ul>
<h6 id="4-关闭线程池"><a href="#4-关闭线程池" class="headerlink" title="4. 关闭线程池"></a>4. 关闭线程池</h6><blockquote>
<p><code>shutdown()</code>和<code>shudownNow()</code>关闭线程池。会遍历线程池中的工作线程，然后逐个调用<code>interrupt()</code>方法中断线程，所以无法响应中断的线程可能无法终止。<strong style='color:red'>区别</strong>：<code>shutdownNow()</code>会先将线程池状态设置为<strong>STOP</strong>，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。<code>shutdow()</code>会将线程池状态设置为<code>SHUTDOWN</code>，中断没有正在执行任务的线程。</p>
<p>只要调用了任何一个方法<code>isShutdown()</code>就会返回true</p>
<p>只要线程池全部关闭后，调用<code>isTerminated</code>才会返回true</p>
</blockquote>
<h6 id="5-合理配置线程池"><a href="#5-合理配置线程池" class="headerlink" title="5. 合理配置线程池"></a>5. 合理配置线程池</h6><blockquote>
<p>合理使用 线程池，就需要分析任务特性</p>
</blockquote>
<ul>
<li>任务的性质，CPU密集任务、IO密集型任务和混合型任务</li>
<li>任务的优先级，使用优先级队列</li>
<li>任务的执行时间，根据执行时间交给不同的线程池</li>
<li>任务的依赖性，是否依赖其他资源，可以设置较长等待时间</li>
</ul>
<blockquote>
<p>CPU密集型，应配置尽量小 的线程，例如CPU+1。IO密集型应配置尽量多的线程2CPU。混合型任务则可以拆分任务，<code>Runtime.getRunTime().availableProcessors()</code>获取当前设备的CPU个数。</p>
<p><strong style='color:red'>使用有界队列</strong>。防止线程池不合理导致队列变大。</p>
</blockquote>
<h6 id="6-线程池的监控"><a href="#6-线程池的监控" class="headerlink" title="6. 线程池的监控"></a>6. 线程池的监控</h6><blockquote>
<p>系统中大量使用线程池，则有必要对线程池进行监控，便于出现问题时快速定位问题。</p>
<p>可以通过线程池提供的参数进行监控，具有以下属性:</p>
</blockquote>
<ul>
<li><code>taskCount</code>: 线程池需要执行的任务数量</li>
<li><code>completedTaskCount</code>: 线程池已经完成的任务数量，小于等于<code>taskCount</code>。</li>
<li><code>largestPoolSize</code>: 曾经创建过的最大线程池数量。</li>
<li><code>getPoolSize</code>:  线程池内的线程数量，线程并不会自动销毁。</li>
<li><code>getActiveCount</code>: 获取活动的线程池数</li>
</ul>
<blockquote>
<p>重写线程池的<code>beforeExecute()</code>、<code>afterExexute()</code>、<code>terminalted()</code>拓展线程池的监控。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>并发工具类</title>
    <url>/blog/2019/05/27/concurrent/8_concurrent_tools/</url>
    <content><![CDATA[<blockquote>
<p>JDK并发包中提供了几个非常有用的并发工具类。<code>CountDownLatch</code>、<code>CyclicBarrier</code>和<code>Semaphore</code>工具类提供了一种并发流程控制的手段。<code>Exchange</code>工具类则提供了在线程间交换数据的一种手段</p>
</blockquote>
<h6 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. <code>CountDownLatch</code></h6><blockquote>
<p>允许一个或者多个线程等待其他线程完成操作。</p>
<p>与<code>join()</code>方法类似，<code>join()</code>用于让当前线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，存活则让当前线程永远等待。以下是公平锁与非公平锁测试中<code>CountDownLatch</code>使用方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unFairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(unFairLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 主线程等待子线程执行结束</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            Job t = <span class="keyword">new</span> Job(lock, countDownLatch);</span><br><span class="line">            t.setName(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印线程名</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SleepUtils.second(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock by [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;],Waiting by &quot;</span> + ((ReentrantLock2) lock).getQueuedThreads());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待线程反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(list);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>CountDownLatch</code>的构造函数接收一个int类型的参数作为计数器。<code>countDown()</code>方法，计数器会减1，<code>await()</code>方法会阻塞当前线程。计数器等于0时<code>await()</code>停止阻塞当前线程。</p>
<p><strong><code>CountDownLatch</code>不可能重新初始化或者修改<code>CountDownLatch</code>对象的计数器的值</strong>。</p>
</blockquote>
<h6 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h6><ol>
<li>简介</li>
</ol>
<blockquote>
<p><code>CyclicBarrier</code>字面意思是可循环使用的屏障。其是让一组线程到达一个屏障(也可以叫做同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会解除，所有线程才会继续运行。</p>
<p><code>CycliBarrier</code>默认构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await()</code>方法通知<code>CyclicBarrier</code>我已经到达屏障，然后阻塞线程，知道所有线程到达屏障。</p>
<p><code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于线程到达屏障时，优先执行<code>barrierAction</code>方便处理复杂业务场景。</p>
</blockquote>
<ol start="2">
<li>应用场景</li>
</ol>
<blockquote>
<p><code>CyclicBarrier</code>可以用于多线程计算数据，最后合并计算结果的场景。</p>
</blockquote>
<ol start="3">
<li>与<code>CountDownLatch</code>区别</li>
</ol>
<blockquote>
<p><code>CountDownLatch</code>的计数器只能使用一次，<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置。</p>
<p><code>CyclicBarrier</code>还有一些其他方法：</p>
</blockquote>
<ul>
<li><code>getNumberWaiting()</code>获得<code>CyclicBarrier</code>阻塞的线程数量</li>
<li><code>isBroken()</code>方法用来了解阻塞线程是否被中断</li>
</ul>
<h6 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h6><blockquote>
<p><code>Semaphore</code>(信号量)是用来控制同时访问特定资源的线程数量，它通过协调各个线程以保证合理的使用公共资源。</p>
</blockquote>
<ol>
<li>应用场景</li>
</ol>
<blockquote>
<p><code>Semaphore</code>可以用作流量控制，特别是共用资源有限的应用场景，比如数据库连接。<code>Semaphore(int permits)</code>接受一个整型的数字，表示可用许可证数量。</p>
</blockquote>
<ul>
<li><code>acquire()</code>: 获取一个许可证</li>
<li><code>release()</code>: 归还一个许可证</li>
<li><code>tryAcquire()</code>: 尝试获取一个许可证</li>
<li><code>int availablePermits()</code>: 返回此信号量中当前可用许可证数</li>
<li><code>int getQueueLength</code>: 返回正在等待获取许可证的线程数</li>
<li><code>boolean hasQueuedThreads()</code>: 是否有线程正在等待获取许可证</li>
<li><code>protected protected void reducePermits()</code>: 减少reduction个许可证</li>
<li><code>protected Collection getQueuedThreads()</code>: 返回所有等待获取许可证的线程集合</li>
</ul>
<h6 id="4-Exchanger"><a href="#4-Exchanger" class="headerlink" title="4. Exchanger"></a>4. Exchanger</h6><blockquote>
<p><code>Exchanger</code>（交换站）是一个用于线程间协作的工具类。用于进行线程间的数据交换。</p>
<p><strong style='color:red'><code>Exchanger</code>可以用于遗传算法和校对工作</strong></p>
<p>若交换的两个线程有没有执行<code>exchange()</code>方法，则会一直等待</p>
<p><code>exchange(V x, long timeout, TimeUnit unit)</code>设置最大等待时长</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>原子操作类</title>
    <url>/blog/2019/05/26/concurrent/7_atomic/</url>
    <content><![CDATA[<blockquote>
<p><code>java.util.concurrent.atomic</code>包，提供了一种用法简单、性能高效、线程安全地更新一个变量的方式</p>
</blockquote>
<h5 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h5><h6 id="1-原子更新基本类型类"><a href="#1-原子更新基本类型类" class="headerlink" title="1. 原子更新基本类型类"></a>1. 原子更新基本类型类</h6><blockquote>
<p>使用原子更新基本类型，<code>Atomic</code>包提供了以下3个类</p>
</blockquote>
<ul>
<li><code>AtomicBoolean</code>: 原子更新布尔类型</li>
<li><code>AtomicInteger</code>: 原子更新整型</li>
<li><code>AtomicLong</code>: 原子更新长整型</li>
</ul>
<blockquote>
<p>以<code>AtomicInteger</code>为例，常用方法如下：</p>
</blockquote>
<ul>
<li><code>int addAndGet(int delta)</code>，以原子方式将输入的数值与实例中的值相加，并返回结果</li>
<li><code>boolean compareAndSet(int expect, int update)</code>：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值</li>
<li><code>int getAndIncrement()</code>: 以原子方式将当前值加1，并返回自增前的值</li>
<li><code>void lazySet(int newValue)</code>：最终设置值为<code>newValue</code>，但是其他线程在之后的一段时间内还是可以读取到旧的值，<a href="http://ifeve.com/how-does-atomiclong-lazyset-work/">AtomicLong.lazySet是如何工作的？</a></li>
<li><code>int getAndSet(int newValue)</code>: 以原子方式设置为<code>newValue</code>值，并返回旧值</li>
</ul>
<h6 id="2-原子更新数组"><a href="#2-原子更新数组" class="headerlink" title="2. 原子更新数组"></a>2. 原子更新数组</h6><blockquote>
<p>原子方式更新数组里的某个元素，<code>Atomic</code>包提供了3个类</p>
</blockquote>
<ul>
<li><code>AtomicIntegerArray</code>: 原子更新壮心数组里的元素</li>
<li><code>AtomicLongArray</code>: 原子更新长整型数组里的元素</li>
<li><code>AtomicReferArray</code>: 原子更新引用类型数组里的元素</li>
</ul>
<blockquote>
<p>以<code>AtomicIntegerArray</code>为例，其常用方法如下：</p>
</blockquote>
<ul>
<li><code>int addAndGet(int i, int delta)</code>: 以原子方式将输入值与索引i的数值相加</li>
<li><code>boolean compareAndSet(int i, int expect, int update)</code>:如果当前值等于预期值，则以原子方式将索引i元素设置为update值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">	<span class="comment">// 数组value通过构造方法传递给原子类，AtomicIntegerArray会将当前数组复制一份</span></span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerArray ai = <span class="keyword">new</span> AtomicIntegerArray(value);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 并不会改变value数组的值</span></span><br><span class="line">        ai.getAndSet(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(ai.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-原子更新引用类型"><a href="#3-原子更新引用类型" class="headerlink" title="3. 原子更新引用类型"></a>3. 原子更新引用类型</h6><blockquote>
<p>要原子更新多个变量，就需要使用原子更新引用类型相关类。<code>Atomic</code>包提供了以下3个类</p>
</blockquote>
<ul>
<li><code>AtomicReference</code>: 原子更新引用类型</li>
<li><code>AtomicReferenceFieldUpdater</code>: 原子更新引用类型里的字段</li>
<li><code>AtomicMarkableReference</code>: 原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是<code>AtomicMarkableReference(V initialRef, boolean initialMark)</code></li>
</ul>
<blockquote>
<p>以<code>AtomicReference</code>说明常用方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;zhangshuai&quot;</span>, <span class="number">27</span>);</span><br><span class="line">        atomicReference.set(user);</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="string">&quot;zhangshuai1&quot;</span>, <span class="number">28</span>);</span><br><span class="line">        atomicReference.compareAndSet(user, user1);</span><br><span class="line">        System.out.println(atomicReference.get().getName());</span><br><span class="line">        System.out.println(atomicReference.get().getOld());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-原子更新字段类"><a href="#4-原子更新字段类" class="headerlink" title="4. 原子更新字段类"></a>4. 原子更新字段类</h6><blockquote>
<p>当需要更新某个类里的字段时,就需要使用原子更新字段类，<code>Atomic</code>包提供了3个类进行字段更新</p>
</blockquote>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>: 原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>: 原子更新长整型字段的更新器</li>
<li><code>AtomicStampedReference</code>: 原子更新带有版本号的引用类型。该类将整数值与引用关联，可以用原子更新数据和数据的版本号，可以解决CAS操作的ABA问题</li>
</ul>
<blockquote>
<p>原子更新字段类需要两步：</p>
</blockquote>
<ul>
<li>因为原子更新字段类都是抽象类，所以每个使用的时候必须使用静态方法<code>newUpdater()</code>创建一个更新器，需要设置想要更新的类和属性。</li>
<li>更新字段必须使用<font color='red'><code>public volatile</code></font>修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, &quot;old&quot;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User zhangshuai = <span class="keyword">new</span> User(<span class="string">&quot;zhangshuai&quot;</span>, <span class="number">27</span>);</span><br><span class="line">        System.out.println(a.getAndIncrement(zhangshuai));</span><br><span class="line">        System.out.println(a.get(zhangshuai));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器与阻塞队列</title>
    <url>/blog/2019/05/26/concurrent/chapter6/6.1_concurrent_container/</url>
    <content><![CDATA[<h5 id="1-ConcurrentHashMap的实现原理与使用"><a href="#1-ConcurrentHashMap的实现原理与使用" class="headerlink" title="1.ConcurrentHashMap的实现原理与使用"></a>1.ConcurrentHashMap的实现原理与使用</h5><blockquote>
<p><code>java.util.concurrent.ConcurrentHashMap</code>是线程安全且高效的<code>HashMap</code>。</p>
</blockquote>
<h6 id="1-为什么要使用ConcurrentHashMap"><a href="#1-为什么要使用ConcurrentHashMap" class="headerlink" title="1. 为什么要使用ConcurrentHashMap"></a>1. 为什么要使用<code>ConcurrentHashMap</code></h6><blockquote>
<p>并发编程中<code>HashMap</code>可能会导致程序死循环，<code>HashTable</code>效率低下。</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> <strong>JDK 7会导致死循环，JDK 8并不会</strong></li>
</ul>
<blockquote>
<p><code>HashMap</code>线程不安全，多线程环境下，<code>HashMap</code>进行<code>put</code>操作会导致死循环，导致CPU利用率接近100%。多线程会导致<code>HashMap</code>的<code>Entry</code>链表形成环形数据结构，<code>Entry</code>的<code>next</code>节点永远不为空，就会产生死循环获取<code>Entry</code>。</p>
<p><code>Hashtable</code>效率低下。其使用<code>synchronized</code>保证线程安全。</p>
<p><code>ConcurrentHashMap</code>的锁分段技术可以有效提升并发访问率。<code>Hashtable</code>效率低下是因为其只有一把锁，导致所有线程竞争一把锁。<code>ConcurrentHashMap</code>所使用的<font style='color:red'>锁分段技术</font>，将数据分成一段一段的存储，然后每一段使用一把锁，当线程访问一段数据的时候，其他段的数据并不会被锁住，也可以被其他线程访问。</p>
</blockquote>
<h6 id="2-ConcurrentHashMap的结构"><a href="#2-ConcurrentHashMap的结构" class="headerlink" title="2. ConcurrentHashMap的结构"></a>2. <code>ConcurrentHashMap</code>的结构</h6><blockquote>
<p>通过<code>ConcurrentHashMap</code>类图分析<code>ConcurrentHashMap</code>结构。</p>
<p><code>ConcurrentHashMap</code>是由<code>Segment</code>数组结构和<code>HashEntry</code>数组结构组成。<code>Segment</code>是一种可重入锁(<code>ReentrantLock</code>)，其和<code>HashMap</code>结构类似，是一种数组和链表结构，每个<code>Segment</code>守护一个<code>HashEntry数组</code>里的额元素，对<code>HashEntry</code>数组的元素修改时，必须首先获得与它对应的<code>Segment</code>锁。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/56.jpg" alt="类图"></p>
<p><img src="https://images.effiu.cn/gitbook/concurrent/57.jpg" alt="类图"></p>
<h6 id="3-ConcurrentHashMap的初始化"><a href="#3-ConcurrentHashMap的初始化" class="headerlink" title="3. ConcurrentHashMap的初始化"></a>3. <code>ConcurrentHashMap</code>的初始化</h6><blockquote>
<p><code>ConcurrentHashMap</code>的初始化是通过<code>initialCapacity</code>、<code>loadFactor</code>、<code>concurrentLevel</code>等几个 参数完成初始化<code>Segment</code>数组、段偏移量<code>segmentShift</code>、段掩码<code>segmentMask</code>和<code>segment</code>里的<code>HashEntry</code>数组实现的。</p>
</blockquote>
<ol>
<li>初始化<code>segments</code>数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是ssize从1向左移动的次数</span></span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// segment数组长度是由ConcurrentLevel决定的</span></span><br><span class="line"><span class="comment">// 确定不小于ConcurrentLevel的最小的2的n次幂</span></span><br><span class="line"><span class="keyword">while</span> (ssize &lt; DEFAULT_CONCURRENCY_LEVEL) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确认参与散列运算的位数</span></span><br><span class="line"><span class="keyword">int</span> segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line"><span class="comment">// 散列运算的掩码</span></span><br><span class="line"><span class="keyword">int</span> segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Segment&lt;K,V&gt;[] segments = (Segment&lt;K,V&gt;[])</span><br><span class="line">    <span class="keyword">new</span> Segment&lt;?,?&gt;[DEFAULT_CONCURRENCY_LEVEL];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</span><br><span class="line">    segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(LOAD_FACTOR);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化每个<code>segment</code></li>
</ol>
<blockquote>
<p>如上代码所示，默认初始化长度为<code>DEFAULT_CONCURRENCY_LEVEL=15</code>，默认<code>loadFactor=0.75f</code></p>
</blockquote>
<h6 id="3-ConcurrentHashMap操作"><a href="#3-ConcurrentHashMap操作" class="headerlink" title="3. ConcurrentHashMap操作"></a>3. <code>ConcurrentHashMap</code>操作</h6><ul>
<li><input disabled="" type="checkbox"> <font color="red"><code>get()</code>、<code>put()</code>、<code>size()</code>源码</font>，JDK8有新变化</li>
</ul>
<h5 id="2-ConcurrentLinkedQueue"><a href="#2-ConcurrentLinkedQueue" class="headerlink" title="2. ConcurrentLinkedQueue"></a>2. <code>ConcurrentLinkedQueue</code></h5><blockquote>
<p>并发编程中有时候需要使用线程安全的队列。实现线程安全的队列有两种方式：</p>
</blockquote>
<ul>
<li>阻塞算法，使用一个(出入队列共用一把锁)或者两个锁(入队和出队使用不同的锁)</li>
<li>非阻塞算法，使用循环CAS方式实现。</li>
</ul>
<blockquote>
<p><code>ConcurrentLinkedQueue</code>是基于链接节点的无界线程安全队列，采用先进先出对节点进行排序</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> <font style='color:red'>阅读<code>ConcurrentLinkedQueue</code>源码</font></li>
</ul>
<h5 id="3-阻塞队列"><a href="#3-阻塞队列" class="headerlink" title="3. 阻塞队列"></a>3. 阻塞队列</h5><h6 id="1-什么是阻塞队列"><a href="#1-什么是阻塞队列" class="headerlink" title="1. 什么是阻塞队列"></a>1. 什么是阻塞队列</h6><blockquote>
<p>阻塞队列是一个支持两个附加操作的队列，阻塞插入和阻塞移除。</p>
</blockquote>
<ul>
<li>支持阻塞的插入方法，当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li>支持阻塞的移除方法，当队列为空时，获取元素的线程会等待队列变为非空</li>
</ul>
<blockquote>
<p>常用于生产者和消费者的场景。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值(是否插入成功)</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h6 id="2-Java里的阻塞队列"><a href="#2-Java里的阻塞队列" class="headerlink" title="2. Java里的阻塞队列"></a>2. Java里的阻塞队列</h6><ul>
<li><p><code>ArrayBlockingQueue</code></p>
<ul>
<li>由数组结构组成的有界阻塞队列</li>
<li>先进先出的原则对元素排序</li>
<li>默认情况不保证线程公平，为了保证公平，会降低吞吐量</li>
</ul>
</li>
<li><p><code>LinkedBlockingQueue</code></p>
<ul>
<li>由链表结构组成的有界阻塞队列</li>
<li>默认最大长度是<code>Integer.MAX_VALUE</code>，按照先进先出的规则进行元素排序</li>
</ul>
</li>
<li><p><code>PriorityBlockingQueue</code></p>
<ul>
<li>支持优先级排序的无界阻塞队列</li>
<li>默认采用自然顺序升序排列</li>
<li>也可以自定义<code>compareTo()</code>指定元素排序规则，也可以构造<code>PriorityBlockingQueue</code>时指定<code>Comparator</code>对元素进行排序。不能保证同优先级元素的顺序</li>
</ul>
</li>
<li><p><code>DelayQueue</code></p>
<ul>
<li><p>使用优先级队列实现的无界阻塞队列，使用<code>PriorityQueue</code>实现</p>
</li>
<li><p>队列中的元素必须实现<code>Delay</code>接口，创建元素时可以指定延迟时间。</p>
</li>
<li><p><font color='red'><code>DelayQueue</code>非常有用，有以下应用场景</font></p>
<ul>
<li>缓存系统，使用<code>DelayQueue</code>保存缓存元素的有效期，一旦成功获取表明缓存到期</li>
<li>定时任务调度，使用<code>DelayQueue</code>保存当天执行的任务和执行时间，一旦获取到任务就开始执行</li>
</ul>
</li>
<li><p>实现<code>Delay</code>接口</p>
<ul>
<li><p>在对象创建的时候，初始化基本数据，使用<code>time</code>记录当前对象延迟时间，<code>sequenceNumber</code>标识元素在队列中的先后顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomoicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ScheduleFuturnTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period)&#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="comment">// 顺序</span></span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<code>getDelay()</code>接口，返回当前元素还需要延时的时间，单位ns</p>
</li>
<li><p>实现<code>compareTo()</code>方法指定元素的顺序。</p>
</li>
</ul>
</li>
<li><p>实现延时阻塞队列，获取元素方法(<code>take()</code>、<code>poll()</code>)部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> q.poll();</span><br><span class="line">first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line"><span class="comment">// leader是等待获取队列头元素的线程</span></span><br><span class="line"><span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 说明已经有其他线程等待获取队列头元素</span></span><br><span class="line">    available.await();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Thread thisThread = Thread.currentThread();</span><br><span class="line">    leader = thisThread;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待接收信号或者delay时间</span></span><br><span class="line">        available.awaitNanos(delay);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>SynchronousQueue</code></p>
<ul>
<li>不存储元素的阻塞队列，每个<code>put()</code>都必须等待<code>take()</code>操作，否则不能继续添加元素</li>
<li>支持公平访问，默认情况下采用非公平策略访问队列</li>
<li>其吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code></li>
</ul>
</li>
<li><p><code>LinkedTransferQueue</code></p>
<ul>
<li>由链表结构组成的无界阻塞队列</li>
<li>多个<code>tryTransfer()</code>和<code>transfer()</code>方法<ul>
<li><code>transfer()</code>，如果当前消费者正在等待接收元素，<code>transfer</code>可以把生产者传入的元素立刻<code>transfer</code>给消费者，若没有消费者则将元素放在队列的tail节点，并等待该元素被消费了才返回</li>
<li><code>tryTransfer()</code>，是用来试探生产者传入的元素是否能直接传给消费者。支持超时返回。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>LinkedBlockingDeque</code>：由链表结构组成的双向阻塞队列</p>
</li>
</ul>
<h6 id="3-阻塞队列的实现原理"><a href="#3-阻塞队列的实现原理" class="headerlink" title="3. 阻塞队列的实现原理"></a>3. 阻塞队列的实现原理</h6><blockquote>
<p>阻塞队列是使用<font color='red'>通知模式实现</font>，基本原理如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork/Join</title>
    <url>/blog/2019/05/26/concurrent/chapter6/6.2_fork_join/</url>
    <content><![CDATA[<h5 id="4-Frok-Join框架"><a href="#4-Frok-Join框架" class="headerlink" title="4. Frok/Join框架"></a>4. Frok/Join框架</h5><blockquote>
<p>Fork/Join的基本原理、算法、设计方式、应用与实现</p>
</blockquote>
<h6 id="1-Fork-Join框架"><a href="#1-Fork-Join框架" class="headerlink" title="1. Fork/Join框架"></a>1. Fork/Join框架</h6><blockquote>
<p>是一个并行执行任务的框架，把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/58.jpg" alt="运行流程图"></p>
<h6 id="2-工作窃取算法"><a href="#2-工作窃取算法" class="headerlink" title="2. 工作窃取算法"></a>2. 工作窃取算法</h6><blockquote>
<p>工作窃取算法是指某个线程从其他队列里窃取任务来执行</p>
</blockquote>
<ul>
<li><strong>优先</strong>：充分利用线程进行并行计算，减少了线程之间的竞争</li>
<li>缺点：当双端队列只存在一个任务时，扔存在竞争，此时会消耗更多系统资源。例如，多个双端队列和多个线程。</li>
<li><strong>缺点</strong>：当双端队列只存在一个任务时，扔存在竞争，此时会消耗更多系统资源。例如，多个双端队列和多个线程。</li>
</ul>
<h6 id="3-Fork-Join-框架的设计"><a href="#3-Fork-Join-框架的设计" class="headerlink" title="3. Fork/Join 框架的设计"></a>3. Fork/Join 框架的设计</h6><ol>
<li><font color='red'>分割任务</font>，有一个fork类把大任务分割成小任务，若小任务仍然很大，则可以继续分割</li>
<li><font color='red'>执行任务并合并结果</font>，子任务分别放在双端队列里，然后启动几个线程分别从双端队列里获取任务执行。子任务执行结果统一放到一个队列里，启动一个线程从队列里拿数据，合并结果</li>
</ol>
<blockquote>
<p><code>ForkJoinTask</code>，使用<code>ForkJoin</code>框架，必须要创建一个<code>ForkJoin</code>任务。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制。<code>Fork/Join</code>框架有两个子类</p>
</blockquote>
<ul>
<li><code>RecursiveAction</code>: 用于没有返回结果的任务</li>
<li><code>RecursiveTask</code>: 用于有返回结果的任务</li>
</ul>
<blockquote>
<p><code>ForkJoinPool</code>：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行，任务分割出的子任务会添加到当前线程所维护的双端队列中，进入队列的头部，当一个工作线程队列里暂时没有任务使，它会随机从其他工作线程的队列尾部获取一个任务。</p>
</blockquote>
<h6 id="4-使用-Fork-Join-框架"><a href="#4-使用-Fork-Join-框架" class="headerlink" title="4. 使用 Fork/Join 框架"></a>4. 使用 Fork/Join 框架</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断任务是否足够小</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续拆分任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;任务拆分:start:&quot;</span> + start + <span class="string">&quot;,middle:&quot;</span> + middle + <span class="string">&quot;,end:&quot;</span> + end);</span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            sum = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        <span class="keyword">if</span> (task.isCompletedAbnormally())&#123;</span><br><span class="line">            System.out.println(task.getException());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5-Fork-Join-框架的异常处理"><a href="#5-Fork-Join-框架的异常处理" class="headerlink" title="5. Fork/Join 框架的异常处理"></a>5. Fork/Join 框架的异常处理</h6><blockquote>
<p><code>ForkJoinTask</code>在执行的时候会抛出异常，但是没办法在主线程捕获异常，所以提供了<code>isCompletedAbnormally()</code>方法检查任务是否已经抛出异常或已经被取消，且可以通过<code>ForkJoinTask</code>的<code>getException()</code>方法获取异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line"><span class="keyword">if</span> (task.isCompletedAbnormally())&#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="6-Fork-Join-框架的实现原理"><a href="#6-Fork-Join-框架的实现原理" class="headerlink" title="6. Fork/Join 框架的实现原理"></a>6. Fork/Join 框架的实现原理</h6><blockquote>
<p><code>ForkJoinPool</code>由<code>ForkJoinTasks</code>数组和<code>ForkJoinWorkerThread</code>数组组成，<code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>的任务，而<code>ForkJoinWorkerTrhead</code>数组负责执行这些任务</p>
</blockquote>
<ol>
<li><code>ForkJoinTask</code>的<code>fork</code>方法实现原理</li>
</ol>
<ul>
<li><input disabled="" type="checkbox"> 阅读jdk8源码</li>
</ul>
<blockquote>
<p>任务有四种状态</p>
</blockquote>
<ul>
<li>已完成(NORMAL)</li>
<li>被取消(CANCELLED)</li>
<li>信号(SIGNAL)</li>
<li>出现异常(EXCEPTIONAL)</li>
</ul>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>双重检查锁定与延迟初始化</title>
    <url>/blog/2019/05/22/concurrent/chapter3/3.8_delay_initialization/</url>
    <content><![CDATA[<blockquote>
<p>在Java多线程中有时候需要采用<strong>延迟初始化</strong>来降低初始化类和创建对象的开销。<strong>双重检查锁定</strong>是常见的延迟初始化技术。但这是一个错误的用法。</p>
</blockquote>
<h6 id="1-双重检查锁定"><a href="#1-双重检查锁定" class="headerlink" title="1. 双重检查锁定"></a>1. 双重检查锁定</h6><blockquote>
<p>Java程序中，有时候会需要推迟一些高开销的对象初始化操作，只有在使用这些对象时才需要初始化，此时就可以采用延迟初始化，正确使用线程安全的延迟初始化需要一些技巧，否则很容易出问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;                          <span class="comment">// 1: A线程执行</span></span><br><span class="line">            instance = <span class="keyword">new</span> String(<span class="string">&quot;initialization&quot;</span>);    <span class="comment">// 2: B线程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述非线程安全实例中，线程A可能会看到未完成初始化的实例<code>instance</code>(2会解释出现的原因)。一种办法是对<code>getInstance()</code>做同步处理<code>public synchronized static String getInstance()</code>，<code>synchronized</code>将导致性能开销，若该方法被多个线程频繁调用，将会导致执行性能的下降。当不会被多个线程频繁调用时，该方案可行。</p>
</blockquote>
<blockquote>
<p>因为<code>synchroinzed</code>存在巨大的性能开销，所以有了**双重检查锁定(Double-Check Lock)**，以此来降低同步的开销。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLocking</span> </span>&#123;                                   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String instance;                                 <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInstance</span><span class="params">()</span></span>&#123;                             <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;                                      <span class="comment">// 4: 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLocking.class)&#123;                // <span class="number">5</span>：加锁</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;                              <span class="comment">// 6: 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> String(<span class="string">&quot;initialization&quot;</span>);<span class="comment">// 7: 问题的根源出在这里</span></span><br><span class="line">                &#125;                                                   <span class="comment">// 8</span></span><br><span class="line">            &#125;                                                       <span class="comment">// 9</span></span><br><span class="line">        &#125;                                                           <span class="comment">// 10</span></span><br><span class="line">        <span class="keyword">return</span> instance;                                            <span class="comment">// 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个<code>if</code>判断检查<code>instance</code>，若不为null，则不需要执行加锁和初始化操作。可以大幅降低<code>synchronized</code>带来的性能开销。有以下好处：</p>
</blockquote>
<ul>
<li>多线程试图在同一时间创建对象时，通过加锁来保证只有一个线程创建对象</li>
<li>对象创建之后，<code>getInstance()</code>也不需要获取锁</li>
</ul>
<blockquote>
<p>当代码执行到第4行，代码读取到<code>instance</code>不为null时，<code>instance</code>引用的对象可能还没有完成初始化</p>
</blockquote>
<h6 id="2-问题的根源"><a href="#2-问题的根源" class="headerlink" title="2. 问题的根源"></a>2. 问题的根源</h6><blockquote>
<p>代码<code>instance = new String(&quot;initialization&quot;);</code>创建了一个对象。可以分解为3步伪代码：</p>
</blockquote>
<ul>
<li><code>memory = allocate();</code>    // 1：分配对象内存空间</li>
<li><code>ctorInstance(memory);</code> // 2：初始化对象</li>
<li><code>instance = memory;</code>       // 3：设置instance指向分配的内存空间</li>
</ul>
<blockquote>
<p>伪代码中，2和3之间可能会被重排序，所以<strong>执行3后对象可能扔未被初始化</strong>。</p>
</blockquote>
<blockquote>
<p><strong>《The Java Language Specification，Java SE 7 Edition》</strong>中规定，所有线程在执行Java程序时必须要遵守<code>intra-thread semantics</code>。<code>intra-thread semantics</code>保证重排序不会改变单线程内的程序执行结果。即<strong>允许单线程内不会改变程序执行结果的重排序</strong>。</p>
</blockquote>
<blockquote>
<p>多线程并发的情况见下图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/29.jpg" alt="多线程执行时序图"></p>
<blockquote>
<p>当多线程执行时，<strong>双重检查机制</strong>可能会出现如上情况，B线程看到一个未被初始化的对象。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td>A1：分配对象内存空间</td>
<td></td>
</tr>
<tr>
<td align="center">t2</td>
<td>A3：设置<code>instance</code>指向内存空间</td>
<td></td>
</tr>
<tr>
<td align="center">t3</td>
<td></td>
<td>B1：判断<code>instance</code>是否为空</td>
</tr>
<tr>
<td align="center">t4</td>
<td></td>
<td>B2：未初始化所以不为null，线程B访问<code>instance</code>引用对象</td>
</tr>
<tr>
<td align="center">t5</td>
<td>A2：初始化对象</td>
<td></td>
</tr>
<tr>
<td align="center">t6</td>
<td>A4：访问<code>instance</code>引用的对象</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>A2和A3重排序了，<code>intra-thread semantics</code>确保A2会在A4之前执行。但是不能保证线程B在B1处判断出<code>instance</code>不为空，所以线程B可能会访问到一个未初始化的对象，有以下<strong>两种解决方案实现线程安全的延迟初始化</strong>：</p>
</blockquote>
<ul>
<li>不允许2和3的重排序</li>
<li>允许2和3重排序，但不允许被其他线程可见</li>
</ul>
<h6 id="3-基于volatile-的解决方案"><a href="#3-基于volatile-的解决方案" class="headerlink" title="3. 基于volatile 的解决方案"></a>3. 基于<code>volatile</code> 的解决方案</h6><blockquote>
<p><code>public volatile static String instance;</code>，<code>instance</code>成员用<code>volatile</code>修饰就可以实现线程安全的延迟初始化，需要JDK 5或者更高版本。当声明为<code>volatile</code>后，3行伪代码中的2和3的重排序，在多线程环境中会被禁止。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/30.jpg" alt="多线程执行时序图"></p>
<blockquote>
<p>本质上是通过禁止伪代码2和3排序实现的。</p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> 为什么<code>volatile</code>可以禁止2和3重排序？</li>
</ul>
<h6 id="4-基于类初始化的解决方案"><a href="#4-基于类初始化的解决方案" class="headerlink" title="4. 基于类初始化的解决方案"></a>4. 基于类初始化的解决方案</h6><blockquote>
<p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在初始化期间，JVM会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化。基于这个特性，实现另一种线程安全的延迟初始化加载方案(<strong>Initialization On Demand Holder idiom</strong>)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String instance = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;     <span class="comment">// 此处会导致InstanceHolder类被初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设两个线程并发执行<code>getInstance()</code>方法，首次执行<code>getInstance()</code>方法的线程将导致<code>InstanceHolder</code>被初始化，如下是执行示意图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/31.jpg" alt="多线程并发执行"></p>
<blockquote>
<p>实质就是，<strong>允许创建对象3步中的2和3重排序，但是不允许非构造线程看到这个重排序</strong>。初始化类，包括执行这个类的静态初始化和初始化在这个类中声明的静态字段。根据Java语言规范，首次发生以下任意情况时，类或者接口类型T将被立即初始化。</p>
</blockquote>
<ul>
<li>T是一个类，且一个T类型的实例被创建</li>
<li>T是一个类，且T中声明的一个静态方法被调用</li>
<li>T中声明的一个静态字段被赋值</li>
<li>T中声明的静态字段被使用，且这个字段不是一个常量字段</li>
<li>T是一个顶级类(Top Level Class)，且一个断言语句嵌套在T内部被执行</li>
</ul>
<blockquote>
<p>Java语言是多线程的，多个线程可能在同一时刻尝试初始化同一个类或接口，所以Java中初始化一个类或接口时，需要做细致的同步处理。</p>
</blockquote>
<blockquote>
<p><strong>Java语言规范规定</strong>，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程<strong>至少获取一次</strong>保证这个类已经被初始化完成。</p>
</blockquote>
<blockquote>
<p>Java初始化一个类或者接口的处理过程如下（<strong>省略了与多线程无关的部分</strong>，为了更好说明初始化过程中的同步机制，把类的初始化过程分为了5个阶段）：</p>
</blockquote>
<ol>
<li>通过在<code>Class</code>对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</li>
</ol>
<p><img src="https://images.effiu.cn/gitbook/concurrent/32.jpg" alt="类初始化"></p>
<blockquote>
<p>过程如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td>A1：尝试获取Class对象的初始化锁，假设A获取到了初始化锁</td>
<td>B1：尝试获取锁，由于A获取到了锁，线程B将一直等待获取初始化锁</td>
</tr>
<tr>
<td align="center">t2</td>
<td>A2：线程A看到类为被初始化(<code>state= noInitialization</code>)，线程设置<code>state = initalizating</code></td>
<td></td>
</tr>
<tr>
<td align="center">t3</td>
<td>A3：线程A释放初始化锁</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li>线程A执行类的初始化，同时线程B在初始化锁对应的<code>condition</code>上等待。</li>
</ol>
<p><img src="https://images.effiu.cn/gitbook/concurrent/33.jpg" alt="第2阶段"></p>
<blockquote>
<p>说明如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td>A1：执行类的静态初始化和初始化类中的静态字段</td>
<td>B1：获取到初始化锁</td>
</tr>
<tr>
<td align="center">t2</td>
<td></td>
<td>B2：读取<code>state=initializing</code></td>
</tr>
<tr>
<td align="center">t3</td>
<td></td>
<td>B3：释放初始化锁</td>
</tr>
<tr>
<td align="center">t4</td>
<td></td>
<td>B4：在初始化锁的<code>condition</code>中等待</td>
</tr>
</tbody></table>
<ol start="3">
<li>线程A设置<code>state=initialized</code>，然后唤醒在<code>condition</code>中等待的所有线程</li>
</ol>
<p><img src="https://images.effiu.cn/gitbook/concurrent/34.jpg" alt="第3阶段"></p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th>线程A</th>
<th align="center">时间</th>
<th>线程A</th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td>A1：获取初始化锁</td>
<td align="center">t4</td>
<td>A4：释放锁</td>
</tr>
<tr>
<td align="center">t2</td>
<td>A2：设置<code>state=initialized</code></td>
<td align="center">t5</td>
<td>A5：线程A的初始化处理完成</td>
</tr>
<tr>
<td align="center">t3</td>
<td>A3：唤醒在<code>condition</code>中等待的所有线程</td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li>线程B结束类的初始化处理</li>
</ol>
<p><img src="https://images.effiu.cn/gitbook/concurrent/35.jpg" alt="第4阶段"></p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th></th>
<th align="center">时间</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td>B1：获取初始化锁</td>
<td align="center">t3</td>
<td>B3：释放初始化锁</td>
</tr>
<tr>
<td align="center">t2</td>
<td>B2：读取<code>state=initialized</code></td>
<td align="center">t4</td>
<td>B4：线程B的类初始化完成</td>
</tr>
</tbody></table>
<blockquote>
<p>多线程执行时序图如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/36.jpg" alt="多线程执行时序图"></p>
<blockquote>
<p>线程A在第2阶段的A1执行类的初始化，在第3阶段的A4释放初始化锁；线程B在第4阶段获取了同一个初始化锁，根据Java内存模型规范的锁规则，存在如下的<code>happens-before</code>关系：线程A执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程B一定可以看到。</p>
</blockquote>
<ol start="5">
<li>线程C执行类的初始化处理</li>
</ol>
<p><img src="https://images.effiu.cn/gitbook/concurrent/37.jpg" alt="第5阶段"></p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th>线程C</th>
<th align="center">时间</th>
<th>线程C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td>C1：获取初始化锁</td>
<td align="center">t3</td>
<td>C3：释放初始化锁</td>
</tr>
<tr>
<td align="center">t2</td>
<td>C2：读取到<code>state=initialized</code></td>
<td align="center">t4</td>
<td>C4：线程C的类初始化处理过程完成</td>
</tr>
</tbody></table>
<blockquote>
<p>同上，存在如下<code>happens-before</code>关系：线程A执行类的初始化时的写入操作，线程C一定能看到。</p>
</blockquote>
<blockquote>
<p><code>condition</code>和<code>state</code>均是为了更好理解而虚构的。</p>
</blockquote>
<h6 id="5-总结："><a href="#5-总结：" class="headerlink" title="5. 总结："></a>5. 总结：</h6><blockquote>
<p>基于类的初始化方案实现代码更简单，但是基于<code>volatile</code>的双重检查锁定方案不仅仅可以对静态字段实现延迟初始化，还可以实现对实例字段的延迟初始化。</p>
</blockquote>
<blockquote>
<p>字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。</p>
<p>大多时候，正常初始化优于延迟初始化。但若需要对实例字段使用线程安全的延迟初始化，则使用<code>volatile</code>的延迟初始化方案；若需要对静态字段使用线程安全的延迟初始化，使用基于类初始化的方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>LockSupport工具与Condition接口</title>
    <url>/blog/2019/05/18/concurrent/chapter5/5.4_lockSupport_Condition/</url>
    <content><![CDATA[<h5 id="5-LockSupport工具"><a href="#5-LockSupport工具" class="headerlink" title="5. LockSupport工具"></a>5. LockSupport工具</h5><blockquote>
<p>当我们需要阻塞或者唤醒一个线程的时候，需要使用<code>java.util.concurrent.locks.LockSupport</code>来完成。<code>java.util.concurrent.locks.LockSupport</code>是构建同步组件的基础工具，其内部定义了一组公共静态方法，提供了基本的线程阻塞和唤醒功能。</p>
</blockquote>
<blockquote>
<p><code>java.util.concurrent.locks.LockSupport</code>定义了一组<code>park*</code>开头的方法用来阻塞当前线程，<code>unpark(Thread thread)</code>方法来唤醒一个被阻塞线程，方法描述见下表：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void park()</td>
<td>阻塞当前线程，需要使用<code>unpark</code>方法或者当前线程被中断，才能够从<code>park()</code>方法返回</td>
</tr>
<tr>
<td align="center">void parkNanos(long nanos)</td>
<td>阻塞当前线程，在<code>park()</code>基础上增加了超时返回</td>
</tr>
<tr>
<td align="center">void parkUntil(long deadline)</td>
<td>阻塞当前线程，直到deadline时间(1970年开始到deadline的时间毫秒数)</td>
</tr>
<tr>
<td align="center">void unpark(Thread thread)</td>
<td>唤醒处于阻塞状态的线程</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Java 6</strong>中增加了以下3个方法，用来展示阻塞对象blocker，代码片段和线程dump，便于开发定位问题</p>
</blockquote>
<ul>
<li><code>void park(Object blocker);</code></li>
<li><code>void parkNanos(Object blocker, long nanos);</code></li>
<li><code>void parkUntil(Object blocker, long deadline);</code></li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/51.jpg" alt="Blocker在线程dump中的作用"></p>
<h5 id="6-Condition接口"><a href="#6-Condition接口" class="headerlink" title="6. Condition接口"></a>6. Condition接口</h5><blockquote>
<p>任意一个Java对象都有一组监视器方法(在Java.lang.Object上)，主要包括<code>wait()</code>、<code>wait(long timeout)</code>、<code>notify()</code>和<code>notifyAll()</code>方法，与<code>synchronized</code>配合，可以实现<strong>等待/通知</strong>模式。</p>
<p><code>Condition</code>接口也有监视器方法，与<code>Lock</code>配合可以实现<strong>等待/通知</strong>模式。以下是对比<strong>Object</strong>的监视器方法和<code>Condition</code>接口：</p>
</blockquote>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Object Monitor Methods</th>
<th>Condition</th>
</tr>
</thead>
<tbody><tr>
<td>前置条件</td>
<td>获取对象的锁</td>
<td>调用<code>Lock.lock()</code>获取锁，<code>Lock.newCondition()</code>获取<code>Condition</code>对象</td>
</tr>
<tr>
<td>调用方式</td>
<td><code>object.wait</code></td>
<td><code>condition.await()</code></td>
</tr>
<tr>
<td>等待队列个数</td>
<td>一个</td>
<td>多个</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态且不响应中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入超时等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁进入超时等待状态到将来某个时间</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的一个线程</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的全部线程</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h6 id="1-Condition接口与示例"><a href="#1-Condition接口与示例" class="headerlink" title="1.Condition接口与示例"></a>1.<code>Condition</code>接口与示例</h6><blockquote>
<p><code>Condition</code>定义了<strong>等待/通知</strong>两种类型的方法，调用前需要先获取到<code>Condition</code>对象的关联锁。<code>Condition</code>是由<code>Lock</code>对象创建的。其使用方式如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionUseCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Condition对象关联的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由Lock对象创建Condition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionAwait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程会释放锁，并在此等待</span></span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// signal()方法通知等待队列中其他线程</span></span><br><span class="line">            <span class="comment">// 一个Condition对应一个等待队列</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Condition</code>部分方法以及描述</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void await() throws InterruptedException</td>
<td>当前线程进入等待状态直到被通知(signal)或者中断，当前线程进入运行状态且从<code>await()</code>方法返回的情况：<br />其他线程调用<code>Condition</code>的<code>signal()</code>或<code>signalAll()</code>方法，而当前线程被选中唤醒<br />- 其他线程(调用interrupt方法)中断当前线程<br />- 如果当前等待线程从<code>await()</code>方法返回，那么表明该线程已经获取了<code>Condition</code>对象对应的锁</td>
</tr>
<tr>
<td>void awaitUninterruptibly()</td>
<td>当现场进入等待状态知道被通知，对中断不敏感</td>
</tr>
<tr>
<td>long awaitNanos(long nanosTimeout) throws InterruptedException</td>
<td>线程进入等待状态直到被通知、中断或超时。返回值是剩余的超时时间，0或者负数表示超时</td>
</tr>
<tr>
<td>boolean await(long time, TimeUnit unit) throws InterruptedException</td>
<td>线程进入等待状态直到被通知、中断或者到某个时间。如果没有到指定时间就被通知，返回true，否则返回false</td>
</tr>
<tr>
<td>void signal()</td>
<td>唤醒一个等待在<code>Condition</code>上的线程，该线程从等待方法返回前，必须获取<code>Condition</code>相关联的锁</td>
</tr>
<tr>
<td>void signalAll()</td>
<td>唤醒所有等待在<code>Condition</code>上的线程，能够从等待方法返回的线程必须获取<code>Condition</code>相关联的锁</td>
</tr>
</tbody></table>
<blockquote>
<p>有界队列是一种特殊的队列，当队列为空时，队列获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现空位，如下代码所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加的下标，删除的下标，数组当前数量，默认均为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex, removeIndex, count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未满通知，维护一个等待队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非空通知，维护一个等待队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素，维护添加下标，count</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 首先要获取锁，保证数组修改的排他性和可见性</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// while循环可以防止，过早或者意外的通知，只有当count!=items.length时才退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                <span class="comment">// 未满等待队列，等待通知（需要当前线程持有锁）</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            items[addIndex++] = t;</span><br><span class="line">            <span class="keyword">if</span> (addIndex == items.length) &#123;</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 非空等待队列通知</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object item = items[removeIndex];</span><br><span class="line">            <span class="comment">// 移除后置空，用于gc回收</span></span><br><span class="line">            items[removeIndex++] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (removeIndex &gt;= items.length) &#123;</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> (T) item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-Condition实现分析"><a href="#2-Condition实现分析" class="headerlink" title="2. Condition实现分析"></a>2. <code>Condition</code>实现分析</h6><blockquote>
<p><code>ConditionObject</code>是<code>AbstractQueuedSynchronizer</code>内部类，<code>Condition</code>操作需要获取相关联的锁，每个<code>Condition</code>对象都包含着一个<strong>等待队列</strong>，该队列是<strong>等待/通知</strong>功能的关键</p>
</blockquote>
<ol>
<li>等待队列</li>
</ol>
<blockquote>
<p>等待队列是一个<strong>FIFO</strong>队列，队列中每个节点都包含一个线程引用，该线程就是在<code>Condition</code>上等待的线程，<code>Condition.await()</code>方法会使该线程释放锁、构造成节点加入到等待队列中进入等待状态。实际上，同步队列和等待队列中节点类型都是同步器的静态内部类<code>AbstractQueuedSynchronizer.Node</code>。</p>
<p>一个<code>Condition</code>包含一个等待队列，<code>Condition</code>包含首节点和尾节点，<code>Condition.await()</code>会将线程构造成节点放入到尾节点，进入等待状态。新增节点只需要，将尾节点的nextWaiter指向新增节点，更新<code>Condition</code>的<code>lastWaiter</code>即可。调用<code>await()</code>的线程必定持有锁，同时也保证了线程安全以及等待队列的线程安全</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/52.jpg" alt="等待队列结构"></p>
<blockquote>
<p><code>Lock</code>可以有多个<code>Condition</code>，所以可以存在多个等待队列，即拥有一个同步队列和多个等待队列。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/53.jpg" alt="等待队列结构"></p>
<ol start="2">
<li>等待</li>
</ol>
<blockquote>
<p><code>Condition.await()</code>会使线程进入等待队列并释放锁、线程状态变为等待状态，当从<code>await()</code>返回时，线程一定重新获得了锁。当调用<code>await()</code>方法时，线程从同步队列的首节点，进入到等待队列的尾节点。如下代码所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 当前线程加入到Condition的等待队列、释放锁、构建节点、改变线程状态</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放同步状态</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 条件是当前在等待队列中的节点是否正在等待重新获取锁，是则返回true</span></span><br><span class="line">    <span class="comment">// 调用signal()后，会将当前节点移出到同步队列中，所以该判断返回true</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 若没有等待重新获取锁，阻塞当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该线程已经获得了锁，且是同步队列的首节点，<strong>将当前线程构造成节点加入到等待队列的尾节点，然后释放锁，唤醒同步队列的后继节点，然后当前线程进入等待状态</strong>。</p>
<p>当等待队列中的节点被唤醒，则节点加入到同步队列中，并开始尝试获取同步状态。若节点是通过中断唤醒，则会抛出<code>InterruptException</code>异常。<font style='color:red'><strong>同步队列首节点加入到等待队列尾节点</strong></font>，见下图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/54.jpg" alt="当前线程加入到等待队列"></p>
<ol start="3">
<li>通知</li>
</ol>
<blockquote>
<p><code>Condition.signal()</code>方法，唤醒在等待队列中时间最长的节点(首节点)，唤醒之前会将节点移动到同步队列中。前置条件是当前线程获取到锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程是否获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 等待队列中的首节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 移动到同步队列中，使用LockSupport.unpark唤醒节点中的线程</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.effiu.cn/gitbook/concurrent/55.jpg" alt="节点从等待队列移动到同步队列"></p>
<blockquote>
<p><code>enq(Node node)</code>方法将等待队列的头节点线程安全地移动到同步队列，再使用<code>LockSupport.unpark(Thread thread)</code>唤醒该节点的线程。被唤醒的线程从<code>await()</code>的for循环中退出，调用同步器的<code>acquiredQueued()</code>方法加入到获取同步状态的竞争中。</p>
</blockquote>
<blockquote>
<p><code>signalAll()</code>方法，相当于将等待队列中的所有线程加入到同步队列中，并唤醒所有节点的线程。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>重入锁与读写锁</title>
    <url>/blog/2019/05/16/concurrent/chapter5/5.3_reetrant_readwrite/</url>
    <content><![CDATA[<h5 id="3-重入锁"><a href="#3-重入锁" class="headerlink" title="3. 重入锁"></a>3. 重入锁</h5><blockquote>
<p>重入锁(<code>ReentrantLock</code>)，就是支持线程重进入锁。表示该锁能够支持一个线程对资源的重复加锁。还支持获取锁时的公平锁和非公平选择。<code>synchronized</code>关键字隐式的支持重进入。</p>
<p><code>ReentrantLock</code>在调用<code>lock()</code>方法时，已经获取到锁的线程，允许再次调用<code>lock()</code>方法获取锁而不被阻塞。</p>
<p>公平锁指的是在绝对时间上，先对锁进行获取的请求一定先被满足，即按照同步队列的FIFO规则获取锁。<strong>公平锁效率比非公平锁效率低</strong>，因为公平锁的上下文切换频率高，造成了更大的系统开销，但是公平锁可以减少“饥饿”发生的概率。</p>
<p><code>ReentrantLock</code>实现重进入和公平性获取锁的特性如下：</p>
</blockquote>
<ul>
<li>实现重进入要满足以下两点<ul>
<li>线程再次获取到锁，即识别获取锁的线程是否是当前占有锁的线程</li>
<li>锁的最终释放，重复n次获取锁，那么需要n次释放，<code>ReentrantLock</code>使用计数表示当前锁被重复获取的次数，n=0表示锁已成功释放</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>ReentrantLock</code>是通过自定义同步器实现锁的获取与释放，以下是非公平实现：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 锁已释放逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS操作获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 设置持有锁线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前锁被持有，则比较持有锁线程与当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 重入成功则通过增加同步状态值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// c == 0，则表示当前锁已被完全释放</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 持有锁线程设置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>公平与非公平锁的区别</li>
</ul>
<blockquote>
<p>以下是公平锁实现：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 在获取锁时需要判断当前线程在同步队列中是否有前驱节点，若存在则说明前驱线程应该要比当前线程更早持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以下通过一个测试用例观察测试公平锁与非公平锁的区别：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfairTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock fairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock unFairLock = <span class="keyword">new</span> ReentrantLock2(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(fairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testLock(unFairLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 主线程等待子线程执行结束</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            Job t = <span class="keyword">new</span> Job(lock, countDownLatch);</span><br><span class="line">            t.setName(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Lock lock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(Lock lock, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印线程名</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过睡眠保证同步队列顺序</span></span><br><span class="line">                    SleepUtils.second(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock by [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;],Waiting by &quot;</span> + ((ReentrantLock2) lock).getQueuedThreads());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待线程反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock2</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock2</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            List&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">super</span>.getQueuedThreads());</span><br><span class="line">            Collections.reverse(list);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以下是输出结果，非公平锁与公平锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock by [<span class="number">1</span>],Waiting by [<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">Lock by [<span class="number">1</span>],Waiting by [<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">Lock by [<span class="number">0</span>],Waiting by [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">Lock by [<span class="number">0</span>],Waiting by [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">Lock by [<span class="number">3</span>],Waiting by [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">Lock by [<span class="number">3</span>],Waiting by [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">Lock by [<span class="number">2</span>],Waiting by [<span class="number">4</span>]</span><br><span class="line">Lock by [<span class="number">2</span>],Waiting by [<span class="number">4</span>]</span><br><span class="line">Lock by [<span class="number">4</span>],Waiting by []</span><br><span class="line">Lock by [<span class="number">4</span>],Waiting by []</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lock by [1],Waiting by [0, 2, 3, 4]</span><br><span class="line">Lock by [0],Waiting by [2, 3, 4, 1]</span><br><span class="line">Lock by [2],Waiting by [3, 4, 1, 0]</span><br><span class="line">Lock by [3],Waiting by [4, 1, 0, 2]</span><br><span class="line">Lock by [4],Waiting by [1, 0, 2, 3]</span><br><span class="line">Lock by [1],Waiting by [0, 2, 3, 4]</span><br><span class="line">Lock by [0],Waiting by [2, 3, 4]</span><br><span class="line">Lock by [2],Waiting by [3, 4]</span><br><span class="line">Lock by [3],Waiting by [4]</span><br><span class="line">Lock by [4],Waiting by []</span><br></pre></td></tr></table></figure>

<blockquote>
<p>非公平锁出现连续获取的情况，说明当一个请求获取锁时，相同线程再次获取锁的概率非常大，其他线程只能在同步队列中等待。</p>
<p>非公平锁会可能使线程”饥饿”，但极少的线程切换，保证了其更大的吞吐量。公平锁保证了锁获取安装FIFO原则，代价是进行大量的线程切换。</p>
</blockquote>
<h5 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4. 读写锁"></a>4. 读写锁</h5><blockquote>
<p>同一时刻只允许一个线程访问，这种锁属于排他锁。读写锁在同一时刻可以允许多个读线程访问，但在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁（读锁和写锁）。<strong>读写锁保证了写操作对读操作的可见性</strong>，还简化了读写交互场景。</p>
<p>写锁被获取到后，所有后续非当前线程的读写操作均被阻塞，当写锁释放后，其他线程的操作才能继续执行。一般情况下，读写锁比排他锁好，因为大多数读场景多于写，具有更好的并发量和吞吐量。Java提供的读写锁是<code>java.util.concurrent.locks.ReentrantReadWriteLock</code>。其特性见下图表：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">公平性选择</td>
<td>支持非公平(默认)和公平的锁获取方式，吞吐量非公平由于公平</td>
</tr>
<tr>
<td align="center">重进入</td>
<td>支持重入，读线程获取锁之后，能够再次获取读锁。写线程获取写锁之后可以再次获取读锁写锁</td>
</tr>
<tr>
<td align="center">锁降级</td>
<td>遵循获取写锁、获取读锁再释放写锁的次序，写锁降级为读锁（其他线程不会立即获取写锁）</td>
</tr>
</tbody></table>
<h6 id="1-读写锁接口"><a href="#1-读写锁接口" class="headerlink" title="1. 读写锁接口"></a>1. 读写锁接口</h6><blockquote>
<p><code>java.util.concurrent.locks.ReadWriteLock</code>定义了读锁和写锁的两个方法，即<code>readLock()</code>和<code>writeLock()</code>方法。<code>java.util.concurrent.locks.ReentrantReadWriteLock</code>还提供了一些用于监控内部工作状态的方法。见下表：</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int getReadLockCount()</td>
<td>返回当前锁被获取的次数。因为可以重复获取锁，所以不等于读锁的线程数</td>
</tr>
<tr>
<td>int getReadHoldCount()</td>
<td>返回当前线程获取读锁的次数。使用<code>ThreadLocal</code>保存次数</td>
</tr>
<tr>
<td>boolean isWriteLocked()</td>
<td>判断写锁是否被获取</td>
</tr>
<tr>
<td>int getWriteHoldCount()</td>
<td>返回当前线程写锁被获取的次数(只能有一个线程获取写锁)</td>
</tr>
</tbody></table>
<h6 id="2-读写锁实现分析"><a href="#2-读写锁实现分析" class="headerlink" title="2. 读写锁实现分析"></a>2. 读写锁实现分析</h6><blockquote>
<p><code>java.util.concurrent.locks.ReentrantReadWriteLock</code>实现：读写状态的设计、写锁的获取与释放、读锁的获取与释放以及锁降级。</p>
</blockquote>
<ol>
<li>读写状态设计</li>
</ol>
<blockquote>
<p>读写锁的自定义同步器需要在同步状态上维护多个读线程和一个写线程状态，所以需要“按位切割使用“这个状态变量，高16位表示读，低16位表示写。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/50.jpg" alt="读写锁切割方式"></p>
<blockquote>
<p>使用<strong>位运算</strong>获取当前读和写各种的状态。假设同步状态为S，那么S &amp; 0000FFFF，按位与运算将高位抹去即写状态。读状态等于S&gt;&gt;&gt;16（无符号补0右移）。写状态增加即S+1，读状态增加即S+(1&lt;&lt;16)。</p>
</blockquote>
<ol start="2">
<li>写锁的获取与释放</li>
</ol>
<blockquote>
<p>写锁是支持重进入的排他锁。见代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 按位与运算，抹去高16位，即写状态</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// c!=0 &amp;&amp; w==0，即状态非0，写锁状态为0，则说明当前读状态非0，进入等待状态</span></span><br><span class="line">        <span class="comment">// 写锁支持重入，所以持有写锁的线程非当前线程，进入等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要判断当前读锁释放存在，存在读锁则写锁不能获取。因为需要保证写锁操作对读锁的可见性，允许读锁存在时获取写锁，那么其他读线程无法感知到写线程的操作。写锁的释放操作与<code>ReentrantLock</code>基本类似。</p>
</blockquote>
<ol start="3">
<li>读锁的获取与释放</li>
</ol>
<blockquote>
<p>读锁支持重入的共享锁。但是当前线程获取读锁时，若写锁已被其他线程获取，则进入等待状态。简化代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">    		<span class="comment">// 写锁被其他线程获取，则进入等待状态</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    		<span class="comment">// 当前读锁数量</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT </span><br><span class="line">                	&amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">// 一些为了监控内部状态的操作</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>锁降级</li>
</ol>
<blockquote>
<p><strong>锁降级</strong>，值的是写锁降级为读锁。即把持住当前拥有的写锁，再获取到读锁，随后是否写锁的过程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlock();</span><br><span class="line">        <span class="comment">// 锁降级从写锁获取到开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            	<span class="comment">// 准备数据的流程（略）</span></span><br><span class="line">            	update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用数据的流程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，<code>volatile update</code>，当数据变更后，<code>update</code>变量被设置为false，其他线程访问此方法会感知到变化，但是只要一个线程获取到写锁，其他线程会被阻塞在读锁或写锁的<code>lock()</code>方法上。当前线程获取写锁完成后再次获取读锁，随后释放写锁，完成锁降级。</p>
<p>锁降级中，写锁释放之前获取读锁是为了保证其他写线程不会感知不到写操作。</p>
<p><code>ReentrantReadWriteLock</code>不支持锁升级（获取读锁、获取写锁、是否读锁的过程）。因为锁升级过程不能保证可见性，读锁已被多个线程获取，获取写锁后，其他线程感知不到写锁的操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>队列同步器</title>
    <url>/blog/2019/05/12/concurrent/chapter5/5.2_AQS_analysis/</url>
    <content><![CDATA[<h6 id="2-2-AQS分析"><a href="#2-2-AQS分析" class="headerlink" title="2.2 AQS分析"></a>2.2 AQS分析</h6><blockquote>
<p>从实现角度分析同步器是如何完成线程同步的，包括同步队列、独占式同步状态获取与释放、共享式同步状态获取与释放、超时获取同步状态等同步器核心数据结构与模板方法。</p>
</blockquote>
<ol>
<li><p>同步队列</p>
<blockquote>
<p><strong>同步器依赖内部的同步队列(FIFO的双向队列)完成同步状态的管理</strong>，线程获取同步状态失败时，同步器会将当前线程以及等待状态信息构造成一个节点(<code>java.util.concurrent.locks.AbstractQueuedSynchronizer.Node</code>)并将其加入到等待队列，阻塞当前线程，同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p>
<p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer.Node</code>，用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。节点的属性类型与名称如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性类型与名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int waitStatus</td>
<td>等待状态，包含以下状态：<br />①<strong>CANCELLED</strong>，值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消等待，节点进入该状态将不会变化<br />②<strong>SINGAL</strong>，值为-1，后继节点的线程处于等待状态，当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行<br />③<strong>CONDITION</strong>，值为-2，节点在等待队列中，节点等待在<strong>Condition</strong>上，当其他线程对Condition调用<code>singal()</code>后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中<br />④<strong>PROPAGATE</strong>，值为-3，表示下一次共享式同步状态获取将会无条件地被传播下去<br />⑤<strong>INITIAL</strong>，值为0，初始状态</td>
</tr>
<tr>
<td>Node prev</td>
<td>前驱节点，当节点假如到同步队列时被设置</td>
</tr>
<tr>
<td>Node next</td>
<td>后继节点</td>
</tr>
<tr>
<td>Node nextWaiter</td>
<td><font style='color:red'>等待队列中的后继节点。若当前节点共享，那么这个字段将是一个SHARED常量，即节点类型(独占或者共享)和等待队列中的后继节点共用一个字段</font></td>
</tr>
<tr>
<td>Thread thread</td>
<td>获取同步状态的线程</td>
</tr>
</tbody></table>
<blockquote>
<p>节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程将会成为节点加入该队列的尾部，且这个加入队列的过程必须要求是线程安全的，所以提供了一个基于CAS的设置尾节点的方法<code>compareAndSetTail(Node expect, Node update)</code>，只有设置成功，当前节点才正式与之前的尾节点建立关联。同步队列的基本结构见下图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/44.jpg" alt="同步队列基本结构"></p>
<blockquote>
<p>节点加入到同步队列见下图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/45.jpg" alt="加入到同步对列"></p>
<blockquote>
<p>同步对列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，后续节点将在获取同步状态成功时将自己设置为首节点。过程如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/46.jpg" alt="加入到同步对列"></p>
<blockquote>
<p>设置首节点是通过同步状态成功的线程实现的，因为只会有一个线程可以成功获取同步状态，所以设置头结点的方法并不需要使用CAS保证线程安全。</p>
</blockquote>
</li>
<li><p>独占式同步状态获取与释放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法用于获取同步状态，对中断不敏感，线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。</p>
</blockquote>
<ul>
<li><code>tryAcquire(arg)</code>：同步状态获取</li>
<li><code>addWaiter(Node.EXCLUSIVE)</code>：节点构造、加入到同步等待队列</li>
<li><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>：自旋，以<strong>死循环</strong>的方式获取同步状态，当获取不到则阻塞节点中的线程时，被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</li>
</ul>
<blockquote>
<p>节点的构造以及加入同步队列代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 设置尾节点，可能会由于并发失败</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过死循环保证节点的添加</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 设置尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>compareAndSetHead(new Node())</code>方法确保节点可以被安全地添加。<code>enq(final Node node)</code>中，同步器通过<strong>死循环</strong>来保证节点的正确添加，在<strong>死循环</strong>中只有通过<strong>CAS</strong>将节点设置为尾节点后，当前线程才能从该方法返回，否则会不断尝试，将并发中设置尾节点的操作<strong>串行化</strong>了，节点进入到同步队列之后就会进入一个<strong>自旋</strong>过程。每个节点都在通过自旋观察，满足条件后进入同步状态，从自旋中退出。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 退出自旋的条件，前驱节点是头节点且尝试获取同步状态成功(前驱节点已经释放同步状态)</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当前线程在<strong>死循环</strong>中尝试获取同步状态，只有前驱节点是头节点才能够尝试获取同步状态。</p>
</blockquote>
<ul>
<li>头节点是成功获取同步状态的节点，头节点释放同步状态之后，将会唤醒后继节点，后继节点将会检查自己的前驱节点是否是头节点</li>
<li>维护同步队列的FIFO原则。节点通过<strong>自旋</strong>获取同步状态，见下图：</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/47.jpg" alt="加入到同步对列"></p>
<blockquote>
<p>节点与节点之间不通信，而是通过简单地判断自身的前驱是否是头节点，防止过早通知线程。独占式同步状态流程，<strong>前驱节点为头节点且能够获取同步状态的判断条件和线程进入等待状态是获取同步状态的自旋过程</strong>。见下图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/48.jpg" alt="加入到同步对列"></p>
<blockquote>
<p>线程通过调用<code>release(int arg)</code>释放同步状态，且会唤醒后继节点，代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>unparkSuccessor(h)</code>方法使用<code>java.util.concurrent.locks.LockSupport</code>唤醒处于等待状态的线程。</p>
</blockquote>
<blockquote>
<p>综上所述，线程获取同步状态时，同步器维护一个同步队列，获取同步状态失败的线程会加入到队列中并进行<strong>自旋</strong>；移出队列的条件是前驱节点是头节点且成功获取了同步状态。释放同步状态时还会唤醒后继节点。</p>
</blockquote>
</li>
<li><p>共享式同步状态的获取与释放</p>
<blockquote>
<p>共享式获取与独占式获取最主要的区别是同一时刻能否有多个线程同时获取到同步状态。以读写锁为例，共享读，独占写。以下是共享式获取同步状态的代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回值大于0时表示能够获取到同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 当前节点的前驱是头节点时会尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// r&gt;0 说明获取同步状态成功，此时会退出自旋</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>共享式获取也需要释放同步状态，其<strong>与独占锁的区别</strong>是<code>tryReleaseShared(int)</code>必须确保同步状态(或资源数)安全释放，一般是通过CAS保证，因为可能是释放同步状态操作的是多个线程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>释放同步状态后将会唤醒后继节点。</p>
</blockquote>
</li>
<li><p>独占式超时获取同步状态</p>
<blockquote>
<p>同步器的<code>doAcquireNanos(int arg, long nanosTimeout)</code>方法可以超时获取同步状态，即在指定时间段内获取同步状态。</p>
<p><strong>响应中断的同步状态获取过程</strong>：一个线程获取不到锁会进入同步队列，同步器提供的<code>acquireInterruptibly(int arg)</code>方法，在等待获取同步锁时，如果线程被中断，会立刻返回，并抛出<code>InterruptedException</code></p>
<p><strong>超时获取同步状态是响应中断获取同步状态的增强版</strong>，<code>doAcquireNanos(int arg, long nanosTimeout)</code>，在支持响应式的基础上，增加了超时获取的特性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 超时截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 剩余超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// nanosTimeout &gt; 0表示超时时间未到</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>独占式超时同步状态与独占式同步获取过程类似。节点的前驱节点为头节点时尝试获取同步状态，如果获取失败则判断是否超时，若超时则线程从<code>LockSupport.parkNanos(this, nanosTimeout)</code>方法返回</p>
<p><code>nanosTimeout &lt; spinForTimeoutThreshold</code>值<code>nanosTimeout</code>小于1000ns时不会进行超时等待，而是进入快速自旋过程，为了避免超时等待中时间过短的不精确。以下是独占式超时获取同步状态的流程：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/49.jpg" alt="加入到同步对列"></p>
<blockquote>
<p>其与独占式获取同步状态的区别：未获取到同步状态时的处理逻辑，即若当前线程在nanosTimeout纳秒内无法获取到同步状态，将会从等待逻辑中自动返回。</p>
</blockquote>
</li>
<li><p>自定义同步组件——TwinsLock</p>
<ul>
<li><p>确定访问模式，允许多个线程访问，所以是共享式访问</p>
</li>
<li><p>定义资源数，两个线程，所以state=2，即0,1,2是合法值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 内部调用Sync重写的tryAcquiredShared(int 方法)</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 允许的线程数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="comment">// newCount &lt; 0 说明获取同步状态失败，</span></span><br><span class="line">                <span class="comment">// compareAndSetState(current, reduceCount) 返回true说明获取同步状态成功且newCount &gt; 0</span></span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + arg;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同步器作为一个桥梁，连接线程访问以及同步状态控制等底层技术与不同并发组件。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock接口</title>
    <url>/blog/2019/05/12/concurrent/chapter5/5.1_lock/</url>
    <content><![CDATA[<h5 id="1-锁"><a href="#1-锁" class="headerlink" title="1. 锁"></a>1. 锁</h5><blockquote>
<p>锁是用来控制多个线程访问共享资源的方式，一个锁可以防止多个线程同时访问共享资源，有些锁可以允许多个线程并发的访问共享资源，例如读写锁。</p>
<p><strong>Java SE 5</strong> 之后新增了<code>java.util.concurrent.locks.Lock</code>接口用来实现锁功能。它提供了与<code>synchronized</code>关键字类似的同步功能，但是在使用时需要显式获取和释放锁，虽然没有了隐式获取和释放锁的便捷性，但是拥有了获取与释放锁的可操作性、可中断的获取锁以及超时获取锁等多种<code>synchronized</code>没有的同步特性。其使用如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 写在try语句外面，防止获取锁时发生了异常，异常抛出后会导致锁无故释放。</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 保证获取到锁后最终能够释放</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>java.util.concurrent.locks.Lock</code>接口提供的<code>synchronized</code>不具备的特性。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">非阻塞地获取锁</td>
<td align="center">线程尝试获取锁，若此时没有线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td align="center">能被中断地获取锁</td>
<td align="center">与<code>synchronized</code>不同，获取到锁的线程能够响应中断，中断时会抛出异常并释放锁</td>
</tr>
<tr>
<td align="center">超时获取锁</td>
<td align="center">在指定时间之前获取锁，超时后放弃获取锁并返回</td>
</tr>
</tbody></table>
<blockquote>
<p><code>java.util.concurrent.locks.Lock</code>，定义了锁的获取与释放的基本操作，API如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void lock()</td>
<td>调用线程会获取锁，获取成功后返回</td>
</tr>
<tr>
<td align="center">void lockInterruptibly() throws InterruptedException</td>
<td>可中断地获取锁，锁的获取中可以中断当前线程</td>
</tr>
<tr>
<td align="center">boolean tryLock()</td>
<td>尝试非阻塞的获取锁，调用后立即返回，<strong>true</strong>则获取成功，否则返回<strong>false</strong></td>
</tr>
<tr>
<td align="center">boolean tryLock(long time, TimeUnit unit) throws InterruptedException</td>
<td>超时获取锁，以下三种情况会返回：<br />① 线程在超时时间内获取到锁<br />② 线程在超时时间内被中断<br />③ 超时时间结束，返回false</td>
</tr>
<tr>
<td align="center">void unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td align="center">Condition newCondition()</td>
<td>获取等待通知组件，和当前的锁绑定，当前线程只有获取到锁，才能调用组件的<code>wait()</code>方法，而调用后，当前线程释放锁</td>
</tr>
</tbody></table>
<h5 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2. 队列同步器"></a>2. 队列同步器</h5><blockquote>
<p>队列同步去<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>（同步器），是用来构建锁或者其他同步组件的基础框架，其内部使用了一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程的排队工作。</p>
</blockquote>
<blockquote>
<p><strong>同步器的主要使用方式是继承</strong>，子类通过继承同步器并实现其抽象方法来管理同步状态。子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，仅仅定义了若干同步状态的获取和释放的方法供自定义同步组件使用，即可以支持独占式获取同步状态，也可以支持共享式获取同步状态。</p>
</blockquote>
<blockquote>
<p><strong>同步器实现锁的关键</strong>，是在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
</blockquote>
<ul>
<li>锁是面向使用者的，定义了使用者与锁交互的接口，隐藏了实现细节</li>
<li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒底层操作。</li>
</ul>
<blockquote>
<p>锁和同步器很好地隔离了使用者和实现者所需要关注的领域。</p>
</blockquote>
<h6 id="2-1-队列同步器的接口与示例"><a href="#2-1-队列同步器的接口与示例" class="headerlink" title="2.1 队列同步器的接口与示例"></a>2.1 队列同步器的接口与示例</h6><blockquote>
<p>同步器的设计是基于模板方法模式的，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法。修改同步状态的3个方法</p>
</blockquote>
<ul>
<li><code>getState()</code>：获取当前同步状态</li>
<li><code>setState(int newState)</code>：设置当前同步状态</li>
<li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，可以保证同步状态设置的原子性。</li>
</ul>
<blockquote>
<p>同步器可重写方法如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">protected boolean tryAcquire(int arg)</td>
<td align="left">独占式获取到同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td>
</tr>
<tr>
<td align="center">protected boolean tryRelease(int arg)</td>
<td align="left">独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td align="center">protected int tryAcquireShared(int arg)</td>
<td align="left">共享式获取同步状态，返回大于0的值，说明成功，否则失败</td>
</tr>
<tr>
<td align="center">protected boolean tryReleaseShared(int arg)</td>
<td align="left">共享式获取同步状态</td>
</tr>
<tr>
<td align="center">protected boolean isHeldExclusively()</td>
<td align="left">当前同步器是否在独占模式下被线程占用，一般用来表示是否被当前线程所独占</td>
</tr>
</tbody></table>
<blockquote>
<p>实现自定义同步组件时，将会调用同步器提供的模板方法，部分方法如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void acquire(int arg)</td>
<td>独占模式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则进入同步队列等待，该方法将会调用重写的<code>tryAcquire(int arg)</code>方法</td>
</tr>
<tr>
<td align="center">void acquireInterruptibly(int arg)</td>
<td>与<code>void acquire(int arg)</code>相同，但是该方法响应中断，在当前线程未获取到锁进入到同步队列等待后，如果当前线程被中断，则该方法会抛出<code>java.lang.InterruptedException</code>并返回</td>
</tr>
<tr>
<td align="center">boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>在<code>acquireInterruptibly(int arg)</code>的基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，将返回false，获取成功则返回true</td>
</tr>
<tr>
<td align="center">void acquireShared(int arg)</td>
<td>共享式获取同步状态，若当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</td>
</tr>
<tr>
<td align="center">void acquireSharedInterruptibly(int arg)</td>
<td>与<code>void acquireShared(int arg)</code>相同，该方法响应中断</td>
</tr>
<tr>
<td align="center">boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>在<code>acquireSharedInterruptibly(int arg)</code>基础上增加了超时限制</td>
</tr>
<tr>
<td align="center">boolean release(int arg)</td>
<td>独占式是否同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td>
</tr>
<tr>
<td align="center">boolean releaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td align="center">Collection<Thread> getQueuedThreads()</td>
<td>获取等待在同步队列上的线程集合</td>
</tr>
</tbody></table>
<blockquote>
<p>同步器提供的模板方法有以下3类</p>
</blockquote>
<ul>
<li>独占式获取与释放同步状态</li>
<li>共享式获取与释放同步状态</li>
<li>查询同步队列中等待线程的情况</li>
</ul>
<blockquote>
<p>独占锁是同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取到锁的线程释放了锁，后继的线程才能获取到锁，以下是示例代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不可重入互斥锁类</span></span><br><span class="line"><span class="comment"> *  使用Mutex时，并不会与AQS交互，而是使用Mutex提供的方法获取与释放锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2019-05-12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果同步仅仅针对当前线程保持，返回true</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  使用CAS设置同步状态</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> state 同步状态</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将同步状态重置为0</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            ois.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将操作代理到Sync</span></span><br><span class="line"><span class="comment">     * 内部类继承了同步器并实现了独占锁式获取和释放同步状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>线程应用实例</title>
    <url>/blog/2019/05/11/concurrent/chapter4/4.3_thread_application/</url>
    <content><![CDATA[<h6 id="1-等待超时模式"><a href="#1-等待超时模式" class="headerlink" title="1. 等待超时模式"></a>1. 等待超时模式</h6><blockquote>
<p>调用场景：调用一个方法时等待一段时间（给定一个时间段），如果该方法能够在给定的时间段之内得到结果，那么结果将立刻返回，反之，超时返回默认结果。而<strong>等待/通知的经典范式：加锁、条件循环和处理逻辑</strong>3个步骤无法满足超时等待的情况。所以做出如下改动：</p>
<p>假设超时时间是T，那么可以推断出当前时间<strong>now+T</strong>后会超时。使用<code>wait(time)</code>方法</p>
<p>等待超时模式是在等待/通知范式的基础上增加了超时控制，伪代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 超时时间点</span></span><br><span class="line">    <span class="keyword">long</span> future = System.currentTimeMills() + mills;</span><br><span class="line">    <span class="keyword">long</span> remaining = mills;</span><br><span class="line">    <span class="comment">// 若 remaining 时间大于0，则继续等待</span></span><br><span class="line">    <span class="keyword">while</span>((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待超时</span></span><br><span class="line">        wait(remaining);</span><br><span class="line">        <span class="comment">// 当前剩余超时时间</span></span><br><span class="line">        remaining = futurn - system.currentTimeMills();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-数据库连接实例"><a href="#2-数据库连接实例" class="headerlink" title="2. 数据库连接实例"></a>2. 数据库连接实例</h6><blockquote>
<p>以下是模拟数据库连接的示例，从连接池中获取、使用和释放资源，获取连接采用超时模式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回收线程池,并通知等待中的线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定多少毫秒内超时获取连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mills</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 默认无超时时间</span></span><br><span class="line">                <span class="keyword">if</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> ((pool.isEmpty()) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 超时等待</span></span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    future = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty())&#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是连接池，以下是创建连接，使用JDK代理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;commit&quot;</span>)) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Connection <span class="title">createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Connection.class&#125;, <span class="keyword">new</span> ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试示例，模拟客户端获取连接、使用、释放连接过程，并统计连接情况。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大连接数为10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ConnectionPool pool = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证所有ConnectionRunner能够同时开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * main将会等待所有ConnectionRunner结束后才会继续执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">10</span>;</span><br><span class="line">        end = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 获取成功连接数</span></span><br><span class="line">        AtomicInteger got = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">// 超时获取连接失败数</span></span><br><span class="line">        AtomicInteger noGot = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConnectionRunner(count,got,noGot),<span class="string">&quot;ConnectionRunnerThread&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start.countDown();</span><br><span class="line">        end.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;total invoke: &quot;</span> + threadCount * count);</span><br><span class="line">        System.out.println(<span class="string">&quot;got connection: &quot;</span> + got);</span><br><span class="line">        System.out.println(<span class="string">&quot;noGot connection: &quot;</span> + noGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger got;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger noGot;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConnectionRunner</span><span class="params">(<span class="keyword">int</span> count, AtomicInteger got, AtomicInteger noGot)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.got = got;</span><br><span class="line">            <span class="keyword">this</span>.noGot = noGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                start.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Connection connection = pool.fetchConnection(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            got.getAndIncrement();</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        noGot.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从以上示例可以得知，随着客户端获取线程逐步增加，客户端出现超时无法获取连接的比率升高，但是可以保证客户端请求线程不会一直挂在获取连接的操作上，会按时返回，并告知客户端获取连接出现问题，这是系统的一种自我保护机制。</p>
</blockquote>
<h6 id="3-线程池技术以及示例"><a href="#3-线程池技术以及示例" class="headerlink" title="3. 线程池技术以及示例"></a>3. 线程池技术以及示例</h6><blockquote>
<p>线程的创建和消亡都是会消耗系统资源，当并发量大时，会频繁创建线程。这会导致频繁的线程上下文切换，增加系统负载。<strong>线程池</strong>可以解决这类问题，其预先创建若干数量线程，不能由用户直接对线程的创建进行控制，重复使用固定或者较为固定数目的线程完成任务，这样可以减少频繁创建和消亡线程的系统资源开销，即使面对过量任务也可以平缓的劣化。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个Job加入到任务队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加工作者线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWroks</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少工作者线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到正在执行的任务数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义了线程池的一系列接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最大限制数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WROKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最小限制数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是一个工作列表，向里面插入工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWorkers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        num = num &lt; MAX_WROKER_NUMBERS ? num &gt; MIN_WORKER_NUMBERS ? num : MIN_WORKER_NUMBERS : MAX_WROKER_NUMBERS;</span><br><span class="line">        initializeWorkers(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向jobs中添加Job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> job</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                <span class="comment">// 使用notifyAll()代价更大，因为会把所有等待队列中的线程移到阻塞队列中</span></span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        workers.forEach(p -&gt; p.shutdown());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWroks</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多线程情况下，需要保证num的原子性，所以需要在锁内部</span></span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WROKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WROKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            initializeWorkers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workerNum - num &lt; MIN_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = workerNum - MIN_WORKER_NUMBERS;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Worker worker = workers.get(num);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                &#125;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">&quot;ThreadPool-Worker-&quot;</span> + threadNum.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者，负责消费任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 等待/通知机制,用户停止当前工作线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="comment">// jobs为空，进入等待状态</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 去除job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 注意是否需要处理异常</span></span><br><span class="line">                    job.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其本质是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端将任务放入队列后便返回，而工作者线程则不断从工作队列上取出工作并执行。</p>
</blockquote>
<h6 id="4-简单Web服务器"><a href="#4-简单Web服务器" class="headerlink" title="4. 简单Web服务器"></a>4. 简单Web服务器</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HTTP线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String basePath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        SimpleHttpServer.basePath = basePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        SimpleHttpServer.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http处理socket线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 初始化流</span></span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                <span class="comment">// 读取第一行，判断文件类型</span></span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                <span class="comment">// 根据http请求头，解析请求url，得到文件路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 初始化输出流</span></span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                <span class="comment">// 图片处理,特殊流</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">&quot;jpg&quot;</span>) || filePath.endsWith(<span class="string">&quot;ico&quot;</span>)) &#123;</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Server: Molly&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-Type: image/jpeg&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-length: &quot;</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                    out.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Server: Molly&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-Type: text/xml; charset=utf-8&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                out.println(<span class="string">&quot;HTTP/1.1 500&quot;</span>);</span><br><span class="line">                out.println(<span class="string">&quot;Server: Molly&quot;</span>);</span><br><span class="line">                out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, reader, in, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable tmp : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    tmp.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过线程池处理socket请求，建立一个工作队列，不会阻塞后续客户端的请求</p>
</blockquote>
<blockquote>
<p>更复杂的HttpServer见: <a href="https://github.com/effiu/mytomcat">mytomcat</a></p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>线程间通信</title>
    <url>/blog/2019/05/05/concurrent/chapter4/4.2_inter-thread_communication/</url>
    <content><![CDATA[<h5 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h5><blockquote>
<p>线程间可以通过通信互相配合完成工作</p>
</blockquote>
<h6 id="1-volatile和synchronized关键字"><a href="#1-volatile和synchronized关键字" class="headerlink" title="1. volatile和synchronized关键字"></a>1. <code>volatile</code>和<code>synchronized</code>关键字</h6><blockquote>
<p>Java支持多个线程同时访问一个对象或者对象的成员变量，每个线程都会拥有这个共享变量的拷贝，所以程序执行过程中，一个线程看到的并不一定是最新的。</p>
<p><code>volatile</code>可以用来修饰字段(成员变量)，就是告知程序任何对该变量的访问均需要从共享内存中获取，对它的改动必须同步刷新到共享内存，可以保证所有线程对变量访问的可见性。过多使用<code>volatile</code>会降低程序执行的效率。</p>
<p><code>synchronized</code>可以修饰方法或者以同步块的形式进行使用，确保多线程在同一时刻只有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性与排他性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对Synchronized.class对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Synchronized.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 静态同步方法，对Synchronized.class对象加锁</span></span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用javap反编译后，部分结果如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line"><span class="comment">// 方法修饰符，表示：public staticflags: ACC_PUBLIC, ACC_STATIC</span></span><br><span class="line">	Code:</span><br><span class="line">        stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: ldc #1 // class com/murdock/books/multithread/book/Synchronized</span><br><span class="line">        <span class="number">2</span>: dup</span><br><span class="line">        <span class="number">3</span>: monitorenter <span class="comment">// monitorenter：监视器进入，获取锁</span></span><br><span class="line">        <span class="number">4</span>: monitorexit <span class="comment">// monitorexit：监视器退出，释放锁</span></span><br><span class="line">        5: invokestatic #16 // Method m:()V</span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 方法修饰符，表示： public static synchronized</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    	Code:</span><br><span class="line">            stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">            <span class="number">0</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>指令，同步方法使用方法修饰符上对的<strong>ACC_SYNCHRONIZED</strong>完成。本质是对一个对象监视器(monitor)的获取，这个获取是排他的，即同一时刻只有一个线程获取到<code>synchronized</code>所保护对象的监视器</p>
</blockquote>
<blockquote>
<p>任意对象都有自己的监视器，当这个对象由同步块或者对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，未获取到监视器的线程将会被阻塞在同步块或同步方法的入口处，进入BLOCKED状态。当持有锁的线程释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。</p>
</blockquote>
<blockquote>
<p>如下图是对象、对象的监视器、同步队列和执行线程之间的关系：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/42.jpg" alt="关系图"></p>
<h6 id="2-等待-通知机制"><a href="#2-等待-通知机制" class="headerlink" title="2. 等待/通知机制"></a>2. 等待/通知机制</h6><blockquote>
<p>一个线程修改了一个对象的值，另一个线程感知到了变化，然后进行响应的操作。等待/通知的相关方法如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">notify()</td>
<td>通知一个在等待队列中的线程，使其从wait()返回，前提是该线程获得了对象锁</td>
</tr>
<tr>
<td align="center">notifyAll()</td>
<td>通知所有等待在该对象同步等待队列上的线程</td>
</tr>
<tr>
<td align="center">wait()</td>
<td>线程进入<strong>WAITING</strong>状态，等待其他线程的通知才会返回，会释放对象的锁</td>
</tr>
<tr>
<td align="center">wait(long)</td>
<td>超时等待，单位ms，若超时没有通知就返回</td>
</tr>
<tr>
<td align="center">wait(long,int)</td>
<td>超时等待，单位ns</td>
</tr>
</tbody></table>
<blockquote>
<p>等待/通知机制，是指一个线程A调用对象O的<code>wait()</code>方法进入等待状态，另一个线程B调用对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>方法返回，执行后续操作。两个线程通过O进行交互。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">&quot;waitThread&quot;</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">&quot;notifyThread&quot;</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 条件不满足时wait,同时释放lock锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">&quot; flag is true. wait@ &quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; flag is false. running@ &quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 条件不满足时wait,同时释放lock锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">&quot; hold lock. notify@ &quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; hold lock again. sleep@ &quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[waitThread,<span class="number">5</span>,main] flag is <span class="keyword">true</span>. wait@ <span class="number">2019</span>-<span class="number">05</span>-<span class="number">04</span>T23:<span class="number">44</span>:<span class="number">01</span>.<span class="number">540</span></span><br><span class="line">Thread[notifyThread,<span class="number">5</span>,main] hold lock. notify@ <span class="number">2019</span>-<span class="number">05</span>-<span class="number">04</span>T23:<span class="number">44</span>:<span class="number">02</span>.<span class="number">396</span></span><br><span class="line">Thread[notifyThread,<span class="number">5</span>,main] hold lock again. sleep@ <span class="number">2019</span>-<span class="number">05</span>-<span class="number">04</span>T23:<span class="number">44</span>:<span class="number">07</span>.<span class="number">398</span></span><br><span class="line">Thread[waitThread,<span class="number">5</span>,main] flag is <span class="keyword">false</span>. running@ <span class="number">2019</span>-<span class="number">05</span>-<span class="number">04</span>T23:<span class="number">44</span>:<span class="number">12.398</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>注意事项：</p>
</blockquote>
<ul>
<li>使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用对象加锁</li>
<li>调用<code>wait()</code>后，线程状态由<strong>RUNNING</strong>变为<strong>WAITING</strong>，将当前线程放置到对象的等待队列中</li>
<li><code>notify()</code>和<code>notifyAll()</code>调用后，等待队列不会立即从<code>wait()</code>返回，而是等待调用线程释放锁之后，等待线程才有机会从<code>wait()</code>返回</li>
<li><code>notify()</code>将等待线程中的一个等待线程从等待队列中移到同步队列中。<code>notifyAll()</code>将所有等待线程移到同步队列中，被移动线程状态由<strong>WAITING</strong>变为<strong>BLOCKED</strong></li>
<li><code>wait()</code>方法返回的前提是获得了对象锁</li>
</ul>
<blockquote>
<p>等待/通知依托于同步机制，目的是确保等待线程从<code>wait()</code>方法返回时能够感知到通知线程对变量做出的修改</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/43.jpg" alt="关系图"></p>
<blockquote>
<p><strong>WaitThread</strong>首先获得了对象锁，然后调用<code>wait()</code>方法，放弃锁进入对象的等待队列，此时<strong>NotifyThread</strong>获得了对象锁，调用<code>notify()</code>方法，将<strong>WaitThread</strong>从等待队列移到<code>synchronizedQueue</code>中，<strong>WaitThread</strong>变为阻塞状态，等待<strong>NotifyThread</strong>释放锁，<strong>WaitThread</strong>会在<strong>NotifyThread</strong>释放锁之后获取锁并从<code>wait()</code>方法返回并继续执行。</p>
</blockquote>
<h6 id="3-等待-通知的经典范式"><a href="#3-等待-通知的经典范式" class="headerlink" title="3. 等待/通知的经典范式"></a>3. 等待/通知的经典范式</h6><blockquote>
<p>等待方规则：</p>
</blockquote>
<ol>
<li>获取对象锁</li>
<li>若条件不满足，调用<code>wait()</code>方法，被通知后仍要检查条件</li>
<li>条件满足后执行对应逻辑</li>
</ol>
<blockquote>
<p>通知方规则：</p>
</blockquote>
<ol>
<li>获取对象锁</li>
<li>改变条件</li>
<li>通知在等待队列中等待的线程</li>
</ol>
<h6 id="4-管道输入-输出流"><a href="#4-管道输入-输出流" class="headerlink" title="4. 管道输入/输出流"></a>4. 管道输入/输出流</h6><blockquote>
<p>管道输入/输出流与普通的文件输入/输出流或者网络输入/输出流不同，其用于线程之间的数据传输，传输媒介是内存。</p>
<p>面向字节：<code>PipedoutputStream</code>、<code>PipedInputStream</code></p>
<p>面向字符：<code>PipedReader</code>、<code>PipedWriter</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">// 输入输出流进行连接，否则会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">&quot;printThread&quot;</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于<strong>Piped</strong>流，必须先进行绑定，调用<code>connect()</code>方法，否则将抛出异常</p>
</blockquote>
<h6 id="5-Thread-join-的使用"><a href="#5-Thread-join-的使用" class="headerlink" title="5. Thread.join()的使用"></a>5. <code>Thread.join()</code>的使用</h6><blockquote>
<p><code>join()</code>的含义：线程A等等thread线程终止之后才从<code>thread.join()</code>返回。<code>join()</code>、<code>join(long)</code>、<code>join(long,int)</code>。线程终止时会调用线程自身的<code>notifyAll()</code>方法，会通知所有等待在该线程对象上的线程。</p>
</blockquote>
<h6 id="6-ThreadLocal"><a href="#6-ThreadLocal" class="headerlink" title="6. ThreadLocal"></a>6. <code>ThreadLocal</code></h6><blockquote>
<p><code>ThreadLocal</code>，线程变量，是一个以<strong>ThreadLocal</strong>对象为键，任意对象为值的存储结构。见以下例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = ThreadLocal.withInitial(() -&gt; System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Const: &quot;</span> + Profiler.end() + <span class="string">&quot; mills&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好处是两个方法的调用不用在一个方法或者类中，比如在AOP中，可以在方法调用的切入点执行<code>begin()</code>方法，在方法调用后的切入点执行<code>end()</code>方法</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的简介、启动与终止</title>
    <url>/blog/2019/05/04/concurrent/chapter4/4.1_thread/</url>
    <content><![CDATA[<h5 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1. 线程简介"></a>1. 线程简介</h5><h6 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h6><blockquote>
<p>启动一个Java程序，操作系统会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫轻量级进程。一个进程里可以创建多个线程，这些线程拥有各自的计数器、堆和局部变量等属性，并且可以访问共享的内存变量，处理器会在线程之间高速切换。</p>
<p>一个Java程序从<code>main()</code>方法开始执行，然后按照既定代码逻辑执行，实际上Java程序是多线程程序，所以会<strong>有很多后台线程在执行</strong>。以下使用JMX查看普通的Java程序包含哪些线程：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Java线程管理MXBean</span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 遍历线程信息，打印线程Id和线程名称信息</span></span><br><span class="line">        Arrays.stream(threadInfos).forEach(p -&gt; System.out.println(<span class="string">&quot;[&quot;</span> + p.getThreadId() + <span class="string">&quot;] &quot;</span> + p.getThreadName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>] Monitor Ctrl-Break</span><br><span class="line">[<span class="number">5</span>] Attach Listener			<span class="comment">// 并不一定会存在</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher		<span class="comment">// 分发处理发送给JVM信号的线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer				<span class="comment">// 调用对象finalize方法的线程</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler		<span class="comment">// 清除Reference的线程</span></span><br><span class="line">[<span class="number">1</span>] main					<span class="comment">// main线程，用户程序入口</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://lovestblog.cn/blog/2014/06/18/jvm-attach/">JVM Attach机制</a></li>
</ul>
<h6 id="2-为什么要使用多线程"><a href="#2-为什么要使用多线程" class="headerlink" title="2. 为什么要使用多线程"></a>2. 为什么要使用多线程</h6><blockquote>
<p>从上面程序可以发现，一个简单的<code>mian()</code>函数启动了多个后台线程。正确使用多线程，能够带来显著的好处。</p>
</blockquote>
<ul>
<li><strong>更多的处理器核心</strong>。现代处理器的核心越来越多，以及超线程技术的广泛运用，现代处理器都更加擅长并行计算，处理器提高性能的方式，也从提高主频向更多的核心发展，所以如何更好利用处理器多核心是主要问题。线程是大多数操作系统调度的基本调度，一个程序作为一个进程来运行。程序运行过程中会创建多个线程，而一个线程只能在一个处理器核心上运行，所以为了更好利用处理器核心，使用多线程技术将计算逻辑分配到多个处理器核心，就可以显著提高程序的处理时间。</li>
<li><strong>更快的响应时间</strong>。对于复杂的业务场景，可以使用多线程技术将数据一致性不强的操作派发给其他线程处理(也可以使用消息队列)，这样做好处是相应用户请求的线程能够尽可能快的处理完成，缩短响应时间，提升用户体验。</li>
<li><strong>更好的编程模型</strong>。Java为多线程编程提供了良好、考究并且一致的编程模型，这样开发人员就不需要考虑将程序多线程化，而是专注于问题的解决。</li>
</ul>
<h6 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3. 线程优先级"></a>3. 线程优先级</h6><blockquote>
<p>现代操作系统采用时分的形式调度运行的线程。操作系统会分出一个个<strong>时间片</strong>，线程分配到若干时间片，当线程时间片用完后就会发生<strong>系统调度</strong>，等待下一次分配，所以<strong>线程分配时间片多少决定了线程使用系统资源</strong>的多少，而<strong>线程的优先级</strong>是决定线程需要多或者少分配一些处理器资源的线程属性。</p>
</blockquote>
<blockquote>
<p>Java线程中通过一个 <code>int</code>成员变量控制优先级，<code>thread.setPriority(int)</code>来修改优先级，默认值是5。优先级高的线程会分配更多的时间片。针对频繁阻塞的线程，要设置更高的优先级；偏重计算的线程，设置较低的优先级。<strong>有些操作系统会忽略线程优先级的设定</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	Changes the priority of this thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 优先级范围从1~10</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程优先级不能作为程序正确性的依赖，因为操作系统可以忽略Java线程对于优先级的设定</p>
</blockquote>
<h6 id="4-线程的状态"><a href="#4-线程的状态" class="headerlink" title="4. 线程的状态"></a>4. 线程的状态</h6><blockquote>
<p>Java线程在运行声明周期中有6中不同的状态，同一线程在某个时刻只能处于其中一个状态。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NEW</td>
<td>初始状态，线程被创建，未调用<code>start()</code>方法</td>
</tr>
<tr>
<td align="center">RUNABLE</td>
<td>运行状态，Java线程将操作系统中的就绪和运行两种状态统称为“运行中”</td>
</tr>
<tr>
<td align="center">BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td align="center">WAITING</td>
<td>等待状态，表示当前线程需要等待其他线程输出一些特定动作(通知或中断)</td>
</tr>
<tr>
<td align="center">TIME_WAITING</td>
<td>超时等待状态，与WAITING有区别，可以在指定时间自行返回</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<blockquote>
<p>查看Java进程运行时的线程信息：<code>jps</code>查看<strong>Java进程</strong>，<code>jstack</code> + 进程ID，以下是部分输出：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vdevops ~]# jps</span><br><span class="line">5052 Bootstrap</span><br><span class="line">27613 gm-web-0.0.1-SNAPSHOT.jar</span><br><span class="line">15774 Jps</span><br><span class="line">[root@vdevops ~]# jstack 27613</span><br><span class="line">2019-05-04 11:50:33</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #40 daemon prio=9 os_prio=0 tid=0x00007f017c003800 nid=0x3db2 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">   </span><br><span class="line">········ 省略</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程在自身的声明周期中的状态是变化的，是随着代码的执行在不同的状态之间切换。Java线程状态变化如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/41.jpg" alt="Java线程状态变化"></p>
<blockquote>
<p>线程创建之后，<code>Thread.start()</code>后开始运行。<code>wait()</code>方法后进入等待状态，此时需要依靠其他线程通知才能够返回到运行状态，<strong>TIME_WAITING</strong>是在等待状态的基础上增加了超时限制，超时将会返回到运行状态。线程调用同步方法时，未获取到锁，就会进入阻塞状态。线程在执行<code>Runnable</code>的<code>run()</code>之后将会进入到终止状态。</p>
</blockquote>
<blockquote>
<p>Java将操作系统中的运行和就绪两个状态合并称为<strong>RUNNABLE</strong>状态。阻塞状态是线程阻塞在进入<code>synchronized</code>关键字修饰方法或代码块(获取锁)时的状态，但是阻塞在<code>java.concurrent.locks.Lock</code>接口 的线程状态是<strong>WAITING</strong>状态，其内部使用了<code>LockSupport</code>中相关方法。</p>
</blockquote>
<h6 id="5-Daemon线程"><a href="#5-Daemon线程" class="headerlink" title="5. Daemon线程"></a>5. Daemon线程</h6><blockquote>
<p><strong>Daemon</strong>线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。当Java虚拟机中不存在<strong>Daemon</strong>线程时，Java虚拟机将会退出，可以<code>Thread.setDaemon(true)</code>将线程设置为<strong>Daemon</strong>线程。<strong>Daemon</strong>线程需要在启动线程之前设置。<strong>Daemon</strong>线程中的<code>finally</code>块并不一定会执行，所以不能依靠<code>finally</code>块中的内容确保执行关闭或清理资源的逻辑。</p>
</blockquote>
<hr>
<h5 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2. 启动和终止线程"></a>2. 启动和终止线程</h5><blockquote>
<p>Java线程<code>start()</code>方法启动，随着<code>run()</code>方法执行完毕线程终止</p>
</blockquote>
<h6 id="1-构造线程"><a href="#1-构造线程" class="headerlink" title="1. 构造线程"></a>1. 构造线程</h6><blockquote>
<p>运行线程之前需要先构建一个线程，构造时需要提供线程所需要的属性：线程组、线程优先级、是否是<strong>Daemon</strong>线程等信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 线程名</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 当前线程是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="comment">// 线程组逻辑</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.addUnstarted();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">// 将Daemon、Priority等设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">// 将父线程的 InheritableThreadLocals复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    <span class="comment">// 分配一个线程id</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现，一个新构造的线程对象是由其<strong>parent线程</strong>类进行空间分配的，而<strong>child线程</strong>继承了父线程的<strong>Deamon</strong>、<strong>Priority优先级</strong>和加载资源的<strong>contextClassLoader</strong>以及可继承的<strong>ThreadLocal</strong>，同时会分配一个唯一的ID来标识<strong>child线程</strong>。</p>
</blockquote>
<h6 id="2-启动线程"><a href="#2-启动线程" class="headerlink" title="2. 启动线程"></a>2. 启动线程</h6><blockquote>
<p>线程在构造初始化完成后，调用<code>start()</code>方法就可以启动这个线程。线程<code>start()</code>的含义：当前线程(<strong>parent线程</strong>)同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用<code>start()</code>方法的线程。启动一个线程前，最好要为线程设置一个名称，便于使用<strong>jstack</strong>分析。</p>
</blockquote>
<h6 id="3-中断线程"><a href="#3-中断线程" class="headerlink" title="3. 中断线程"></a>3. 中断线程</h6><ul>
<li><input disabled="" type="checkbox"> <strong>未完全理解</strong></li>
</ul>
<blockquote>
<p>中断可以理解为线程的一个标识位属性。它表示一个运行中的线程是否被其他线程进行中断操作，其他线程可以通过调用线程的<code>interrupt()</code>方法对其进行中断操作。</p>
</blockquote>
<blockquote>
<p>线程通过检查自身是否被中断来进行响应，<code>isInterrupt()</code>方法进行判断是否被中断。<code>Thread.interrupt()</code>对当前线程的中断标识进行复位。若该线程已经处于终结状态，即使该线程被中断过，在调用线程对象的<code>isInterrupted()</code>时依旧会返回false。</p>
</blockquote>
<blockquote>
<p><strong>Java API</strong>可以发现，很多声明会抛出<code>InterruptedException</code>的方法(<code>Thread.sleep(long millis)</code>)会在抛出<code>InterruptExcepption</code>之前，Java虚拟机会将该线程的中断标识位清除，此事调用<code>isInterrupted</code>方法会返回<code>false</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 睡眠线程</span></span><br><span class="line">        Thread sleepRunner = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepRunner(), <span class="string">&quot;sleepRunner&quot;</span>);</span><br><span class="line">        sleepRunner.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不停运行线程</span></span><br><span class="line">        Thread busyRunner = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyRunner(), <span class="string">&quot;busyRunner&quot;</span>);</span><br><span class="line">        busyRunner.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sleepRunner.start();</span><br><span class="line">        busyRunner.start();</span><br><span class="line">        <span class="comment">// 休眠5s让线程充分运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        sleepRunner.interrupt();</span><br><span class="line">        busyRunner.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;SleepRunner interrupted is &quot;</span> + sleepRunner.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;BusyRunner interrupted is &quot;</span> + busyRunner.isInterrupted());</span><br><span class="line">        <span class="comment">// 防止sleepRunner和busyRunner立刻退出</span></span><br><span class="line">        SleepUtils.second(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现抛出<code>InterruptedException</code>的线程SleepRunner，其中断标识位被清除了(因为调用了<code>sleep</code>方法)，一直运作的线程<strong>busyRunner</strong>，中断标识位没有被清除</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SleepRunner interrupted is <span class="keyword">false</span></span><br><span class="line">BusyRunner interrupted is <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h6 id="4-过期的suspend-、resume-、stop"><a href="#4-过期的suspend-、resume-、stop" class="headerlink" title="4. 过期的suspend()、resume()、stop()"></a>4. 过期的<code>suspend()</code>、<code>resume()</code>、<code>stop()</code></h6><blockquote>
<p>Thread的API里<code>suspend()</code>、<code>resume()</code>和<code>stop()</code>分别对应线程的暂停、恢复和停止。API是过期的，不建议使用。</p>
<p><code>suspend()</code>在调用后，线程并不会释放已经占有的的资源(比如锁)，而是占用资源进入睡眠状态，这样容易引起死锁问题。<code>stop()</code>方法在终结一个线程时不会保证线程的资源正常释放。</p>
</blockquote>
<h6 id="5-安全地终止线程"><a href="#5-安全地终止线程" class="headerlink" title="5. 安全地终止线程"></a>5. 安全地终止线程</h6><blockquote>
<p>中断状态是一个标识位，中断操作是一种简单的线程间交互方式，这种交互方式最适合用来取消或停止任务，还可以利用一个<code>boolean</code>变量控制是否需要停止任务并终止该线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">&quot;countThread&quot;</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠1s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">&quot;countThread&quot;</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠1s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Count i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上通过标识位或者中断操作的方式可以使线程在终止时有机会去清理资源，更加安全和优雅。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>happens-before</title>
    <url>/blog/2019/04/30/concurrent/chapter3/3.7_happens-before/</url>
    <content><![CDATA[<blockquote>
<p><code>happens-bofore</code>是JMM最核心的概念。</p>
</blockquote>
<h6 id="1-JMM的设计"><a href="#1-JMM的设计" class="headerlink" title="1. JMM的设计"></a>1. JMM的设计</h6><blockquote>
<p>JMM的设计意图：</p>
</blockquote>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。希望基于一个强内存模型编码。</li>
<li>编译器和处理器对内存模型的实现。编译器和 处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型</li>
</ul>
<blockquote>
<p><code>JSR-133</code>找一个平衡点，既要为程序员提供强的内存可见性保证；又要尽可能少束缚编译器和处理器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;			<span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1.0</span>;				<span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r;	<span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上所示代码，<strong>A happens-before C</strong>和<strong>B happens-before C</strong>是必须的，A和B没有必须关系，所以JMM把<code>happens-before</code>要求分为两类：</p>
</blockquote>
<ul>
<li>会改变程序执行结果的重排序，JMM会要求编译器和处理器必须禁止这种重排序</li>
<li>不会改变程序执行结果的重排序，JMM允许这种重排序</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/25.jpg" alt="JMM设计示意图"></p>
<blockquote>
<p>从上图可以得出以下结论</p>
</blockquote>
<ul>
<li>JMM提供的<code>happens-before</code>规则可以满足程序员的需求。提供了足够强的内存可见性保证</li>
<li>JMM对编译器和 处理器的束缚尽可能减少了，只要不改变程序执行结果（单线程程序或者正确同步的多线程程序），编译器和处理器可以随便优化</li>
</ul>
<h6 id="2-happens-before的定义"><a href="#2-happens-before的定义" class="headerlink" title="2.happens-before的定义"></a>2.<code>happens-before</code>的定义</h6><blockquote>
<p><code>JSR-133</code>使用<code>happens-before</code>概念执行两个操作之间的执行顺序（两个操作可以在一个线程之内，也可以在多线程之间），所以JMM可以通过<code>happens-before</code>关系向程序员提供跨线程内存的可见性保证</p>
</blockquote>
<blockquote>
<p><code>JSR-133</code>对<code>happens-before</code>关系定义如下：</p>
</blockquote>
<ul>
<li>一个操作<code>happens-before</code>另一个操作，那么第一个操作执行结果将对第二个操作可见，第一个操作的执行顺序必须排在第二个之前，这是<strong>JMM对程序员的承诺</strong></li>
<li>两个操作之间的<code>happens-before</code>关系，并不意味着编译器和处理器会按照这种顺序执行，若重排序后的执行结果，与按照<code>happens-before</code>关系的执行结果一致，那么允许这种重排序。<strong>JMM对编译器和处理器的约束原则</strong></li>
</ul>
<blockquote>
<p><code>happens-before</code>关系和<code>as-if-serial</code>语义类似。</p>
<p><code>as-if-serial</code>保证单线程内程序的执行结果不被改变，<code>happens-before</code>保证正确同步的多线程程序执行结果不被改变。目的是再不改变程序执行结果的情况下，尽可能地提高并行度。</p>
</blockquote>
<h6 id="3-happens-before规则"><a href="#3-happens-before规则" class="headerlink" title="3 happens-before规则"></a>3 <code>happens-before</code>规则</h6><blockquote>
<p><code>JSR-133</code>定义的<code>happens-before</code>规则如下：</p>
</blockquote>
<ol>
<li>程序顺序规则：一个线程中的每个操作，<code>happens-before</code>于该线程中的任意后续操作（<strong>实际JMM允许编译器和处理器在不改变程序执行结果的情况下重排序</strong>）</li>
<li>监视器锁规则：一个锁的解锁，<code>happens-before</code>于随后对这个锁的加锁</li>
<li><code>volatile</code>变量规则：对一个<code>volatile</code>的写，<code>happens-before</code>与任意后续操作对这个<code>volatile</code>域的读</li>
<li>传递性：A <code>happens-before</code> B，B <code>happens-before</code> C，那么 A <code>happens-before</code> C</li>
<li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么线程A中<code>ThreadB.start()</code>操作<code>happens-before</code>线程B的任何操作</li>
<li><code>join()规则</code>：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作<code>happens-before</code>于线程A从<code>ThreadB.join()</code>操作成功返回</li>
</ol>
<h6 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h6><blockquote>
<p>正确理解<code>happens-before</code>的各项规则。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/26.jpg" alt="happens-before示意图"></p>
<ul>
<li><p>1<code>happens-before</code>2和3<code>happens-before</code>4是由<strong>程序顺序规则产生</strong>，即编译器和处理器遵守<code>as-if-serial</code>语义，保证了程序的顺序执行</p>
</li>
<li><p>2<code>happens-before</code>3是由**<code>volatile</code>规则产生**，对一个<code>volatile</code>变量的读，总是能够看到任意线程之前对这个<code>volatile</code>变量最后的写入。</p>
</li>
<li><p>1<code>happens-before</code>4由<strong>传递性规则</strong>产生。<strong>传递性</strong>是由<code>volatile</code>的内存屏障插入策略和<code>volatile</code>的编译器重排序规则共同保证的</p>
</li>
</ul>
<blockquote>
<p><code>start()</code>规则：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/27.jpg" alt="happens-before关系示意图"></p>
<blockquote>
<p>1 <code>happens-before</code> 2由程序顺序规则产生。2 <code>happens-before</code> 4由<code>start()</code>规则产生，根据<strong>传递性规则</strong>1 <code>happens-before</code> 4，意味着线程A在执行<code>ThrandB.start()</code>之前对共享变量做的修改对线程B可见。</p>
</blockquote>
<blockquote>
<p><code>join()规则</code>，线程A执行过程中通过执行<code>ThreadB.join()</code>等待B终止。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/28.jpg" alt="happens-before关系示意图"></p>
<blockquote>
<p>2  <code>happens-before</code> 4 由<strong>join规则</strong>产生，4 <code>happens-before</code> 5 由<strong>程序规则产生</strong>，根据<strong>传递性</strong> 2 <code>happens-before</code> 5，所以线程A执行操作<code>ThreadB.join()</code>并成功返回后，线程B的任意操作将对线程A可见。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>final内存语义</title>
    <url>/blog/2019/04/29/concurrent/chapter3/3.6_final/</url>
    <content><![CDATA[<blockquote>
<p>对<code>final</code>域的读和写像是普通的变量访问</p>
</blockquote>
<h6 id="1-final域的重排序规则"><a href="#1-final域的重排序规则" class="headerlink" title="1. final域的重排序规则"></a>1. final域的重排序规则</h6><blockquote>
<p>编译器和处理器针对<code>final</code>域要遵守两个重排序规则</p>
</blockquote>
<ol>
<li>与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含<code>final</code>域的对象的引用，与随后初次读这个<code>final</code>域，这两个操作之间不能重排序</li>
</ol>
<h6 id="2-写final域的重排序"><a href="#2-写final域的重排序" class="headerlink" title="2. 写final域的重排序"></a>2. 写<code>final</code>域的重排序</h6><blockquote>
<p>如下，假设线程A执行<code>writer()</code>方法，线程B执行<code>reader()</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须初始化，</span></span><br><span class="line"><span class="comment">     * 直接赋值或者构造方法，代码块初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写普通域</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 写final域</span></span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程A执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两步操作</span></span><br><span class="line">        <span class="comment">// 1. 构造一个对象；2. 将这个对象的引用赋值给应用变量obj</span></span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程B执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读对象引用</span></span><br><span class="line">        FinalExample object = obj;</span><br><span class="line">        <span class="comment">// 读普通域</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;</span><br><span class="line">        <span class="comment">// 读final域</span></span><br><span class="line">        <span class="keyword">int</span> b = object.j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写<code>final</code>域的重排序规则禁止把<code>final</code>域的写重排序到构造函数之外</p>
</blockquote>
<ol>
<li>JMM禁止编译器把<code>final</code>域的写重排序到构造函数之外</li>
<li>编译器会在<code>final</code>域之后，构造函数return之前，插入一个<code>StoreStore</code>屏障，这个屏障会禁止处理器把<code>final</code>域的写重排序到构造函数之外。</li>
</ol>
<blockquote>
<p>线程A执行<code>writer()</code>方法分为两步。<code>FinalExample</code>类，假设线程B读对象的引用与读对象成员域之间没有重排序(<strong>读final域的重排序规则</strong>)，执行后可能会产生如下图结果:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/21.jpg" alt="线程执行时序图"></p>
<blockquote>
<p>普通域的写操作被重排序到了构造函数之外，读线程B读取的是普通域初始化之前的值。</p>
</blockquote>
<blockquote>
<p>写<code>final</code>域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的<code>final</code>域已经被正确初始化了，而普通域不具有这个保障。</p>
</blockquote>
<h6 id="3-读final域的重排序"><a href="#3-读final域的重排序" class="headerlink" title="3. 读final域的重排序"></a>3. 读<code>final</code>域的重排序</h6><blockquote>
<p>读<code>final</code>域的重排序规则是：初次读对象引用与初次读对象包含的<code>final</code>域，JMM禁止<strong>处理器</strong>重排序这两个操作，编译器会在读<code>final</code>域操作前面插入一个<code>LoadLoad</code>屏障。初次读对象的引用与初次读对象包含的<code>final</code>域，这两个操作之间存在间接依赖关系，而编译器遵守间接依赖关系，所以这个规则不针对编译器重排序。</p>
</blockquote>
<blockquote>
<p>假设线程A没有发生任何重排序，可能会产生如下执行结果：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/22.jpg" alt="线程执行时序图"></p>
<blockquote>
<p>普通成员域的读操作被处理器重排序到了对象引用之前。</p>
<p>读<code>final</code>域的重排序规则：读一个对象的 <code>final</code>域之前，一定会先读包含这个<code>final</code>域的对象的引用。</p>
</blockquote>
<h6 id="4-final域为引用类型"><a href="#4-final域为引用类型" class="headerlink" title="4. final域为引用类型"></a>4. <code>final</code>域为引用类型</h6><blockquote>
<p>以上针对的是<code>final</code>为基础数据类型，当<code>final</code>域是引用类型时，写<code>final</code>域的重排规则对编译器和处理器增加了如下约束：在构造函数内对一个<code>final</code>引用的对象的成员写入，与随后在构造函数外把这个被构造函数对象的引用赋值给一个引用变量，这两个操作不能重排序。见下例：</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">public class FinalReferenceExample &#123;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    final int[] intArray;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    static FinalReferenceExample obj;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    public FinalReferenceExample()&#123;         // 构造函数</span></span><br><span class="line"><span class="xml">        intArray = new int[1];              // 1 对final域的写入</span></span><br><span class="line"><span class="xml">        intArray[0] = 1;                    // 2 对final域引用的对象的成员的写入</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    public static void writeOne()&#123;          // 写线程A执行</span></span><br><span class="line"><span class="xml">        obj = new FinalReferenceExample();  // 3 把被构造的对象的引用赋值给某个引用变量</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    public static void writeTwo()&#123;          //  写线程B执行</span></span><br><span class="line"><span class="xml">        obj.intArray[0] = 2;                // 4</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    public static void reader()&#123;            // 读线程C执行</span></span><br><span class="line"><span class="xml">        if (obj != null)&#123;                   // 5</span></span><br><span class="line"><span class="xml">            int tmp1 = obj.intArray[0];     // 6</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先线程A执行构造方法，然后线程B和C执行各自方法。根据以上重排序规则, 1和3以及2和3都不能重排序。</p>
</blockquote>
<blockquote>
<p>JMM可以确保线程C可以看到线程A在构造函数中对<code>final</code>引用对象写入以及对final引用对象成员的写入，保证不了线程B的写入对线程C可见。以下是一种执行情况：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/23.jpg" alt="引用型final执行时序图"></p>
<blockquote>
<p>线程B与线程C存在数据竞争，执行结果不可预知。要想保证线程C与看到线程B对<code>final</code>引用对象成员的写入，线程之前需要使用同步原语(<code>lock</code>或<code>volatile</code>)确保内存可见性。</p>
</blockquote>
<h6 id="5-final引用不能从构造函数内“溢出”"><a href="#5-final引用不能从构造函数内“溢出”" class="headerlink" title="5. final引用不能从构造函数内“溢出”"></a>5. <code>final</code>引用不能从构造函数内“溢出”</h6><blockquote>
<p>写<code>final</code>域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的<code>final</code>域已经在构造函数中被正确初始化了。还需要一个保证：不能让这个被构造对象的引用为其他线程所见，即对象引用不能在构造函数中“溢出”。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;                                      <span class="comment">// 1</span></span><br><span class="line">        obj = <span class="keyword">this</span>;                                 <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>)&#123;                           <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;                       <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设A执行<code>writer()</code>方法，线程B执行<code>reader()</code>方法。操作1和2允许被重排序，假如操作2允许被“溢出”，那么可能产生如下执行结果：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/24.jpg" alt="执行结果图"></p>
<blockquote>
<p>综上：在构造函数返回前，被构造对象的引用贝能为其他线程可见，在构造函数返回后，任意线程将保证可以看到<code>final</code>域正确初始化后的值</p>
</blockquote>
<h6 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a><code>final</code>语义在处理器中的实现</h6><blockquote>
<p>写<code>final</code>域的重排序规则要求编译器在<code>final</code>域写之后，构造函数<strong>return</strong>之前插入一个<code>StoreStore</code>屏障。读<code>final</code>规则要求编译器在读<code>final</code>之前加入一个<code>LoadLoad</code>屏障。</p>
</blockquote>
<blockquote>
<p>实际情况会根据处理器略有不同，但不会影响执行顺序。例如: x86处理器不会对存在间接依赖关系的操作做重排序，此时会省略掉<code>StoreStore</code>和<code>LoadLoad</code>内存屏障。</p>
</blockquote>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h6><blockquote>
<p><code>JSR-133</code>增强了<code>final</code>语义。通过为<code>final</code>域增加写和读重排序规则，可以为Java程序员提供初始化安全保证。只要对象是正确构造的(被构造对象在构造函数中没有“溢出”)，那么不需要使用同步就可以保证任意线程都能看到这个<code>final</code>域在构造函数中被初始化之后的值。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>锁的内存语义</title>
    <url>/blog/2019/04/26/concurrent/chapter3/3.5_lock/</url>
    <content><![CDATA[<blockquote>
<p>锁可以让内存区互斥执行</p>
</blockquote>
<h6 id="1-锁的释放-获取建立的happens-before关系"><a href="#1-锁的释放-获取建立的happens-before关系" class="headerlink" title="1.  锁的释放-获取建立的happens-before关系"></a>1.  锁的释放-获取建立的<code>happens-before</code>关系</h6><blockquote>
<p>锁是并发编程中对重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
</blockquote>
<h6 id="2-锁的释放和获取的内存语义"><a href="#2-锁的释放和获取的内存语义" class="headerlink" title="2. 锁的释放和获取的内存语义"></a>2. 锁的释放和获取的内存语义</h6><ol>
<li>线程释放锁时，JMM会把该线程对应的内地内存中的共享变量刷新到主内存中</li>
<li>线程获取锁时，JMM会把该线程对应的本地内存置为无效，使得被监视器保护的临界区代码必须从主内存中读取共享变量</li>
</ol>
<blockquote>
<p><strong>锁的释放-获取与<code>volatile</code>的写-读具有相同的内存语义</strong></p>
</blockquote>
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来获取锁的线程发出了消息(线程A对共享变量做了修改)</li>
<li>线程B获取一个锁，实质上是线程B接受了之前线程发出的消息(之前的线程释放所之前对共享变量做了修改)</li>
<li>线程A释放锁-线程B获取锁，实质上是线程A通过主内存向线程B发送消息</li>
</ul>
<h6 id="3-锁内存语义的实现"><a href="#3-锁内存语义的实现" class="headerlink" title="3. 锁内存语义的实现"></a>3. 锁内存语义的实现</h6><blockquote>
<p>借助<code>java.util.concurrent.locks.ReentrantLock</code>的源码，分析锁内存语义的具体实现机制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a ++;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ReentrantLock</code>中<code>lock()</code>方法获取锁，unlock()方法释放锁。<code>ReentrantLock</code>的实现依赖于Java同步器框架<code>AbstrantQueuedSynchronized</code>(<strong>AQS</strong>)。<strong>AQS</strong>使用一个<code>volatile</code>变量(<strong>state</strong>)维护同步状态。以下是<code>ReentrantLock</code>的类图</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/19.jpg" alt="ReentrantLock类图"></p>
<blockquote>
<p><code>ReentrantLock</code>分为公平锁和非公平锁，首先分析公平锁，查看源码可得公平锁调用轨迹如下:</p>
</blockquote>
<ol>
<li><code>ReentrantLock#lock</code>方法</li>
<li><code>FairSync#lock</code>方法</li>
<li><code>AbstrantQueuedSynchronized#acquire</code>方法</li>
<li><code>ReentrantLock#tryAcquire</code>方法</li>
</ol>
<blockquote>
<p><code>ReentrantLock#tryAcquire</code>方法是真正加锁的源代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取锁的开始</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取锁的开始先读<code>volatile</code>变量<code>state</code></p>
<p>解锁方法调用轨迹如下:</p>
</blockquote>
<ol>
<li><code>ReentrantLock#unlock</code>方法</li>
<li><code>AbstractQueuedSynchronizer#release</code>方法</li>
<li><code>Sync#tryRelease</code>方法</li>
</ol>
<blockquote>
<p><code>Sync#tryRelease</code>方法是解锁的源代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在释放锁的最后写volatile变量state</p>
</blockquote>
<blockquote>
<p><strong>根据<code>volatile</code>的<code>happens-before</code>规则，释放锁的线程在写<code>volatile</code>之前可见的共享变量，在执行获取锁的线程读取同一个<code>volatile</code>变量后将立即变得对获取锁的线程可见。</strong></p>
</blockquote>
<blockquote>
<p>非公平锁的内存语义实现。 非公平锁的释放与公平锁的释放完全一致。以下是非公平锁的获取，<code>lock()</code>轨迹如下:</p>
</blockquote>
<ol>
<li><code>ReentrantLock#lock</code>方法</li>
<li><code>NonfairSync#lock</code>方法</li>
<li><code>AbstractQueuedSynchronzed#acquire</code> -&gt; <code>AbstractQueuedSynchronized#acquireQueued</code>方法</li>
<li><code>NonfairSync#tryAcquire</code> -&gt; <code>NonfairSync.nonfairTryAcquire</code>方法</li>
<li><code>AbstractQueuedSynchronized#compareAndSetState</code>方法</li>
</ol>
<blockquote>
<p><code>AbstractQueuedSynchronized#compareAndSetState</code>方法源码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法以原子操作的方式更新<code>state</code>变量，<code>compareAndSet</code>方法即<strong>CAS</strong>。<strong>JDK</strong>文档对该方法的说明如下：</p>
<p>如果当前状态值等于预期值则以原子的方法将同步状态更新为给定的值。此操作具有<code>volatile</code>读和写的内存语义。<strong>编译器不会对<code>volatile</code>写与<code>volatile</code>写之前的任意内存操作重排序，也不会对<code>volatile</code>与<code>volatile</code>读之后的任意操作重排序，所以CAS操作不能对CAS与CAS前后的操作重排序</strong></p>
</blockquote>
<blockquote>
<p>公平锁和非公平锁内存语义如下:</p>
</blockquote>
<ol>
<li>公平锁和非公平锁释放时，都会最后写<code>volatile</code>变量<strong>state</strong></li>
<li>公平锁获取锁时，会先读<code>volatile</code>变量<strong>state</strong></li>
<li>非公平锁获取时，会使用CAS操作更新<code>volatile</code>变量，这个操作具有<code>volatile</code>读和写的内存语义</li>
</ol>
<blockquote>
<p><code>ReentrantLock</code>分析得出，锁释放-获取内存语义实现至少有以下两种方式：</p>
</blockquote>
<ul>
<li>利用<code>volatile</code>变量的写-读所具有的内存语义</li>
<li>利用CAS所附带的<code>volatile</code>读和<code>volatile</code>写的内存语义</li>
</ul>
<h6 id="4-concurrent包的实现"><a href="#4-concurrent包的实现" class="headerlink" title="4. concurrent包的实现"></a>4. concurrent包的实现</h6><blockquote>
<p>Java的CAS具有<code>volatile</code>的读和写的内存语义，所以Java线程之前通信有四种方式：</p>
</blockquote>
<ol>
<li>A线程写<code>volatile</code>变量，随后B线程读这个<code>volatile</code>变量。  </li>
<li>A线程写<code>volatile</code>变量，随后B线程用CAS更新这个<code>volatile</code>变量。 </li>
<li>A线程用<strong>CAS</strong>更新一个<code>volatile</code>变量，随后B线程用<strong>CAS</strong>更新这个<code>volatile</code>变量。 </li>
<li>A线程用<strong>CAS</strong>更新一个<code>volatile</code>变量，随后B线程读这个<code>volatile</code>变量</li>
</ol>
<blockquote>
<p><strong><code>concurrent</code>包的通用化实现模式：</strong></p>
</blockquote>
<ol>
<li><strong>声明共享变量为<code>volatile</code></strong></li>
<li><strong>使用CAS的原子条件更新实现线程之间的同步</strong></li>
<li><strong>配合<code>volatile</code>的读/写和CAS具有的<code>volatile</code>读和写的内存语义实现线程之间的通信</strong></li>
</ol>
<blockquote>
<p>AQS，非阻塞数据结构和原子变量类(<code>java.util.concurrent.atomic.*</code>)等基础类都是使用这种模式实现的。<code>concurrent</code>包中的高层类依赖于这些基础类实现。<code>concurrent</code>包的实现示意图如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/20.jpg" alt="concurrent包的实现示意图"></p>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile内存语义</title>
    <url>/blog/2019/04/24/concurrent/chapter3/3.4_volatile/</url>
    <content><![CDATA[<h6 id="1-volatile内存语义"><a href="#1-volatile内存语义" class="headerlink" title="1. volatile内存语义"></a>1. <code>volatile</code>内存语义</h6><blockquote>
<p><code>volatile</code>语义是把对<code>volatile</code>变量的单个读/写，看成是使用同一个锁对单个读/写操作做了同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用volatile声明64位的long变量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> v1 = <span class="number">0L</span>;</span><br><span class="line">	<span class="comment">// 单个volatile变量的写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        v1 = l;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 复合(多个)volatile变量的读/写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        v1++;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 单个volatile变量的读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample1</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 64位的long普通变量</span></span><br><span class="line">    <span class="keyword">long</span> v1 = <span class="number">0L</span>;</span><br><span class="line">	<span class="comment">// 单个普通变量的写用同一个锁同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        v1 = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        <span class="keyword">long</span> tmp = get();</span><br><span class="line">        <span class="comment">// 普通的写操作</span></span><br><span class="line">        tmp += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 调用已同步的写操作</span></span><br><span class="line">        set(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 对单个普通变量的读操作使用同一个锁同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上两个类的效果一样。 一个<code>volatile</code>变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，其执行效果相同。</p>
</blockquote>
<blockquote>
<p>锁的<code>happens-before</code>规则保证释放锁和获取锁两个线程之间的内存可见性，对于<code>volatile</code>变量来说，对于一个<code>volatile</code>的读，总是能看到(任意线程)对这个<code>volatile</code>变量的写操作。</p>
</blockquote>
<blockquote>
<p>锁的语义决定了临界区代码的执行具有原子性。如果是多个<code>volatile</code>操作或者类似于<code>volatile++</code>的复合操作，这些操作不具有原子性。<code>volatile++</code>是先读后写的复合操作。**<code>volatile</code>变量具有以下特性:**</p>
</blockquote>
<ul>
<li>可见性。对一个<code>volatile</code>变量的读，总是能看到(任意线程)对这个<code>volatile</code>变量最后的写入</li>
<li>原子性。对任意单个<code>volatile</code>变量的读/写操作具有原子性，但是类似于<code>volatile++</code>的复合操作不具有原子性</li>
</ul>
<h6 id="2-volatile-写-读建立的-happens-before-关系"><a href="#2-volatile-写-读建立的-happens-before-关系" class="headerlink" title="2. volatile 写 - 读建立的 happens-before 关系"></a>2. <code>volatile</code> 写 - 读建立的 <code>happens-before</code> 关系</h6><blockquote>
<p><code>volatile</code>对内存可见性的影响比<code>volatile</code>自身的特性更重要。<code>volatile</code>变量的写 - 读可以实现线程之间的通信。<code>volatile</code>的写 - 读与锁的释放 - 获取有相同的内存语义。见下例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;          <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;    <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;      <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;  <span class="comment">// 4</span></span><br><span class="line">            <span class="comment">// ······</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，假设线程A执行<code>writer()</code>之后，线程B执行<code>reader()</code>，根据<code>happens-before</code>规则得到如下几点:</p>
</blockquote>
<ul>
<li>根据程序次序规则，1<code>happens-before</code>2，3<code>happens-before</code>4</li>
<li>根据<code>volatile</code>规则，2<code>happens-before</code>3</li>
<li>根据<code>happens-before</code>规则的传递性，2<code>happens-before</code>3</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/15.jpg" alt="happens-before"></p>
<h6 id="3-volatile-写-读内存语义"><a href="#3-volatile-写-读内存语义" class="headerlink" title="3. volatile 写-读内存语义"></a>3. <code>volatile</code> 写-读内存语义</h6><blockquote>
<p><code>volatile</code>内存语义: </p>
</blockquote>
<ul>
<li>当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当读一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存置为无效，线程接下来会从主内存中读取共享变量。</li>
</ul>
<blockquote>
<p>以实例程序<code>VolatileExample</code>为例，<code>volatile</code>写和<code>volatile</code>读综合起来看，线程B读一个<code>volatile</code>变量后，写线程A在写这个<code>volatile</code>变量<strong>之前所有可见的共享变量的值</strong>都将立即变得对读线程B可见。</p>
</blockquote>
<ul>
<li>线程A写一个<code>volatile</code>变量，实质上是线程A向接下来将要读这个<code>volatile</code>变量的某个线程发出了（其对共享变量所做修改的）消息</li>
<li>线程B读一个<code>volatile</code>消息，实质上是线程B接收了之前某个线程发出的（在写这个<code>volatile</code>变量之前对共享变量所做的修改的）消息</li>
<li>线程A写一个<code>volatile</code>变量，随后线程B读这个<code>volatile</code>变量，这个过程实际上是线程A通过主内存向线程B发送消息</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/16.jpg" alt="共享变量状态"></p>
<h6 id="4-volatile内存语义的实现"><a href="#4-volatile内存语义的实现" class="headerlink" title="4. volatile内存语义的实现"></a>4. <code>volatile</code>内存语义的实现</h6><blockquote>
<p>重排序分为编译器排序和处理器排序，为了实现<code>volatile</code>内存语义JMM会分别限制这两种类型的重排序类型。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/17.jpg" alt="volatile重排序规则表"></p>
<blockquote>
<p>可得出以下结论:</p>
</blockquote>
<ul>
<li><p>第二个操作是<code>volatile</code>写时，不管第一个操作是什么，都不能重排序。确保<code>volatile</code>写之前的操作不会被编译器重排序到<code>volatile</code>写之后</p>
</li>
<li><p>第一个操作是<code>volatile</code>读时，不管第二个操作是什么，都不能重排序。确保<code>volatile</code>读之前的操作不会被编译器重排序到<code>volatile</code>读之前</p>
</li>
<li><p>第一个操作是<code>volatile</code>写，第二个操作是<code>volatile</code>读时，不能重排序</p>
</li>
</ul>
<blockquote>
<p>为了实现<code>volatile</code>内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障禁止特定类型的处理器重排序。</p>
</blockquote>
<ul>
<li>在每个<code>volatile</code>写操作前面插入<code>StoreStore</code>屏障</li>
<li>在每个<code>volatile</code>写操作后面插入<code>StoreLoad</code>屏障</li>
<li>在每个<code>volatile</code>读操作后面插入<code>LoadLoad</code>屏障</li>
<li>在每个<code>volatile</code>读操作后面插入<code>LoadStore</code>屏障</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrieExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// volatile 读</span></span><br><span class="line">        <span class="keyword">int</span> i = v1;</span><br><span class="line">        <span class="comment">// volatile 读</span></span><br><span class="line">        <span class="keyword">int</span> j = v2;</span><br><span class="line">        <span class="comment">// 普通写</span></span><br><span class="line">        a = i + j;</span><br><span class="line">        <span class="comment">// volatile 写</span></span><br><span class="line">        v1 = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// volatile 写</span></span><br><span class="line">        v2 = j * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>针对<code>readAndWrite()</code>方法，编译器在生成字节码时会做如下优化:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/18.jpg" alt="指令序列示意图"></p>
<blockquote>
<p>以上优化针对不同处理器平台，不同的内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。</p>
</blockquote>
<h6 id="5-volatile内存语义增强"><a href="#5-volatile内存语义增强" class="headerlink" title="5. volatile内存语义增强"></a>5. <code>volatile</code>内存语义增强</h6><blockquote>
<p>旧的内存模型中，<code>volatile</code>写-读没有锁的释放-获取所具有的的内存语义，即<code>volatile</code>写操作之前写操作并不会被写到内存中。<strong>为了提供一种比锁更轻量级的线程之间通信的机制</strong>，严格限制编译器和处理器对<code>volatile</code>变量与普通变量的重排序，确保<code>volatile</code>写-读和锁的释放-获取具有相同的内存语义</p>
</blockquote>
<blockquote>
<p><code>volatile</code>仅仅保证对单个<code>volatile</code>变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。功能上，锁比<code>volatile</code>更强大；可伸缩性和执行性上，<code>volatile</code>更具有优势</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序一致性</title>
    <url>/blog/2019/04/15/concurrent/chapter3/3.3_order_consistency/</url>
    <content><![CDATA[<blockquote>
<p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。</p>
</blockquote>
<h6 id="1-数据竞争与顺序一致性"><a href="#1-数据竞争与顺序一致性" class="headerlink" title="1. 数据竞争与顺序一致性"></a>1. 数据竞争与顺序一致性</h6><blockquote>
<p>数据未正确同步时，就可能存在数据竞争。Java内存模型规范对数据竞争的定义如下:</p>
</blockquote>
<ul>
<li><strong>在一个线程中写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序。</strong></li>
</ul>
<blockquote>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。若一个多线程程序能正确同步，那么这个程序将是一个没有数据竞争的程序。</p>
</blockquote>
<blockquote>
<p>JMM对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。同步即广义的同步，包括对<code>synchronized</code>、<code>volatile</code>和<code>final</code>的正确使用</p>
</blockquote>
<h6 id="2-顺序一致性内存模型"><a href="#2-顺序一致性内存模型" class="headerlink" title="2. 顺序一致性内存模型"></a>2. 顺序一致性内存模型</h6><blockquote>
<p>顺序一致性内存模型是一个被计算机科学家理想化的理论参考模型，其有两大特性；</p>
</blockquote>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行</li>
<li>（无论程序是否同步）所有线程都只能看到一个单一的操作执行顺序，在顺序一致性模型中，每个操作都是原子执行且必须立刻对所有线程可见</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/13.jpg" alt="顺序一致性模型"></p>
<blockquote>
<p>从概念上讲，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每个线程必须按照程序的顺序来执行内存读/写操作。任意时间点只有一个线程可以连接到内存。当多个线程并发执行时，开关可以把所有线程内存读/写操作串行化（在顺序一致性锁模型中，所有操作之间具有全序关系）。例子见<strong>《Java并发编程的艺术》</strong>page33</p>
</blockquote>
<blockquote>
<p>在JMM中未同步程序整体的执行顺序是无序的，所有线程看到的操作执行顺序也可能不一致。例如当前线程把写过的数据缓存到本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见。</p>
</blockquote>
<h6 id="3-同步程序的顺序一致性效果"><a href="#3-同步程序的顺序一致性效果" class="headerlink" title="3. 同步程序的顺序一致性效果"></a>3. 同步程序的顺序一致性效果</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JMM中临界区域内的代码可以重排序（但JMM不会允许临界区内的代码“溢出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区与进入临界区两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/14.jpg" alt="内存模型中的执行时序对比图"></p>
<blockquote>
<p>线程A和B虽然在各自临界区内做了重排序，但由于监视器互斥执行的特性，线程B无法观察到线程A在临界区内做了重排序，提高了执行效率，也没有改变程序的执行结果。</p>
<p>JMM的具体实现上的基本方针为：<strong>在不改变（正确同步）程序执行结果的前提下，尽可能为编译器和处理器的优化打开方便之门</strong></p>
</blockquote>
<h6 id="4-未同步程序的执行特性"><a href="#4-未同步程序的执行特性" class="headerlink" title="4. 未同步程序的执行特性"></a>4. 未同步程序的执行特性</h6><ul>
<li><input disabled="" type="checkbox"> 阅读原文</li>
</ul>
<blockquote>
<p>JMM对未同步或未正确同步的多线程程序，只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值。为了实现最小安全性，JVM在堆上分配内存对象时，首先会清理内存空间，然后分配对象（JVM内部会同步这两个操作），在以清零的内存空间分配对象时，域的默认初始化已经完成。</p>
</blockquote>
<blockquote>
<p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。要保证执行结果一致，JMM需要禁止大量处理器和编译器的优化，会对程序产生很大影响。</p>
</blockquote>
<blockquote>
<p>为同步程序在JMM中执行时，整体上是无序的，其执行结果也无法预知。未同步程序在两个模型中的执行特性有如下几个差异：</p>
</blockquote>
<ul>
<li><strong>顺序一致性模型保证单线程内的操作会按照顺序执行，而JMM不保证单线程内是按照程序的顺序执行的（在临界区内的重排序）</strong></li>
<li><strong>顺序一致性保证所有线程看到一致的操作执行顺序，JMM不保证所有线程可以看到一致的操作执行顺序</strong></li>
<li><strong>不保证对64位的long型和double型变量的写操作的原子性，顺序一致性保证所有内存的读/写都具有原子性</strong></li>
</ul>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 缓存机制</title>
    <url>/blog/2019/04/15/essay/mybatis_cache/</url>
    <content><![CDATA[<a id="more"></a>


<ul>
<li><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">MyBatis缓存机制</a></li>
</ul>
<blockquote>
<p>MyBatis是常见的Java数据库访问层框架，日常使用中大多使用MyBatis的默认缓存配置，但是当并发量高时会引起脏数据，形成一些潜在的隐患，<a href="https://github.com/kailuncen/mybatis-cache-demo">源码demo</a></p>
</blockquote>
<h5 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1. 一级缓存"></a>1. 一级缓存</h5><h6 id="1-一级缓存介绍"><a href="#1-一级缓存介绍" class="headerlink" title="1. 一级缓存介绍"></a>1. 一级缓存介绍</h6><blockquote>
<p>在程序运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存优化这种应用场景，若是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/6e38df6a.jpg" alt="Mysql一级缓存执行过程"></p>
<blockquote>
<p>每个SqlSession中都持有<code>org.apache.ibatis.executor</code>，每个<strong>Executor</strong>中都有<strong>LocalCache</strong>。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在<strong>LocalCache</strong>进行查询，如果缓存命中(<strong>key是根据类名+方法名+参数等生成的</strong>)，直接返回给用户，如果没有命中，查询数据库，结果写入<strong>localCache</strong>，最后返回结果给用户</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BaseExecutor是四种Executor执行器共同的父抽象类，localCache是其成员属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有查询会被加入到一级缓存中</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/d76ec5fe.jpg" alt="Mysql一级缓存执行过程"></p>
<h6 id="2-一级缓存配置"><a href="#2-一级缓存配置" class="headerlink" title="2. 一级缓存配置"></a>2. 一级缓存配置</h6><blockquote>
<p>实现MyBatis的一级缓存，添加如下代码，<code>SESSION</code>表示在MyBatis中执行的所有语句，都会共享这个缓存，<code>STATEMENT</code>，只针对当前<strong>Statement</strong>有效</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocalCacheScope 的缓存类型枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> LocalCacheScope &#123;</span><br><span class="line">  SESSION,STATEMENT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session</span></span><br><span class="line">configuration.setLocalCacheScope(LocalCacheScope.SESSION);</span><br></pre></td></tr></table></figure>

<ul>
<li>开启一级缓存，则同一<strong>SqlSession</strong>中，多次查询只有第一次查询数据库</li>
<li>若同一<strong>SqlSession</strong>中，多次查询中间存在<strong>update</strong>语句，则会使一级缓存失效</li>
<li>SqlSession1和SqlSession2，都查询数据，<strong>Session</strong>间不会共享，一级缓存只会在<strong>Session</strong>范围内共享。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalCacheScope</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">    SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2更新了&quot;</span> + studentMapper2.updateStudentName(<span class="string">&quot;小岑&quot;</span>,<span class="number">1</span>) + <span class="string">&quot;个学生的数据&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>sqlSession2</code>更新了id为1的学生的姓名，从凯伦改为了小岑，但session1之后的查询中，id为1的学生的名字还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部共享。</p>
</blockquote>
<h6 id="3-一级缓存工作流程与源码分析"><a href="#3-一级缓存工作流程与源码分析" class="headerlink" title="3. 一级缓存工作流程与源码分析"></a>3. 一级缓存工作流程与源码分析</h6><blockquote>
<p>一级缓存执行时序图</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/bb851700.png" alt="一级缓存执行时序图"></p>
<blockquote>
<p><code>SqlSession</code>对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层实现细节，默认实现类是<code>DefaultSqlSession</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSession</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String var1, Object var2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处省略部分代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String var1, Object var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Executor</code>: <code>SqlSession</code>向数据库提供操作数据库的方法，但和数据库有关的职责委托给<code>Executor</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ResultHandler NO_RESULT_HANDLER = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Transaction <span class="title">getTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其子类如下:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/83326eb3.jpg" alt="Executor类图"></p>
<blockquote>
<p>首先初始化<code>SqlSessionFactory</code>，<code>SqlSessionFactory</code>获取<code>SqlSession</code>，<code>SqlSession</code>会根据<code>Configuration</code>创建<code>Executor</code>。具体见<code>DefaultSqlSession</code>源码</p>
</blockquote>
<blockquote>
<p>一级缓存中，主要实现在<code>BaseExecutor</code>中，相关源码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 清空缓存 localCache</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">        <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">        clearLocalCache();</span><br><span class="line">        <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">        <span class="comment">// 生成key的规则</span></span><br><span class="line">        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">        <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	<span class="comment">// 省略无关代码</span></span><br><span class="line">        List&lt;E&gt; list;</span><br><span class="line">        <span class="comment">// 根据CacheKey从localCache中获取</span></span><br><span class="line">    	list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存查询为空，则去数据库查询</span></span><br><span class="line">        	list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 此处省略代码</span></span><br><span class="line">        <span class="comment">// 判断一级缓存的级别</span></span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        	clearLocalCache(); <span class="comment">// issue #482</span></span><br><span class="line">      	&#125;</span><br><span class="line">    	<span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  生成key的规则</span></span><br><span class="line"><span class="comment">     * id + offset + limit + sql + parameter + propertyName + additionalParameter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">        CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">        cacheKey.update(ms.getId());</span><br><span class="line">        cacheKey.update(rowBounds.getOffset());</span><br><span class="line">        cacheKey.update(rowBounds.getLimit());</span><br><span class="line">        cacheKey.update(boundSql.getSql());</span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">        <span class="keyword">if</span> (parameterMappings.size() &gt; <span class="number">0</span> &amp;&amp; parameterObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">          <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">            cacheKey.update(parameterObject);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">              String propertyName = parameterMapping.getProperty();</span><br><span class="line">              <span class="keyword">if</span> (metaObject.hasGetter(propertyName)) &#123;</span><br><span class="line">                cacheKey.update(metaObject.getValue(propertyName));</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                cacheKey.update(boundSql.getAdditionalParameter(propertyName));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheKey;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>PerpetualCache</code>是接口<code>Cache</code>的子类之一，内部持有<code>HashMap</code>，对一级缓存的操作实际上是对<code>HashMap</code>的操作，如下是<code>PerpetualCache</code>的部分源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">  <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readWriteLock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Cache instances require an ID.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cache)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Cache otherCache = (Cache) o;</span><br><span class="line">    <span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Cache instances require an ID.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> getId().hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>CacheKey</code>内包含一级缓存key的生成规则，源码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1146682552656046210L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheKey NULL_CACHE_KEY = <span class="keyword">new</span> NullCacheKey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> multiplier;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">    <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    updateAll(objects);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpdateCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> updateList.size();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 由 BaseExecutor#createCacheKey()方法调用</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : object.hashCode();</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAll</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : objects) &#123;</span><br><span class="line">      update(o);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == object) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hashcode != cacheKey.hashcode) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (checksum != cacheKey.checksum) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (count != cacheKey.count) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject = updateList.get(i);</span><br><span class="line">      Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">      <span class="keyword">if</span> (thisObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thatObject != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thisObject.equals(thatObject)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-一级缓存总结"><a href="#4-一级缓存总结" class="headerlink" title="4. 一级缓存总结"></a>4. 一级缓存总结</h6><ul>
<li>MyBatis一级缓存声明周期与SqlSession一致</li>
<li>MyBatis一级缓存内部设计简单，是一个没有容量限制的HashMap，在缓存功能上有所欠缺</li>
<li>MyBatis一级缓存最大范围是SqlSession，在存在多个SqlSession或者分布式环境下，数据库写操作会引起脏数据，建议设定缓存级别的<code>Statement</code></li>
</ul>
<h5 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2. 二级缓存"></a>2. 二级缓存</h5><h6 id="1-二级缓存介绍"><a href="#1-二级缓存介绍" class="headerlink" title="1. 二级缓存介绍"></a>1. 二级缓存介绍</h6><blockquote>
<p>一级缓存中，共享范围与<code>SqlSession</code>一致，但是二级缓存中可以在多个<code>SqlSession</code>之间共享缓存。二级缓存开启后，会使用<code>CachingExecutor</code>装饰<code>Executor</code>，进入一级缓存查询流程前，先在<code>CachingExecutor</code>中进行二级缓存查询，如下是二级缓存工作流程图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/28399eba.png"></p>
<blockquote>
<p>如上图所示，二级缓存开启后，同一个<code>namescape</code>下共用同一个<code>Cache</code>，即被多个<code>SqlSession</code>共享，是一个全局变量，数据执行流程是 二级缓存-&gt;一级缓存-&gt;数据库</p>
</blockquote>
<h6 id="2-二级缓存配置"><a href="#2-二级缓存配置" class="headerlink" title="2. 二级缓存配置"></a>2. 二级缓存配置</h6><blockquote>
<p>开启二级缓存<code>configuration.setCacheEnabled(true)</code>或者<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;</code>。在MyBatis映射XML文件中使用<code>&lt;cache /&gt;</code>或者<code>&lt;cache-ref /&gt;</code>。</p>
</blockquote>
<ol>
<li><p><code>&lt;cache /&gt;</code>标签</p>
<ul>
<li><code>type</code>，默认是<code>PerpetualCache</code></li>
<li><code>eviction</code>，定义回收的策略，常见的由FIFO，LRU，LFU等</li>
<li><code>flushInterval</code>，配置一定时间自动刷新，单位是ms</li>
<li><code>size</code>，配置缓存对象的个数</li>
<li><code>readOnly</code>，是否只读，若配置可读写，则需要对应的实体类可序列化</li>
<li><code>blocking</code>，若缓存中不存在对应的key，是否会阻塞，直到数据进入缓存</li>
</ul>
</li>
<li><p><code>&lt;cache-ref /&gt;</code></p>
<blockquote>
<p>代表引入其他<code>namescape</code>的缓存配置，两个命名空间公用一个Cache，<code>&lt;cache-ref namescape=&quot;mapper.XxxMapper&quot; /&gt;</code></p>
</blockquote>
</li>
<li><p>二级缓存使用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">    SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 注意提交与不提交事务的区别</span></span><br><span class="line">    sqlSession1.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 发生update操作</span></span><br><span class="line">    studentMapper3.updateStudentName(<span class="string">&quot;方方&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    sqlSession3.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>sqlSession1</code>不提交事务时，二级缓存未起作用；<code>sqlSession1</code>事务提交后，二级缓存才会起作用；当发生<code>update</code>操作并提交事务后，二级缓存未起作用，因为update操作清空了二级缓存</p>
</blockquote>
<blockquote>
<p>MyBatis的二级缓存不适应用于映射文件中存在多表查询的情况。我们为每个数据库表创建单独的映射文件，所以如果二级缓存也是基于<code>namescape</code>的，多表查询语句所在的<code>namescape</code>无法感应到关联表所在的<code>namescape</code>对多表查询中涉及的修改，引发脏数据问题。所以使用<code>&lt;cache-ref=&quot;mapper.namescape&quot;&gt;</code>与关联表共用一个<code>namescape</code>，以实现公用一个Cache的目的</p>
</blockquote>
<h6 id="3-二级缓存源码"><a href="#3-二级缓存源码" class="headerlink" title="3. 二级缓存源码"></a>3. 二级缓存源码</h6><blockquote>
<p>MyBatis的二级缓存工作流程与一级缓存类似，在一级缓存处理前，用<code>CachingExecutor</code>装饰了<code>BaseExecutor</code>，在具体的工作委托给<code>delegate</code>之前，实现了二级缓存的查询与写入功能。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">private</span> Executor delegate;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> autoCommit;</span><br><span class="line">  	<span class="comment">// 保存了Cache和TransactionalCache的映射关系，CachingExecutor会默认使用他包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响。</span></span><br><span class="line">    <span class="comment">// 见下方源码 TransactionalCacheManager 类</span></span><br><span class="line">    <span class="keyword">private</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> dirty;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    	CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    	<span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 二级缓存</span></span><br><span class="line">        Cache cache = ms.getCache();</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否需要刷新缓存，默认 select 不会刷新缓存，但是 insert/delete/update 会刷新缓存</span></span><br><span class="line">            flushCacheIfRequired(ms);</span><br><span class="line">            <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="comment">// 处理存储过程</span></span><br><span class="line">                ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">                <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">                    cache.getReadWriteLock().readLock().lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 二级缓存查询命中后直接返回</span></span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        List&lt;E&gt; cachedList = (List&lt;E&gt;) cache.getObject(key);</span><br><span class="line">                        <span class="keyword">if</span> (cachedList != <span class="keyword">null</span>) <span class="keyword">return</span> cachedList;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cache.getReadWriteLock().readLock().unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 二级缓存未命中，则去一级缓存或者数据库查询(BaseExecutor)</span></span><br><span class="line">                List&lt;E&gt; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">            	<span class="comment">// 将一级缓存或者数据库查询返回的结果放到tcm持有的缓存中，等待数据提交后再放到Cache中</span></span><br><span class="line">                <span class="comment">// TransactionalCacheManager#putObject()</span></span><br><span class="line">                tcm.putObject(cache, key, list);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">    <span class="comment">// 事务提交后，将</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	delegate.commit(required);</span><br><span class="line">    	tcm.commit();</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要刷新缓存，insert/update/delete操作会刷新缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">        Cache cache = ms.getCache();</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        	dirty = <span class="keyword">true</span>;</span><br><span class="line">          	tcm.clear(cache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 维护的是Cache和用TransactionalCache包装后的Cache的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;Cache, TransactionalCache&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TransactionalCache#putObject</span></span><br><span class="line">    	getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// tcm事务提交</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      		<span class="comment">// 提交 待提交缓存中的数据</span></span><br><span class="line">            txCache.commit();</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ······ 此处省略代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    	TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">    	<span class="keyword">if</span> (txCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      		txCache = <span class="keyword">new</span> TransactionalCache(cache);</span><br><span class="line">      		transactionalCaches.put(cache, txCache);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> txCache;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// ······ 此处省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">private</span> Cache delegate;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> clearOnCommit;</span><br><span class="line">  	<span class="keyword">private</span> Map&lt;Object, AddEntry&gt; entriesToAddOnCommit;</span><br><span class="line">  	<span class="keyword">private</span> Map&lt;Object, RemoveEntry&gt; entriesToRemoveOnCommit;</span><br><span class="line">    <span class="comment">// ······ 此处省略代码</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 从二级缓存中获取数据</span></span><br><span class="line">    	Object object = delegate.getObject(key);</span><br><span class="line">    	<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用于统计缓存命中率</span></span><br><span class="line">      		entriesMissedInCache.add(key);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// issue #146</span></span><br><span class="line">    	<span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      		<span class="keyword">return</span> object;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">    <span class="comment">// 将查询结果缓存到待提交事务缓存中，只有当事务提交后对缓存的操作才会生效，事务回滚或者不生效，则不对缓存产生影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">    	entriesToRemoveOnCommit.remove(key);</span><br><span class="line">    	entriesToAddOnCommit.put(key, <span class="keyword">new</span> AddEntry(delegate, key, object));</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// ······ 此处省略代码</span></span><br><span class="line">    <span class="comment">// 清空缓存</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">    	entriesToAddOnCommit.clear();</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// 提交事务后，将待提交的数据提交到二级缓存中，并清空缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      		delegate.clear();</span><br><span class="line">    	&#125;</span><br><span class="line">    	flushPendingEntries();</span><br><span class="line">    	reset();</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">    <span class="comment">// 将待提交的缓存数据提交到二级缓存中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历待提交的缓存数据</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">          	<span class="comment">// 将待提交的Map进行循环处理，委托给包装的Cache类，进行putObject的操作</span></span><br><span class="line">            delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">          	<span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">            	delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">&#125;    								</span><br></pre></td></tr></table></figure>



<blockquote>
<p>List<E> cachedList = (List<E>) cache.getObject(key);`本质是装饰者模式的应用，装饰链是:</p>
<p>SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; LruCache -&gt; PerpetualCache。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/1f5233b2.jpg" alt="装饰链"></p>
<ul>
<li><code>SynchronizedCache</code>，同步Cache，直接使用<code>synchronized</code>关键字修饰。</li>
<li><code>LoggingCache</code>，日志功能，装饰类，用于记录缓存的命中率，若开始debug模式，则会输出日志命中率。</li>
<li><code>SerializedCache</code>，序列化功能，将结果值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。</li>
<li><code>LruCache</code>，采用了Lru算法的Cache实现，移除最近最少使用的Key/Value。</li>
<li><code>PerpetualCache</code>， 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap。</li>
</ul>
<h6 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h6><ol>
<li>Mybatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间的数据共享，同时粒度更细，<code>namescape</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻</li>
<li>分布式环境下，默认的<strong>MyBatis Cache</strong>实现都是基于本地存储的，分布式环境下必然会出现读取脏数据，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>指令重排序</title>
    <url>/blog/2019/04/15/concurrent/chapter3/3.2_instrction_reordering/</url>
    <content><![CDATA[<blockquote>
<p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p>
</blockquote>
<h6 id="1-数据依赖性"><a href="#1-数据依赖性" class="headerlink" title="1. 数据依赖性"></a>1. 数据依赖性</h6><blockquote>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，那么这两个操作之间就存在数据依赖性。数据依赖分为三种类型：</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>写后读</td>
<td>a=1;b=a</td>
<td>写一个变量之后，再读这个变量</td>
</tr>
<tr>
<td>写后写</td>
<td>a=1;a=2</td>
<td>写一个变量之后，再写这个变量</td>
</tr>
<tr>
<td>读后写</td>
<td>a=b;b=1</td>
<td>读一个变量之后，再写这个变量</td>
</tr>
</tbody></table>
<blockquote>
<p>只要重新排序两个操作的执行顺序，程序的执行结果就会被改变。编译器和处理器在重排序时会遵守<strong>数据依赖性</strong>，不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p><strong>数据依赖性仅仅针对单个处理器中执行的指令序列和单个线程中执行的操作顺序</strong>，不同处理器或者不同线程之间的数据依赖不会被编译器和处理器考虑。</p>
</blockquote>
<h6 id="2-as-if-serial-语义"><a href="#2-as-if-serial-语义" class="headerlink" title="2. as-if-serial 语义"></a>2. as-if-serial 语义</h6><blockquote>
<p><strong>as-if-serial</strong>语义是不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。<strong>编译器、runtime和处理器都必须遵守as-if-serial语义</strong>。</p>
<p>编译器和处理器遵守<strong>as-if-serial</strong>规则，不会对存在数据依赖关系的操作做重排序。但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p><strong>as-if-serial</strong>语义把单线程程序保护了起来，使得单线程程序看起来是按照程序的顺序执行的。</p>
</blockquote>
<blockquote>
<p>软件技术和硬件技术有一个共同的目标：<strong>在不改变程序执行结果的前提下，尽可能提高并行度。</strong></p>
</blockquote>
<h6 id="3-重排序对多线程的影响"><a href="#3-重排序对多线程的影响" class="headerlink" title="3. 重排序对多线程的影响"></a>3. 重排序对多线程的影响</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;				<span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;		<span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;			<span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a;	<span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程A执行<code>writer</code>方法，线程B执行<code>reader()</code>方法。因为操作1和2,3和4没有数据依赖关系，所以编译器和处理器可以对这两个操作重排序。根据重排序的情况不同产生不同的结果</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/11.jpg" alt="指令重排"></p>
<blockquote>
<p>上图，操作1和操作2做了重排序</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/12.jpg" alt="指令重排"></p>
<blockquote>
<p>上图中操作3和操作4做了重排序，操作3和操作4是控制依赖关系，会影响指令序列执行的并行度，编译器和处理器会采用猜测执行来克服控制相关性对并行度的影响。以处理器的猜测为例，处理器会提前读取并计算，然后把计算结果临时保存到一个名为重排序缓冲的硬件缓存中，当操作3判断为真时，把变量结果写入到变量i中。</p>
<p><strong>as-if-serial</strong>语义允许对存在控制依赖的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制依赖的操作重排序，会改变程序的执行结果。</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型的基础</title>
    <url>/blog/2019/04/14/concurrent/chapter3/3.1_JMM/</url>
    <content><![CDATA[<blockquote>
<p>Java内存模型的基础</p>
</blockquote>
<h6 id="1-并发编程模型的两个关键问题"><a href="#1-并发编程模型的两个关键问题" class="headerlink" title="1. 并发编程模型的两个关键问题"></a>1. 并发编程模型的两个关键问题</h6><blockquote>
<p>并发编程中，需要处理两个关键问题</p>
</blockquote>
<ol>
<li>线程之间如何通信，以什么机制交换信息</li>
<li>线程之间如何同步</li>
</ol>
<blockquote>
<p>线程之间通信机制有两种</p>
</blockquote>
<ul>
<li>共享内存：线程间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信</li>
<li>消息传递：线程之间没有公共状态，而是必须通过发送消息进行显式通信</li>
</ul>
<blockquote>
<p>同步指程序中用于控制不同线程间操作发生相对顺序的机制。</p>
</blockquote>
<ul>
<li>共享内存模型中，同步是显式的，必须显式指定某个方法或者某块代码需要在线程之间互斥</li>
<li>消息传递模型中，同步是隐式的，因为消息的发送必须消息的接收之前</li>
</ul>
<blockquote>
<p>Java的并发采用的是共享内存模型，Java线程之间的通信是隐式的</p>
</blockquote>
<h6 id="2-Java内存模型的抽象结构"><a href="#2-Java内存模型的抽象结构" class="headerlink" title="2. Java内存模型的抽象结构"></a>2. Java内存模型的抽象结构</h6><blockquote>
<p>实例域、静态域和数组元素(即”共享变量”)都存储在堆内存中，<strong>堆内存在线程之间共享</strong></p>
</blockquote>
<blockquote>
<p><strong>局部变量、方法定义参数和异常处理参数不会在线程之间共享</strong>，所以也不会有内存可见性问题，也不受内存模型的影响</p>
</blockquote>
<blockquote>
<p>Java线程之间的通信由<strong>Java内存模型</strong>(JMM)控制。</p>
<p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>本地内存并不真实存在，涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
</blockquote>
<blockquote>
<p>举例如下： 线程A与线程B通信，必须需要线程A把本地内存中更新过的共享变量刷新到主内存中去，线程B到主内存中去读取线程A之前已更新过的共享变量</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/06.jpg"></p>
<blockquote>
<p>总体来看，线程A与线程B通信必须经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为保证可见性。以下两个问题可结合Java锁机制考虑。</p>
<ol>
<li>线程A何时将x=1写入到主内存</li>
<li>线程B何时从主内存读取x=1</li>
</ol>
</blockquote>
<h6 id="3-源代码到指令序列的重排序"><a href="#3-源代码到指令序列的重排序" class="headerlink" title="3. 源代码到指令序列的重排序"></a>3. 源代码到指令序列的重排序</h6><blockquote>
<p>为了提高程序性能，编译器和处理器常常对指令做重排序，重排序有3中类型：</p>
</blockquote>
<ol>
<li><strong>编译器优化重排序</strong>。编译器会在不改变单线程程序语义的前提下，重新安排语句的执行顺序，属于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。</li>
<li><strong>指令级并行的重排序</strong>。处理器采用**指令并行技术(Instruction-Level Parallelism,ILP)**来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li><strong>内存系统的重排序</strong>。由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去在乱序执行</li>
</ol>
<blockquote>
<p>对于指令级并行的重排序和内存系统的重排序，JMM的处理器重排序规则会要求Java编译器生成指令序列时，插入特定类型的<strong>内存屏障</strong>指令，禁止特定类型的处理器重排序</p>
</blockquote>
<blockquote>
<p>如下是Java源代码到最终执行的指令序列</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/07.jpg" alt="指令排序"></p>
<h6 id="4-并发编程模型的分类"><a href="#4-并发编程模型的分类" class="headerlink" title="4. 并发编程模型的分类"></a>4. 并发编程模型的分类</h6><blockquote>
<p>现代处理器使用写缓冲区临时保存向内存写入的数据</p>
</blockquote>
<ul>
<li>写缓冲区可以保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟</li>
<li>以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用</li>
<li>每个处理器上的写缓冲区，仅仅对其所在的处理器可见</li>
</ul>
<blockquote>
<p>会对内存操作的执行顺序产生影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写顺序一致，举例如下:</p>
</blockquote>
<blockquote>
<p>处理器操作内存的执行结果</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/08.jpg" alt="处理器操作内存的执行结果"></p>
<blockquote>
<p>与内存的交互过程，处理器A和处理器B可以同时把共享变量写入自己的缓冲区(A1,B1)，然后从内存中读取另一个共享变量(A2,B2)，最后才把自己写缓存区中保存的脏数据刷新到内存中(A3,B3)，这种顺序就会产生x=y=0的结果。</p>
<p>从内存操作的实际方式顺序来说，知道处理器A执行A3刷新自己的写缓存区，写操作A1才算真正完成了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但是内存操作实际上发生的顺序却是A2-&gt;A1。处理器A的内存操作顺序被重排序了，处理器B同样如此</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/09.jpg" alt="处理器与内存的交互"></p>
<blockquote>
<p>处理器的重排序规则</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">处理器\规则</th>
<th align="center">Load-Load</th>
<th align="center">Load-Store</th>
<th align="center">Store-Store</th>
<th align="center">Store-Load</th>
<th align="center">数据依赖</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SPARC-TSO</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">x86</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">IA64</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">PowerPC</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
</tbody></table>
<blockquote>
<p>常见的处理器都允许<strong>Store-Load</strong>重排序；都不允许针对数据依赖的操作重排序；前两个拥有相对较强的内存模型，仅仅允许写-读操作做重排序(因为<strong>都使用了写缓冲区</strong>)</p>
</blockquote>
<blockquote>
<p>前文说过，针对处理器重排序(包括指令级并行的重排序和内存系统的重排序)，JMM会在生成指令序列的适当位置插入<strong>内存屏障</strong>指令禁止特定类型的处理器重排序，JMM把内存屏障指令分为4类</p>
</blockquote>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>确保Load1数据的装载先于Load2及所有后续装载指令的装载</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>确保Store1数据对其他处理器可见(刷新到内存)先于Store2及所有后续存储指令的存储</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore;Store2</td>
<td>确保Load1数据装载先于Store2及所有后续存储指令刷新到内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad;Load2</td>
<td>确保Store1数据对其他处理器变得可见(刷新到内存)先于Load2及所有后续装载指定的装载。该指令会使该屏障之前的所有内存访问指令(Load和Store)完成之后，才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<blockquote>
<p>StoreLoad Barriers是全能型指令，具有其他三个屏障的效果。执行屏障开销会很昂贵，因为当前处理器通常要把缓冲区中的数据全部刷新到内存中</p>
</blockquote>
<h6 id="5-happens-before简介"><a href="#5-happens-before简介" class="headerlink" title="5. happens-before简介"></a>5. happens-before简介</h6><blockquote>
<p>JDK 5开始，Java使用了JSR-133内存模型。JSR-133使用<strong>happens-before</strong>概念来阐述操作之间的内存可见性。如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间的必须存在<strong>happens-before</strong>关系。与程序员相关的<strong>happens-before</strong>关系如下:</p>
</blockquote>
<ul>
<li>程序顺序规则：一个线程中的每个操作，<strong>happens-before</strong>于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，<strong>happens-before</strong>于随后对这个锁的加锁</li>
<li>volatile常量规则：对一个volatile域的写，<strong>happens-before</strong>于任意后续对这个volatile域的读</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ul>
<blockquote>
<p>两个操作之间具有happens-before关系，并不意味着一个操作必须要在后一个操作之前执行。仅仅要求前一个操作对于后一个操作可见，且前一个操作按顺序排在第二个操作之前。happens-before与JMM关系如下:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/10.jpg" alt="happens-before与JMM的关系"></p>
<blockquote>
<p>一个<strong>happens-before</strong>规则对应于一个或多个编译器和处理器重排序规则</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>原子操作的实现原理</title>
    <url>/blog/2019/04/13/concurrent/chapter2/2.3_atomic/</url>
    <content><![CDATA[<blockquote>
<p>原子(atomic)，指不能被分割的最小粒子。原子操作(atomic operation)指不可被中断的一个或者一系列操作。Intel处理器和Java实现原子操作原理如下：</p>
</blockquote>
<h6 id="1-CPU术语定义"><a href="#1-CPU术语定义" class="headerlink" title="1. CPU术语定义"></a>1. CPU术语定义</h6><table>
<thead>
<tr>
<th>术语名称</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>缓存行</td>
<td>Cache line</td>
<td>缓存的最小操作单位</td>
</tr>
<tr>
<td>比较并交换</td>
<td>Compare and Swap</td>
<td>CAS操作需要输入两个数值，一个旧值和一个新值，在操作期间先比较旧值是否发生变化，没有变化才会换成新值，发生变化了则不交换</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>CPU pipeline</td>
<td>CPU流水线像工业生产上的装配流水线。CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条x86指令分成5</del>6步由这些电路单元分别执行，这样可以在CPU一个时钟周期内完成一条指令，提高了CPU运算速度</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td>Memory order violation</td>
<td>内存顺序冲突一般由假共享引起。假共享是指多个CPU同时修改同一个缓存行的不同部分引起其中一个CPU操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线</td>
</tr>
</tbody></table>
<h6 id="2-处理器如何保证原子操作"><a href="#2-处理器如何保证原子操作" class="headerlink" title="2. 处理器如何保证原子操作"></a>2. 处理器如何保证原子操作</h6><blockquote>
<p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。首先处理器会自动保证基本的内存操作的原子性，指处理器读取一个字节时，其他处理器不能访问这个字节内存地址。复杂的内存操作处理器是不能自动保证原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。为此，处理器提供了总线锁定和缓存锁定两个机制保证复杂内存操作的原子性。</p>
</blockquote>
<ol>
<li><p>使用总线保证原子性</p>
<blockquote>
<p>多个处理器同时对共享变量进行读写改操作（例如，i++操作），那么共享变量就会被多个处理器同时进行操作，这样操作就是非原子性的，可能出现共享变量的值和期望值不一样。总线锁是使用处理器提供的一个**LOCK#**信号，当一个处理器在总线上输出此信号时，其他处理器请求将被阻塞住，使改处理器独享内存</p>
</blockquote>
</li>
<li><p>缓存锁保证原子性</p>
<blockquote>
<p>为了保证原子性，我们只需要保证对某个内存地址的操作是原子性即可。而总线开销比较大，因为<strong>LOCK#**把CPU和内存之间的通信锁住了，锁住期间处理器不能操作其他内存地址的数据，所以使用</strong>缓存锁定**代替总线锁定进行优化。</p>
</blockquote>
<blockquote>
<p><strong>缓存一致性机制</strong>会阻止同时修改由两个以上处理器缓存的内存区域数据。</p>
<p><strong>缓存锁定</strong>指的是内存区域如果被缓存在处理器的缓存行中，由于缓存一致性机制不能存在两个处理器同时修改处理器缓存的内存区域，那么在LOCK期间会被锁定，当它执行锁操作回写到内存时，处理器不能在总线上声言**LOCK#**信号，而是修改内部的内存地址，当其他处理器回写被锁定的缓存行的数据时，会使缓存行无效。如下图所示，当CPU1修改缓存行中的i时会使用缓存锁定，那么CPU2就不能同时缓存i的缓存行。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/05.jpg" alt="缓存锁定"></p>
<blockquote>
<p>有两种情况处理器不会使用缓存锁定，会直接使用总线锁定</p>
</blockquote>
<ul>
<li>当操作的数据不能缓存在处理器内部或者数据库跨多个缓存行时</li>
<li>处理器不支持缓存锁定</li>
</ul>
</li>
</ol>
<h6 id="3-Java如何实现原子操作"><a href="#3-Java如何实现原子操作" class="headerlink" title="3. Java如何实现原子操作"></a>3. Java如何实现原子操作</h6><blockquote>
<p>Java可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作</p>
</blockquote>
<ol>
<li><p>JVM中的CAS操作是利用了处理器提供的<strong>CMPXCHG</strong>指令实现的。<strong>自旋CAS</strong>实现的基本思路就是进行CAS操作直到成功为止。</p>
<blockquote>
<p>JDK的并发包里面提供了一些类支持原子操作，例如<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>等。<a href="https://dev.tencent.com/u/effiu/p/essay-project/git/blob/master/src/main/java/com/effiu/essay/concurrent/learn/chapter2/Counter.java">代码见</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Counter cas = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">600</span>);</span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                cas.count();</span><br><span class="line">                cas.safeCount();</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadList.stream().forEach(p -&gt; p.start());</span><br><span class="line">        <span class="comment">//等待所有的线程执行完成</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threadList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非线程安全计数器结果值不唯一</span></span><br><span class="line">        System.out.println(cas.i);</span><br><span class="line">        <span class="comment">// 计数结果是100</span></span><br><span class="line">        System.out.println(cas.atomicInteger.get());</span><br><span class="line">        System.out.println(System.currentTimeMillis() - l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用CAS实现线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = atomicInteger.get();</span><br><span class="line">            <span class="keyword">boolean</span> b = atomicInteger.compareAndSet(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CAS实现原子操作存在3个问题</p>
<ol>
<li><strong>ABA问题</strong>，CAS操作需要在操作值的时候，检查值有没有发生变化，没有发生变化则更新。</li>
</ol>
<blockquote>
<p>CAS操作会产生一个问题.ABA问题，即A-&gt;B-&gt;A，CAS检查不出这种操作。其解决思路是使用版本号，在变量前面加上版本号。即1A-&gt;2B-&gt;3A。<code>java.util.concurrent.atomic.AtomicStampedReference</code>类解决ABA问题，<code>java.util.concurrent.atomic.AtomicStampedReference#compareAndSet</code>方法作用是首先检查当前引用是否等于预期引用，然后检查当前标志是否等于预期标志，只有全部相等，才能以原子的方式修改引用与标志。</p>
</blockquote>
<ol start="2">
<li>循环时间长开销大</li>
</ol>
<blockquote>
<p>CAS自旋长时间不成功，会给CPU带来非常大的执行开销。JVM能支持处理器提供的<strong>pause</strong>指令，使效率有一定的提升。<strong>pause</strong>指令有两个作用：</p>
</blockquote>
<ul>
<li>延迟流水线执行指令，使CPU不会消耗过多执行资源。</li>
<li>避免在退出循环的时候因为内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行资源。</li>
</ul>
<ol start="3">
<li>只能保证一个共享变量的原子操作</li>
</ol>
<blockquote>
<p>对多个共享变量操作时，循环CAS无法保证操作的原子性。可以使用<strong>锁</strong>或者把多个共享变量合并成一个共享变量来操作。<code>java.util.concurrent.atomic.AtomicReference</code>保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作。</p>
</blockquote>
</li>
<li><p>锁机制实现原子操作</p>
<blockquote>
<p><strong>锁机制保证了只有获得锁的线程才能够操作锁定的区域</strong>。JVM内部实现了多种锁机制。例如<strong>偏向锁、轻量级锁、重量级锁</strong>，除了偏向锁，JVM实现锁的方式都使用了循环CAS，即线程获得锁和释放锁时都是用循环CAS机制。</p>
</blockquote>
</li>
</ol>
<h6 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h6><blockquote>
<p>介绍了<code>volatile</code>、<code>synchronized</code>和原子操作的实现原理。Java中的大部分容器和框架都依赖于本章介绍的<code>volatile</code>和原子操作的实现原理</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized</title>
    <url>/blog/2019/04/09/concurrent/chapter2/2.2_synchronized/</url>
    <content><![CDATA[<blockquote>
<p>Java SE 1.6对<code>synchronized</code>进行了各种优化，本文介绍了Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</p>
</blockquote>
<h6 id="1-synchronized-发音-sɪŋkrənaɪzd"><a href="#1-synchronized-发音-sɪŋkrənaɪzd" class="headerlink" title="1. synchronized 发音 [sɪŋkrənaɪzd]"></a>1. synchronized 发音 [sɪŋkrənaɪzd]</h6><blockquote>
<p><code>synchronized</code>实现同步的基础：Java中每个对象都可以作为锁，具体表现为3种形式：</p>
</blockquote>
<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前<strong>Class</strong>对象</li>
<li>对于同步方法块，锁是<code>Synchronized</code>括号里配置的对象</li>
</ul>
<blockquote>
<p>当一个线程试图访问同步代码块时，必须先得到锁，退出或者抛出异常必须释放锁。</p>
<p><code>Synchronized</code>在JVM里的实现原理，JVM基于进入和退出<strong>Monitor</strong>对象来实现方法同步和代码块同步，但是实现细节不一样。代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现，而方法的同步是使用另外一种方式实现的。</p>
<p><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，<code>monitorexit</code>是插入到方法结束处和异常处，JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。任何对象都有一个<code>monitor</code>与之关联，当一个<code>monitor</code>被持有后，它将处于锁定状态。线程执行到<code>monitorenter</code>时，会尝试获取对象所对应的<code>monitor</code>所有权，即尝试获得对象锁。</p>
</blockquote>
<h6 id="2-Java对象头"><a href="#2-Java对象头" class="headerlink" title="2. Java对象头"></a>2. Java对象头</h6><blockquote>
<p><code>synchronized</code>用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，若非数组类型，则用2个字宽存储对象头。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">32/64bit</td>
<td>Mark Word</td>
<td>存储对象的hashCode、分代年龄和锁标记位</td>
</tr>
<tr>
<td align="center">32/64bit</td>
<td>Class Metadata Address</td>
<td>存储到对象的类型数据的指针</td>
</tr>
<tr>
<td align="center">32/64bit</td>
<td>Array length</td>
<td>数组的长度(如果当前对象是数组)</td>
</tr>
</tbody></table>
<blockquote>
<p>Java对象头里的<strong>Mark Word</strong>的存储结构</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">25bit</th>
<th align="center">4bit</th>
<th align="center">1bit是否偏向锁</th>
<th align="center">2bit锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无锁状态</td>
<td align="center">对象的hashCode</td>
<td align="center">对象分代年龄</td>
<td align="center">0</td>
<td align="center">01</td>
</tr>
</tbody></table>
<blockquote>
<p>运行期间<strong>Mark Word</strong>里存储的数据会随着标志位的变化而变化，如下图:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/01.jpg" alt="Mark Word变化"></p>
<blockquote>
<p>64位虚拟机下，Mark Word是64位大小，存储结构如下:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/02.jpg" alt="Mark Word存储结构"></p>
<h6 id="3-锁的升级与对比"><a href="#3-锁的升级与对比" class="headerlink" title="3. 锁的升级与对比"></a>3. 锁的升级与对比</h6><blockquote>
<p>Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗，引入的“偏向锁”和“轻量级锁”，锁共有四种状态，级别从高到低依次是<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁</strong>、<strong>重量级锁</strong>，会随着竞争情况逐渐升级。锁可以升级但不能降级，这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
</blockquote>
<ol>
<li><p>偏向锁</p>
<ul>
<li><input disabled="" type="checkbox"> CAS 算法原理</li>
</ul>
<blockquote>
<p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中记录并存储偏向锁的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单验证下对象头的Mark Word里是否存储着指向当前线程的偏向锁，验证成功，则说明已经获得了锁；验证失败，则需要在验证下Mark Word 中偏向锁的标识是否设置成1(表示当前是偏向锁)；若没有则使用CAS竞争锁；若设置了，则使用CAS将对象头的偏向锁指向当前线程</p>
</blockquote>
<ol>
<li><p>偏向锁的撤销</p>
<blockquote>
<p>偏向锁使用了一种等到竞争出现才会释放所的机制。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，若线程不处于活动状态，则将对象头设置成无锁状态；若线程仍活着，则拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁，最后唤醒暂停的线程</p>
</blockquote>
</li>
</ol>
<p><img src="https://images.effiu.cn/gitbook/concurrent/04.jpg" alt="偏向锁的获得和插销流程"></p>
<ol start="2">
<li><p>关闭偏向锁</p>
<blockquote>
<p>如果偏向锁在Java 6和Java 7是默认启用的，默认是在程序启动几秒钟后才能激活，可以使用JVM参数关闭延迟</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:biasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若确定应用程序所有锁通常处于竞争状态，通过JVM参数关闭偏向锁，这样程序会默认进入轻量级锁状态</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:UseBiasedLocking=false</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>轻量级锁</p>
<ol>
<li><p>轻量级锁加锁</p>
<blockquote>
<p>线程执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的<strong>Mark Word</strong>复制到锁记录中，然后线程尝试使用CAS将对象头中的**Mark Word(Displaced Mark Word)**替换为指向锁记录的指针，成功则说明线程获得锁；失败表示其他线程竞争锁，当前线程便尝试使用自旋获取锁</p>
</blockquote>
</li>
<li><p>轻量级锁解锁</p>
<blockquote>
<p>轻量级锁解锁时，会使用原子的CAS操作将<strong>Displaced Mark Word</strong>替换回到对象头，如果成功则表示没有竞争发生，若失败锁就会膨胀成重量级锁。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/03.jpg" alt="轻量级锁及膨胀流程图"></p>
<blockquote>
<p>自旋会消耗CPU，所以为了避免无用的自旋，一旦锁升级成重量级锁，就不会恢复成轻量级锁，锁在这个状态下，其他线程试图获取锁时，会被阻塞住，当持有锁的线程释放所之后会唤醒这些线程，被唤醒的线程进入到新一轮竞争中</p>
</blockquote>
</li>
<li><p>锁的优缺点对比</p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在所得竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的相应速度</td>
<td>如果始终得到不锁竞争的线程，使用自旋会消耗CPU追求响应时间</td>
<td>同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile</title>
    <url>/blog/2019/04/07/concurrent/chapter2/2.1_volatile/</url>
    <content><![CDATA[<h6 id="1-volatile-ˈvɑ-lətl-的定义与实现原理"><a href="#1-volatile-ˈvɑ-lətl-的定义与实现原理" class="headerlink" title="1. volatile[ˈvɑ:lətl]的定义与实现原理"></a>1. volatile[ˈvɑ:lətl]的定义与实现原理</h6><blockquote>
<p><code>volatile</code>是轻量级的<code>synchronized</code>[sɪŋkrənaɪzd]，在多处理器并发中保证了共享变量的“可见性”。“可见性”指的是当一个线程修改另一个共享变量时，另一个线程可以读到这个修改的值。使用恰当的话，比<code>synchronized</code>成本低，因为不会引起线程上下文的切换和调度。</p>
</blockquote>
<blockquote>
<p>Java编程语言允许线程访问共享变量，为了确保共享变量被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。如下是<code>volatile</code>实现原理相关的CPU术语与说明</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">术语</th>
<th align="left">英文单词</th>
<th align="left">术语描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存屏障</td>
<td align="left">memory barriers[‘bærɪrz]</td>
<td align="left">是一组处理器指令，用户实现对内存操作的顺序限制</td>
</tr>
<tr>
<td align="left">缓存行</td>
<td align="left">cache line</td>
<td align="left">CPU高速缓存中可以分配最小的存储单位。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令</td>
</tr>
<tr>
<td align="left">原子操作</td>
<td align="left">atomic operation</td>
<td align="left">不可中断的一个或者一系列操作</td>
</tr>
<tr>
<td align="left">缓存行填充</td>
<td align="left">cache line fill</td>
<td align="left">当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存(L1,L2,L3或所有)</td>
</tr>
<tr>
<td align="left">缓存命中</td>
<td align="left">cache hit</td>
<td align="left">如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取</td>
</tr>
<tr>
<td align="left">写命中</td>
<td align="left">write hit</td>
<td align="left">当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存</td>
</tr>
<tr>
<td align="left">写缺失</td>
<td align="left">write misses the cache</td>
<td align="left">一个有效的缓存行被写入到不存在的内存区域</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转变成汇编语言如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x01a3deld: movb $0x0,0x1104800(%esi);</span><br><span class="line">0x01a3de24: lock addl $ 0x0,(%esp);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>volatile</code>变量修饰的共享变量进行写操作时会多出第二行代码，<code>Lock</code>的前缀指令在多核处理器中操作如下:</p>
</blockquote>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</li>
</ul>
<blockquote>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完不知道何时会写到内存。但是如果对声明了<code>volatile</code>的变量进行写操作，JVM就会向处理器发送一条<code>Lock</code>前缀的指令，将这个变量在缓存行的数据写回到系统内存，但是，就算是写回到内存，如果其他处理器缓存的值还是旧值，再执行计算操作就会有问题，所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期了，当处理发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到数据缓存里</p>
</blockquote>
<h6 id="2-volatile使用优化"><a href="#2-volatile使用优化" class="headerlink" title="2. volatile使用优化"></a>2. <code>volatile</code>使用优化</h6><blockquote>
<p>JDK7中<code>LinkedTransferQueue</code>类中使用了一种追加字节的方式来优化队列出队和入队的性能。</p>
</blockquote>
<ol>
<li><p>追加字节优化性能</p>
<blockquote>
<p>一个对象的引用占用4个字节，追加了15个变量(60字节)，所以一共有64个字节</p>
</blockquote>
</li>
<li><p>追加64字节后可以提高并发效率</p>
<blockquote>
<p>对于core i7等处理器的L1、L2、L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着，如果队列的头结点和尾结点都不足64位，处理器会将其读到同一个高速缓存中，多处理器中每个处理器都会缓存同样的头、尾结点，当一个处理器试图修改头结点时，会锁定整个缓存行，在缓存一致性作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，队列的入队和出队操作会不停修改头结点和尾节点，此时会严重影响出队和入队效率。追加字节后头、尾节点在修改时不会互相锁定</p>
</blockquote>
</li>
<li><p>不是在使用<code>volatile</code>变量时都应该追加字节</p>
<ul>
<li>缓存行非64位的处理器，例如奔腾系列</li>
<li>共享变量不会被频繁地写，追加字节会带来一定的性能消耗，如果不频繁的被写，则没必要追加字节</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 命令</title>
    <url>/blog/2019/04/02/essay/linux_cmd/</url>
    <content><![CDATA[<p>linux 命令</p>
<a id="more"></a>

<ol>
<li><p><strong>awk</strong> 命令，<a href="https://www.cnblogs.com/xudong-bupt/p/3721210.html">详情参考</a></p>
<p> awk是行处理器,，以下是部分命令</p>
<ul>
<li>$0 表示整个当前行</li>
<li>$1 表示每行第一个字段</li>
<li><strong>print</strong> 是awk打印指定内容的主要命令</li>
</ul>
<ol start="2">
<li><p><strong>sort</strong> 命令，<a href="http://www.cnblogs.com/fulucky/p/8022718.html">详情参考</a></p>
<p>将文本文件内容加以排序,sort可针对文本文件的内容，以行为单位来排序。</p>
<ul>
<li><strong>-b</strong> 忽略每行前面开始的空格字符串</li>
<li><strong>-c</strong> 检查文件是否已经按照顺序排序</li>
<li><strong>-o</strong> 将排序后的结果存入指定的文件</li>
<li><strong>-r</strong> 以相反的顺序排序</li>
<li><strong>-t</strong> 指定排序时使用的分隔字符</li>
<li>······</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>uniq</strong> 命令，<a href="http://www.runoob.com/linux/linux-comm-uniq.html">详情参考</a></p>
<p> 用于检查及删除文件中重复出现的行列，一般与sort命令结合使用。<br> <code>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件]</code></p>
<ul>
<li><strong>-c</strong> 或者 <strong>-count</strong> 在每列旁边展示该行重复出现的次数</li>
<li><strong>-d</strong> 或者 <strong>-repeated</strong> 仅仅显示重复出现的列</li>
<li>······</li>
</ul>
</li>
<li><p><strong>firewalld</strong>的基本使用</p>
<ul>
<li><p>启动： systemctl start firewalld</p>
</li>
<li><p>关闭： systemctl stop firewalld</p>
</li>
<li><p>查看状态： systemctl status firewalld </p>
</li>
<li><p>开机禁用  ： systemctl disable firewalld</p>
</li>
<li><p>开机启用  ： systemctl enable firewalld</p>
<blockquote>
<p>systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</p>
</blockquote>
</li>
<li><p>启动一个服务：systemctl start firewalld.service</p>
</li>
<li><p>关闭一个服务：systemctl stop firewalld.service</p>
</li>
<li><p>重启一个服务：systemctl restart firewalld.service</p>
</li>
<li><p>显示一个服务的状态：systemctl status firewalld.service</p>
</li>
<li><p>在开机时启用一个服务：systemctl enable firewalld.service</p>
</li>
<li><p>在开机时禁用一个服务：systemctl disable firewalld.service</p>
</li>
<li><p>查看服务是否开机启动：systemctl is-enabled firewalld.service</p>
</li>
<li><p>查看已启动的服务列表：systemctl list-unit-files|grep enabled</p>
</li>
<li><p>查看启动失败的服务列表：systemctl –failed3.配置firewalld-cmd查看版本： firewall-cmd –version</p>
</li>
<li><p>查看帮助： firewall-cmd –help</p>
</li>
<li><p>显示状态： firewall-cmd –state</p>
</li>
<li><p>查看所有打开的端口： firewall-cmd –zone=public –list-ports</p>
</li>
<li><p>更新防火墙规则： firewall-cmd –reload</p>
</li>
<li><p>查看区域信息:  firewall-cmd –get-active-zones</p>
</li>
<li><p>查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0</p>
</li>
<li><p>拒绝所有包：firewall-cmd –panic-on</p>
</li>
<li><p>取消拒绝状态： firewall-cmd –panic-off</p>
</li>
<li><p>查看是否拒绝： firewall-cmd –query-panic</p>
</li>
<li><p>添加 firewall-cmd –zone=public –add-port=80/tcp –permanent    （–permanent永久生效，没有此参数重启后失效）</p>
</li>
<li><p>重新载入: firewall-cmd –reload</p>
</li>
<li><p>查看: firewall-cmd –zone=public –query-port=80/tcp</p>
</li>
<li><p>删除: firewall-cmd –zone=public –remove-port=80/tcp –permanent</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程的挑战</title>
    <url>/blog/2019/04/01/concurrent/1_challenges/</url>
    <content><![CDATA[<blockquote>
<p>并发编程的目的是为了让程序运行更快，但是并不是启动更多的线程就能让程序更大限度并发执行。如果想通过多线程执行任务使程序运行得更快，会面临很多挑战。<strong>上下文切换问题、死锁问题，以及受限于硬件和软件的资源限制问题</strong></p>
</blockquote>
<h6 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1. 上下文切换"></a>1. 上下文切换</h6><blockquote>
<p>即使单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片实现。一般是几十毫秒(ms)</p>
</blockquote>
<ol>
<li>多线程并不一定快<blockquote>
<p><a href="https://dev.tencent.com/u/effiu/p/essay-project/git/blob/master/src/main/java/com/essay/concurrent/learn/chapter1/ConcurrencyTest.java">代码</a></p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>循环次数</th>
<th>串行执行</th>
<th>并发执行</th>
</tr>
</thead>
<tbody><tr>
<td>10亿</td>
<td>1250ms</td>
<td>1000ms</td>
</tr>
<tr>
<td>1亿</td>
<td>155ms</td>
<td>220ms</td>
</tr>
<tr>
<td>10万</td>
<td>4 ms</td>
<td>110ms</td>
</tr>
</tbody></table>
<h6 id="2-如何减少上下文切换"><a href="#2-如何减少上下文切换" class="headerlink" title="2. 如何减少上下文切换"></a>2. 如何减少上下文切换</h6><blockquote>
<p>减少上下文切换的方法有无锁并发编程、CAS算法、使用少线程和使用协程</p>
</blockquote>
<ul>
<li>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法避免上下文切换，例如将数据ID按照Hash算法取模分段，不同的线程处理不同段的数据 </li>
<li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁</li>
<li>使用最少线程。避免创建不必要的线程。</li>
<li>协程。单线程实现多任务的调度，并在单线程里维持多个任务间的切换</li>
</ul>
<blockquote>
<p>减少上下文切换</p>
</blockquote>
<ol>
<li><p>查看当前Java进程PID</p>
</li>
<li><p>jstack pid 查看当前Java进程的线程,以下是部分线程信息</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[root@vdevops opt]# jstack 27568</span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">26</span> <span class="number">23</span>:<span class="number">04</span>:<span class="number">10</span></span><br><span class="line"><span class="function">Full thread dump Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(<span class="number">25.144</span>-b01 mixed mode)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&quot;Attach Listener&quot; #42 daemon prio</span>=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f708c007000</span> nid=<span class="number">0x8f6</span> waiting on condition [<span class="number">0x0000000000000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;ajp-nio-8009-Acceptor-0&quot; #40 daemon prio=5 os_prio=0 tid=0x00007f70b4499000 nid=0x6bd8 runnable [0x00007f70828e7000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)</span><br><span class="line">    at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:<span class="number">422</span>)</span><br><span class="line">    at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:<span class="number">250</span>)</span><br><span class="line">    - locked &lt;<span class="number">0x00000000f5fceae8</span>&gt; (a java.lang.Object)</span><br><span class="line">    at org.apache.tomcat.util.net.NioEndpoint$Acceptor.run(NioEndpoint.java:<span class="number">692</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">&quot;ajp-nio-8009-ClientPoller-0&quot; #39 daemon prio=5 os_prio=0 tid=0x00007f70b4497000 nid=0x6bd7 runnable [0x00007f70829e8000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)</span><br><span class="line">    at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:<span class="number">269</span>)</span><br><span class="line">    at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:<span class="number">93</span>)</span><br><span class="line">    at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:<span class="number">86</span>)</span><br><span class="line">    - locked &lt;<span class="number">0x00000000f69cf4c8</span>&gt; (a sun.nio.ch.Util$<span class="number">3</span>)</span><br><span class="line">    - locked &lt;<span class="number">0x00000000f69cf4d8</span>&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">    - locked &lt;<span class="number">0x00000000f69cf480</span>&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line">    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:<span class="number">97</span>)</span><br><span class="line">    at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:<span class="number">1051</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;VM Thread&quot;</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f70b406d800</span> nid=<span class="number">0x6bb2</span> runnable </span><br><span class="line"><span class="string">&quot;VM Periodic Task Thread&quot;</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f70b40b7000</span> nid=<span class="number">0x6bb9</span> waiting on condition </span><br><span class="line">JNI global references: <span class="number">259</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>统计线程分别处于的状态</p>
<blockquote>
<p><code>awk &#39;&#123;print $2$3$4$5&#125;&#39; | grep &#39;java.lang.Thread.State&#39; dump | sort | uniq -c</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span>    java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="number">1</span>    java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line"><span class="number">1</span>    java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line"><span class="number">1</span>    java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line"><span class="number">2</span>    java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line"><span class="number">20</span>    java.lang.Thread.State: WAITING (parking)</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析线程，以及找到解决方案</p>
</li>
</ol>
<h6 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h6><blockquote>
<p>锁可能会引起死锁，会造成系统不可用，如下是一些避免死锁的办法</p>
</blockquote>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>替代使用内部锁机制</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况</li>
</ul>
<h6 id="4-资源限制的挑战"><a href="#4-资源限制的挑战" class="headerlink" title="4. 资源限制的挑战"></a>4. 资源限制的挑战</h6><blockquote>
<p>指进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。硬件资源限制有带宽的上传/下载速度、硬盘的读写速度和CPU的处理速度。软件限制有数据库的连接和socket连接数等。</p>
</blockquote>
<ul>
<li>资源限制引发的问题：将代码执行速度加快的原则是将代码中串行执行的部分编程并行，但是某段代码由于资源限制，仍在串行执行，这时候程序就会因为上下文切换和资源调度运行更慢。</li>
<li>解决资源限制的问题：硬件资源限制，可以考虑使用集群并发执行程序。软件资源限制，可以使用资源池复用。</li>
<li>在资源限制的情况下进行并发编程：根据不同的资源限制调整程序的并发度，例如下载文件依赖于带宽和硬盘读写速度。</li>
</ul>
<h6 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h6><blockquote>
<p>多使用JDK并发包提供的并发容器和工具类解决并发问题</p>
</blockquote>
]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
</search>
