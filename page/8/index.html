<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.effiu.cn","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"path":"search.xml"};
  </script>

  <meta name="description" content="effiu的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="effiu&#39;s blog">
<meta property="og:url" content="https://www.effiu.cn/page/8/index.html">
<meta property="og:site_name" content="effiu&#39;s blog">
<meta property="og:description" content="effiu的博客">
<meta property="og:locale">
<meta property="article:author" content="effiu">
<meta property="article:tag" content="effiu&#39;s blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.effiu.cn/page/8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>effiu's blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">effiu's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">生活不止眼前的苟且，还有诗和远方的田野</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/blog/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="effiu"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">effiu</p>
  <div class="site-description" itemprop="description">effiu的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/05/12/concurrent/chapter5/5.1_lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/05/12/concurrent/chapter5/5.1_lock/" class="post-title-link" itemprop="url">Lock接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-12 15:26 15:26:00" itemprop="dateCreated datePublished" datetime="2019-05-12T15:26:00+08:00">2019-05-12 15:26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/05/12/concurrent/chapter5/5.1_lock/" class="post-meta-item leancloud_visitors" data-flag-title="Lock接口" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="1-锁"><a href="#1-锁" class="headerlink" title="1. 锁"></a>1. 锁</h5><blockquote>
<p>锁是用来控制多个线程访问共享资源的方式，一个锁可以防止多个线程同时访问共享资源，有些锁可以允许多个线程并发的访问共享资源，例如读写锁。</p>
<p><strong>Java SE 5</strong> 之后新增了<code>java.util.concurrent.locks.Lock</code>接口用来实现锁功能。它提供了与<code>synchronized</code>关键字类似的同步功能，但是在使用时需要显式获取和释放锁，虽然没有了隐式获取和释放锁的便捷性，但是拥有了获取与释放锁的可操作性、可中断的获取锁以及超时获取锁等多种<code>synchronized</code>没有的同步特性。其使用如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 写在try语句外面，防止获取锁时发生了异常，异常抛出后会导致锁无故释放。</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 保证获取到锁后最终能够释放</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>java.util.concurrent.locks.Lock</code>接口提供的<code>synchronized</code>不具备的特性。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">非阻塞地获取锁</td>
<td align="center">线程尝试获取锁，若此时没有线程获取到，则成功获取并持有锁</td>
</tr>
<tr>
<td align="center">能被中断地获取锁</td>
<td align="center">与<code>synchronized</code>不同，获取到锁的线程能够响应中断，中断时会抛出异常并释放锁</td>
</tr>
<tr>
<td align="center">超时获取锁</td>
<td align="center">在指定时间之前获取锁，超时后放弃获取锁并返回</td>
</tr>
</tbody></table>
<blockquote>
<p><code>java.util.concurrent.locks.Lock</code>，定义了锁的获取与释放的基本操作，API如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void lock()</td>
<td>调用线程会获取锁，获取成功后返回</td>
</tr>
<tr>
<td align="center">void lockInterruptibly() throws InterruptedException</td>
<td>可中断地获取锁，锁的获取中可以中断当前线程</td>
</tr>
<tr>
<td align="center">boolean tryLock()</td>
<td>尝试非阻塞的获取锁，调用后立即返回，<strong>true</strong>则获取成功，否则返回<strong>false</strong></td>
</tr>
<tr>
<td align="center">boolean tryLock(long time, TimeUnit unit) throws InterruptedException</td>
<td>超时获取锁，以下三种情况会返回：<br />① 线程在超时时间内获取到锁<br />② 线程在超时时间内被中断<br />③ 超时时间结束，返回false</td>
</tr>
<tr>
<td align="center">void unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td align="center">Condition newCondition()</td>
<td>获取等待通知组件，和当前的锁绑定，当前线程只有获取到锁，才能调用组件的<code>wait()</code>方法，而调用后，当前线程释放锁</td>
</tr>
</tbody></table>
<h5 id="2-队列同步器"><a href="#2-队列同步器" class="headerlink" title="2. 队列同步器"></a>2. 队列同步器</h5><blockquote>
<p>队列同步去<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>（同步器），是用来构建锁或者其他同步组件的基础框架，其内部使用了一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程的排队工作。</p>
</blockquote>
<blockquote>
<p><strong>同步器的主要使用方式是继承</strong>，子类通过继承同步器并实现其抽象方法来管理同步状态。子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，仅仅定义了若干同步状态的获取和释放的方法供自定义同步组件使用，即可以支持独占式获取同步状态，也可以支持共享式获取同步状态。</p>
</blockquote>
<blockquote>
<p><strong>同步器实现锁的关键</strong>，是在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
</blockquote>
<ul>
<li>锁是面向使用者的，定义了使用者与锁交互的接口，隐藏了实现细节</li>
<li>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒底层操作。</li>
</ul>
<blockquote>
<p>锁和同步器很好地隔离了使用者和实现者所需要关注的领域。</p>
</blockquote>
<h6 id="2-1-队列同步器的接口与示例"><a href="#2-1-队列同步器的接口与示例" class="headerlink" title="2.1 队列同步器的接口与示例"></a>2.1 队列同步器的接口与示例</h6><blockquote>
<p>同步器的设计是基于模板方法模式的，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法。修改同步状态的3个方法</p>
</blockquote>
<ul>
<li><code>getState()</code>：获取当前同步状态</li>
<li><code>setState(int newState)</code>：设置当前同步状态</li>
<li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置当前状态，可以保证同步状态设置的原子性。</li>
</ul>
<blockquote>
<p>同步器可重写方法如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">protected boolean tryAcquire(int arg)</td>
<td align="left">独占式获取到同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td>
</tr>
<tr>
<td align="center">protected boolean tryRelease(int arg)</td>
<td align="left">独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td align="center">protected int tryAcquireShared(int arg)</td>
<td align="left">共享式获取同步状态，返回大于0的值，说明成功，否则失败</td>
</tr>
<tr>
<td align="center">protected boolean tryReleaseShared(int arg)</td>
<td align="left">共享式获取同步状态</td>
</tr>
<tr>
<td align="center">protected boolean isHeldExclusively()</td>
<td align="left">当前同步器是否在独占模式下被线程占用，一般用来表示是否被当前线程所独占</td>
</tr>
</tbody></table>
<blockquote>
<p>实现自定义同步组件时，将会调用同步器提供的模板方法，部分方法如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void acquire(int arg)</td>
<td>独占模式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则进入同步队列等待，该方法将会调用重写的<code>tryAcquire(int arg)</code>方法</td>
</tr>
<tr>
<td align="center">void acquireInterruptibly(int arg)</td>
<td>与<code>void acquire(int arg)</code>相同，但是该方法响应中断，在当前线程未获取到锁进入到同步队列等待后，如果当前线程被中断，则该方法会抛出<code>java.lang.InterruptedException</code>并返回</td>
</tr>
<tr>
<td align="center">boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>在<code>acquireInterruptibly(int arg)</code>的基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，将返回false，获取成功则返回true</td>
</tr>
<tr>
<td align="center">void acquireShared(int arg)</td>
<td>共享式获取同步状态，若当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态</td>
</tr>
<tr>
<td align="center">void acquireSharedInterruptibly(int arg)</td>
<td>与<code>void acquireShared(int arg)</code>相同，该方法响应中断</td>
</tr>
<tr>
<td align="center">boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>在<code>acquireSharedInterruptibly(int arg)</code>基础上增加了超时限制</td>
</tr>
<tr>
<td align="center">boolean release(int arg)</td>
<td>独占式是否同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td>
</tr>
<tr>
<td align="center">boolean releaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td align="center">Collection<Thread> getQueuedThreads()</td>
<td>获取等待在同步队列上的线程集合</td>
</tr>
</tbody></table>
<blockquote>
<p>同步器提供的模板方法有以下3类</p>
</blockquote>
<ul>
<li>独占式获取与释放同步状态</li>
<li>共享式获取与释放同步状态</li>
<li>查询同步队列中等待线程的情况</li>
</ul>
<blockquote>
<p>独占锁是同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取到锁的线程释放了锁，后继的线程才能获取到锁，以下是示例代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不可重入互斥锁类</span></span><br><span class="line"><span class="comment"> *  使用Mutex时，并不会与AQS交互，而是使用Mutex提供的方法获取与释放锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2019-05-12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果同步仅仅针对当前线程保持，返回true</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  使用CAS设置同步状态</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> state 同步状态</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将同步状态重置为0</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            ois.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将操作代理到Sync</span></span><br><span class="line"><span class="comment">     * 内部类继承了同步器并实现了独占锁式获取和释放同步状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/05/11/concurrent/chapter4/4.3_thread_application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/05/11/concurrent/chapter4/4.3_thread_application/" class="post-title-link" itemprop="url">线程应用实例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-11 23:56 23:56:00" itemprop="dateCreated datePublished" datetime="2019-05-11T23:56:00+08:00">2019-05-11 23:56</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/05/11/concurrent/chapter4/4.3_thread_application/" class="post-meta-item leancloud_visitors" data-flag-title="线程应用实例" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 id="1-等待超时模式"><a href="#1-等待超时模式" class="headerlink" title="1. 等待超时模式"></a>1. 等待超时模式</h6><blockquote>
<p>调用场景：调用一个方法时等待一段时间（给定一个时间段），如果该方法能够在给定的时间段之内得到结果，那么结果将立刻返回，反之，超时返回默认结果。而<strong>等待/通知的经典范式：加锁、条件循环和处理逻辑</strong>3个步骤无法满足超时等待的情况。所以做出如下改动：</p>
<p>假设超时时间是T，那么可以推断出当前时间<strong>now+T</strong>后会超时。使用<code>wait(time)</code>方法</p>
<p>等待超时模式是在等待/通知范式的基础上增加了超时控制，伪代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">get</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 超时时间点</span></span><br><span class="line">    <span class="keyword">long</span> future = System.currentTimeMills() + mills;</span><br><span class="line">    <span class="keyword">long</span> remaining = mills;</span><br><span class="line">    <span class="comment">// 若 remaining 时间大于0，则继续等待</span></span><br><span class="line">    <span class="keyword">while</span>((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待超时</span></span><br><span class="line">        wait(remaining);</span><br><span class="line">        <span class="comment">// 当前剩余超时时间</span></span><br><span class="line">        remaining = futurn - system.currentTimeMills();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-数据库连接实例"><a href="#2-数据库连接实例" class="headerlink" title="2. 数据库连接实例"></a>2. 数据库连接实例</h6><blockquote>
<p>以下是模拟数据库连接的示例，从连接池中获取、使用和释放资源，获取连接采用超时模式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回收线程池,并通知等待中的线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定多少毫秒内超时获取连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mills</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 默认无超时时间</span></span><br><span class="line">                <span class="keyword">if</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> ((pool.isEmpty()) &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 超时等待</span></span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    future = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty())&#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是连接池，以下是创建连接，使用JDK代理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;commit&quot;</span>)) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Connection <span class="title">createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Connection.class&#125;, <span class="keyword">new</span> ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试示例，模拟客户端获取连接、使用、释放连接过程，并统计连接情况。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大连接数为10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ConnectionPool pool = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证所有ConnectionRunner能够同时开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * main将会等待所有ConnectionRunner结束后才会继续执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">10</span>;</span><br><span class="line">        end = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 获取成功连接数</span></span><br><span class="line">        AtomicInteger got = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">// 超时获取连接失败数</span></span><br><span class="line">        AtomicInteger noGot = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConnectionRunner(count,got,noGot),<span class="string">&quot;ConnectionRunnerThread&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start.countDown();</span><br><span class="line">        end.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;total invoke: &quot;</span> + threadCount * count);</span><br><span class="line">        System.out.println(<span class="string">&quot;got connection: &quot;</span> + got);</span><br><span class="line">        System.out.println(<span class="string">&quot;noGot connection: &quot;</span> + noGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger got;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger noGot;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConnectionRunner</span><span class="params">(<span class="keyword">int</span> count, AtomicInteger got, AtomicInteger noGot)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.got = got;</span><br><span class="line">            <span class="keyword">this</span>.noGot = noGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                start.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Connection connection = pool.fetchConnection(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            got.getAndIncrement();</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        noGot.getAndIncrement();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从以上示例可以得知，随着客户端获取线程逐步增加，客户端出现超时无法获取连接的比率升高，但是可以保证客户端请求线程不会一直挂在获取连接的操作上，会按时返回，并告知客户端获取连接出现问题，这是系统的一种自我保护机制。</p>
</blockquote>
<h6 id="3-线程池技术以及示例"><a href="#3-线程池技术以及示例" class="headerlink" title="3. 线程池技术以及示例"></a>3. 线程池技术以及示例</h6><blockquote>
<p>线程的创建和消亡都是会消耗系统资源，当并发量大时，会频繁创建线程。这会导致频繁的线程上下文切换，增加系统负载。<strong>线程池</strong>可以解决这类问题，其预先创建若干数量线程，不能由用户直接对线程的创建进行控制，重复使用固定或者较为固定数目的线程完成任务，这样可以减少频繁创建和消亡线程的系统资源开销，即使面对过量任务也可以平缓的劣化。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个Job加入到任务队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加工作者线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWroks</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少工作者线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到正在执行的任务数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义了线程池的一系列接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最大限制数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WROKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最小限制数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是一个工作列表，向里面插入工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWorkers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        num = num &lt; MAX_WROKER_NUMBERS ? num &gt; MIN_WORKER_NUMBERS ? num : MIN_WORKER_NUMBERS : MAX_WROKER_NUMBERS;</span><br><span class="line">        initializeWorkers(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向jobs中添加Job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> job</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                <span class="comment">// 使用notifyAll()代价更大，因为会把所有等待队列中的线程移到阻塞队列中</span></span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        workers.forEach(p -&gt; p.shutdown());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWroks</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多线程情况下，需要保证num的原子性，所以需要在锁内部</span></span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WROKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WROKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            initializeWorkers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workerNum - num &lt; MIN_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = workerNum - MIN_WORKER_NUMBERS;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Worker worker = workers.get(num);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                &#125;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">&quot;ThreadPool-Worker-&quot;</span> + threadNum.incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作者，负责消费任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 等待/通知机制,用户停止当前工作线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="comment">// jobs为空，进入等待状态</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 去除job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 注意是否需要处理异常</span></span><br><span class="line">                    job.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其本质是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端将任务放入队列后便返回，而工作者线程则不断从工作队列上取出工作并执行。</p>
</blockquote>
<h6 id="4-简单Web服务器"><a href="#4-简单Web服务器" class="headerlink" title="4. 简单Web服务器"></a>4. 简单Web服务器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HTTP线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String basePath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        SimpleHttpServer.basePath = basePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        SimpleHttpServer.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http处理socket线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 初始化流</span></span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                <span class="comment">// 读取第一行，判断文件类型</span></span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                <span class="comment">// 根据http请求头，解析请求url，得到文件路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 初始化输出流</span></span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                <span class="comment">// 图片处理,特殊流</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">&quot;jpg&quot;</span>) || filePath.endsWith(<span class="string">&quot;ico&quot;</span>)) &#123;</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Server: Molly&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-Type: image/jpeg&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-length: &quot;</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                    out.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Server: Molly&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;Content-Type: text/xml; charset=utf-8&quot;</span>);</span><br><span class="line">                    out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                out.println(<span class="string">&quot;HTTP/1.1 500&quot;</span>);</span><br><span class="line">                out.println(<span class="string">&quot;Server: Molly&quot;</span>);</span><br><span class="line">                out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, reader, in, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable tmp : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    tmp.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过线程池处理socket请求，建立一个工作队列，不会阻塞后续客户端的请求</p>
</blockquote>
<blockquote>
<p>更复杂的HttpServer见: <a target="_blank" rel="noopener" href="https://github.com/effiu/mytomcat">mytomcat</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/05/05/concurrent/chapter4/4.2_inter-thread_communication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/05/05/concurrent/chapter4/4.2_inter-thread_communication/" class="post-title-link" itemprop="url">线程间通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-05 00:19 00:19:00" itemprop="dateCreated datePublished" datetime="2019-05-05T00:19:00+08:00">2019-05-05 00:19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/05/05/concurrent/chapter4/4.2_inter-thread_communication/" class="post-meta-item leancloud_visitors" data-flag-title="线程间通信" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3. 线程间通信"></a>3. 线程间通信</h5><blockquote>
<p>线程间可以通过通信互相配合完成工作</p>
</blockquote>
<h6 id="1-volatile和synchronized关键字"><a href="#1-volatile和synchronized关键字" class="headerlink" title="1. volatile和synchronized关键字"></a>1. <code>volatile</code>和<code>synchronized</code>关键字</h6><blockquote>
<p>Java支持多个线程同时访问一个对象或者对象的成员变量，每个线程都会拥有这个共享变量的拷贝，所以程序执行过程中，一个线程看到的并不一定是最新的。</p>
<p><code>volatile</code>可以用来修饰字段(成员变量)，就是告知程序任何对该变量的访问均需要从共享内存中获取，对它的改动必须同步刷新到共享内存，可以保证所有线程对变量访问的可见性。过多使用<code>volatile</code>会降低程序执行的效率。</p>
<p><code>synchronized</code>可以修饰方法或者以同步块的形式进行使用，确保多线程在同一时刻只有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性与排他性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对Synchronized.class对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Synchronized.class)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 静态同步方法，对Synchronized.class对象加锁</span></span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用javap反编译后，部分结果如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line"><span class="comment">// 方法修饰符，表示：public staticflags: ACC_PUBLIC, ACC_STATIC</span></span><br><span class="line">	Code:</span><br><span class="line">        stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: ldc #1 // class com/murdock/books/multithread/book/Synchronized</span><br><span class="line">        <span class="number">2</span>: dup</span><br><span class="line">        <span class="number">3</span>: monitorenter <span class="comment">// monitorenter：监视器进入，获取锁</span></span><br><span class="line">        <span class="number">4</span>: monitorexit <span class="comment">// monitorexit：监视器退出，释放锁</span></span><br><span class="line">        5: invokestatic #16 // Method m:()V</span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 方法修饰符，表示： public static synchronized</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    	Code:</span><br><span class="line">            stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">            <span class="number">0</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现同步代码块使用<code>monitorenter</code>和<code>monitorexit</code>指令，同步方法使用方法修饰符上对的<strong>ACC_SYNCHRONIZED</strong>完成。本质是对一个对象监视器(monitor)的获取，这个获取是排他的，即同一时刻只有一个线程获取到<code>synchronized</code>所保护对象的监视器</p>
</blockquote>
<blockquote>
<p>任意对象都有自己的监视器，当这个对象由同步块或者对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，未获取到监视器的线程将会被阻塞在同步块或同步方法的入口处，进入BLOCKED状态。当持有锁的线程释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。</p>
</blockquote>
<blockquote>
<p>如下图是对象、对象的监视器、同步队列和执行线程之间的关系：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/42.jpg" alt="关系图"></p>
<h6 id="2-等待-通知机制"><a href="#2-等待-通知机制" class="headerlink" title="2. 等待/通知机制"></a>2. 等待/通知机制</h6><blockquote>
<p>一个线程修改了一个对象的值，另一个线程感知到了变化，然后进行响应的操作。等待/通知的相关方法如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">notify()</td>
<td>通知一个在等待队列中的线程，使其从wait()返回，前提是该线程获得了对象锁</td>
</tr>
<tr>
<td align="center">notifyAll()</td>
<td>通知所有等待在该对象同步等待队列上的线程</td>
</tr>
<tr>
<td align="center">wait()</td>
<td>线程进入<strong>WAITING</strong>状态，等待其他线程的通知才会返回，会释放对象的锁</td>
</tr>
<tr>
<td align="center">wait(long)</td>
<td>超时等待，单位ms，若超时没有通知就返回</td>
</tr>
<tr>
<td align="center">wait(long,int)</td>
<td>超时等待，单位ns</td>
</tr>
</tbody></table>
<blockquote>
<p>等待/通知机制，是指一个线程A调用对象O的<code>wait()</code>方法进入等待状态，另一个线程B调用对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>方法返回，执行后续操作。两个线程通过O进行交互。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">&quot;waitThread&quot;</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">&quot;notifyThread&quot;</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 条件不满足时wait,同时释放lock锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">&quot; flag is true. wait@ &quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; flag is false. running@ &quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 条件不满足时wait,同时释放lock锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">&quot; hold lock. notify@ &quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; hold lock again. sleep@ &quot;</span> + LocalDateTime.now().toString());</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[waitThread,<span class="number">5</span>,main] flag is <span class="keyword">true</span>. wait@ <span class="number">2019</span>-<span class="number">05</span>-<span class="number">04</span>T23:<span class="number">44</span>:<span class="number">01</span>.<span class="number">540</span></span><br><span class="line">Thread[notifyThread,<span class="number">5</span>,main] hold lock. notify@ <span class="number">2019</span>-<span class="number">05</span>-<span class="number">04</span>T23:<span class="number">44</span>:<span class="number">02</span>.<span class="number">396</span></span><br><span class="line">Thread[notifyThread,<span class="number">5</span>,main] hold lock again. sleep@ <span class="number">2019</span>-<span class="number">05</span>-<span class="number">04</span>T23:<span class="number">44</span>:<span class="number">07</span>.<span class="number">398</span></span><br><span class="line">Thread[waitThread,<span class="number">5</span>,main] flag is <span class="keyword">false</span>. running@ <span class="number">2019</span>-<span class="number">05</span>-<span class="number">04</span>T23:<span class="number">44</span>:<span class="number">12.398</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>注意事项：</p>
</blockquote>
<ul>
<li>使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用对象加锁</li>
<li>调用<code>wait()</code>后，线程状态由<strong>RUNNING</strong>变为<strong>WAITING</strong>，将当前线程放置到对象的等待队列中</li>
<li><code>notify()</code>和<code>notifyAll()</code>调用后，等待队列不会立即从<code>wait()</code>返回，而是等待调用线程释放锁之后，等待线程才有机会从<code>wait()</code>返回</li>
<li><code>notify()</code>将等待线程中的一个等待线程从等待队列中移到同步队列中。<code>notifyAll()</code>将所有等待线程移到同步队列中，被移动线程状态由<strong>WAITING</strong>变为<strong>BLOCKED</strong></li>
<li><code>wait()</code>方法返回的前提是获得了对象锁</li>
</ul>
<blockquote>
<p>等待/通知依托于同步机制，目的是确保等待线程从<code>wait()</code>方法返回时能够感知到通知线程对变量做出的修改</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/43.jpg" alt="关系图"></p>
<blockquote>
<p><strong>WaitThread</strong>首先获得了对象锁，然后调用<code>wait()</code>方法，放弃锁进入对象的等待队列，此时<strong>NotifyThread</strong>获得了对象锁，调用<code>notify()</code>方法，将<strong>WaitThread</strong>从等待队列移到<code>synchronizedQueue</code>中，<strong>WaitThread</strong>变为阻塞状态，等待<strong>NotifyThread</strong>释放锁，<strong>WaitThread</strong>会在<strong>NotifyThread</strong>释放锁之后获取锁并从<code>wait()</code>方法返回并继续执行。</p>
</blockquote>
<h6 id="3-等待-通知的经典范式"><a href="#3-等待-通知的经典范式" class="headerlink" title="3. 等待/通知的经典范式"></a>3. 等待/通知的经典范式</h6><blockquote>
<p>等待方规则：</p>
</blockquote>
<ol>
<li>获取对象锁</li>
<li>若条件不满足，调用<code>wait()</code>方法，被通知后仍要检查条件</li>
<li>条件满足后执行对应逻辑</li>
</ol>
<blockquote>
<p>通知方规则：</p>
</blockquote>
<ol>
<li>获取对象锁</li>
<li>改变条件</li>
<li>通知在等待队列中等待的线程</li>
</ol>
<h6 id="4-管道输入-输出流"><a href="#4-管道输入-输出流" class="headerlink" title="4. 管道输入/输出流"></a>4. 管道输入/输出流</h6><blockquote>
<p>管道输入/输出流与普通的文件输入/输出流或者网络输入/输出流不同，其用于线程之间的数据传输，传输媒介是内存。</p>
<p>面向字节：<code>PipedoutputStream</code>、<code>PipedInputStream</code></p>
<p>面向字符：<code>PipedReader</code>、<code>PipedWriter</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">// 输入输出流进行连接，否则会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">&quot;printThread&quot;</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于<strong>Piped</strong>流，必须先进行绑定，调用<code>connect()</code>方法，否则将抛出异常</p>
</blockquote>
<h6 id="5-Thread-join-的使用"><a href="#5-Thread-join-的使用" class="headerlink" title="5. Thread.join()的使用"></a>5. <code>Thread.join()</code>的使用</h6><blockquote>
<p><code>join()</code>的含义：线程A等等thread线程终止之后才从<code>thread.join()</code>返回。<code>join()</code>、<code>join(long)</code>、<code>join(long,int)</code>。线程终止时会调用线程自身的<code>notifyAll()</code>方法，会通知所有等待在该线程对象上的线程。</p>
</blockquote>
<h6 id="6-ThreadLocal"><a href="#6-ThreadLocal" class="headerlink" title="6. ThreadLocal"></a>6. <code>ThreadLocal</code></h6><blockquote>
<p><code>ThreadLocal</code>，线程变量，是一个以<strong>ThreadLocal</strong>对象为键，任意对象为值的存储结构。见以下例子：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = ThreadLocal.withInitial(() -&gt; System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Const: &quot;</span> + Profiler.end() + <span class="string">&quot; mills&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好处是两个方法的调用不用在一个方法或者类中，比如在AOP中，可以在方法调用的切入点执行<code>begin()</code>方法，在方法调用后的切入点执行<code>end()</code>方法</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/05/04/concurrent/chapter4/4.1_thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/05/04/concurrent/chapter4/4.1_thread/" class="post-title-link" itemprop="url">线程的简介、启动与终止</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-04 22:28 22:28:00" itemprop="dateCreated datePublished" datetime="2019-05-04T22:28:00+08:00">2019-05-04 22:28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/05/04/concurrent/chapter4/4.1_thread/" class="post-meta-item leancloud_visitors" data-flag-title="线程的简介、启动与终止" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1. 线程简介"></a>1. 线程简介</h5><h6 id="1-线程介绍"><a href="#1-线程介绍" class="headerlink" title="1. 线程介绍"></a>1. 线程介绍</h6><blockquote>
<p>启动一个Java程序，操作系统会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫轻量级进程。一个进程里可以创建多个线程，这些线程拥有各自的计数器、堆和局部变量等属性，并且可以访问共享的内存变量，处理器会在线程之间高速切换。</p>
<p>一个Java程序从<code>main()</code>方法开始执行，然后按照既定代码逻辑执行，实际上Java程序是多线程程序，所以会<strong>有很多后台线程在执行</strong>。以下使用JMX查看普通的Java程序包含哪些线程：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Java线程管理MXBean</span></span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 遍历线程信息，打印线程Id和线程名称信息</span></span><br><span class="line">        Arrays.stream(threadInfos).forEach(p -&gt; System.out.println(<span class="string">&quot;[&quot;</span> + p.getThreadId() + <span class="string">&quot;] &quot;</span> + p.getThreadName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果如下所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">6</span>] Monitor Ctrl-Break</span><br><span class="line">[<span class="number">5</span>] Attach Listener			<span class="comment">// 并不一定会存在</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher		<span class="comment">// 分发处理发送给JVM信号的线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer				<span class="comment">// 调用对象finalize方法的线程</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler		<span class="comment">// 清除Reference的线程</span></span><br><span class="line">[<span class="number">1</span>] main					<span class="comment">// main线程，用户程序入口</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2014/06/18/jvm-attach/">JVM Attach机制</a></li>
</ul>
<h6 id="2-为什么要使用多线程"><a href="#2-为什么要使用多线程" class="headerlink" title="2. 为什么要使用多线程"></a>2. 为什么要使用多线程</h6><blockquote>
<p>从上面程序可以发现，一个简单的<code>mian()</code>函数启动了多个后台线程。正确使用多线程，能够带来显著的好处。</p>
</blockquote>
<ul>
<li><strong>更多的处理器核心</strong>。现代处理器的核心越来越多，以及超线程技术的广泛运用，现代处理器都更加擅长并行计算，处理器提高性能的方式，也从提高主频向更多的核心发展，所以如何更好利用处理器多核心是主要问题。线程是大多数操作系统调度的基本调度，一个程序作为一个进程来运行。程序运行过程中会创建多个线程，而一个线程只能在一个处理器核心上运行，所以为了更好利用处理器核心，使用多线程技术将计算逻辑分配到多个处理器核心，就可以显著提高程序的处理时间。</li>
<li><strong>更快的响应时间</strong>。对于复杂的业务场景，可以使用多线程技术将数据一致性不强的操作派发给其他线程处理(也可以使用消息队列)，这样做好处是相应用户请求的线程能够尽可能快的处理完成，缩短响应时间，提升用户体验。</li>
<li><strong>更好的编程模型</strong>。Java为多线程编程提供了良好、考究并且一致的编程模型，这样开发人员就不需要考虑将程序多线程化，而是专注于问题的解决。</li>
</ul>
<h6 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="3. 线程优先级"></a>3. 线程优先级</h6><blockquote>
<p>现代操作系统采用时分的形式调度运行的线程。操作系统会分出一个个<strong>时间片</strong>，线程分配到若干时间片，当线程时间片用完后就会发生<strong>系统调度</strong>，等待下一次分配，所以<strong>线程分配时间片多少决定了线程使用系统资源</strong>的多少，而<strong>线程的优先级</strong>是决定线程需要多或者少分配一些处理器资源的线程属性。</p>
</blockquote>
<blockquote>
<p>Java线程中通过一个 <code>int</code>成员变量控制优先级，<code>thread.setPriority(int)</code>来修改优先级，默认值是5。优先级高的线程会分配更多的时间片。针对频繁阻塞的线程，要设置更高的优先级；偏重计算的线程，设置较低的优先级。<strong>有些操作系统会忽略线程优先级的设定</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	Changes the priority of this thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 优先级范围从1~10</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程优先级不能作为程序正确性的依赖，因为操作系统可以忽略Java线程对于优先级的设定</p>
</blockquote>
<h6 id="4-线程的状态"><a href="#4-线程的状态" class="headerlink" title="4. 线程的状态"></a>4. 线程的状态</h6><blockquote>
<p>Java线程在运行声明周期中有6中不同的状态，同一线程在某个时刻只能处于其中一个状态。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NEW</td>
<td>初始状态，线程被创建，未调用<code>start()</code>方法</td>
</tr>
<tr>
<td align="center">RUNABLE</td>
<td>运行状态，Java线程将操作系统中的就绪和运行两种状态统称为“运行中”</td>
</tr>
<tr>
<td align="center">BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td align="center">WAITING</td>
<td>等待状态，表示当前线程需要等待其他线程输出一些特定动作(通知或中断)</td>
</tr>
<tr>
<td align="center">TIME_WAITING</td>
<td>超时等待状态，与WAITING有区别，可以在指定时间自行返回</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<blockquote>
<p>查看Java进程运行时的线程信息：<code>jps</code>查看<strong>Java进程</strong>，<code>jstack</code> + 进程ID，以下是部分输出：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@vdevops ~]# jps</span><br><span class="line">5052 Bootstrap</span><br><span class="line">27613 gm-web-0.0.1-SNAPSHOT.jar</span><br><span class="line">15774 Jps</span><br><span class="line">[root@vdevops ~]# jstack 27613</span><br><span class="line">2019-05-04 11:50:33</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #40 daemon prio=9 os_prio=0 tid=0x00007f017c003800 nid=0x3db2 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">   </span><br><span class="line">········ 省略</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程在自身的声明周期中的状态是变化的，是随着代码的执行在不同的状态之间切换。Java线程状态变化如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/41.jpg" alt="Java线程状态变化"></p>
<blockquote>
<p>线程创建之后，<code>Thread.start()</code>后开始运行。<code>wait()</code>方法后进入等待状态，此时需要依靠其他线程通知才能够返回到运行状态，<strong>TIME_WAITING</strong>是在等待状态的基础上增加了超时限制，超时将会返回到运行状态。线程调用同步方法时，未获取到锁，就会进入阻塞状态。线程在执行<code>Runnable</code>的<code>run()</code>之后将会进入到终止状态。</p>
</blockquote>
<blockquote>
<p>Java将操作系统中的运行和就绪两个状态合并称为<strong>RUNNABLE</strong>状态。阻塞状态是线程阻塞在进入<code>synchronized</code>关键字修饰方法或代码块(获取锁)时的状态，但是阻塞在<code>java.concurrent.locks.Lock</code>接口 的线程状态是<strong>WAITING</strong>状态，其内部使用了<code>LockSupport</code>中相关方法。</p>
</blockquote>
<h6 id="5-Daemon线程"><a href="#5-Daemon线程" class="headerlink" title="5. Daemon线程"></a>5. Daemon线程</h6><blockquote>
<p><strong>Daemon</strong>线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。当Java虚拟机中不存在<strong>Daemon</strong>线程时，Java虚拟机将会退出，可以<code>Thread.setDaemon(true)</code>将线程设置为<strong>Daemon</strong>线程。<strong>Daemon</strong>线程需要在启动线程之前设置。<strong>Daemon</strong>线程中的<code>finally</code>块并不一定会执行，所以不能依靠<code>finally</code>块中的内容确保执行关闭或清理资源的逻辑。</p>
</blockquote>
<hr>
<h5 id="2-启动和终止线程"><a href="#2-启动和终止线程" class="headerlink" title="2. 启动和终止线程"></a>2. 启动和终止线程</h5><blockquote>
<p>Java线程<code>start()</code>方法启动，随着<code>run()</code>方法执行完毕线程终止</p>
</blockquote>
<h6 id="1-构造线程"><a href="#1-构造线程" class="headerlink" title="1. 构造线程"></a>1. 构造线程</h6><blockquote>
<p>运行线程之前需要先构建一个线程，构造时需要提供线程所需要的属性：线程组、线程优先级、是否是<strong>Daemon</strong>线程等信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 线程名</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 当前线程是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="comment">// 线程组逻辑</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.addUnstarted();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">// 将Daemon、Priority等设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">// 将父线程的 InheritableThreadLocals复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    <span class="comment">// 分配一个线程id</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现，一个新构造的线程对象是由其<strong>parent线程</strong>类进行空间分配的，而<strong>child线程</strong>继承了父线程的<strong>Deamon</strong>、<strong>Priority优先级</strong>和加载资源的<strong>contextClassLoader</strong>以及可继承的<strong>ThreadLocal</strong>，同时会分配一个唯一的ID来标识<strong>child线程</strong>。</p>
</blockquote>
<h6 id="2-启动线程"><a href="#2-启动线程" class="headerlink" title="2. 启动线程"></a>2. 启动线程</h6><blockquote>
<p>线程在构造初始化完成后，调用<code>start()</code>方法就可以启动这个线程。线程<code>start()</code>的含义：当前线程(<strong>parent线程</strong>)同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用<code>start()</code>方法的线程。启动一个线程前，最好要为线程设置一个名称，便于使用<strong>jstack</strong>分析。</p>
</blockquote>
<h6 id="3-中断线程"><a href="#3-中断线程" class="headerlink" title="3. 中断线程"></a>3. 中断线程</h6><ul>
<li><input disabled="" type="checkbox"> <strong>未完全理解</strong></li>
</ul>
<blockquote>
<p>中断可以理解为线程的一个标识位属性。它表示一个运行中的线程是否被其他线程进行中断操作，其他线程可以通过调用线程的<code>interrupt()</code>方法对其进行中断操作。</p>
</blockquote>
<blockquote>
<p>线程通过检查自身是否被中断来进行响应，<code>isInterrupt()</code>方法进行判断是否被中断。<code>Thread.interrupt()</code>对当前线程的中断标识进行复位。若该线程已经处于终结状态，即使该线程被中断过，在调用线程对象的<code>isInterrupted()</code>时依旧会返回false。</p>
</blockquote>
<blockquote>
<p><strong>Java API</strong>可以发现，很多声明会抛出<code>InterruptedException</code>的方法(<code>Thread.sleep(long millis)</code>)会在抛出<code>InterruptExcepption</code>之前，Java虚拟机会将该线程的中断标识位清除，此事调用<code>isInterrupted</code>方法会返回<code>false</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 睡眠线程</span></span><br><span class="line">        Thread sleepRunner = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepRunner(), <span class="string">&quot;sleepRunner&quot;</span>);</span><br><span class="line">        sleepRunner.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不停运行线程</span></span><br><span class="line">        Thread busyRunner = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyRunner(), <span class="string">&quot;busyRunner&quot;</span>);</span><br><span class="line">        busyRunner.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sleepRunner.start();</span><br><span class="line">        busyRunner.start();</span><br><span class="line">        <span class="comment">// 休眠5s让线程充分运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        sleepRunner.interrupt();</span><br><span class="line">        busyRunner.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;SleepRunner interrupted is &quot;</span> + sleepRunner.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;BusyRunner interrupted is &quot;</span> + busyRunner.isInterrupted());</span><br><span class="line">        <span class="comment">// 防止sleepRunner和busyRunner立刻退出</span></span><br><span class="line">        SleepUtils.second(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现抛出<code>InterruptedException</code>的线程SleepRunner，其中断标识位被清除了(因为调用了<code>sleep</code>方法)，一直运作的线程<strong>busyRunner</strong>，中断标识位没有被清除</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SleepRunner interrupted is <span class="keyword">false</span></span><br><span class="line">BusyRunner interrupted is <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h6 id="4-过期的suspend-、resume-、stop"><a href="#4-过期的suspend-、resume-、stop" class="headerlink" title="4. 过期的suspend()、resume()、stop()"></a>4. 过期的<code>suspend()</code>、<code>resume()</code>、<code>stop()</code></h6><blockquote>
<p>Thread的API里<code>suspend()</code>、<code>resume()</code>和<code>stop()</code>分别对应线程的暂停、恢复和停止。API是过期的，不建议使用。</p>
<p><code>suspend()</code>在调用后，线程并不会释放已经占有的的资源(比如锁)，而是占用资源进入睡眠状态，这样容易引起死锁问题。<code>stop()</code>方法在终结一个线程时不会保证线程的资源正常释放。</p>
</blockquote>
<h6 id="5-安全地终止线程"><a href="#5-安全地终止线程" class="headerlink" title="5. 安全地终止线程"></a>5. 安全地终止线程</h6><blockquote>
<p>中断状态是一个标识位，中断操作是一种简单的线程间交互方式，这种交互方式最适合用来取消或停止任务，还可以利用一个<code>boolean</code>变量控制是否需要停止任务并终止该线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">&quot;countThread&quot;</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠1s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">&quot;countThread&quot;</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠1s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Count i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上通过标识位或者中断操作的方式可以使线程在终止时有机会去清理资源，更加安全和优雅。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/04/30/concurrent/chapter3/3.7_happens-before/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/04/30/concurrent/chapter3/3.7_happens-before/" class="post-title-link" itemprop="url">happens-before</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-30 00:10 00:10:00" itemprop="dateCreated datePublished" datetime="2019-04-30T00:10:00+08:00">2019-04-30 00:10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/04/30/concurrent/chapter3/3.7_happens-before/" class="post-meta-item leancloud_visitors" data-flag-title="happens-before" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><code>happens-bofore</code>是JMM最核心的概念。</p>
</blockquote>
<h6 id="1-JMM的设计"><a href="#1-JMM的设计" class="headerlink" title="1. JMM的设计"></a>1. JMM的设计</h6><blockquote>
<p>JMM的设计意图：</p>
</blockquote>
<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。希望基于一个强内存模型编码。</li>
<li>编译器和处理器对内存模型的实现。编译器和 处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型</li>
</ul>
<blockquote>
<p><code>JSR-133</code>找一个平衡点，既要为程序员提供强的内存可见性保证；又要尽可能少束缚编译器和处理器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;			<span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1.0</span>;				<span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r;	<span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上所示代码，<strong>A happens-before C</strong>和<strong>B happens-before C</strong>是必须的，A和B没有必须关系，所以JMM把<code>happens-before</code>要求分为两类：</p>
</blockquote>
<ul>
<li>会改变程序执行结果的重排序，JMM会要求编译器和处理器必须禁止这种重排序</li>
<li>不会改变程序执行结果的重排序，JMM允许这种重排序</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/25.jpg" alt="JMM设计示意图"></p>
<blockquote>
<p>从上图可以得出以下结论</p>
</blockquote>
<ul>
<li>JMM提供的<code>happens-before</code>规则可以满足程序员的需求。提供了足够强的内存可见性保证</li>
<li>JMM对编译器和 处理器的束缚尽可能减少了，只要不改变程序执行结果（单线程程序或者正确同步的多线程程序），编译器和处理器可以随便优化</li>
</ul>
<h6 id="2-happens-before的定义"><a href="#2-happens-before的定义" class="headerlink" title="2.happens-before的定义"></a>2.<code>happens-before</code>的定义</h6><blockquote>
<p><code>JSR-133</code>使用<code>happens-before</code>概念执行两个操作之间的执行顺序（两个操作可以在一个线程之内，也可以在多线程之间），所以JMM可以通过<code>happens-before</code>关系向程序员提供跨线程内存的可见性保证</p>
</blockquote>
<blockquote>
<p><code>JSR-133</code>对<code>happens-before</code>关系定义如下：</p>
</blockquote>
<ul>
<li>一个操作<code>happens-before</code>另一个操作，那么第一个操作执行结果将对第二个操作可见，第一个操作的执行顺序必须排在第二个之前，这是<strong>JMM对程序员的承诺</strong></li>
<li>两个操作之间的<code>happens-before</code>关系，并不意味着编译器和处理器会按照这种顺序执行，若重排序后的执行结果，与按照<code>happens-before</code>关系的执行结果一致，那么允许这种重排序。<strong>JMM对编译器和处理器的约束原则</strong></li>
</ul>
<blockquote>
<p><code>happens-before</code>关系和<code>as-if-serial</code>语义类似。</p>
<p><code>as-if-serial</code>保证单线程内程序的执行结果不被改变，<code>happens-before</code>保证正确同步的多线程程序执行结果不被改变。目的是再不改变程序执行结果的情况下，尽可能地提高并行度。</p>
</blockquote>
<h6 id="3-happens-before规则"><a href="#3-happens-before规则" class="headerlink" title="3 happens-before规则"></a>3 <code>happens-before</code>规则</h6><blockquote>
<p><code>JSR-133</code>定义的<code>happens-before</code>规则如下：</p>
</blockquote>
<ol>
<li>程序顺序规则：一个线程中的每个操作，<code>happens-before</code>于该线程中的任意后续操作（<strong>实际JMM允许编译器和处理器在不改变程序执行结果的情况下重排序</strong>）</li>
<li>监视器锁规则：一个锁的解锁，<code>happens-before</code>于随后对这个锁的加锁</li>
<li><code>volatile</code>变量规则：对一个<code>volatile</code>的写，<code>happens-before</code>与任意后续操作对这个<code>volatile</code>域的读</li>
<li>传递性：A <code>happens-before</code> B，B <code>happens-before</code> C，那么 A <code>happens-before</code> C</li>
<li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么线程A中<code>ThreadB.start()</code>操作<code>happens-before</code>线程B的任何操作</li>
<li><code>join()规则</code>：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作<code>happens-before</code>于线程A从<code>ThreadB.join()</code>操作成功返回</li>
</ol>
<h6 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h6><blockquote>
<p>正确理解<code>happens-before</code>的各项规则。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/26.jpg" alt="happens-before示意图"></p>
<ul>
<li><p>1<code>happens-before</code>2和3<code>happens-before</code>4是由<strong>程序顺序规则产生</strong>，即编译器和处理器遵守<code>as-if-serial</code>语义，保证了程序的顺序执行</p>
</li>
<li><p>2<code>happens-before</code>3是由**<code>volatile</code>规则产生**，对一个<code>volatile</code>变量的读，总是能够看到任意线程之前对这个<code>volatile</code>变量最后的写入。</p>
</li>
<li><p>1<code>happens-before</code>4由<strong>传递性规则</strong>产生。<strong>传递性</strong>是由<code>volatile</code>的内存屏障插入策略和<code>volatile</code>的编译器重排序规则共同保证的</p>
</li>
</ul>
<blockquote>
<p><code>start()</code>规则：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/27.jpg" alt="happens-before关系示意图"></p>
<blockquote>
<p>1 <code>happens-before</code> 2由程序顺序规则产生。2 <code>happens-before</code> 4由<code>start()</code>规则产生，根据<strong>传递性规则</strong>1 <code>happens-before</code> 4，意味着线程A在执行<code>ThrandB.start()</code>之前对共享变量做的修改对线程B可见。</p>
</blockquote>
<blockquote>
<p><code>join()规则</code>，线程A执行过程中通过执行<code>ThreadB.join()</code>等待B终止。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/28.jpg" alt="happens-before关系示意图"></p>
<blockquote>
<p>2  <code>happens-before</code> 4 由<strong>join规则</strong>产生，4 <code>happens-before</code> 5 由<strong>程序规则产生</strong>，根据<strong>传递性</strong> 2 <code>happens-before</code> 5，所以线程A执行操作<code>ThreadB.join()</code>并成功返回后，线程B的任意操作将对线程A可见。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/04/29/concurrent/chapter3/3.6_final/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/04/29/concurrent/chapter3/3.6_final/" class="post-title-link" itemprop="url">final内存语义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-29 00:28 00:28:00" itemprop="dateCreated datePublished" datetime="2019-04-29T00:28:00+08:00">2019-04-29 00:28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/04/29/concurrent/chapter3/3.6_final/" class="post-meta-item leancloud_visitors" data-flag-title="final内存语义" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>对<code>final</code>域的读和写像是普通的变量访问</p>
</blockquote>
<h6 id="1-final域的重排序规则"><a href="#1-final域的重排序规则" class="headerlink" title="1. final域的重排序规则"></a>1. final域的重排序规则</h6><blockquote>
<p>编译器和处理器针对<code>final</code>域要遵守两个重排序规则</p>
</blockquote>
<ol>
<li>与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含<code>final</code>域的对象的引用，与随后初次读这个<code>final</code>域，这两个操作之间不能重排序</li>
</ol>
<h6 id="2-写final域的重排序"><a href="#2-写final域的重排序" class="headerlink" title="2. 写final域的重排序"></a>2. 写<code>final</code>域的重排序</h6><blockquote>
<p>如下，假设线程A执行<code>writer()</code>方法，线程B执行<code>reader()</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须初始化，</span></span><br><span class="line"><span class="comment">     * 直接赋值或者构造方法，代码块初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写普通域</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 写final域</span></span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程A执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两步操作</span></span><br><span class="line">        <span class="comment">// 1. 构造一个对象；2. 将这个对象的引用赋值给应用变量obj</span></span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程B执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读对象引用</span></span><br><span class="line">        FinalExample object = obj;</span><br><span class="line">        <span class="comment">// 读普通域</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;</span><br><span class="line">        <span class="comment">// 读final域</span></span><br><span class="line">        <span class="keyword">int</span> b = object.j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写<code>final</code>域的重排序规则禁止把<code>final</code>域的写重排序到构造函数之外</p>
</blockquote>
<ol>
<li>JMM禁止编译器把<code>final</code>域的写重排序到构造函数之外</li>
<li>编译器会在<code>final</code>域之后，构造函数return之前，插入一个<code>StoreStore</code>屏障，这个屏障会禁止处理器把<code>final</code>域的写重排序到构造函数之外。</li>
</ol>
<blockquote>
<p>线程A执行<code>writer()</code>方法分为两步。<code>FinalExample</code>类，假设线程B读对象的引用与读对象成员域之间没有重排序(<strong>读final域的重排序规则</strong>)，执行后可能会产生如下图结果:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/21.jpg" alt="线程执行时序图"></p>
<blockquote>
<p>普通域的写操作被重排序到了构造函数之外，读线程B读取的是普通域初始化之前的值。</p>
</blockquote>
<blockquote>
<p>写<code>final</code>域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的<code>final</code>域已经被正确初始化了，而普通域不具有这个保障。</p>
</blockquote>
<h6 id="3-读final域的重排序"><a href="#3-读final域的重排序" class="headerlink" title="3. 读final域的重排序"></a>3. 读<code>final</code>域的重排序</h6><blockquote>
<p>读<code>final</code>域的重排序规则是：初次读对象引用与初次读对象包含的<code>final</code>域，JMM禁止<strong>处理器</strong>重排序这两个操作，编译器会在读<code>final</code>域操作前面插入一个<code>LoadLoad</code>屏障。初次读对象的引用与初次读对象包含的<code>final</code>域，这两个操作之间存在间接依赖关系，而编译器遵守间接依赖关系，所以这个规则不针对编译器重排序。</p>
</blockquote>
<blockquote>
<p>假设线程A没有发生任何重排序，可能会产生如下执行结果：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/22.jpg" alt="线程执行时序图"></p>
<blockquote>
<p>普通成员域的读操作被处理器重排序到了对象引用之前。</p>
<p>读<code>final</code>域的重排序规则：读一个对象的 <code>final</code>域之前，一定会先读包含这个<code>final</code>域的对象的引用。</p>
</blockquote>
<h6 id="4-final域为引用类型"><a href="#4-final域为引用类型" class="headerlink" title="4. final域为引用类型"></a>4. <code>final</code>域为引用类型</h6><blockquote>
<p>以上针对的是<code>final</code>为基础数据类型，当<code>final</code>域是引用类型时，写<code>final</code>域的重排规则对编译器和处理器增加了如下约束：在构造函数内对一个<code>final</code>引用的对象的成员写入，与随后在构造函数外把这个被构造函数对象的引用赋值给一个引用变量，这两个操作不能重排序。见下例：</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">public class FinalReferenceExample &#123;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    final int[] intArray;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    static FinalReferenceExample obj;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    public FinalReferenceExample()&#123;         // 构造函数</span></span><br><span class="line"><span class="xml">        intArray = new int[1];              // 1 对final域的写入</span></span><br><span class="line"><span class="xml">        intArray[0] = 1;                    // 2 对final域引用的对象的成员的写入</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    public static void writeOne()&#123;          // 写线程A执行</span></span><br><span class="line"><span class="xml">        obj = new FinalReferenceExample();  // 3 把被构造的对象的引用赋值给某个引用变量</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    public static void writeTwo()&#123;          //  写线程B执行</span></span><br><span class="line"><span class="xml">        obj.intArray[0] = 2;                // 4</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    public static void reader()&#123;            // 读线程C执行</span></span><br><span class="line"><span class="xml">        if (obj != null)&#123;                   // 5</span></span><br><span class="line"><span class="xml">            int tmp1 = obj.intArray[0];     // 6</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先线程A执行构造方法，然后线程B和C执行各自方法。根据以上重排序规则, 1和3以及2和3都不能重排序。</p>
</blockquote>
<blockquote>
<p>JMM可以确保线程C可以看到线程A在构造函数中对<code>final</code>引用对象写入以及对final引用对象成员的写入，保证不了线程B的写入对线程C可见。以下是一种执行情况：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/23.jpg" alt="引用型final执行时序图"></p>
<blockquote>
<p>线程B与线程C存在数据竞争，执行结果不可预知。要想保证线程C与看到线程B对<code>final</code>引用对象成员的写入，线程之前需要使用同步原语(<code>lock</code>或<code>volatile</code>)确保内存可见性。</p>
</blockquote>
<h6 id="5-final引用不能从构造函数内“溢出”"><a href="#5-final引用不能从构造函数内“溢出”" class="headerlink" title="5. final引用不能从构造函数内“溢出”"></a>5. <code>final</code>引用不能从构造函数内“溢出”</h6><blockquote>
<p>写<code>final</code>域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的<code>final</code>域已经在构造函数中被正确初始化了。还需要一个保证：不能让这个被构造对象的引用为其他线程所见，即对象引用不能在构造函数中“溢出”。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">1</span>;                                      <span class="comment">// 1</span></span><br><span class="line">        obj = <span class="keyword">this</span>;                                 <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>)&#123;                           <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> temp = obj.i;                       <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设A执行<code>writer()</code>方法，线程B执行<code>reader()</code>方法。操作1和2允许被重排序，假如操作2允许被“溢出”，那么可能产生如下执行结果：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/24.jpg" alt="执行结果图"></p>
<blockquote>
<p>综上：在构造函数返回前，被构造对象的引用贝能为其他线程可见，在构造函数返回后，任意线程将保证可以看到<code>final</code>域正确初始化后的值</p>
</blockquote>
<h6 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a><code>final</code>语义在处理器中的实现</h6><blockquote>
<p>写<code>final</code>域的重排序规则要求编译器在<code>final</code>域写之后，构造函数<strong>return</strong>之前插入一个<code>StoreStore</code>屏障。读<code>final</code>规则要求编译器在读<code>final</code>之前加入一个<code>LoadLoad</code>屏障。</p>
</blockquote>
<blockquote>
<p>实际情况会根据处理器略有不同，但不会影响执行顺序。例如: x86处理器不会对存在间接依赖关系的操作做重排序，此时会省略掉<code>StoreStore</code>和<code>LoadLoad</code>内存屏障。</p>
</blockquote>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h6><blockquote>
<p><code>JSR-133</code>增强了<code>final</code>语义。通过为<code>final</code>域增加写和读重排序规则，可以为Java程序员提供初始化安全保证。只要对象是正确构造的(被构造对象在构造函数中没有“溢出”)，那么不需要使用同步就可以保证任意线程都能看到这个<code>final</code>域在构造函数中被初始化之后的值。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/04/26/concurrent/chapter3/3.5_lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/04/26/concurrent/chapter3/3.5_lock/" class="post-title-link" itemprop="url">锁的内存语义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-26 00:39 00:39:00" itemprop="dateCreated datePublished" datetime="2019-04-26T00:39:00+08:00">2019-04-26 00:39</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/04/26/concurrent/chapter3/3.5_lock/" class="post-meta-item leancloud_visitors" data-flag-title="锁的内存语义" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>锁可以让内存区互斥执行</p>
</blockquote>
<h6 id="1-锁的释放-获取建立的happens-before关系"><a href="#1-锁的释放-获取建立的happens-before关系" class="headerlink" title="1.  锁的释放-获取建立的happens-before关系"></a>1.  锁的释放-获取建立的<code>happens-before</code>关系</h6><blockquote>
<p>锁是并发编程中对重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
</blockquote>
<h6 id="2-锁的释放和获取的内存语义"><a href="#2-锁的释放和获取的内存语义" class="headerlink" title="2. 锁的释放和获取的内存语义"></a>2. 锁的释放和获取的内存语义</h6><ol>
<li>线程释放锁时，JMM会把该线程对应的内地内存中的共享变量刷新到主内存中</li>
<li>线程获取锁时，JMM会把该线程对应的本地内存置为无效，使得被监视器保护的临界区代码必须从主内存中读取共享变量</li>
</ol>
<blockquote>
<p><strong>锁的释放-获取与<code>volatile</code>的写-读具有相同的内存语义</strong></p>
</blockquote>
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来获取锁的线程发出了消息(线程A对共享变量做了修改)</li>
<li>线程B获取一个锁，实质上是线程B接受了之前线程发出的消息(之前的线程释放所之前对共享变量做了修改)</li>
<li>线程A释放锁-线程B获取锁，实质上是线程A通过主内存向线程B发送消息</li>
</ul>
<h6 id="3-锁内存语义的实现"><a href="#3-锁内存语义的实现" class="headerlink" title="3. 锁内存语义的实现"></a>3. 锁内存语义的实现</h6><blockquote>
<p>借助<code>java.util.concurrent.locks.ReentrantLock</code>的源码，分析锁内存语义的具体实现机制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a ++;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ReentrantLock</code>中<code>lock()</code>方法获取锁，unlock()方法释放锁。<code>ReentrantLock</code>的实现依赖于Java同步器框架<code>AbstrantQueuedSynchronized</code>(<strong>AQS</strong>)。<strong>AQS</strong>使用一个<code>volatile</code>变量(<strong>state</strong>)维护同步状态。以下是<code>ReentrantLock</code>的类图</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/19.jpg" alt="ReentrantLock类图"></p>
<blockquote>
<p><code>ReentrantLock</code>分为公平锁和非公平锁，首先分析公平锁，查看源码可得公平锁调用轨迹如下:</p>
</blockquote>
<ol>
<li><code>ReentrantLock#lock</code>方法</li>
<li><code>FairSync#lock</code>方法</li>
<li><code>AbstrantQueuedSynchronized#acquire</code>方法</li>
<li><code>ReentrantLock#tryAcquire</code>方法</li>
</ol>
<blockquote>
<p><code>ReentrantLock#tryAcquire</code>方法是真正加锁的源代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取锁的开始</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取锁的开始先读<code>volatile</code>变量<code>state</code></p>
<p>解锁方法调用轨迹如下:</p>
</blockquote>
<ol>
<li><code>ReentrantLock#unlock</code>方法</li>
<li><code>AbstractQueuedSynchronizer#release</code>方法</li>
<li><code>Sync#tryRelease</code>方法</li>
</ol>
<blockquote>
<p><code>Sync#tryRelease</code>方法是解锁的源代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在释放锁的最后写volatile变量state</p>
</blockquote>
<blockquote>
<p><strong>根据<code>volatile</code>的<code>happens-before</code>规则，释放锁的线程在写<code>volatile</code>之前可见的共享变量，在执行获取锁的线程读取同一个<code>volatile</code>变量后将立即变得对获取锁的线程可见。</strong></p>
</blockquote>
<blockquote>
<p>非公平锁的内存语义实现。 非公平锁的释放与公平锁的释放完全一致。以下是非公平锁的获取，<code>lock()</code>轨迹如下:</p>
</blockquote>
<ol>
<li><code>ReentrantLock#lock</code>方法</li>
<li><code>NonfairSync#lock</code>方法</li>
<li><code>AbstractQueuedSynchronzed#acquire</code> -&gt; <code>AbstractQueuedSynchronized#acquireQueued</code>方法</li>
<li><code>NonfairSync#tryAcquire</code> -&gt; <code>NonfairSync.nonfairTryAcquire</code>方法</li>
<li><code>AbstractQueuedSynchronized#compareAndSetState</code>方法</li>
</ol>
<blockquote>
<p><code>AbstractQueuedSynchronized#compareAndSetState</code>方法源码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法以原子操作的方式更新<code>state</code>变量，<code>compareAndSet</code>方法即<strong>CAS</strong>。<strong>JDK</strong>文档对该方法的说明如下：</p>
<p>如果当前状态值等于预期值则以原子的方法将同步状态更新为给定的值。此操作具有<code>volatile</code>读和写的内存语义。<strong>编译器不会对<code>volatile</code>写与<code>volatile</code>写之前的任意内存操作重排序，也不会对<code>volatile</code>与<code>volatile</code>读之后的任意操作重排序，所以CAS操作不能对CAS与CAS前后的操作重排序</strong></p>
</blockquote>
<blockquote>
<p>公平锁和非公平锁内存语义如下:</p>
</blockquote>
<ol>
<li>公平锁和非公平锁释放时，都会最后写<code>volatile</code>变量<strong>state</strong></li>
<li>公平锁获取锁时，会先读<code>volatile</code>变量<strong>state</strong></li>
<li>非公平锁获取时，会使用CAS操作更新<code>volatile</code>变量，这个操作具有<code>volatile</code>读和写的内存语义</li>
</ol>
<blockquote>
<p><code>ReentrantLock</code>分析得出，锁释放-获取内存语义实现至少有以下两种方式：</p>
</blockquote>
<ul>
<li>利用<code>volatile</code>变量的写-读所具有的内存语义</li>
<li>利用CAS所附带的<code>volatile</code>读和<code>volatile</code>写的内存语义</li>
</ul>
<h6 id="4-concurrent包的实现"><a href="#4-concurrent包的实现" class="headerlink" title="4. concurrent包的实现"></a>4. concurrent包的实现</h6><blockquote>
<p>Java的CAS具有<code>volatile</code>的读和写的内存语义，所以Java线程之前通信有四种方式：</p>
</blockquote>
<ol>
<li>A线程写<code>volatile</code>变量，随后B线程读这个<code>volatile</code>变量。  </li>
<li>A线程写<code>volatile</code>变量，随后B线程用CAS更新这个<code>volatile</code>变量。 </li>
<li>A线程用<strong>CAS</strong>更新一个<code>volatile</code>变量，随后B线程用<strong>CAS</strong>更新这个<code>volatile</code>变量。 </li>
<li>A线程用<strong>CAS</strong>更新一个<code>volatile</code>变量，随后B线程读这个<code>volatile</code>变量</li>
</ol>
<blockquote>
<p><strong><code>concurrent</code>包的通用化实现模式：</strong></p>
</blockquote>
<ol>
<li><strong>声明共享变量为<code>volatile</code></strong></li>
<li><strong>使用CAS的原子条件更新实现线程之间的同步</strong></li>
<li><strong>配合<code>volatile</code>的读/写和CAS具有的<code>volatile</code>读和写的内存语义实现线程之间的通信</strong></li>
</ol>
<blockquote>
<p>AQS，非阻塞数据结构和原子变量类(<code>java.util.concurrent.atomic.*</code>)等基础类都是使用这种模式实现的。<code>concurrent</code>包中的高层类依赖于这些基础类实现。<code>concurrent</code>包的实现示意图如下：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/20.jpg" alt="concurrent包的实现示意图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/04/24/concurrent/chapter3/3.4_volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/04/24/concurrent/chapter3/3.4_volatile/" class="post-title-link" itemprop="url">volatile内存语义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-24 22:53 22:53:00" itemprop="dateCreated datePublished" datetime="2019-04-24T22:53:00+08:00">2019-04-24 22:53</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/04/24/concurrent/chapter3/3.4_volatile/" class="post-meta-item leancloud_visitors" data-flag-title="volatile内存语义" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 id="1-volatile内存语义"><a href="#1-volatile内存语义" class="headerlink" title="1. volatile内存语义"></a>1. <code>volatile</code>内存语义</h6><blockquote>
<p><code>volatile</code>语义是把对<code>volatile</code>变量的单个读/写，看成是使用同一个锁对单个读/写操作做了同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用volatile声明64位的long变量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> v1 = <span class="number">0L</span>;</span><br><span class="line">	<span class="comment">// 单个volatile变量的写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        v1 = l;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 复合(多个)volatile变量的读/写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        v1++;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 单个volatile变量的读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample1</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 64位的long普通变量</span></span><br><span class="line">    <span class="keyword">long</span> v1 = <span class="number">0L</span>;</span><br><span class="line">	<span class="comment">// 单个普通变量的写用同一个锁同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        v1 = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        <span class="keyword">long</span> tmp = get();</span><br><span class="line">        <span class="comment">// 普通的写操作</span></span><br><span class="line">        tmp += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 调用已同步的写操作</span></span><br><span class="line">        set(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 对单个普通变量的读操作使用同一个锁同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上两个类的效果一样。 一个<code>volatile</code>变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，其执行效果相同。</p>
</blockquote>
<blockquote>
<p>锁的<code>happens-before</code>规则保证释放锁和获取锁两个线程之间的内存可见性，对于<code>volatile</code>变量来说，对于一个<code>volatile</code>的读，总是能看到(任意线程)对这个<code>volatile</code>变量的写操作。</p>
</blockquote>
<blockquote>
<p>锁的语义决定了临界区代码的执行具有原子性。如果是多个<code>volatile</code>操作或者类似于<code>volatile++</code>的复合操作，这些操作不具有原子性。<code>volatile++</code>是先读后写的复合操作。**<code>volatile</code>变量具有以下特性:**</p>
</blockquote>
<ul>
<li>可见性。对一个<code>volatile</code>变量的读，总是能看到(任意线程)对这个<code>volatile</code>变量最后的写入</li>
<li>原子性。对任意单个<code>volatile</code>变量的读/写操作具有原子性，但是类似于<code>volatile++</code>的复合操作不具有原子性</li>
</ul>
<h6 id="2-volatile-写-读建立的-happens-before-关系"><a href="#2-volatile-写-读建立的-happens-before-关系" class="headerlink" title="2. volatile 写 - 读建立的 happens-before 关系"></a>2. <code>volatile</code> 写 - 读建立的 <code>happens-before</code> 关系</h6><blockquote>
<p><code>volatile</code>对内存可见性的影响比<code>volatile</code>自身的特性更重要。<code>volatile</code>变量的写 - 读可以实现线程之间的通信。<code>volatile</code>的写 - 读与锁的释放 - 获取有相同的内存语义。见下例：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;          <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;    <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;      <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a;  <span class="comment">// 4</span></span><br><span class="line">            <span class="comment">// ······</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上例中，假设线程A执行<code>writer()</code>之后，线程B执行<code>reader()</code>，根据<code>happens-before</code>规则得到如下几点:</p>
</blockquote>
<ul>
<li>根据程序次序规则，1<code>happens-before</code>2，3<code>happens-before</code>4</li>
<li>根据<code>volatile</code>规则，2<code>happens-before</code>3</li>
<li>根据<code>happens-before</code>规则的传递性，2<code>happens-before</code>3</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/15.jpg" alt="happens-before"></p>
<h6 id="3-volatile-写-读内存语义"><a href="#3-volatile-写-读内存语义" class="headerlink" title="3. volatile 写-读内存语义"></a>3. <code>volatile</code> 写-读内存语义</h6><blockquote>
<p><code>volatile</code>内存语义: </p>
</blockquote>
<ul>
<li>当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当读一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存置为无效，线程接下来会从主内存中读取共享变量。</li>
</ul>
<blockquote>
<p>以实例程序<code>VolatileExample</code>为例，<code>volatile</code>写和<code>volatile</code>读综合起来看，线程B读一个<code>volatile</code>变量后，写线程A在写这个<code>volatile</code>变量<strong>之前所有可见的共享变量的值</strong>都将立即变得对读线程B可见。</p>
</blockquote>
<ul>
<li>线程A写一个<code>volatile</code>变量，实质上是线程A向接下来将要读这个<code>volatile</code>变量的某个线程发出了（其对共享变量所做修改的）消息</li>
<li>线程B读一个<code>volatile</code>消息，实质上是线程B接收了之前某个线程发出的（在写这个<code>volatile</code>变量之前对共享变量所做的修改的）消息</li>
<li>线程A写一个<code>volatile</code>变量，随后线程B读这个<code>volatile</code>变量，这个过程实际上是线程A通过主内存向线程B发送消息</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/16.jpg" alt="共享变量状态"></p>
<h6 id="4-volatile内存语义的实现"><a href="#4-volatile内存语义的实现" class="headerlink" title="4. volatile内存语义的实现"></a>4. <code>volatile</code>内存语义的实现</h6><blockquote>
<p>重排序分为编译器排序和处理器排序，为了实现<code>volatile</code>内存语义JMM会分别限制这两种类型的重排序类型。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/17.jpg" alt="volatile重排序规则表"></p>
<blockquote>
<p>可得出以下结论:</p>
</blockquote>
<ul>
<li><p>第二个操作是<code>volatile</code>写时，不管第一个操作是什么，都不能重排序。确保<code>volatile</code>写之前的操作不会被编译器重排序到<code>volatile</code>写之后</p>
</li>
<li><p>第一个操作是<code>volatile</code>读时，不管第二个操作是什么，都不能重排序。确保<code>volatile</code>读之前的操作不会被编译器重排序到<code>volatile</code>读之前</p>
</li>
<li><p>第一个操作是<code>volatile</code>写，第二个操作是<code>volatile</code>读时，不能重排序</p>
</li>
</ul>
<blockquote>
<p>为了实现<code>volatile</code>内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障禁止特定类型的处理器重排序。</p>
</blockquote>
<ul>
<li>在每个<code>volatile</code>写操作前面插入<code>StoreStore</code>屏障</li>
<li>在每个<code>volatile</code>写操作后面插入<code>StoreLoad</code>屏障</li>
<li>在每个<code>volatile</code>读操作后面插入<code>LoadLoad</code>屏障</li>
<li>在每个<code>volatile</code>读操作后面插入<code>LoadStore</code>屏障</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrieExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// volatile 读</span></span><br><span class="line">        <span class="keyword">int</span> i = v1;</span><br><span class="line">        <span class="comment">// volatile 读</span></span><br><span class="line">        <span class="keyword">int</span> j = v2;</span><br><span class="line">        <span class="comment">// 普通写</span></span><br><span class="line">        a = i + j;</span><br><span class="line">        <span class="comment">// volatile 写</span></span><br><span class="line">        v1 = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// volatile 写</span></span><br><span class="line">        v2 = j * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>针对<code>readAndWrite()</code>方法，编译器在生成字节码时会做如下优化:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/18.jpg" alt="指令序列示意图"></p>
<blockquote>
<p>以上优化针对不同处理器平台，不同的内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。</p>
</blockquote>
<h6 id="5-volatile内存语义增强"><a href="#5-volatile内存语义增强" class="headerlink" title="5. volatile内存语义增强"></a>5. <code>volatile</code>内存语义增强</h6><blockquote>
<p>旧的内存模型中，<code>volatile</code>写-读没有锁的释放-获取所具有的的内存语义，即<code>volatile</code>写操作之前写操作并不会被写到内存中。<strong>为了提供一种比锁更轻量级的线程之间通信的机制</strong>，严格限制编译器和处理器对<code>volatile</code>变量与普通变量的重排序，确保<code>volatile</code>写-读和锁的释放-获取具有相同的内存语义</p>
</blockquote>
<blockquote>
<p><code>volatile</code>仅仅保证对单个<code>volatile</code>变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。功能上，锁比<code>volatile</code>更强大；可伸缩性和执行性上，<code>volatile</code>更具有优势</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/04/15/concurrent/chapter3/3.3_order_consistency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/04/15/concurrent/chapter3/3.3_order_consistency/" class="post-title-link" itemprop="url">顺序一致性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-15 23:38 23:38:00" itemprop="dateCreated datePublished" datetime="2019-04-15T23:38:00+08:00">2019-04-15 23:38</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:54 00:54:36" itemprop="dateModified" datetime="2019-09-02T00:54:36+08:00">2019-09-02 00:54</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrent/" itemprop="url" rel="index"><span itemprop="name">concurrent</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/04/15/concurrent/chapter3/3.3_order_consistency/" class="post-meta-item leancloud_visitors" data-flag-title="顺序一致性" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。</p>
</blockquote>
<h6 id="1-数据竞争与顺序一致性"><a href="#1-数据竞争与顺序一致性" class="headerlink" title="1. 数据竞争与顺序一致性"></a>1. 数据竞争与顺序一致性</h6><blockquote>
<p>数据未正确同步时，就可能存在数据竞争。Java内存模型规范对数据竞争的定义如下:</p>
</blockquote>
<ul>
<li><strong>在一个线程中写一个变量，在另一个线程中读同一个变量，而且写和读没有通过同步来排序。</strong></li>
</ul>
<blockquote>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。若一个多线程程序能正确同步，那么这个程序将是一个没有数据竞争的程序。</p>
</blockquote>
<blockquote>
<p>JMM对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。同步即广义的同步，包括对<code>synchronized</code>、<code>volatile</code>和<code>final</code>的正确使用</p>
</blockquote>
<h6 id="2-顺序一致性内存模型"><a href="#2-顺序一致性内存模型" class="headerlink" title="2. 顺序一致性内存模型"></a>2. 顺序一致性内存模型</h6><blockquote>
<p>顺序一致性内存模型是一个被计算机科学家理想化的理论参考模型，其有两大特性；</p>
</blockquote>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行</li>
<li>（无论程序是否同步）所有线程都只能看到一个单一的操作执行顺序，在顺序一致性模型中，每个操作都是原子执行且必须立刻对所有线程可见</li>
</ul>
<p><img src="https://images.effiu.cn/gitbook/concurrent/13.jpg" alt="顺序一致性模型"></p>
<blockquote>
<p>从概念上讲，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每个线程必须按照程序的顺序来执行内存读/写操作。任意时间点只有一个线程可以连接到内存。当多个线程并发执行时，开关可以把所有线程内存读/写操作串行化（在顺序一致性锁模型中，所有操作之间具有全序关系）。例子见<strong>《Java并发编程的艺术》</strong>page33</p>
</blockquote>
<blockquote>
<p>在JMM中未同步程序整体的执行顺序是无序的，所有线程看到的操作执行顺序也可能不一致。例如当前线程把写过的数据缓存到本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见。</p>
</blockquote>
<h6 id="3-同步程序的顺序一致性效果"><a href="#3-同步程序的顺序一致性效果" class="headerlink" title="3. 同步程序的顺序一致性效果"></a>3. 同步程序的顺序一致性效果</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">int</span> i = a * a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JMM中临界区域内的代码可以重排序（但JMM不会允许临界区内的代码“溢出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区与进入临界区两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/concurrent/14.jpg" alt="内存模型中的执行时序对比图"></p>
<blockquote>
<p>线程A和B虽然在各自临界区内做了重排序，但由于监视器互斥执行的特性，线程B无法观察到线程A在临界区内做了重排序，提高了执行效率，也没有改变程序的执行结果。</p>
<p>JMM的具体实现上的基本方针为：<strong>在不改变（正确同步）程序执行结果的前提下，尽可能为编译器和处理器的优化打开方便之门</strong></p>
</blockquote>
<h6 id="4-未同步程序的执行特性"><a href="#4-未同步程序的执行特性" class="headerlink" title="4. 未同步程序的执行特性"></a>4. 未同步程序的执行特性</h6><ul>
<li><input disabled="" type="checkbox"> 阅读原文</li>
</ul>
<blockquote>
<p>JMM对未同步或未正确同步的多线程程序，只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值。为了实现最小安全性，JVM在堆上分配内存对象时，首先会清理内存空间，然后分配对象（JVM内部会同步这两个操作），在以清零的内存空间分配对象时，域的默认初始化已经完成。</p>
</blockquote>
<blockquote>
<p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。要保证执行结果一致，JMM需要禁止大量处理器和编译器的优化，会对程序产生很大影响。</p>
</blockquote>
<blockquote>
<p>为同步程序在JMM中执行时，整体上是无序的，其执行结果也无法预知。未同步程序在两个模型中的执行特性有如下几个差异：</p>
</blockquote>
<ul>
<li><strong>顺序一致性模型保证单线程内的操作会按照顺序执行，而JMM不保证单线程内是按照程序的顺序执行的（在临界区内的重排序）</strong></li>
<li><strong>顺序一致性保证所有线程看到一致的操作执行顺序，JMM不保证所有线程可以看到一致的操作执行顺序</strong></li>
<li><strong>不保证对64位的long型和double型变量的写操作的原子性，顺序一致性保证所有内存的读/写都具有原子性</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="https://www.effiu.cn/2019/04/15/essay/mybatis_cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="effiu">
      <meta itemprop="description" content="effiu的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="effiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2019/04/15/essay/mybatis_cache/" class="post-title-link" itemprop="url">MyBatis 缓存机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-15 15:32 15:32:00" itemprop="dateCreated datePublished" datetime="2019-04-15T15:32:00+08:00">2019-04-15 15:32</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-19 15:51 15:51:50" itemprop="dateModified" datetime="2020-07-19T15:51:50+08:00">2020-07-19 15:51</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/essay/" itemprop="url" rel="index"><span itemprop="name">essay</span></a>
                </span>
            </span>

          
            <span id="/blog/2019/04/15/essay/mybatis_cache/" class="post-meta-item leancloud_visitors" data-flag-title="MyBatis 缓存机制" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>


<ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">MyBatis缓存机制</a></li>
</ul>
<blockquote>
<p>MyBatis是常见的Java数据库访问层框架，日常使用中大多使用MyBatis的默认缓存配置，但是当并发量高时会引起脏数据，形成一些潜在的隐患，<a target="_blank" rel="noopener" href="https://github.com/kailuncen/mybatis-cache-demo">源码demo</a></p>
</blockquote>
<h5 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1. 一级缓存"></a>1. 一级缓存</h5><h6 id="1-一级缓存介绍"><a href="#1-一级缓存介绍" class="headerlink" title="1. 一级缓存介绍"></a>1. 一级缓存介绍</h6><blockquote>
<p>在程序运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存优化这种应用场景，若是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/6e38df6a.jpg" alt="Mysql一级缓存执行过程"></p>
<blockquote>
<p>每个SqlSession中都持有<code>org.apache.ibatis.executor</code>，每个<strong>Executor</strong>中都有<strong>LocalCache</strong>。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在<strong>LocalCache</strong>进行查询，如果缓存命中(<strong>key是根据类名+方法名+参数等生成的</strong>)，直接返回给用户，如果没有命中，查询数据库，结果写入<strong>localCache</strong>，最后返回结果给用户</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BaseExecutor是四种Executor执行器共同的父抽象类，localCache是其成员属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有查询会被加入到一级缓存中</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/d76ec5fe.jpg" alt="Mysql一级缓存执行过程"></p>
<h6 id="2-一级缓存配置"><a href="#2-一级缓存配置" class="headerlink" title="2. 一级缓存配置"></a>2. 一级缓存配置</h6><blockquote>
<p>实现MyBatis的一级缓存，添加如下代码，<code>SESSION</code>表示在MyBatis中执行的所有语句，都会共享这个缓存，<code>STATEMENT</code>，只针对当前<strong>Statement</strong>有效</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalCacheScope 的缓存类型枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> LocalCacheScope &#123;</span><br><span class="line">  SESSION,STATEMENT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session</span></span><br><span class="line">configuration.setLocalCacheScope(LocalCacheScope.SESSION);</span><br></pre></td></tr></table></figure>

<ul>
<li>开启一级缓存，则同一<strong>SqlSession</strong>中，多次查询只有第一次查询数据库</li>
<li>若同一<strong>SqlSession</strong>中，多次查询中间存在<strong>update</strong>语句，则会使一级缓存失效</li>
<li>SqlSession1和SqlSession2，都查询数据，<strong>Session</strong>间不会共享，一级缓存只会在<strong>Session</strong>范围内共享。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalCacheScope</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">    SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2更新了&quot;</span> + studentMapper2.updateStudentName(<span class="string">&quot;小岑&quot;</span>,<span class="number">1</span>) + <span class="string">&quot;个学生的数据&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>sqlSession2</code>更新了id为1的学生的姓名，从凯伦改为了小岑，但session1之后的查询中，id为1的学生的名字还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部共享。</p>
</blockquote>
<h6 id="3-一级缓存工作流程与源码分析"><a href="#3-一级缓存工作流程与源码分析" class="headerlink" title="3. 一级缓存工作流程与源码分析"></a>3. 一级缓存工作流程与源码分析</h6><blockquote>
<p>一级缓存执行时序图</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/bb851700.png" alt="一级缓存执行时序图"></p>
<blockquote>
<p><code>SqlSession</code>对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层实现细节，默认实现类是<code>DefaultSqlSession</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSession</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String var1, Object var2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此处省略部分代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String var1, Object var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Executor</code>: <code>SqlSession</code>向数据库提供操作数据库的方法，但和数据库有关的职责委托给<code>Executor</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ResultHandler NO_RESULT_HANDLER = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Transaction <span class="title">getTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其子类如下:</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/83326eb3.jpg" alt="Executor类图"></p>
<blockquote>
<p>首先初始化<code>SqlSessionFactory</code>，<code>SqlSessionFactory</code>获取<code>SqlSession</code>，<code>SqlSession</code>会根据<code>Configuration</code>创建<code>Executor</code>。具体见<code>DefaultSqlSession</code>源码</p>
</blockquote>
<blockquote>
<p>一级缓存中，主要实现在<code>BaseExecutor</code>中，相关源码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 清空缓存 localCache</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">        <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">        clearLocalCache();</span><br><span class="line">        <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">        <span class="comment">// 生成key的规则</span></span><br><span class="line">        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">        <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	<span class="comment">// 省略无关代码</span></span><br><span class="line">        List&lt;E&gt; list;</span><br><span class="line">        <span class="comment">// 根据CacheKey从localCache中获取</span></span><br><span class="line">    	list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存查询为空，则去数据库查询</span></span><br><span class="line">        	list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// 此处省略代码</span></span><br><span class="line">        <span class="comment">// 判断一级缓存的级别</span></span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        	clearLocalCache(); <span class="comment">// issue #482</span></span><br><span class="line">      	&#125;</span><br><span class="line">    	<span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  生成key的规则</span></span><br><span class="line"><span class="comment">     * id + offset + limit + sql + parameter + propertyName + additionalParameter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">        CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">        cacheKey.update(ms.getId());</span><br><span class="line">        cacheKey.update(rowBounds.getOffset());</span><br><span class="line">        cacheKey.update(rowBounds.getLimit());</span><br><span class="line">        cacheKey.update(boundSql.getSql());</span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">        <span class="keyword">if</span> (parameterMappings.size() &gt; <span class="number">0</span> &amp;&amp; parameterObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">          <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">            cacheKey.update(parameterObject);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">              String propertyName = parameterMapping.getProperty();</span><br><span class="line">              <span class="keyword">if</span> (metaObject.hasGetter(propertyName)) &#123;</span><br><span class="line">                cacheKey.update(metaObject.getValue(propertyName));</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                cacheKey.update(boundSql.getAdditionalParameter(propertyName));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheKey;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>PerpetualCache</code>是接口<code>Cache</code>的子类之一，内部持有<code>HashMap</code>，对一级缓存的操作实际上是对<code>HashMap</code>的操作，如下是<code>PerpetualCache</code>的部分源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">  <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readWriteLock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Cache instances require an ID.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cache)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Cache otherCache = (Cache) o;</span><br><span class="line">    <span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Cache instances require an ID.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> getId().hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>CacheKey</code>内包含一级缓存key的生成规则，源码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1146682552656046210L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheKey NULL_CACHE_KEY = <span class="keyword">new</span> NullCacheKey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> multiplier;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">    <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    updateAll(objects);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpdateCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> updateList.size();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 由 BaseExecutor#createCacheKey()方法调用</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : object.hashCode();</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAll</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : objects) &#123;</span><br><span class="line">      update(o);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == object) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hashcode != cacheKey.hashcode) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (checksum != cacheKey.checksum) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (count != cacheKey.count) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject = updateList.get(i);</span><br><span class="line">      Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">      <span class="keyword">if</span> (thisObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thatObject != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thisObject.equals(thatObject)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-一级缓存总结"><a href="#4-一级缓存总结" class="headerlink" title="4. 一级缓存总结"></a>4. 一级缓存总结</h6><ul>
<li>MyBatis一级缓存声明周期与SqlSession一致</li>
<li>MyBatis一级缓存内部设计简单，是一个没有容量限制的HashMap，在缓存功能上有所欠缺</li>
<li>MyBatis一级缓存最大范围是SqlSession，在存在多个SqlSession或者分布式环境下，数据库写操作会引起脏数据，建议设定缓存级别的<code>Statement</code></li>
</ul>
<h5 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2. 二级缓存"></a>2. 二级缓存</h5><h6 id="1-二级缓存介绍"><a href="#1-二级缓存介绍" class="headerlink" title="1. 二级缓存介绍"></a>1. 二级缓存介绍</h6><blockquote>
<p>一级缓存中，共享范围与<code>SqlSession</code>一致，但是二级缓存中可以在多个<code>SqlSession</code>之间共享缓存。二级缓存开启后，会使用<code>CachingExecutor</code>装饰<code>Executor</code>，进入一级缓存查询流程前，先在<code>CachingExecutor</code>中进行二级缓存查询，如下是二级缓存工作流程图：</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/28399eba.png"></p>
<blockquote>
<p>如上图所示，二级缓存开启后，同一个<code>namescape</code>下共用同一个<code>Cache</code>，即被多个<code>SqlSession</code>共享，是一个全局变量，数据执行流程是 二级缓存-&gt;一级缓存-&gt;数据库</p>
</blockquote>
<h6 id="2-二级缓存配置"><a href="#2-二级缓存配置" class="headerlink" title="2. 二级缓存配置"></a>2. 二级缓存配置</h6><blockquote>
<p>开启二级缓存<code>configuration.setCacheEnabled(true)</code>或者<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;</code>。在MyBatis映射XML文件中使用<code>&lt;cache /&gt;</code>或者<code>&lt;cache-ref /&gt;</code>。</p>
</blockquote>
<ol>
<li><p><code>&lt;cache /&gt;</code>标签</p>
<ul>
<li><code>type</code>，默认是<code>PerpetualCache</code></li>
<li><code>eviction</code>，定义回收的策略，常见的由FIFO，LRU，LFU等</li>
<li><code>flushInterval</code>，配置一定时间自动刷新，单位是ms</li>
<li><code>size</code>，配置缓存对象的个数</li>
<li><code>readOnly</code>，是否只读，若配置可读写，则需要对应的实体类可序列化</li>
<li><code>blocking</code>，若缓存中不存在对应的key，是否会阻塞，直到数据进入缓存</li>
</ul>
</li>
<li><p><code>&lt;cache-ref /&gt;</code></p>
<blockquote>
<p>代表引入其他<code>namescape</code>的缓存配置，两个命名空间公用一个Cache，<code>&lt;cache-ref namescape=&quot;mapper.XxxMapper&quot; /&gt;</code></p>
</blockquote>
</li>
<li><p>二级缓存使用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheWithCommitOrClose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line">    SqlSession sqlSession2 = factory.openSession(<span class="keyword">true</span>); </span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper读取数据: &quot;</span> + studentMapper.getStudentById(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 注意提交与不提交事务的区别</span></span><br><span class="line">    sqlSession1.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 发生update操作</span></span><br><span class="line">    studentMapper3.updateStudentName(<span class="string">&quot;方方&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    sqlSession3.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2读取数据: &quot;</span> + studentMapper2.getStudentById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>sqlSession1</code>不提交事务时，二级缓存未起作用；<code>sqlSession1</code>事务提交后，二级缓存才会起作用；当发生<code>update</code>操作并提交事务后，二级缓存未起作用，因为update操作清空了二级缓存</p>
</blockquote>
<blockquote>
<p>MyBatis的二级缓存不适应用于映射文件中存在多表查询的情况。我们为每个数据库表创建单独的映射文件，所以如果二级缓存也是基于<code>namescape</code>的，多表查询语句所在的<code>namescape</code>无法感应到关联表所在的<code>namescape</code>对多表查询中涉及的修改，引发脏数据问题。所以使用<code>&lt;cache-ref=&quot;mapper.namescape&quot;&gt;</code>与关联表共用一个<code>namescape</code>，以实现公用一个Cache的目的</p>
</blockquote>
<h6 id="3-二级缓存源码"><a href="#3-二级缓存源码" class="headerlink" title="3. 二级缓存源码"></a>3. 二级缓存源码</h6><blockquote>
<p>MyBatis的二级缓存工作流程与一级缓存类似，在一级缓存处理前，用<code>CachingExecutor</code>装饰了<code>BaseExecutor</code>，在具体的工作委托给<code>delegate</code>之前，实现了二级缓存的查询与写入功能。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">private</span> Executor delegate;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> autoCommit;</span><br><span class="line">  	<span class="comment">// 保存了Cache和TransactionalCache的映射关系，CachingExecutor会默认使用他包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响。</span></span><br><span class="line">    <span class="comment">// 见下方源码 TransactionalCacheManager 类</span></span><br><span class="line">    <span class="keyword">private</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> dirty;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    	CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    	<span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 二级缓存</span></span><br><span class="line">        Cache cache = ms.getCache();</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否需要刷新缓存，默认 select 不会刷新缓存，但是 insert/delete/update 会刷新缓存</span></span><br><span class="line">            flushCacheIfRequired(ms);</span><br><span class="line">            <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="comment">// 处理存储过程</span></span><br><span class="line">                ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">                <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">                    cache.getReadWriteLock().readLock().lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 二级缓存查询命中后直接返回</span></span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        List&lt;E&gt; cachedList = (List&lt;E&gt;) cache.getObject(key);</span><br><span class="line">                        <span class="keyword">if</span> (cachedList != <span class="keyword">null</span>) <span class="keyword">return</span> cachedList;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cache.getReadWriteLock().readLock().unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 二级缓存未命中，则去一级缓存或者数据库查询(BaseExecutor)</span></span><br><span class="line">                List&lt;E&gt; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">            	<span class="comment">// 将一级缓存或者数据库查询返回的结果放到tcm持有的缓存中，等待数据提交后再放到Cache中</span></span><br><span class="line">                <span class="comment">// TransactionalCacheManager#putObject()</span></span><br><span class="line">                tcm.putObject(cache, key, list);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">    <span class="comment">// 事务提交后，将</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	delegate.commit(required);</span><br><span class="line">    	tcm.commit();</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要刷新缓存，insert/update/delete操作会刷新缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">        Cache cache = ms.getCache();</span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        	dirty = <span class="keyword">true</span>;</span><br><span class="line">          	tcm.clear(cache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 维护的是Cache和用TransactionalCache包装后的Cache的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;Cache, TransactionalCache&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TransactionalCache#putObject</span></span><br><span class="line">    	getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// tcm事务提交</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      		<span class="comment">// 提交 待提交缓存中的数据</span></span><br><span class="line">            txCache.commit();</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ······ 此处省略代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    	TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">    	<span class="keyword">if</span> (txCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      		txCache = <span class="keyword">new</span> TransactionalCache(cache);</span><br><span class="line">      		transactionalCaches.put(cache, txCache);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> txCache;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// ······ 此处省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">private</span> Cache delegate;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> clearOnCommit;</span><br><span class="line">  	<span class="keyword">private</span> Map&lt;Object, AddEntry&gt; entriesToAddOnCommit;</span><br><span class="line">  	<span class="keyword">private</span> Map&lt;Object, RemoveEntry&gt; entriesToRemoveOnCommit;</span><br><span class="line">    <span class="comment">// ······ 此处省略代码</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 从二级缓存中获取数据</span></span><br><span class="line">    	Object object = delegate.getObject(key);</span><br><span class="line">    	<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用于统计缓存命中率</span></span><br><span class="line">      		entriesMissedInCache.add(key);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// issue #146</span></span><br><span class="line">    	<span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      		<span class="keyword">return</span> object;</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">    <span class="comment">// 将查询结果缓存到待提交事务缓存中，只有当事务提交后对缓存的操作才会生效，事务回滚或者不生效，则不对缓存产生影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">    	entriesToRemoveOnCommit.remove(key);</span><br><span class="line">    	entriesToAddOnCommit.put(key, <span class="keyword">new</span> AddEntry(delegate, key, object));</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// ······ 此处省略代码</span></span><br><span class="line">    <span class="comment">// 清空缓存</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">    	entriesToAddOnCommit.clear();</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// 提交事务后，将待提交的数据提交到二级缓存中，并清空缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      		delegate.clear();</span><br><span class="line">    	&#125;</span><br><span class="line">    	flushPendingEntries();</span><br><span class="line">    	reset();</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">    <span class="comment">// 将待提交的缓存数据提交到二级缓存中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历待提交的缓存数据</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">          	<span class="comment">// 将待提交的Map进行循环处理，委托给包装的Cache类，进行putObject的操作</span></span><br><span class="line">            delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">          	<span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">            	delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ······ 省略代码</span></span><br><span class="line">&#125;    								</span><br></pre></td></tr></table></figure>



<blockquote>
<p>List<E> cachedList = (List<E>) cache.getObject(key);`本质是装饰者模式的应用，装饰链是:</p>
<p>SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; LruCache -&gt; PerpetualCache。</p>
</blockquote>
<p><img src="https://images.effiu.cn/gitbook/mybatis/1f5233b2.jpg" alt="装饰链"></p>
<ul>
<li><code>SynchronizedCache</code>，同步Cache，直接使用<code>synchronized</code>关键字修饰。</li>
<li><code>LoggingCache</code>，日志功能，装饰类，用于记录缓存的命中率，若开始debug模式，则会输出日志命中率。</li>
<li><code>SerializedCache</code>，序列化功能，将结果值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。</li>
<li><code>LruCache</code>，采用了Lru算法的Cache实现，移除最近最少使用的Key/Value。</li>
<li><code>PerpetualCache</code>， 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap。</li>
</ul>
<h6 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h6><ol>
<li>Mybatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间的数据共享，同时粒度更细，<code>namescape</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li>
<li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻</li>
<li>分布式环境下，默认的<strong>MyBatis Cache</strong>实现都是基于本地存储的，分布式环境下必然会出现读取脏数据，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/blog/page/9/">9</a><a class="extend next" rel="next" href="/blog/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18062655号 </a>
      <img src="https://images.effiu.cn/gongan.png" style="display: inline-block;">
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">effiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">614k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">9:18</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  




  
<script src="/blog/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"Jw6tthQmGwY5Sc2OlYBjIePr-gzGzoHsz","appKey":"CjWG9xugjMIBiCz8MsGnH9WI","placeholder":"Just go go","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"language":null,"visitor":true,"comment_count":false,"recordIP":false,"serverURLs":null}
    ));
  }, window.Valine);
});
</script>

</body>
</html>
