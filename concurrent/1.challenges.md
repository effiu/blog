> 并发编程的目的是为了让程序运行更快，但是并不是启动更多的线程就能让程序更大限度并发执行。如果想通过多线程执行任务使程序运行得更快，会面临很多挑战。**上下文切换问题、死锁问题，以及受限于硬件和软件的资源限制问题**

###### 1. 上下文切换
> 即使单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片实现。一般是几十毫秒(ms)

1. 多线程并不一定快
    > [代码](https://dev.tencent.com/u/effiu/p/essay-project/git/blob/master/src/main/java/com/essay/concurrent/learn/chapter1/ConcurrencyTest.java)
	
| 循环次数 | 串行执行 | 并发执行 |
| --- | --- | --- |
| 10亿 | 1250ms | 1000ms |
| 1亿 | 155ms | 220ms |
| 10万 | 4 ms | 110ms |

###### 2. 如何减少上下文切换

> 减少上下文切换的方法有无锁并发编程、CAS算法、使用少线程和使用协程

- 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法避免上下文切换，例如将数据ID按照Hash算法取模分段，不同的线程处理不同段的数据 
- CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁
- 使用最少线程。避免创建不必要的线程。
- 协程。单线程实现多任务的调度，并在单线程里维持多个任务间的切换

> 减少上下文切换

1. 查看当前Java进程PID

2. jstack pid 查看当前Java进程的线程,以下是部分线程信息
    ```java
    [root@vdevops opt]# jstack 27568
    2018-12-26 23:04:10
    Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed mode):
    
    "Attach Listener" #42 daemon prio=9 os_prio=0 tid=0x00007f708c007000 nid=0x8f6 waiting on condition [0x0000000000000000]
       java.lang.Thread.State: RUNNABLE
    
    "ajp-nio-8009-Acceptor-0" #40 daemon prio=5 os_prio=0 tid=0x00007f70b4499000 nid=0x6bd8 runnable [0x00007f70828e7000]
       java.lang.Thread.State: RUNNABLE
        at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)
        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422)
        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250)
        - locked <0x00000000f5fceae8> (a java.lang.Object)
        at org.apache.tomcat.util.net.NioEndpoint$Acceptor.run(NioEndpoint.java:692)
        at java.lang.Thread.run(Thread.java:748)
    
    "ajp-nio-8009-ClientPoller-0" #39 daemon prio=5 os_prio=0 tid=0x00007f70b4497000 nid=0x6bd7 runnable [0x00007f70829e8000]
       java.lang.Thread.State: RUNNABLE
        at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
        at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
        at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)
        at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
        - locked <0x00000000f69cf4c8> (a sun.nio.ch.Util$3)
        - locked <0x00000000f69cf4d8> (a java.util.Collections$UnmodifiableSet)
        - locked <0x00000000f69cf480> (a sun.nio.ch.EPollSelectorImpl)
        at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
        at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:1051)
        at java.lang.Thread.run(Thread.java:748)
    ```
    ```java
        "VM Thread" os_prio=0 tid=0x00007f70b406d800 nid=0x6bb2 runnable 
        "VM Periodic Task Thread" os_prio=0 tid=0x00007f70b40b7000 nid=0x6bb9 waiting on condition 
        JNI global references: 259
    ```

3. 统计线程分别处于的状态
   > `awk '{print $2$3$4$5}' | grep 'java.lang.Thread.State' dump | sort | uniq -c`
   
   ```java
   12    java.lang.Thread.State: RUNNABLE
   1    java.lang.Thread.State: TIMED_WAITING (on object monitor)
   1    java.lang.Thread.State: TIMED_WAITING (parking)
   1    java.lang.Thread.State: TIMED_WAITING (sleeping)
   2    java.lang.Thread.State: WAITING (on object monitor)
   20    java.lang.Thread.State: WAITING (parking)
   ```

4. 分析线程，以及找到解决方案

###### 3. 死锁 

> 锁可能会引起死锁，会造成系统不可用，如下是一些避免死锁的办法

*  避免一个线程同时获取多个锁
* 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
* 尝试使用定时锁，使用`lock.tryLock(timeout)`替代使用内部锁机制
* 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

###### 4. 资源限制的挑战

> 指进行并发编程时，程序的执行速度受限于计算机硬件资源或者软件资源。硬件资源限制有带宽的上传/下载速度、硬盘的读写速度和CPU的处理速度。软件限制有数据库的连接和socket连接数等。

* 资源限制引发的问题：将代码执行速度加快的原则是将代码中串行执行的部分编程并行，但是某段代码由于资源限制，仍在串行执行，这时候程序就会因为上下文切换和资源调度运行更慢。
* 解决资源限制的问题：硬件资源限制，可以考虑使用集群并发执行程序。软件资源限制，可以使用资源池复用。
* 在资源限制的情况下进行并发编程：根据不同的资源限制调整程序的并发度，例如下载文件依赖于带宽和硬盘读写速度。

###### 5. 总结

> 多使用JDK并发包提供的并发容器和工具类解决并发问题